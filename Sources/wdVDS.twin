'*****************************************************************************************
'This file is a part of WinDevLib - Windows Development Library for twinBASIC
'https://github.com/fafalone/WinDevLib
'Code ported by Jon Johnson. 
'"Windows" is a trademark of the Microsoft Corporation.
'Certain Description attributes (c) Microsoft, taken from SDK headers and official docs.
'Licensed under Creative Commons CC0 1.0 Universal
'*****************************************************************************************

'WinDevLib - wdVDS :: Virtual Disk Service

'vdserr.h
'vdscmprv.idl
'vsprvcm.idl
'vdshwprv.idl
'vdscmmn.idl
'vdslun.idl
'vdssp.idl
'vdshp.idl
'vdsvd.idl
'vds.idl
'vdshpcm.idl

[InterfaceId("118610B7-8D94-4030-B5B8-500889788E4E")]
[OleAutomation(False)]
Interface IEnumVdsObject Extends stdole.IUnknown
    [PreserveSig]
    [Description("method Next")]
    Function Next(ByVal celt As Long, ByRef ppObjectArray As IUnknown, ByRef pcFetched As Long) As Long
    [Description("method Skip")]
    Sub Skip(ByVal celt As Long)
    [Description("method Reset")]
    Sub Reset()
    [Description("method Clone")]
    Sub Clone(ByRef ppenum As IEnumVdsObject)
End Interface

[InterfaceId("D5D23B6D-5A55-4492-9889-397A3C2D2DBC")]
[OleAutomation(False)]
Interface IVdsAsync Extends stdole.IUnknown
    [Description("method Cancel")]
    Sub Cancel()
    [Description("method Wait")]
    Sub Wait(ByRef phrResult As Long /* HRESULT */, ByRef pAsyncOut As VDS_ASYNC_OUTPUT)
    [Description("method QueryStatus")]
    Sub QueryStatus(ByRef phrResult As Long /* HRESULT */, ByRef pulPercentCompleted As Long)
End Interface

[InterfaceId("8326CD1D-CF59-4936-B786-5EFC08798E25")]
[OleAutomation(False)]
Interface IVdsAdviseSink Extends stdole.IUnknown
    [Description("method OnNotify")]
    Sub OnNotify(ByVal lNumberOfNotifications As Long, ByRef pNotificationArray As VDS_NOTIFICATION)
End Interface

[InterfaceId("10C5E575-7984-4E81-A56B-431F5F92AE42")]
[OleAutomation(False)]
Interface IVdsProvider Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pProviderProp As VDS_PROVIDER_PROP)
End Interface

[InterfaceId("1732BE13-E8F9-4A03-BFBC-5F616AA66CE1")]
[OleAutomation(False)]
Interface IVdsProviderSupport Extends stdole.IUnknown
    [Description("method GetVersionSupport")]
    Sub GetVersionSupport(ByRef ulVersionSupport As Long)
End Interface

[InterfaceId("9AA58360-CE33-4F92-B658-ED24B14425B8")]
[OleAutomation(False)]
Interface IVdsSwProvider Extends stdole.IUnknown
    [Description("method QueryPacks")]
    Sub QueryPacks(ByRef ppenum As IEnumVdsObject)
    [Description("method CreatePack")]
    Sub CreatePack(ByRef ppPack As IVdsPack)
End Interface

[InterfaceId("3B69D7F5-9D94-4648-91CA-79939BA263BF")]
[OleAutomation(False)]
Interface IVdsPack Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pPackProp As VDS_PACK_PROP)
    [Description("method GetProvider")]
    Sub GetProvider(ByRef ppProvider As IVdsProvider)
    [Description("method QueryVolumes")]
    Sub QueryVolumes(ByRef ppenum As IEnumVdsObject)
    [Description("method QueryDisks")]
    Sub QueryDisks(ByRef ppenum As IEnumVdsObject)
    [Description("method CreateVolume")]
    Sub CreateVolume(ByVal type As VDS_VOLUME_TYPE, ByRef pInputDiskArray As VDS_INPUT_DISK, ByVal lNumberOfDisks As Long, ByVal ulStripeSize As Long, ByRef ppAsync As IVdsAsync)
    #If Win64 Then
    [Description("method AddDisk")]
    Sub AddDisk(DiskId As UUID, ByVal PartitionStyle As VDS_PARTITION_STYLE, ByVal bAsHotSpare As BOOL)
    [Description("method MigrateDisks")]
    Sub MigrateDisks(ByRef pDiskArray As UUID, ByVal lNumberOfDisks As Long, TaretPack As UUID, ByVal bForce As BOOL, ByVal bQueryOnly As BOOL, ByRef pResults As Long /* HRESULT */, ByRef pbRebootNeeded As BOOL)
    [Description("method ReplaceDisk")]
    Sub ReplaceDisk(DiskId As UUID, NewDisk As UUID, ByRef ppAsync As IVdsAsync)
    [Description("method RemoveMissingDisk")]
    Sub RemoveMissingDisk(DiskId As UUID)
    #Else
    [Description("method AddDisk")]
    Sub AddDisk(ByVal DiskId1 As Long, ByVal DiskId2 As Long, ByVal DiskId3 As Long, ByVal DiskId4 As Long, ByVal PartitionStyle As VDS_PARTITION_STYLE, ByVal bAsHotSpare As BOOL)
    [Description("method MigrateDisks")]
    Sub MigrateDisks(ByRef pDiskArray As UUID, ByVal lNumberOfDisks As Long, ByVal TargetPack1 As Long, ByVal TargetPack2 As Long, ByVal TargetPack3 As Long, ByVal TargetPackd4 As Long, ByVal bForce As BOOL, ByVal bQueryOnly As BOOL, ByRef pResults As Long /* HRESULT */, ByRef pbRebootNeeded As BOOL)
    [Description("method ReplaceDisk")]
    Sub ReplaceDisk(ByVal OldDiskId1 As Long, ByVal OldDiskId2 As Long, ByVal OldDiskId3 As Long, ByVal OldDiskId4 As Long, ByVal NewDiskId1 As Long, ByVal NewDiskId2 As Long, ByVal NewDiskId3 As Long, ByVal NewDiskId4 As Long, ByRef ppAsync As IVdsAsync)
    [Description("method RemoveMissingDisk")]
    Sub RemoveMissingDisk(ByVal DiskId1 As Long, ByVal DiskId2 As Long, ByVal DiskId3 As Long, ByVal DiskId4 As Long)
    #End If
    [Description("method Recover")]
    Sub Recover(ByRef ppAsync As IVdsAsync)
End Interface

[InterfaceId("13B50BFF-290A-47DD-8558-B7C58DB1A71A")]
[OleAutomation(False)]
Interface IVdsPack2 Extends stdole.IUnknown
    [Description("method CreateVolume2")]
    Sub CreateVolume2(ByVal type As VDS_VOLUME_TYPE, ByRef pInputDiskArray As VDS_INPUT_DISK, ByVal lNumberOfDisks As Long, ByVal ulStripeSize As Long, ByVal ulAlign As Long, ByRef ppAsync As IVdsAsync)
End Interface

[InterfaceId("07E5C822-F00C-47A1-8FCE-B244DA56FD06")]
[OleAutomation(False)]
Interface IVdsDisk Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pDiskProperties As VDS_DISK_PROP)
    [Description("method GetPack")]
    Sub GetPack(ByRef ppPack As IVdsPack)
    [Description("method GetIdentificationData")]
    Sub GetIdentificationData(ByRef pLunInfo As VDS_LUN_INFORMATION)
    [Description("method QueryExtents")]
    Sub QueryExtents(ByRef ppExtentArray As LongPtr, ByRef plNumberOfExtents As Long)
    [Description("method ConvertStyle")]
    Sub ConvertStyle(ByVal NewStyle As VDS_PARTITION_STYLE)
    [Description("method SetFlags")]
    Sub SetFlags(ByVal ulFlags As VDS_DISK_FLAG)
    [Description("method ClearFlags")]
    Sub ClearFlags(ByVal ulFlags As VDS_DISK_FLAG)
End Interface

[InterfaceId("40F73C8B-687D-4A13-8D96-3D7F2E683936")]
[OleAutomation(False)]
Interface IVdsDisk2 Extends stdole.IUnknown
    [Description("method SetSANMode")]
    Sub SetSANMode(ByVal bEnable As BOOL)
End Interface

[InterfaceId("90681B1D-6A7F-48E8-9061-31B7AA125322")]
[OleAutomation(False)]
Interface IVdsDiskOnline Extends stdole.IUnknown
    [Description("method Online")]
    Sub Online()
    [Description("method Offline")]
    Sub Offline()
End Interface

[InterfaceId("6E6F6B40-977C-4069-BDDD-AC710059F8C0")]
[OleAutomation(False)]
Interface IVdsAdvancedDisk Extends stdole.IUnknown
    [Description("method GetPartitionProperties")]
    Sub GetPartitionProperties(ByVal ullOffset As LongLong, ByRef pPartitionProp As VDS_PARTITION_PROP)
    [Description("method QueryPartitions")]
    Sub QueryPartitions(ByRef ppPartitionPropArray As LongPtr, ByRef plNumberOfPartitions As Long)
    [Description("method CreatePartition")]
    Sub CreatePartition(ByVal ullOffset As LongLong, ByVal ullSize As LongLong, ByRef Para As CREATE_PARTITION_PARAMETERS, ByRef ppAsync As IVdsAsync)
    [Description("method DeletePartition")]
    Sub DeletePartition(ByVal ullOffset As LongLong, ByVal bForce As BOOL, ByVal bForceProtected As BOOL)
    [Description("method ChangeAttributes")]
    Sub ChangeAttributes(ByVal ullOffset As LongLong, ByRef Para As CHANGE_ATTRIBUTES_PARAMETERS)
    [Description("method AssignDriveLetter")]
    Sub AssignDriveLetter(ByVal ullOffset As LongLong, ByVal wcLetter As Integer)
    [Description("method DeleteDriveLetter")]
    Sub DeleteDriveLetter(ByVal ullOffset As LongLong, ByVal wcLetter As Integer)
    [Description("method GetDriveLetter")]
    Sub GetDriveLetter(ByVal ullOffset As LongLong, ByRef pwcLetter As Integer)
    [Description("method FormtPartition")]
    Sub FormatPartition(ByVal ullOffset As LongLong, ByVal type As VDS_FILE_SYSTEM_TYPE, ByVal pwszLabel As LongPtr, ByVal dwUnitAllocationSize As Long, ByVal bForce As BOOL, ByVal bQuickFormat As BOOL, ByVal bEnableCompression As BOOL, ByRef ppAsync As IVdsAsync)
    Sub Clean(ByVal bForce As BOOL, ByVal bForceOEM As BOOL, ByVal bFullClean As BOOL, ByRef ppAsync As IVdsAsync)
End Interface

[InterfaceId("9723F420-9355-42DE-AB66-E31BB15BEEAC")]
[OleAutomation(False)]
Interface IVdsAdvancedDisk2 Extends stdole.IUnknown
    [Description("method ChangePartitionType")]
    Sub ChangePartitionType(ByVal ullOffset As LongLong, ByVal bForce As BOOL, ByRef Para As CHANGE_PARTITION_TYPE_PARAMETERS)
End Interface

[InterfaceId("3858C0D5-0F35-4BF5-9714-69874963BC36")]
[OleAutomation(False)]
Interface IVdsAdvancedDisk3 Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pAdvDiskProp As VDS_ADVANCEDDISK_PROP)
    [Description("method GetUniqueId")]
    Sub GetUniqueId(ByRef ppwszId As LongPtr)
End Interface

[InterfaceId("9882F547-CFC3-420B-9750-00DFBEC50662")]
[OleAutomation(False)]
Interface IVdsCreatePartitionEx Extends stdole.IUnknown
    [Description("method CreatePartitionEx")]
    Sub CreatePartitionEx(ByVal ullOffset As LongLong, ByVal ullSize As LongLong, ByVal ulAlign As Long, ByRef Para As CREATE_PARTITION_PARAMETERS, ByRef ppAsync As IVdsAsync)
End Interface

[InterfaceId("0316560B-5DB4-4ED9-BBB5-213436DDC0D9")]
[OleAutomation(False)]
Interface IVdsRemovable Extends stdole.IUnknown
    [Description("method QueryMedia")]
    Sub QueryMedia()
    [Description("method Eject")]
    Sub Eject()
End Interface

[InterfaceId("88306BB2-E71F-478C-86A2-79DA200A0F11")]
[OleAutomation(False)]
Interface IVdsVolume Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pVolumeProperties As VDS_VOLUME_PROP)
    [Description("method GetPack")]
    Sub GetPack(ByRef ppPack As IVdsPack)
    [Description("method QueryPlexes")]
    Sub QueryPlexes(ByRef ppenum As IEnumVdsObject)
    [Description("method Extend")]
    Sub Extend(ByRef pInputDiskArray As VDS_INPUT_DISK, ByVal lNumberOfDisks As Long, ByRef ppAsync As IVdsAsync)
    [Description("method Shrink")]
    Sub Shrink(ByVal ullNumberOfBytesToRemove As LongLong, ByRef ppAsync As IVdsAsync)
    #If Win64 Then
    [Description("method AddPlex")]
    Sub AddPlex(VolumeId As UUID, ByRef ppAsync As IVdsAsync)
    [Description("BreakPlex")]
    Sub BreakPlex(plexId As UUID, ByRef ppAsync As IVdsAsync)
    [Description("RemovePlex")]
    Sub RemovePlex(plexId As UUID, ByRef ppAsync As IVdsAsync)
    #Else
    [Description("method AddPlex")]
    Sub AddPlex(ByVal VolumeId1 As Long, ByVal VolumeId2 As Long, ByVal VolumeId3 As Long, ByVal VolumeId4 As Long, ByRef ppAsync As IVdsAsync)
    [Description("BreakPlex")]
    Sub BreakPlex(ByVal plexId1 As Long, ByVal plexId2 As Long, ByVal plexId3 As Long, ByVal plexId4 As Long, ByRef ppAsync As IVdsAsync)
    [Description("RemovePlex")]
    Sub RemovePlex(ByVal plexId1 As Long, ByVal plexId2 As Long, ByVal plexId3 As Long, ByVal plexId4 As Long, ByRef ppAsync As IVdsAsync)
    #End If
    [Description("method Delete")]
    Sub Delete(ByVal bForce As BOOL)
    [Description("method SetFlags")]
    Sub SetFlags(ByVal ulFlags As VDS_VOLUME_FLAG, ByVal bRevertOnClose As BOOL)
    [Description("method ClearFlags")]
    Sub ClearFlags(ByVal ulFlags As VDS_VOLUME_FLAG)
End Interface

[InterfaceId("72AE6713-DCBB-4A03-B36B-371F6AC6B53D")]
[OleAutomation(False)]
Interface IVdsVolume2 Extends stdole.IUnknown
    [Description("method GetProperties2")]
    Sub GetProperties2(ByRef pVolumeProperties As VDS_VOLUME_PROP2)
End Interface

[InterfaceId("1BE2275A-B315-4F70-9E44-879B3A2A53F2")]
[OleAutomation(False)]
Interface IVdsVolumeOnline Extends stdole.IUnknown
    [Description("method Online")]
    Sub Online()
End Interface

[InterfaceId("4DAA0135-E1D1-40F1-AAA5-3CC1E53221C3")]
[OleAutomation(False)]
Interface IVdsVolumePlex Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pPlexProperties As VDS_VOLUME_PLEX_PROP)
    [Description("method GetVolume")]
    Sub GetVolume(ByRef ppVolume As IVdsVolume)
    [Description("method QueryExtents")]
    Sub QueryExtents(ByRef ppExtentArray As LongPtr, ByRef plNumberOfExtents As Long)
    [Description("method Repair")]
    Sub Repair(ByRef pInputDiskArray As VDS_INPUT_DISK, ByVal lNumberOfDisks As Long, ByRef ppAsync As IVdsAsync)
End Interface

[InterfaceId("8F4B2F5D-EC15-4357-992F-473EF10975B9")]
[OleAutomation(False)]
Interface IVdsDisk3 Extends stdole.IUnknown
    [Description("method GetProperties2")]
    Sub GetProperties2(ByRef pDiskProperties As VDS_DISK_PROP2)
    [Description("method QueryFreeExtents")]
    Sub QueryFreeExtents(ByVal ulAlign As Long, ByRef ppFreeExtentArray As LongPtr, ByRef plNumberOfFreeExtents As Long)
End Interface

[InterfaceId("D99BDAAE-B13A-4178-9FDB-E27F16B4603E")]
[OleAutomation(False)]
Interface IVdsHwProvider Extends stdole.IUnknown
    [Description("method QuerySubSystems")]
    Sub QuerySubSystems(ByRef ppenum As IEnumVdsObject)
    [Description("method Reenumerate")]
    Sub Reenumerate()
    [Description("method Refresh")]
    Sub Refresh()
End Interface

[InterfaceId("3E0F5166-542D-4FC6-947A-012174240B7E")]
[OleAutomation(False)]
Interface IVdsHwProviderType Extends stdole.IUnknown
    [Description("method GetProviderType")]
    Sub GetProviderType(ByRef pType As VDS_HWPROVIDER_TYPE)
End Interface

[InterfaceId("8190236F-C4D0-4E81-8011-D69512FCC984")]
[OleAutomation(False)]
Interface IVdsHwProviderType2 Extends stdole.IUnknown
    [Description("method GetProviderType2")]
    Sub GetProviderType2(ByRef pType As VDS_HWPROVIDER_TYPE)
End Interface

[InterfaceId("D5B5937A-F188-4C79-B86C-11C920AD11B8")]
[OleAutomation(False)]
Interface IVdsHwProviderStoragePools Extends stdole.IUnknown
    [Description("method QueryStoragePools")]
    Sub QueryStoragePools(ByVal ulFlags As VDS_STORAGE_POOL_TYPE, ByVal ullRemainingFreeSpace As LongLong, ByRef pPoolAttributes As VDS_POOL_ATTRIBUTES, ByRef ppenum As IEnumVdsObject)
    #If Win64 Then
    [Description("method CreateLunInStoragePool")]
    Sub CreateLunInStoragePool(ByVal type As VDS_LUN_TYPE, ByVal ullSizeInBytes As LongLong, StoragePoolId As UUID, ByVal pwszUnmaskingList As LongPtr, ByRef pHints2 As VDS_HINTS2, ByRef ppAsync As IVdsAsync)
    [Description("method QueryMaxLunCreateSizeInStoragePool")]
    Sub QueryMaxLunCreateSizeInStoragePool(ByVal type As VDS_LUN_TYPE, StoragePoolId As UUID, ByRef pHints2 As VDS_HINTS2, ByRef pullMaxLunSize As LongLong)
    #Else
    [Description("method CreateLunInStoragePool")]
    Sub CreateLunInStoragePool(ByVal type As VDS_LUN_TYPE, ByVal ullSizeInBytes As LongLong, ByVal StoragePoolId1 As Long, ByVal StoragePoolId2 As Long, ByVal StoragePoolId3 As Long, ByVal StoragePoolId4 As Long, ByVal pwszUnmaskingList As LongPtr, ByRef pHints2 As VDS_HINTS2, ByRef ppAsync As IVdsAsync)
    [Description("method QueryMaxLunCreateSizeInStoragePool")]
    Sub QueryMaxLunCreateSizeInStoragePool(ByVal type As VDS_LUN_TYPE, ByVal StoragePoolId1 As Long, ByVal StoragePoolId2 As Long, ByVal StoragePoolId3 As Long, ByVal StoragePoolId4 As Long, ByRef pHints2 As VDS_HINTS2, ByRef pullMaxLunSize As LongLong)
    #End If
End Interface

[InterfaceId("6FCEE2D3-6D90-4F91-80E2-A5C7CAACA9D8")]
[OleAutomation(False)]
Interface IVdsSubSystem Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pSubSystemProp As VDS_SUB_SYSTEM_PROP)
    [Description("method GetProvider")]
    Sub GetProvider(ByRef ppProvider As IVdsProvider)
    [Description("method QueryControllers")]
    Sub QueryControllers(ByRef ppenum As IEnumVdsObject)
    [Description("method QueryLuns")]
    Sub QueryLuns(ByRef ppenum As IEnumVdsObject)
    [Description("method QueryDrives")]
    Sub QueryDrives(ByRef ppenum As IEnumVdsObject)
    [Description("method GetDrive")]
    Sub GetDrive(ByVal sBusNumber As Integer, ByVal sSlotNumber As Integer, ByRef ppDrive As IVdsDrive)
    [Description("method Reenumerate")]
    Sub Reenumerate()
    [Description("method SetControllerStatus")]
    Sub SetControllerStatus(ByRef pOnlineControllerIdArray As UUID, ByVal lNumberOfOnlineControllers As Long, ByRef pOfflineControllerIdArray As UUID, ByVal lNumberOfOfflineControllers As Long)
    [Description("method CreateLun")]
    Sub CreateLun(ByVal type As VDS_LUN_TYPE, ByVal ullSizeInBytes As LongLong, ByRef pDriveIdArray As UUID, ByVal lNumberOfDrives As Long, ByVal pwszUnmaskingList As LongPtr, ByRef pHints As VDS_HINTS, ByRef ppAsync As IVdsAsync)
    #If Win64 Then
    [Description("method ReplaceDrive")]
    Sub ReplaceDrive(DriveToBeReplaced As UUID, ReplacementDrive As UUID)
    #Else
    [Description("method ReplaceDrive")]
    Sub ReplaceDrive(ByVal DriveToBeReplaced1 As Long, ByVal DriveToBeReplaced2 As Long, ByVal DriveToBeReplaced3 As Long, ByVal DriveToBeReplaced4 As Long, ByVal ReplacementDrive1 As Long, ByVal ReplacementDrive2 As Long, ByVal ReplacementDrive3 As Long, ByVal ReplacementDrive4 As Long)
    #End If
    [Description("method SetStatus")]
    Sub SetStatus(ByVal Status As VDS_SUB_SYSTEM_STATUS)
    [Description("method QueryMaxLunCreateSize")]
    Sub QueryMaxLunCreateSize(ByVal type As VDS_LUN_TYPE, ByRef pDriveIdArray As UUID, ByVal lNumberOfDrives As Long, ByRef pHints As VDS_HINTS, ByRef pullMaxLunSize As LongLong)
End Interface

[InterfaceId("BE666735-7800-4A77-9D9C-40F85B87E292")]
[OleAutomation(False)]
Interface IVdsSubSystem2 Extends stdole.IUnknown
    [Description("method GetProperties2")]
    Sub GetProperties2(ByRef pSubSystemProp2 As VDS_SUB_SYSTEM_PROP2)
    [Description("method GetDrive2")]
    Sub GetDrive2(ByVal sBusNumber As Integer, ByVal sSlotNumber As Integer, ByVal ulEnclosureNumber As Long, ByRef ppDrive As IVdsDrive)
    [Description("method CreateLun2")]
    Sub CreateLun2(ByVal type As VDS_LUN_TYPE, ByVal ullSizeInBytes As LongLong, ByRef pDriveIdArray As UUID, ByVal lNumberOfDrives As Long, ByVal pwszUnmaskingList As LongPtr, ByRef pHints2 As VDS_HINTS2, ByRef ppAsync As IVdsAsync)
    [Description("method QueryMaxLunCreateSize2")]
    Sub QueryMaxLunCreateSize2(ByVal type As VDS_LUN_TYPE, ByRef pDriveIdArray As UUID, ByVal lNumberOfDrives As Long, ByRef pHints2 As VDS_HINTS2, ByRef pullMaxLunSize As LongLong)
End Interface

[InterfaceId("0D70FAA3-9CD4-4900-AA20-6981B6AAFC75")]
[OleAutomation(False)]
Interface IVdsSubSystemNaming Extends stdole.IUnknown
    Sub SetFriendlyName(ByVal pwszFriendlyName As LongPtr)
End Interface

[InterfaceId("0027346F-40D0-4B45-8CEC-5906DC0380C8")]
[OleAutomation(False)]
Interface IVdsSubSystemIscsi Extends stdole.IUnknown
    [Description("method QueryTargets")]
    Sub QueryTargets(ByRef ppenum As IEnumVdsObject)
    [Description("method QueryPortals")]
    Sub QueryPortals(ByRef ppenum As IEnumVdsObject)
    [Description("method CreateTarget")]
    Sub CreateTarget(ByVal pwszIscsiName As LongPtr, ByVal pwszFriendlyName As LongPtr, ByRef ppAsync As IVdsAsync)
    [Description("method SetIpsecGroupPresharedKey")]
    Sub SetIpsecGroupPresharedKey(ByRef pIpsecKey As VDS_ISCSI_IPSEC_KEY)
End Interface

[InterfaceId("9E6FA560-C141-477B-83BA-0B6C38F7FEBF")]
[OleAutomation(False)]
Interface IVdsSubSystemInterconnect Extends stdole.IUnknown
    Sub GetSupportedInterconnects(ByRef pulSupportedInterconnectsFlag As VDS_INTERCONNECT_FLAG)
End Interface

[InterfaceId("18691D0D-4E7F-43E8-92E4-CF44BEEED11C")]
[OleAutomation(False)]
Interface IVdsControllerPort Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pPortProp As VDS_PORT_PROP)
    [Description("method GetController")]
    Sub GetController(ByRef ppController As IVdsController)
    [Description("method QueryAssociatedLuns")]
    Sub QueryAssociatedLuns(ByRef ppenum As IEnumVdsObject)
    [Description("method Reset")]
    Sub Reset()
    [Description("method SetStatus")]
    Sub SetStatus(ByVal Status As VDS_PORT_STATUS)
End Interface

[InterfaceId("CB53D96E-DFFB-474A-A078-790D1E2BC082")]
[OleAutomation(False)]
Interface IVdsController Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pControllerProp As VDS_CONTROLLER_PROP)
    [Description("method GetSubSystem")]
    Sub GetSubSystem(ByRef ppSubSystem As IVdsSubSystem)
    [Description("method GetPortProperties")]
    Sub GetPortProperties(ByVal sPortNumber As Integer, ByRef pPortProp As VDS_PORT_PROP)
    [Description("method FlushCache")]
    Sub FlushCache()
    [Description("method InvalidateCache")]
    Sub InvalidateCache()
    [Description("method Reset")]
    Sub Reset()
    [Description("method QueryAssociatedLuns")]
    Sub QueryAssociatedLuns(ByRef ppenum As IEnumVdsObject)
    [Description("method SetStatus")]
    Sub SetStatus(ByVal Status As VDS_CONTROLLER_STATUS)
End Interface

[InterfaceId("CA5D735F-6BAE-42C0-B30E-F2666045CE71")]
[OleAutomation(False)]
Interface IVdsControllerControllerPort Extends stdole.IUnknown
    [Description("method QueryControllerPorts")]
    Sub QueryControllerPorts(ByRef ppenum As IEnumVdsObject)
End Interface

[InterfaceId("FF24EFA4-AADE-4B6B-898B-EAA6A20887C7")]
[OleAutomation(False)]
Interface IVdsDrive Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pDriveProp As VDS_DRIVE_PROP)
    [Description("method GetSubSystem")]
    Sub GetSubSystem(ByRef ppSubSystem As IVdsSubSystem)
    [Description("method QueryExtents")]
    Sub QueryExtents(ByRef ppExtentArray As VDS_DRIVE_EXTENT, ByRef plNumberOfExtents As Long)
    [Description("method SetFlags")]
    Sub SetFlags(ByVal ulFlags As VDS_DRIVE_FLAG)
    [Description("method ClearFlags")]
    Sub ClearFlags(ByVal ulFlags As VDS_DRIVE_FLAG)
    [Description("method SetStatus")]
    Sub SetStatus(ByVal Status As VDS_DRIVE_STATUS)
End Interface

[InterfaceId("60B5A730-ADDF-4436-8CA7-5769E2D1FFA4")]
[OleAutomation(False)]
Interface IVdsDrive2 Extends stdole.IUnknown
    [Description("method GetProperties2")]
    Sub GetProperties2(ByRef pDriveProp2 As VDS_DRIVE_PROP2)
End Interface

[InterfaceId("3540A9C7-E60F-4111-A840-8BBA6C2C83D8")]
[OleAutomation(False)]
Interface IVdsLun Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pLunProp As VDS_LUN_PROP)
    [Description("method GetSubSystem")]
    Sub GetSubSystem(ByRef ppSubSystem As IVdsSubSystem)
    [Description("method GetIdentificationData")]
    Sub GetIdentificationData(ByRef pLunInfo As VDS_LUN_INFORMATION)
    [Description("method QueryActiveControllers")]
    Sub QueryActiveControllers(ByRef ppenum As IEnumVdsObject)
    [Description("method Extend")]
    Sub Extend(ByVal ullNumberOfBytesToAdd As LongLong, ByRef pDriveIdArray As UUID, ByVal lNumberOfDrives As Long, ByRef ppAsync As IVdsAsync)
    [Description("method Shrink")]
    Sub Shrink(ByVal ullNumberOfBytesToRemove As LongLong, ByRef ppAsync As IVdsAsync)
    [Description("method QueryPlexes")]
    Sub QueryPlexes(ByRef ppenum As IEnumVdsObject)
    #If Win64 Then
    [Description("method AddPlex")]
    Sub AddPlex(lunId As UUID, ByRef ppAsync As IVdsAsync)
    [Description("method RemovePlex")]
    Sub RemovePlex(plexId As UUID, ByRef ppAsync As IVdsAsync)
    #Else
    [Description("method AddPlex")]
    Sub AddPlex(ByVal lunId1 As Long, ByVal lunId2 As Long, ByVal lunId3 As Long, ByVal lunId4 As Long, ByRef ppAsync As IVdsAsync)
    [Description("method RemovePlex")]
    Sub RemovePlex(ByVal plexId1 As Long, ByVal plexId2 As Long, ByVal plexId3 As Long, ByVal plexId4 As Long, ByRef ppAsync As IVdsAsync)
    #End If
    [Description("method Recover")]
    Sub Recover(ByRef ppAsync As IVdsAsync)
    [Description("method SetMask")]
    Sub SetMask(ByVal pwszUnmaskingList As LongPtr)
    [Description("method Delete")]
    Sub Delete()
    [Description("method AssociateControllers")]
    Sub AssociateControllers(ByRef pActiveControllerIdArray As UUID, ByVal lNumberOfActiveControllers As Long, ByRef pInactiveControllerIdArray As UUID, ByVal lNumberOfInactiveControllers As Long)
    [Description("method QueryHints")]
    Sub QueryHints(ByRef pHints As VDS_HINTS)
    [Description("method ApplyHints")]
    Sub ApplyHints(ByRef pHints As VDS_HINTS)
    [Description("method SetStatus")]
    Sub SetStatus(ByVal Status As VDS_LUN_STATUS)
    [Description("method QueryMaxLunExtendSize")]
    Sub QueryMaxLunExtendSize(ByRef pDriveIdArray As UUID, ByVal lNumberOfDrives As Long, ByRef pullMaxBytesToBeAdded As LongLong)
End Interface

[InterfaceId("E5B3A735-9EFB-499A-8071-4394D9EE6FCB")]
[OleAutomation(False)]
Interface IVdsLun2 Extends stdole.IUnknown
    [Description("method QueryHints2")]
    Sub QueryHints2(ByRef pHints2 As VDS_HINTS2)
    [Description("method ApplyHints2")]
    Sub ApplyHints2(ByRef pHints2 As VDS_HINTS2)
End Interface

[InterfaceId("907504CB-6B4E-4D88-A34D-17BA661FBB06")]
[OleAutomation(False)]
Interface IVdsLunNaming Extends stdole.IUnknown
    Sub SetFriendlyName(ByVal pwszFriendlyName As LongPtr)
End Interface

[InterfaceId("D3F95E46-54B3-41F9-B678-0F1871443A08")]
[OleAutomation(False)]
Interface IVdsLunNumber Extends stdole.IUnknown
    Sub GetLunNumber(ByRef pulLunNumber As Long)
End Interface

[InterfaceId("451FE266-DA6D-406A-BB60-82E534F85AEB")]
[OleAutomation(False)]
Interface IVdsLunControllerPorts Extends stdole.IUnknown
    [Description("method AssociateControllerPorts")]
    Sub AssociateControllerPorts(ByRef pActiveControllerPortIdArray As UUID, ByVal lNumberOfActiveControllerPorts As Long, ByRef pInactiveControllerPortIdArray As UUID, ByVal lNumberOfInactiveControllerPorts As Long)
    [Description("method QueryActiveControllerPorts")]
    Sub QueryActiveControllerPorts(ByRef ppenum As IEnumVdsObject)
End Interface

[InterfaceId("7C5FBAE3-333A-48A1-A982-33C15788CDE3")]
[OleAutomation(False)]
Interface IVdsLunMpio Extends stdole.IUnknown
    [Description("method GetPathInfo")]
    Sub GetPathInfo(ByRef ppPaths As LongPtr, ByRef plNumberOfPaths As Long)
    [Description("method GetLoadBalancePolicy")]
    Sub GetLoadBalancePolicy(ByRef pPolicy As VDS_LOADBALANCE_POLICY_ENUM, ByRef ppPaths As LongPtr, ByRef plNumberOfPaths As Long)
    [Description("method SetLoadBalancePolicy")]
    Sub SetLoadBalancePolicy(ByVal policy As VDS_LOADBALANCE_POLICY_ENUM, ByRef pPaths As VDS_PATH_POLICY, ByVal lNumberOfPaths As Long)
    [Description("method GetSupportedLbPolicies")]
    Sub GetSupportedLbPolicies(ByRef pulLbFlags As VDS_PROVIDER_LBSUPPORT_FLAG)
End Interface

[InterfaceId("0D7C1E64-B59B-45AE-B86A-2C2CC6A42067")]
[OleAutomation(False)]
Interface IVdsLunIscsi Extends stdole.IUnknown
    [Description("method AssociateTargets")]
    Sub AssociateTargets(ByRef pTargetIdArray As UUID, ByVal lNumberOfTargets As Long)
    [Description("method QueryAssociatedTargets")]
    Sub QueryAssociatedTargets(ByRef ppenum As IEnumVdsObject)
End Interface

[InterfaceId("0EE1A790-5D2E-4ABB-8C99-C481E8BE2138")]
[OleAutomation(False)]
Interface IVdsLunPlex Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pPlexProp As VDS_LUN_PLEX_PROP)
    [Description("method GetLun")]
    Sub GetLun(ByRef ppLun As IVdsLun)
    [Description("method QueryExtents")]
    Sub QueryExtents(ByRef ppExtentArray As LongPtr, ByRef plNumberOfExtents As Long)
    [Description("method QueryHints")]
    Sub QueryHints(ByRef pHints As VDS_HINTS)
    [Description("method ApplyHints")]
    Sub ApplyHints(ByRef pHints As VDS_HINTS)
End Interface

[InterfaceId("7FA1499D-EC85-4A8A-A47B-FF69201FCD34")]
[OleAutomation(False)]
Interface IVdsIscsiPortal Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pPortalProp As VDS_ISCSI_PORTAL_PROP)
    [Description("method GetSubSystem")]
    Sub GetSubSystem(ByRef ppSubSystem As IVdsSubSystem)
    [Description("method QueryAssociatedPortalGroups")]
    Sub QueryAssociatedPortalGroups(ByRef ppenum As IEnumVdsObject)
    [Description("method SetStatus")]
    Sub SetStatus(ByVal Status As VDS_ISCSI_PORTAL_STATUS)
    [Description("method SetIpsecTunnelAddress")]
    Sub SetIpsecTunnelAddress(ByRef pTunnelAddress As VDS_IPADDRESS, ByRef pDestinationAddress As VDS_IPADDRESS)
    [Description("method GetIpsecSecurity")]
    Sub GetIpsecSecurity(ByRef pInitiatorPortalAddress As VDS_IPADDRESS, ByRef pullSecurityFlags As LongLong)
    [Description("method SetIpsecSecurity")]
    Sub SetIpsecSecurity(ByRef pInitiatorPortalAddress As VDS_IPADDRESS, ByVal ullSecurityFlags As LongLong, ByRef pIpsecKey As VDS_ISCSI_IPSEC_KEY)
End Interface

[InterfaceId("AA8F5055-83E5-4BCC-AA73-19851A36A849")]
[OleAutomation(False)]
Interface IVdsIscsiTarget Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pTargetProp As VDS_ISCSI_TARGET_PROP)
    [Description("method GetSubSystem")]
    Sub GetSubSystem(ByRef ppSubSystem As IVdsSubSystem)
    [Description("method QueryPortalGroups")]
    Sub QueryPortalGroups(ByRef ppenum As IEnumVdsObject)
    [Description("method QueryAssociatedLuns")]
    Sub QueryAssociatedLuns(ByRef ppenum As IEnumVdsObject)
    [Description("method CreatePortalGroup")]
    Sub CreatePortalGroup(ByRef ppAsync As IVdsAsync)
    [Description("method Delete")]
    Sub Delete(ByRef ppAsync As IVdsAsync)
    [Description("method SetFriendlyName")]
    Sub SetFriendlyName(ByVal pwszFriendlyName As LongPtr)
    [Description("method SetSharedSecret")]
    Sub SetSharedSecret(ByRef pTargetSharedSecret As VDS_ISCSI_SHARED_SECRET, ByVal pwszInitiatorName As LongPtr)
    [Description("method RememberInitiatorSharedSecret")]
    Sub RememberInitiatorSharedSecret(ByVal pwszInitiatorName As LongPtr, ByRef pInitiatorSharedSecret As VDS_ISCSI_SHARED_SECRET)
    [Description("method GetConnectedInitiators")]
    Sub GetConnectedInitiators(ByRef pppwszInitiatorList As LongPtr, ByRef plNumberOfInitiators As Long)
End Interface

[InterfaceId("FEF5F89D-A3DD-4B36-BF28-E7DDE045C593")]
[OleAutomation(False)]
Interface IVdsIscsiPortalGroup Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pPortalGroupProp As VDS_ISCSI_PORTALGROUP_PROP)
    [Description("method GetTarget")]
    Sub GetTarget(ByRef ppTarget As IVdsIscsiTarget)
    [Description("method QueryAssociatedPortals")]
    Sub QueryAssociatedPortals(ByRef ppenum As IEnumVdsObject)
    #If Win64 Then
    [Description("method AddPortal")]
    Sub AddPortal(portalId As UUID, ByRef ppAsync As IVdsAsync)
    [Description("method RemovePortal")]
    Sub RemovePortal(portalId As UUID, ByRef ppAsync As IVdsAsync)
    #Else
    [Description("method AddPortal")]
    Sub AddPortal(ByVal portalId1 As Long, ByVal portalId2 As Long, ByVal portalId3 As Long, ByVal portalId4 As Long, ByRef ppAsync As IVdsAsync)
    [Description("method RemovePortal")]
    Sub RemovePortal(ByVal portalId1 As Long, ByVal portalId2 As Long, ByVal portalId3 As Long, ByVal portalId4 As Long, ByRef ppAsync As IVdsAsync)
    #End If
    [Description("method Delete")]
    Sub Delete(ByRef ppAsync As IVdsAsync)
End Interface

[InterfaceId("932CA8CF-0EB3-4BA8-9620-22665D7F8450")]
[OleAutomation(False)]
Interface IVdsStoragePool Extends stdole.IUnknown
    [Description("method GetProvider")]
    Sub GetProvider(ByRef ppProvider As IVdsProvider)
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pStoragePoolProp As VDS_STORAGE_POOL_PROP)
    [Description("method GetAttributes")]
    Sub GetAttributes(ByRef pStoragePoolAttributes As VDS_POOL_ATTRIBUTES)
    [Description("method QueryDriveExtents")]
    Sub QueryDriveExtents(ByRef ppExtentArray As LongPtr, ByRef plNumberOfExtents As Long)
    [Description("method QueryAllocatedLuns")]
    Sub QueryAllocatedLuns(ByRef ppenum As IEnumVdsObject)
    [Description("method QueryAllocatedStoragePools")]
    Sub QueryAllocatedStoragePools(ByRef ppenum As IEnumVdsObject)
End Interface

[InterfaceId("DAEBEEF3-8523-47ED-A2B9-05CECCE2A1AE")]
[OleAutomation(False)]
Interface IVdsMaintenance Extends stdole.IUnknown
    [Description("method StartMaintenance")]
    Sub StartMaintenance(ByVal operation As VDS_MAINTENANCE_OPERATION)
    [Description("method StopMaintenance")]
    Sub StopMaintenance(ByVal operation As VDS_MAINTENANCE_OPERATION)
    [Description("method PulseMaintenance")]
    Sub PulseMaintenance(ByVal operation As VDS_MAINTENANCE_OPERATION, ByVal ulCount As Long)
End Interface

[InterfaceId("B481498C-8354-45F9-84A0-0BDD2832A91F")]
[OleAutomation(False)]
Interface IVdsVdProvider Extends stdole.IUnknown
    [Description("method QueryVDisks")]
    Sub QueryVDisks(ByRef ppenum As IEnumVdsObject)
    [Description("method CreateVDisk")]
    Sub CreateVDisk(ByRef VirtualDeviceType As VIRTUAL_STORAGE_TYPE, ByVal pPath As LongPtr, ByVal pStringSecurityDescriptor As LongPtr, ByVal flags As CREATE_VIRTUAL_DISK_FLAG, ByVal ProviderSpecificFlags As Long, ByVal reserved As Long, ByRef pCreateDiskParameters As VDS_CREATE_VDISK_PARAMETERS, ByRef ppAsync As IVdsAsync)
    [Description("method AddVDisk")]
    Sub AddVDisk(ByRef VirtualDeviceType As VIRTUAL_STORAGE_TYPE, ByVal pPath As LongPtr, ByRef ppVDisk As IVdsVDisk)
    Sub GetDiskFromVDisk(ByVal pVDisk As IVdsVDisk, ByRef ppDisk As IVdsDisk)
    Sub GetVDiskFromDisk(ByVal pDisk As IVdsDisk, ByRef ppVDisk As IVdsVDisk)
End Interface

[InterfaceId("1E062B84-E5E6-4B4B-8A25-67B81E8F13E8")]
[OleAutomation(False)]
Interface IVdsVDisk Extends stdole.IUnknown
    Sub Open(ByVal AccessMask As VIRTUAL_DISK_ACCESS_MASK, ByVal flags As OPEN_VIRTUAL_DISK_FLAG, ByVal ReadWriteDepth As Long, ByRef ppOpenVDisk As IVdsOpenVDisk)
    Sub GetProperties(ByRef pDiskProperties As VDS_VDISK_PROPERTIES)
    Sub GetHostVolume(ByRef ppVolume As IVdsVolume)
    Sub GetDeviceName(ByRef ppDeviceName As LongPtr)
End Interface

[InterfaceId("75C8F324-F715-4FE3-A28E-F9011B61A4A1")]
[OleAutomation(False)]
Interface IVdsOpenVDisk Extends stdole.IUnknown
    Sub Attach(ByVal pStringSecurityDescriptor As LongPtr, ByVal flags As ATTACH_VIRTUAL_DISK_FLAG, ByVal ProviderSpecificFlags As Long, ByVal timeOutInMs As Long, ByRef ppAsync As IVdsAsync)
    Sub Detach(ByVal flags As DETACH_VIRTUAL_DISK_FLAG, ByVal ProviderSpecificFlags As Long)
    Sub DetachAndDelete(ByVal flags As DETACH_VIRTUAL_DISK_FLAG, ByVal ProviderSpecificFlags As Long)
    Sub Compact(ByVal flags As COMPACT_VIRTUAL_DISK_FLAG, ByVal reserved As Long, ByRef ppAsync As IVdsAsync)
    Sub Merge(ByVal flags As MERGE_VIRTUAL_DISK_FLAG, ByVal MergeDepth As Long, ByRef ppAsync As IVdsAsync)
    Sub Expand(ByVal flags As EXPAND_VIRTUAL_DISK_FLAG, ByVal NewSize As LongLong, ByRef ppAsync As IVdsAsync)
End Interface

[InterfaceId("E0393303-90D4-4A97-AB71-E9B671EE2729")]
[OleAutomation(False)]
Interface IVdsServiceLoader Extends stdole.IUnknown
    [Description("method LoadService")]
    Sub LoadService(ByVal pwszMachineName As LongPtr, ByRef ppService As IVdsService)
End Interface

[InterfaceId("0818A8EF-9BA9-40D8-A6F9-E22833CC771E")]
[OleAutomation(False)]
Interface IVdsService Extends stdole.IUnknown
    [Description("method IsServiceReady")]
    Sub IsServiceReady()
    [Description("method WaitForServiceReady")]
    Sub WaitForServiceReady()
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pServiceProp As VDS_SERVICE_PROP)
    [Description("method QueryProviders")]
    Sub QueryProviders(ByVal masks As VDS_QUERY_PROVIDER_FLAG, ByRef ppenum As IEnumVdsObject)
    [Description("method QueryMaskedDisks")]
    Sub QueryMaskedDisks(ByRef ppenum As IEnumVdsObject)
    [Description("method QueryUnallocatedDisks")]
    Sub QueryUnallocatedDisks(ByRef ppenum As IEnumVdsObject)
    [Description("method GetObject")]
    #If Win64 Then
    Sub GetObject(ObjectId As UUID, ByVal type As VDS_OBJECT_TYPE, ByRef ppObjectUnk As IUnknown)
    #Else
    Sub GetObject(ByVal ObjectId1 As Long, ByVal ObjectId2 As Long, ByVal ObjectId3 As Long, ByVal ObjectId4 As Long, ByVal type As VDS_OBJECT_TYPE, ByRef ppObjectUnk As IUnknown)
    #End If
    [Description("method QueryDriveLetters")]
    Sub QueryDriveLetters(ByVal wcFirstLetter As Integer, ByVal Count As Long, ByRef pDriveLetterPropArray As VDS_DRIVE_LETTER_PROP)
    [Description("method QueryFileSystemTypes")]
    Sub QueryFileSystemTypes(ByRef ppFileSystemTypeProps As LongPtr, ByRef plNumberOfFileSystems As Long)
    [Description("method Reenumerate")]
    Sub Reenumerate()
    [Description("method Refresh")]
    Sub Refresh()
    [Description("method CleanupObsoleteMountPoints")]
    Sub CleanupObsoleteMountPoints()
    [Description("method Advise")]
    Sub Advise(ByVal pSink As IVdsAdviseSink, ByRef pdwCookie As Long)
    [Description("method Unadvise")]
    Sub Unadvise(ByVal dwCookie As Long)
    [Description("method Reboot")]
    Sub Reboot()
    [Description("method SetFlags")]
    Sub SetFlags(ByVal ulFlags As VDS_SERVICE_FLAG)
    [Description("method ClearFlags")]
    Sub ClearFlags(ByVal ulFlags As VDS_SERVICE_FLAG)
End Interface

[InterfaceId("B6B22DA8-F903-4BE7-B492-C09D875AC9DA")]
[OleAutomation(False)]
Interface IVdsServiceUninstallDisk Extends stdole.IUnknown
    [Description("method GetDiskIdFromLunInfo")]
    Sub GetDiskIdFromLunInfo(ByRef pLunInfo As VDS_LUN_INFORMATION, ByRef pDiskId As UUID)
    [Description("method UninstallDisks")]
    Sub UninstallDisks(ByRef pDiskIdArray As UUID, ByVal ulCount As Long, ByVal bForce As Byte, ByRef pbReboot As Byte, ByRef pResults As Long /* HRESULT */)
End Interface

[InterfaceId("0AC13689-3134-47C6-A17C-4669216801BE")]
[OleAutomation(False)]
Interface IVdsServiceHba Extends stdole.IUnknown
    [Description("method QueryHbaPorts")]
    Sub QueryHbaPorts(ByRef ppenum As IEnumVdsObject)
End Interface

[InterfaceId("14FBE036-3ED7-4E10-90E9-A5FF991AFF01")]
[OleAutomation(False)]
Interface IVdsServiceIscsi Extends stdole.IUnknown
    [Description("method GetInitiatorName")]
    Sub GetInitiatorName(ByRef ppwszIscsiName As LongPtr)
    [Description("method QueryInitiatorAdapters")]
    Sub QueryInitiatorAdapters(ByRef ppenum As IEnumVdsObject)
    [Description("method SetIpsecGroupPresharedKey")]
    Sub SetIpsecGroupPresharedKey(ByRef pIpsecKey As VDS_ISCSI_IPSEC_KEY)
    [Description("method SetAllIpsecTunnelAddresses")]
    Sub SetAllIpsecTunnelAddresses(ByRef pTunnelAddress As VDS_IPADDRESS, ByRef pDestinationAddress As VDS_IPADDRESS)
    #If Win64 Then
    [Description("method SetAllIpsecSecurity")]
    Sub SetAllIpsecSecurity(targetPortalId As UUID, ByVal ullSecurityFlags As LongLong, ByRef pIpsecKey As VDS_ISCSI_IPSEC_KEY)
    [Description("method SetInitiatorSharedSecret")]
    Sub SetInitiatorSharedSecret(ByRef pInitiatorSharedSecret As VDS_ISCSI_SHARED_SECRET, targetId As UUID)
    [Description("method RememberTargetSharedSecret")]
    Sub RememberTargetSharedSecret(targetId As UUID, ByRef pTargetSharedSecret As VDS_ISCSI_SHARED_SECRET)
    #Else
    [Description("method SetAllIpsecSecurity")]
    Sub SetAllIpsecSecurity(ByVal targetPortalId1 As Long, ByVal targetPortalId2 As Long, ByVal targetPortalId3 As Long, ByVal targetPortalId4 As Long, ByVal ullSecurityFlags As LongLong, ByRef pIpsecKey As VDS_ISCSI_IPSEC_KEY)
    [Description("method SetInitiatorSharedSecret")]
    Sub SetInitiatorSharedSecret(ByRef pInitiatorSharedSecret As VDS_ISCSI_SHARED_SECRET, ByVal targetId1 As Long, ByVal targetId2 As Long, ByVal targetId3 As Long, ByVal targetId4 As Long)
    [Description("method RememberTargetSharedSecret")]
    Sub RememberTargetSharedSecret(ByVal targetId1 As Long, ByVal targetId2 As Long, ByVal targetId3 As Long, ByVal targetId4 As Long, ByRef pTargetSharedSecret As VDS_ISCSI_SHARED_SECRET)
    #End If
End Interface

 [InterfaceId("4AFC3636-DB01-4052-80C3-03BBCB8D3C69")]
 [OleAutomation(False)]
 Interface IVdsServiceInitialization Extends stdole.IUnknown
     [Description("method Initialize")]
     Sub Initialize(ByVal pwszMachineName As LongPtr)
 End Interface

[InterfaceId("2ABD757F-2851-4997-9A13-47D2A885D6CA")]
[OleAutomation(False)]
Interface IVdsHbaPort Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pHbaPortProp As VDS_HBAPORT_PROP)
    [Description("method SetAllPathStatuses")]
    Sub SetAllPathStatuses(ByVal Status As VDS_PATH_STATUS)
End Interface

[InterfaceId("B07FEDD4-1682-4440-9189-A39B55194DC5")]
[OleAutomation(False)]
Interface IVdsIscsiInitiatorAdapter Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pInitiatorAdapterProp As VDS_ISCSI_INITIATOR_ADAPTER_PROP)
    [Description("method QueryInitiatorPortals")]
    Sub QueryInitiatorPortals(ByRef ppenum As IEnumVdsObject)
    #If Win64 Then
    [Description("method LoginToTarget")]
    Sub LoginToTarget(ByVal loginType As VDS_ISCSI_LOGIN_TYPE, targetId As UUID, targetPortalId As UUID, initiatorPortalId As UUID, ByVal ulLoginFlags As VDS_ISCSI_LOGIN_FLAG, ByVal bHeaderDigest As BOOL, ByVal bDataDigest As BOOL, ByVal authType As VDS_ISCSI_AUTH_TYPE, ByRef ppAsync As IVdsAsync)
    [Description("method LogoutFromTarget")]
    Sub LogoutFromTarget(targetId As UUID, ByRef ppAsync As IVdsAsync)
    #Else
    [Description("method LoginToTarget")]
    Sub LoginToTarget(ByVal loginType As VDS_ISCSI_LOGIN_TYPE, ByVal targetId1 As Long, ByVal targetId2 As Long, ByVal targetId3 As Long, ByVal targetId4 As Long, ByVal targetPortalId1 As Long, ByVal targetPortalId2 As Long, ByVal targetPortalId3 As Long, ByVal targetPortalId4 As Long, ByVal initiatorPortalId1 As Long, ByVal initiatorPortalId2 As Long, ByVal initiatorPortalId3 As Long, ByVal initiatorPortalId4 As Long, ByVal ulLoginFlags As VDS_ISCSI_LOGIN_FLAG, ByVal bHeaderDigest As BOOL, ByVal bDataDigest As BOOL, ByVal authType As VDS_ISCSI_AUTH_TYPE, ByRef ppAsync As IVdsAsync)
    [Description("method LogoutFromTarget")]
    Sub LogoutFromTarget(ByVal targetId1 As Long, ByVal targetId2 As Long, ByVal targetId3 As Long, ByVal targetId4 As Long, ByRef ppAsync As IVdsAsync)
    #End If
End Interface

[InterfaceId("38A0A9AB-7CC8-4693-AC07-1F28BD03C3DA")]
[OleAutomation(False)]
Interface IVdsIscsiInitiatorPortal Extends stdole.IUnknown
    [Description("method GetProperties")]
    Sub GetProperties(ByRef pInitiatorPortalProp As VDS_ISCSI_INITIATOR_PORTAL_PROP)
    [Description("method GetInitiatorAdapter")]
    Sub GetInitiatorAdapter(ByRef ppInitiatorAdapter As IVdsIscsiInitiatorAdapter)
    [Description("method SetIpsecTunnelAddress")]
    Sub SetIpsecTunnelAddress(ByRef pTunnelAddress As VDS_IPADDRESS, ByRef pDestinationAddress As VDS_IPADDRESS)
    #If Win64 Then
    [Description("method GetIpsecSecurity")]
    Sub GetIpsecSecurity(targetPortalId As UUID, ByRef pullSecurityFlags As LongLong)
    [Description("method SetIpsecSecurity")]
    Sub SetIpsecSecurity(targetPortalId As UUID, ByVal ullSecurityFlags As LongLong, ByRef pIpsecKey As VDS_ISCSI_IPSEC_KEY)
    #Else
    [Description("method GetIpsecSecurity")]
    Sub GetIpsecSecurity(ByVal targetPortalId1 As Long, ByVal targetPortalId2 As Long, ByVal targetPortalId3 As Long, ByVal targetPortalId4 As Long, ByRef pullSecurityFlags As LongLong)
    [Description("method SetIpsecSecurity")]
    Sub SetIpsecSecurity(ByVal targetPortalId1 As Long, ByVal targetPortalId2 As Long, ByVal targetPortalId3 As Long, ByVal targetPortalId4 As Long, ByVal ullSecurityFlags As LongLong, ByRef pIpsecKey As VDS_ISCSI_IPSEC_KEY)
    #End If
End Interface

[InterfaceId("538684E0-BA3D-4BC0-ACA9-164AFF85C2A9")]
[OleAutomation(False)]
Interface IVdsDiskPartitionMF Extends stdole.IUnknown
    [Description("method GetPartitionFileSystemProperties")]
    Sub GetPartitionFileSystemProperties(ByVal ullOffset As LongLong, ByRef pFileSystemProp As VDS_FILE_SYSTEM_PROP)
    [Description("method GetPartitionFileSystemTypeName")]
    Sub GetPartitionFileSystemTypeName(ByVal ullOffset As LongLong, ByRef ppwszFileSystemTypeName As LongPtr)
    [Description("method QueryPartitionFileSystemFormatSupport")]
    Sub QueryPartitionFileSystemFormatSupport(ByVal ullOffset As LongLong, ByRef ppFileSystemSupportProps As LongPtr, ByRef plNumberOfFileSystems As Long)
    [Description("method FormatPartitionEx")]
    Sub FormatPartitionEx(ByVal ullOffset As LongLong, ByVal pwszFileSystemTypeName As LongPtr, ByVal usFileSystemRevision As Integer, ByVal ulDesiredUnitAllocationSize As Long, ByVal pwszLabel As LongPtr, ByVal bForce As BOOL, ByVal bQuickFormat As BOOL, ByVal bEnableCompression As BOOL, ByRef ppAsync As IVdsAsync)
End Interface

 [InterfaceId("EE2D5DED-6236-4169-931D-B9778CE03DC6")]
 [OleAutomation(False)]
 Interface IVdsVolumeMF Extends stdole.IUnknown
     [Description("method queryFileSystemProperties")]
     Sub GetFileSystemProperties(ByRef pFileSystemProp As VDS_FILE_SYSTEM_PROP)
     [Description("method Format")]
     Sub Format(ByVal type As VDS_FILE_SYSTEM_TYPE, ByVal pwszLabel As LongPtr, ByVal dwUnitAllocationSize As Long, ByVal bForce As BOOL, ByVal bQuickFormat As BOOL, ByVal bEnableCompression As BOOL, ByRef ppAsync As IVdsAsync)
     [Description("method AddAccessPath")]
     Sub AddAccessPath(ByVal pwszPath As LongPtr)
     [Description("method QueryAccessPaths")]
     Sub QueryAccessPaths(ByRef pwszPathArray As LongPtr, ByRef plNumberOfAccessPaths As Long)
     [Description("method QueryReparsePoints")]
     Sub QueryReparsePoints(ByRef ppReparsePointProps As LongPtr, ByRef plNumberOfReparsePointProps As Long)
     [Description("method DeleteAccessPath")]
     Sub DeleteAccessPath(ByVal pwszPath As LongPtr, ByVal bForce As BOOL)
     [Description("method Mount")]
     Sub Mount()
     [Description("method Dismount")]
     Sub Dismount(ByVal bForce As BOOL, ByVal bPermanent As BOOL)
     [Description("method SetFileSystemFlags")]
     Sub SetFileSystemFlags(ByVal ulFlags As VDS_FILE_SYSTEM_FLAG)
     [Description("method ClearFileSystemFlags")]
     Sub ClearFileSystemFlags(ByVal ulFlags As VDS_FILE_SYSTEM_FLAG)
 End Interface

 [InterfaceId("4DBCEE9A-6343-4651-B85F-5E75D74D983C")]
 [OleAutomation(False)]
 Interface IVdsVolumeMF2 Extends stdole.IUnknown
     [Description("method GetFileSystemTypeName")]
     Sub GetFileSystemTypeName(ByRef ppwszFileSystemTypeName As LongPtr)
     [Description("method QueryFileSystemFormatSupport")]
     Sub QueryFileSystemFormatSupport(ByRef ppFileSystemSupportProps As LongPtr, ByRef plNumberOfFileSystems As Long)
     [Description("method FormatEx")]
     Sub FormatEx(ByVal pwszFileSystemTypeName As LongPtr, ByVal usFileSystemRevision As Integer, ByVal ulDesiredUnitAllocationSize As Long, ByVal pwszLabel As LongPtr, ByVal bForce As BOOL, ByVal bQuickFormat As BOOL, ByVal bEnableCompression As BOOL, ByRef ppAsync As IVdsAsync)
 End Interface

 [InterfaceId("D68168C9-82A2-4F85-B6E9-74707C49A58F")]
 [OleAutomation(False)]
 Interface IVdsVolumeShrink Extends stdole.IUnknown
     [Description("method QueryMaxReclaimableBytes")]
     Sub QueryMaxReclaimableBytes(ByRef pullMaxNumberOfReclaimableBytes As LongLong)
     [Description("method Shrink")]
     Sub Shrink(ByVal ullDesiredNumberOfReclaimableBytes As LongLong, ByVal ullMinNumberOfReclaimableBytes As LongLong, ByRef ppAsync As IVdsAsync)
 End Interface

 [InterfaceId("83BFB87F-43FB-4903-BAA6-127F01029EEC")]
 [OleAutomation(False)]
 Interface IVdsSubSystemImportTarget Extends stdole.IUnknown
     [Description("method GetImportTarget")]
     Sub GetImportTarget(ByRef ppwszIscsiName As LongPtr)
     [Description("method SetImportTarget")]
     Sub SetImportTarget(ByVal pwszIscsiName As LongPtr)
 End Interface

 [InterfaceId("AD837C28-52C1-421D-BF04-FAE7DA665396")]
 [OleAutomation(False)]
 Interface IVdsIscsiPortalLocal Extends stdole.IUnknown
     [Description("method SetIpsecSecurityLocal")]
     Sub SetIpsecSecurityLocal(ByVal ullSecurityFlags As LongLong, ByRef pIpsecKey As VDS_ISCSI_IPSEC_KEY)
 End Interface

 [InterfaceId("FC5D23E8-A88B-41A5-8DE0-2D2F73C5A630")]
 [OleAutomation(False)]
 Interface IVdsServiceSAN Extends stdole.IUnknown
     [Description("method GetSANPolicy")]
     Sub GetSANPolicy(ByRef pSanPolicy As VDS_SAN_POLICY)
     [Description("method SetSANPolicy")]
     Sub SetSANPolicy(ByVal SanPolicy As VDS_SAN_POLICY)
 End Interface

 [InterfaceId("6788FAF9-214E-4B85-BA59-266953616E09")]
 [OleAutomation(False)]
 Interface IVdsVolumeMF3 Extends stdole.IUnknown
     [Description("method QueryVolumeGuidPathnames")]
     Sub QueryVolumeGuidPathnames(ByRef pwszPathArray As LongPtr, ByRef pulNumberOfPaths As Long)
     [Description("method FormatEx2")]
     Sub FormatEx2(ByVal pwszFileSystemTypeName As LongPtr, ByVal usFileSystemRevision As Integer, ByVal ulDesiredUnitAllocationSize As Long, ByVal pwszLabel As LongPtr, ByVal Options As VDS_FORMAT_OPTION_FLAGS, ByRef ppAsync As IVdsAsync)
     [Description("method OfflineVolume")]
     Sub OfflineVolume()
 End Interface

 [InterfaceId("9CBE50CA-F2D2-4BF4-ACE1-96896B729625")]
 [OleAutomation(False)]
 Interface IVdsDiskPartitionMF2 Extends stdole.IUnknown
     [Description("method FormatPartitionEx2")]
     Sub FormatPartitionEx2(ByVal ullOffset As LongLong, ByVal pwszFileSystemTypeName As LongPtr, ByVal usFileSystemRevision As Integer, ByVal ulDesiredUnitAllocationSize As Long, ByVal pwszLabel As LongPtr, ByVal Options As VDS_FORMAT_OPTION_FLAGS, ByRef ppAsync As IVdsAsync)
 End Interface

 [InterfaceId("15FC031C-0652-4306-B2C3-F558B8F837E2")]
 [OleAutomation(False)]
 Interface IVdsServiceSw Extends stdole.IUnknown
     [Description("method GetDiskObject")]
     Sub GetDiskObject(ByVal pwszDeviceID As LongPtr, ByRef ppDiskUnk As IUnknown)
 End Interface

 [InterfaceId("11F3CD41-B7E8-48FF-9472-9DFF018AA292")]
 [OleAutomation(False)]
 Interface IVdsProviderPrivate Extends stdole.IUnknown
     [Description("method GetObject")]
    #If Win64 Then
    Sub GetObject(ObjectId As UUID, ByVal type As VDS_OBJECT_TYPE, ByRef ppObjectUnk As IUnknown)
    #Else
     Sub GetObject(ByVal ObjectId1 As Long, ByVal ObjectId2 As Long, ByVal ObjectId3 As Long, ByVal ObjectId4 As Long, ByVal type As VDS_OBJECT_TYPE, ByRef ppObjectUnk As IUnknown)
    #End If
     [Description("method OnLoad")]
     Sub OnLoad(ByVal pwszMachineName As LongPtr, ByVal pCallbackObject As IUnknown)
     [Description("method OnUnload")]
     Sub OnUnload(ByVal bForceUnload As BOOL)
 End Interface

 [InterfaceId("98F17BF3-9F33-4F12-8714-8B4075092C2E")]
 [OleAutomation(False)]
 Interface IVdsHwProviderPrivate Extends stdole.IUnknown
     [Description("method QueryIfOwnLun")]
     Sub QueryIfCreatedLun(ByVal pwszDevicePath As LongPtr, ByRef pVdsLunInformation As VDS_LUN_INFORMATION, ByRef pLunId As UUID)
 End Interface

 [InterfaceId("310A7715-AC2B-4C6F-9827-3D742F351676")]
 [OleAutomation(False)]
 Interface IVdsHwProviderPrivateMpio Extends stdole.IUnknown
     [Description("method SetAllPathStatusesFromHbaPort")]
     #If Win64 Then
     Sub SetAllPathStatusesFromHbaPort(ByRef hbaPortProp As VDS_HBAPORT_PROP, ByVal Status As VDS_PATH_STATUS)
    #Else
    Sub SetAllPathStatusesFromHbaPort(ByVal hbaPortProp1 As Long, ByVal hbaPortProp2 As Long, ByVal hbaPortProp3 As Long, ByVal hbaPortProp4 As Long, ByVal hbaPortProp5 As Long, ByVal hbaPortProp6 As Long, ByVal hbaPortProp7 As Long, ByVal hbaPortProp8 As Long, ByVal hbaPortProp9 As Long, ByVal hbaPortProp10 As Long, ByVal hbaPortProp11 As Long, ByVal hbaPortProp12 As Long, ByVal Status As VDS_PATH_STATUS)
    #End If
 End Interface

 [InterfaceId("D188E97D-85AA-4D33-ABC6-26299A10FFC1")]
 [OleAutomation(False)]
 Interface IVdsAdmin Extends stdole.IUnknown
     #If Win64 Then
     [Description("method RegisterProvider")]
     Sub RegisterProvider(providerId As UUID, providerClsId As UUID, ByVal pwszName As LongPtr, ByVal type As VDS_PROVIDER_TYPE, ByVal pwszMachineName As LongPtr, ByVal pwszVersion As LongPtr, guidVersion As UUID)
     [Description("method UnregisterProvider")]
     Sub UnregisterProvider(providerId As UUID)
     #Else
     [Description("method RegisterProvider")]
     Sub RegisterProvider(ByVal providerId1 As Long, ByVal providerId2 As Long, ByVal providerId3 As Long, ByVal providerId4 As Long, ByVal providerClsid1 As Long, ByVal providerClsid2 As Long, ByVal providerClsid3 As Long, ByVal providerClsid4 As Long, ByVal pwszName As LongPtr, ByVal type As VDS_PROVIDER_TYPE, ByVal pwszMachineName As LongPtr, ByVal pwszVersion As LongPtr, ByVal guidVersionId1 As Long, ByVal guidVersionId2 As Long, ByVal guidVersionId3 As Long, ByVal guidVersionId4 As Long)
     [Description("method UnregisterProvider")]
     Sub UnregisterProvider(ByVal providerId1 As Long, ByVal providerId2 As Long, ByVal providerId3 As Long, ByVal providerId4 As Long)
     #End If
 End Interface


'CLSID_VdsLoader
[CoClassId("9C38ED61-D565-4728-AEEE-C80952F0ECDE")]
CoClass VdsLoader
    [Default] Interface IVdsServiceLoader
End CoClass
    
 
 

Module wdVDS
    Public Enum VdsObjectStatus
        STATUS_UNKNOWN = 0
        STATUS_ONLINE = 1
        STATUS_NOT_READY = 2
        STATUS_NO_MEDIA = 3
        STATUS_OFFLINE = 4
        STATUS_FAILED = 5
        STATUS_MISSING = 6
        STATUS_STANDBY = 7
        STATUS_REMOVED = 8
        STATUS_PARTIALLY_MANAGED = 9
    End Enum
    
    Public Enum VDS_OBJECT_TYPE
        '  values >=0 and <10 are exposed to the service, client, and provider.
        '  values >=10 and <30 are reserved for software providers.
        '  values >=30 and <60 are reserved for hardware providers.
        '  values >=90 are reserved by the VDS service and not exposed to providers.
        '  values >=100 are used internally by the VDS service and not exposed to
        '   clients and providers.
        '  values >=200 are reserved for virtual disk storage providers.
        VDS_OT_UNKNOWN = 0
        VDS_OT_PROVIDER = 1
        VDS_OT_PACK = 10
        VDS_OT_VOLUME = 11
        VDS_OT_VOLUME_PLEX = 12
        VDS_OT_DISK = 13
        VDS_OT_SUB_SYSTEM = 30
        VDS_OT_CONTROLLER = 31
        VDS_OT_DRIVE = 32
        VDS_OT_LUN = 33
        VDS_OT_LUN_PLEX = 34
        VDS_OT_PORT = 35
        VDS_OT_PORTAL = 36
        VDS_OT_TARGET = 37
        VDS_OT_PORTAL_GROUP = 38
        VDS_OT_STORAGE_POOL = 39
        VDS_OT_HBAPORT = 90
        VDS_OT_INIT_ADAPTER = 91
        VDS_OT_INIT_PORTAL = 92
        VDS_OT_ASYNC = 100
        VDS_OT_ENUM = 101
        VDS_OT_VDISK = 200
        VDS_OT_OPEN_VDISK = 201
    End Enum
    
    Public Enum VDS_PROVIDER_TYPE
        VDS_PT_UNKNOWN = 0
        VDS_PT_SOFTWARE = 1
        VDS_PT_HARDWARE = 2
        VDS_PT_VIRTUALDISK = 3
        VDS_PT_MAX = 4
    End Enum
    
    Public Enum VDS_PROVIDER_FLAG
        ' 
        '  This flag is set by dynamic providers. Applications can tell from
        '  this flag if a disk is dynamic or not.
        ' 
        VDS_PF_DYNAMIC = &H00000001
        ' 
        '  The hardware provider manages an in-box hardware controller,
        '  instead of a external RAID cabinet.
        ' 
        VDS_PF_INTERNAL_HARDWARE_PROVIDER = &H00000002
        ' 
        '  This flag is for basic provider which does not really have the
        '  concept of pack. We fake a pack for each basic disk. The pack
        '  contains only one disk.
        ' 
        VDS_PF_ONE_DISK_ONLY_PER_PACK = &H00000004
        ' 
        '  This flag is for downrev provider. On a downrev machine, multiple
        '  disk groups(pack) are not supported. Only one pack can be online
        '  at a time.
        ' 
        VDS_PF_ONE_PACK_ONLINE_ONLY = &H00000008
        ' 
        '  All volumes managed by this provider must have contiguous space.
        '  This flag currently applies to basic provider only. We may remove
        '  it if we think it's enough to have VDS_PF_DYNAMIC flag.
        ' 
        VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS = &H00000010
        ' 
        '  These three are internal flags that will be translated to
        '  VDS_SVF_SUPPORT_DYNAMIC, VDS_SVF_SUPPORT_FAULT_TOLERANT
        '  VDS_SVF_SUPPORT_DYNAMIC_1394 by the service.
        ' 
        VDS_PF_SUPPORT_DYNAMIC = &H80000000
        VDS_PF_SUPPORT_FAULT_TOLERANT = &H40000000 ' Indicates that both mirrors and RAID5 are supported.
        VDS_PF_SUPPORT_DYNAMIC_1394 = &H20000000
        ' 
        '  Added for Windows 7. Client SKUs support mirrors but not RAID5.
        '  No change to server SKUs, both mirrors and RAID5 are supported.
        '  These are for the dynamic provider only.
        ' 
        VDS_PF_SUPPORT_MIRROR = &H00000020
        VDS_PF_SUPPORT_RAID5 = &H00000040
    End Enum
    
    Public Enum VDS_RECOVER_ACTION
        VDS_RA_UNKNOWN = 0
        VDS_RA_REFRESH = 1
        VDS_RA_RESTART = 2
    End Enum
    
    Public Enum VDS_NOTIFICATION_TARGET_TYPE
        VDS_NTT_UNKNOWN = 0
        VDS_NTT_PACK = VDS_OT_PACK
        VDS_NTT_VOLUME = VDS_OT_VOLUME
        VDS_NTT_DISK = VDS_OT_DISK
        VDS_NTT_PARTITION = 60
        VDS_NTT_DRIVE_LETTER = 61
        VDS_NTT_FILE_SYSTEM = 62
        VDS_NTT_MOUNT_POINT = 63
        VDS_NTT_SUB_SYSTEM = VDS_OT_SUB_SYSTEM
        VDS_NTT_CONTROLLER = VDS_OT_CONTROLLER
        VDS_NTT_DRIVE = VDS_OT_DRIVE
        VDS_NTT_LUN = VDS_OT_LUN
        VDS_NTT_PORT = VDS_OT_PORT
        VDS_NTT_PORTAL = VDS_OT_PORTAL
        VDS_NTT_TARGET = VDS_OT_TARGET
        VDS_NTT_PORTAL_GROUP = VDS_OT_PORTAL_GROUP
        VDS_NTT_SERVICE = 200
    End Enum
    
    Public Type VDS_PACK_NOTIFICATION
        ulEvent As VdsNotify
        packId As UUID
    End Type
    Public Type VDS_DISK_NOTIFICATION
        ulEvent As VdsNotify ' arrival, departure, modified.
        diskId As UUID
    End Type
    Public Type VDS_VOLUME_NOTIFICATION
        ulEvent As VdsNotify
        ' created, deleted, modified, resyncing progress
        volumeId As UUID
        plexId As UUID
        ' This is for resyncing and rebuilding only.
        ' resyncing can happen on more than one plex at
        ' different pace.
        ulPercentCompleted As Long
    End Type
    Public Type VDS_PARTITION_NOTIFICATION
        ulEvent As VdsNotify
        ' created, deleted, modified, resyncing progress
        diskId As UUID
        ullOffset As LongLong
    End Type
    Public Type VDS_SERVICE_NOTIFICATION
        ulEvent As VdsNotify
        action As VDS_RECOVER_ACTION
    End Type
    Public Type VDS_DRIVE_LETTER_NOTIFICATION
        ulEvent As VdsNotify ' freed, used
        wcLetter As Integer
        volumeId As UUID
    End Type
    Public Type VDS_FILE_SYSTEM_NOTIFICATION
        ulEvent As VdsNotify ' created, format progress
        volumeId As UUID
        dwPercentCompleted As Long
    End Type
    Public Type VDS_MOUNT_POINT_NOTIFICATION
        ulEvent As VdsNotify ' mount points changed
        volumeId As UUID
    End Type
    Public Type VDS_SUB_SYSTEM_NOTIFICATION
        ulEvent As VdsNotify
        subSystemId As UUID
    End Type
    Public Type VDS_CONTROLLER_NOTIFICATION
        ulEvent As VdsNotify
        controllerId As UUID
    End Type
    Public Type VDS_DRIVE_NOTIFICATION
        ulEvent As VdsNotify
        driveId As UUID
    End Type
    Public Type VDS_LUN_NOTIFICATION
        ulEvent As VdsNotify
        LunId As UUID
    End Type
    Public Type VDS_PORT_NOTIFICATION
        ulEvent As VdsNotify
        portId As UUID
    End Type
    Public Type VDS_PORTAL_NOTIFICATION
        ulEvent As VdsNotify
        portalId As UUID
    End Type
    Public Type VDS_TARGET_NOTIFICATION
        ulEvent As VdsNotify
        targetId As UUID
    End Type
    Public Type VDS_PORTAL_GROUP_NOTIFICATION
        ulEvent As VdsNotify
        portalGroupId As UUID
    End Type
    Public Type VDS_NOTIFICATION
        objectType As VDS_NOTIFICATION_TARGET_TYPE
        '[switch_is(objectType)] union
        '{
        '    [case(VDS_NTT_PACK)]
        '        VDS_PACK_NOTIFICATION           Pack;
        '    [case(VDS_NTT_DISK)]
        '        VDS_DISK_NOTIFICATION           Disk;
        '    [case(VDS_NTT_VOLUME)]
        '        VDS_VOLUME_NOTIFICATION         Volume;
        '    [case(VDS_NTT_PARTITION)]
        '        VDS_PARTITION_NOTIFICATION      Partition;
        '    [case(VDS_NTT_DRIVE_LETTER)]
        '        VDS_DRIVE_LETTER_NOTIFICATION   Letter;
        '    [case(VDS_NTT_FILE_SYSTEM)]
        '        VDS_FILE_SYSTEM_NOTIFICATION    FileSystem;
        '    [case(VDS_NTT_MOUNT_POINT)]
        '        VDS_MOUNT_POINT_NOTIFICATION    MountPoint;
        '    [case(VDS_NTT_SUB_SYSTEM)]
        '        VDS_SUB_SYSTEM_NOTIFICATION     SubSystem;
        '    [case(VDS_NTT_CONTROLLER)]
        '        VDS_CONTROLLER_NOTIFICATION     Controller;
        '    [case(VDS_NTT_DRIVE)]
        '        VDS_DRIVE_NOTIFICATION          Drive;
        '    [case(VDS_NTT_LUN)]
        '        VDS_LUN_NOTIFICATION            Lun;
        '    [case(VDS_NTT_PORT)]
        '        VDS_PORT_NOTIFICATION           Port;
        '    [case(VDS_NTT_PORTAL)]
        '        VDS_PORTAL_NOTIFICATION         Portal;
        '    [case(VDS_NTT_TARGET)]
        '        VDS_TARGET_NOTIFICATION         Target;
        '    [case(VDS_NTT_PORTAL_GROUP)]
        '        VDS_PORTAL_GROUP_NOTIFICATION   PortalGroup;
        '    [case(VDS_NTT_SERVICE)]
        '        VDS_SERVICE_NOTIFICATION        Service;
        '    [default] ;
        '};
        pad As Long
        u(0 To 39) As Byte
    End Type
    
    Public Enum VDS_ASYNC_OUTPUT_TYPE
        VDS_ASYNCOUT_UNKNOWN = 0
        VDS_ASYNCOUT_CREATEVOLUME = 1
        VDS_ASYNCOUT_EXTENDVOLUME = 2
        VDS_ASYNCOUT_SHRINKVOLUME = 3
        VDS_ASYNCOUT_ADDVOLUMEPLEX = 4
        VDS_ASYNCOUT_BREAKVOLUMEPLEX = 5
        VDS_ASYNCOUT_REMOVEVOLUMEPLEX = 6
        VDS_ASYNCOUT_REPAIRVOLUMEPLEX = 7
        VDS_ASYNCOUT_RECOVERPACK = 8
        VDS_ASYNCOUT_REPLACEDISK = 9
        VDS_ASYNCOUT_CREATEPARTITION = 10
        VDS_ASYNCOUT_CLEAN = 11
        VDS_ASYNCOUT_CREATELUN = 50
        '     VDS_ASYNCOUT_BREAKLUNPLEX       = 51, // ** DEPRECATED **
        VDS_ASYNCOUT_ADDLUNPLEX = 52
        VDS_ASYNCOUT_REMOVELUNPLEX = 53
        VDS_ASYNCOUT_EXTENDLUN = 54
        VDS_ASYNCOUT_SHRINKLUN = 55
        VDS_ASYNCOUT_RECOVERLUN = 56
        '  iSCSI related asyncs
        VDS_ASYNCOUT_LOGINTOTARGET = 60
        VDS_ASYNCOUT_LOGOUTFROMTARGET = 61
        VDS_ASYNCOUT_CREATETARGET = 62
        VDS_ASYNCOUT_CREATEPORTALGROUP = 63
        VDS_ASYNCOUT_DELETETARGET = 64
        VDS_ASYNCOUT_ADDPORTAL = 65
        VDS_ASYNCOUT_REMOVEPORTAL = 66
        VDS_ASYNCOUT_DELETEPORTALGROUP = 67
        VDS_ASYNCOUT_FORMAT = 101
        ' 
        '  Virtual disk related output.
        ' 
        VDS_ASYNCOUT_CREATE_VDISK = 200
        VDS_ASYNCOUT_ATTACH_VDISK = 201
        VDS_ASYNCOUT_COMPACT_VDISK = 202
        VDS_ASYNCOUT_MERGE_VDISK = 203
        VDS_ASYNCOUT_EXPAND_VDISK = 204
    End Enum
    Public Type VDS_ASYNC_OUTPUT
        type As VDS_ASYNC_OUTPUT_TYPE
        '[switch_is(type)] union
        '{
        '    // CreatePartition() or CreatePartitionEx() return value.
        '    [case(VDS_ASYNCOUT_CREATEPARTITION)]
        '        struct _cp
        '    {
        '        ULONGLONG ullOffset;    // acual offset of the create partition
        '        UUID volumeId; // ID of the associated volume if the
        '        // partition is a volume.
        '    } cp;
        '    // CreateVolume() return value
        '    [case(VDS_ASYNCOUT_CREATEVOLUME)]
        '        struct _cv
        '    {
        '        IUnknown* pVolumeUnk;
        '    } cv;
        '    // BreakPlex() return value
        '    [case(VDS_ASYNCOUT_BREAKVOLUMEPLEX)]
        '        struct _bvp
        '    {
        '        IUnknown* pVolumeUnk;
        '    } bvp;
        '    // Shrink() return value
        '    [case(VDS_ASYNCOUT_SHRINKVOLUME)]
        '        struct _sv
        '    {
        '        ULONGLONG    ullReclaimedBytes;    // actual number of reclaimed bytes
        '    } sv;
        '    [case(VDS_ASYNCOUT_CREATELUN)]
        '        struct _cl
        '    {
        '        IUnknown* pLunUnk;
        '    } cl;
        '    /** DEPRECATED **
        '    *        [case(VDS_ASYNCOUT_BREAKLUNPLEX)]
        '    *        struct _blp
        '    *        {
        '    *            IUnknown *pLunUnk;
        '    *
        '    *        } blp;
        '    */
        '    // CreateTarget() return value
        '    [case(VDS_ASYNCOUT_CREATETARGET)]
        '        struct _ct
        '    {
        '        IUnknown* pTargetUnk;
        '    } ct;
        '    // CreatePortalGroup() return value
        '    [case(VDS_ASYNCOUT_CREATEPORTALGROUP)]
        '        struct _cpg
        '    {
        '        IUnknown* pPortalGroupUnk;
        '    } cpg;
        '    [case(VDS_ASYNCOUT_CREATE_VDISK)]
        '        struct _cvd
        '    {
        '        IUnknown* pVDiskUnk;
        '    } cvd;
        '    [default] ;
        '};
        pad As Long
        u(0 To 23) As Byte
    End Type
    
    Public Enum VDS_IPADDRESS_TYPE
        VDS_IPT_TEXT = 0
        VDS_IPT_IPV4 = 1
        VDS_IPT_IPV6 = 2
        VDS_IPT_EMPTY = 3
    End Enum
    
    Public Enum VDS_HEALTH
        VDS_H_UNKNOWN = 0
        VDS_H_HEALTHY = 1
        VDS_H_REBUILDING = 2
        VDS_H_STALE = 3
        VDS_H_FAILING = 4
        VDS_H_FAILING_REDUNDANCY = 5
        VDS_H_FAILED_REDUNDANCY = 6
        VDS_H_FAILED_REDUNDANCY_FAILING = 7
        VDS_H_FAILED = 8
        VDS_H_REPLACED = 9
        VDS_H_PENDING_FAILURE = 10
        VDS_H_DEGRADED = 11
    End Enum
    
    Public Enum VDS_TRANSITION_STATE
        VDS_TS_UNKNOWN = 0
        VDS_TS_STABLE = 1
        VDS_TS_EXTENDING = 2
        VDS_TS_SHRINKING = 3
        VDS_TS_RECONFIGING = 4 ' Volume is changing location on disk.
        VDS_TS_RESTRIPING = 5
    End Enum
    
    Public Enum VDS_FILE_SYSTEM_TYPE
        VDS_FST_UNKNOWN = 0
        VDS_FST_RAW
        VDS_FST_FAT
        VDS_FST_FAT32
        VDS_FST_NTFS
        VDS_FST_CDFS
        VDS_FST_UDF
        VDS_FST_EXFAT
        VDS_FST_CSVFS
        VDS_FST_REFS
    End Enum
    
    Public Enum VDS_HBAPORT_TYPE
        '  These types correspond to the definitions in the HBA API
        VDS_HPT_UNKNOWN = 1 ' Unknown
        VDS_HPT_OTHER = 2 ' Other
        VDS_HPT_NOTPRESENT = 3 ' Not present
        VDS_HPT_NPORT = 5 ' Fabric
        VDS_HPT_NLPORT = 6 ' Public Loop
        VDS_HPT_FLPORT = 7 ' Fabric on a Loop
        VDS_HPT_FPORT = 8 ' Fabric Port
        VDS_HPT_EPORT = 9 ' Fabric Expansion Port
        VDS_HPT_GPORT = 10 ' Generic Fabric Port
        VDS_HPT_LPORT = 20 ' Private Loop
        VDS_HPT_PTP = 21 ' Point to Point
    End Enum
    
    Public Enum VDS_HBAPORT_STATUS
        '  These states correspond to the definitions in the HBA API
        VDS_HPS_UNKNOWN = 1 ' Unknown
        VDS_HPS_ONLINE = 2 ' Operational
        VDS_HPS_OFFLINE = 3 ' User Offline
        VDS_HPS_BYPASSED = 4 ' Bypassed
        VDS_HPS_DIAGNOSTICS = 5 ' In Diagnostics Mode
        VDS_HPS_LINKDOWN = 6 ' Link Down
        VDS_HPS_ERROR = 7 ' Port Error
        VDS_HPS_LOOPBACK = 8 ' Loopback
    End Enum
    
    Public Enum VDS_HBAPORT_SPEED_FLAG
        '  These flags correspond to the definitions in the HBA API
        VDS_HSF_UNKNOWN = &H0 ' Unknown - transceiver incapable of reporting
        VDS_HSF_1GBIT = &H1 ' 1 GBit/sec
        VDS_HSF_2GBIT = &H2 ' 2 GBit/sec
        VDS_HSF_10GBIT = &H4 ' 10 GBit/sec
        VDS_HSF_4GBIT = &H8 ' 4 GBit/sec
        VDS_HSF_NOT_NEGOTIATED = &H8000& '(1 << 15) // Speed not established
    End Enum
    
    Public Enum VDS_PATH_STATUS
        VDS_MPS_UNKNOWN = STATUS_UNKNOWN
        VDS_MPS_ONLINE = STATUS_ONLINE
        VDS_MPS_FAILED = STATUS_FAILED
        VDS_MPS_STANDBY = STATUS_STANDBY
    End Enum
    
    Public Enum VDS_LOADBALANCE_POLICY_ENUM
        VDS_LBP_UNKNOWN = 0
        VDS_LBP_FAILOVER = 1
        VDS_LBP_ROUND_ROBIN = 2
        VDS_LBP_ROUND_ROBIN_WITH_SUBSET = 3
        VDS_LBP_DYN_LEAST_QUEUE_DEPTH = 4
        VDS_LBP_WEIGHTED_PATHS = 5
        VDS_LBP_LEAST_BLOCKS = 6
        VDS_LBP_VENDOR_SPECIFIC = 7
    End Enum
    
    Public Enum VDS_PROVIDER_LBSUPPORT_FLAG
        VDS_LBF_FAILOVER = &H01
        VDS_LBF_ROUND_ROBIN = &H02
        VDS_LBF_ROUND_ROBIN_WITH_SUBSET = &H04
        VDS_LBF_DYN_LEAST_QUEUE_DEPTH = &H08
        VDS_LBF_WEIGHTED_PATHS = &H10
        VDS_LBF_LEAST_BLOCKS = &H20
        VDS_LBF_VENDOR_SPECIFIC = &H40
    End Enum
    
    Public Enum VDS_VERSION_SUPPORT_FLAG
        VDS_VSF_1_0 = &H01
        VDS_VSF_1_1 = &H02
        VDS_VSF_2_0 = &H04
        VDS_VSF_2_1 = &H08
        VDS_VSF_3_0 = &H10
    End Enum
    
    Public Enum VDS_HWPROVIDER_TYPE
        VDS_HWT_UNKNOWN = 0
        VDS_HWT_PCI_RAID = 1
        VDS_HWT_FIBRE_CHANNEL = 2
        VDS_HWT_ISCSI = 3
        VDS_HWT_SAS = 4
        VDS_HWT_HYBRID = 5
    End Enum
    
    Public Enum VDS_ISCSI_LOGIN_TYPE
        VDS_ILT_MANUAL = 0
        VDS_ILT_PERSISTENT = 1
        VDS_ILT_BOOT = 2
    End Enum
    
    Public Enum VDS_ISCSI_AUTH_TYPE
        VDS_IAT_NONE = 0
        VDS_IAT_CHAP = 1
        VDS_IAT_MUTUAL_CHAP = 2
    End Enum
    
    Public Enum VDS_ISCSI_IPSEC_FLAG
        '  These flags correspond to the definitions in the iSNS portal security bitmap
        VDS_IIF_VALID = &H01
        VDS_IIF_IKE = &H02
        VDS_IIF_MAIN_MODE = &H04
        VDS_IIF_AGGRESSIVE_MODE = &H08
        VDS_IIF_PFS_ENABLE = &H10
        VDS_IIF_TRANSPORT_MODE_PREFERRED = &H20
        VDS_IIF_TUNNEL_MODE_PREFERRED = &H40
    End Enum
    
    Public Enum VDS_ISCSI_LOGIN_FLAG
        VDS_ILF_REQUIRE_IPSEC = &H1
        VDS_ILF_MULTIPATH_ENABLED = &H2
    End Enum
    
    Public Type VDS_PATH_ID
        ullSourceId As LongLong
        ullPathId As LongLong
    End Type
    
    Public Type VDS_WWN
        ' This structure corresponds to the HBA_WWN structure in the HBA API
        rguchWwn(0 To 7) As Byte
    End Type
    
    Public Type VDS_IPADDRESS
        type As VDS_IPADDRESS_TYPE
        ipv4Address As Long
        ipv6Address(0 To 15) As Byte
        ulIpv6FlowInfo As Long
        ulIpv6ScopeId As Long
        wszTextAddress(0 To 256) As Integer
        ulPort As Long
    End Type
    
    Public Type VDS_ISCSI_IPSEC_KEY
        '[size_is(ulKeySize)] UCHAR* pKey;
        pKey As LongPtr
        ulKeySize As Long
    End Type
    
    Public Type VDS_ISCSI_SHARED_SECRET
        '[size_is(ulSharedSecretSize)] UCHAR* pSharedSecret;
        pSharedSecret As LongPtr
        ulSharedSecretSize As Long
    End Type
    
    Public Type VDS_HBAPORT_PROP
        id As UUID
        wwnNode As VDS_WWN
        wwnPort As VDS_WWN
        type As VDS_HBAPORT_TYPE
        status As VDS_HBAPORT_STATUS
        ulPortSpeed As Long
        ulSupportedPortSpeed As Long
    End Type
    
    Public Type VDS_ISCSI_INITIATOR_ADAPTER_PROP
        id As UUID
        pwszName As LongPtr
    End Type
    
    Public Type VDS_ISCSI_INITIATOR_PORTAL_PROP
        id As UUID
        address As VDS_IPADDRESS
        ulPortIndex As Long
    End Type
    
    Public Type VDS_PROVIDER_PROP
        id As UUID
        pwszName As LongPtr
        guidVersionId As UUID
        pwszVersion As LongPtr
        type As VDS_PROVIDER_TYPE
        ulFlags As VDS_PROVIDER_FLAG
        ulStripeSizeFlags As Long
        ' This is for software provider only.
        ' The Microsoft dynamic provider supports only 64k as a stripe size.
        ' The Microsoft basic provider should set this to 0 - it does not support stripes.
        sRebuildPriority As Integer
        ' This field is not used by microsoft providers.
    End Type
    
    Public Type VDS_PATH_INFO
        pathId As VDS_PATH_ID
        type As VDS_HWPROVIDER_TYPE
        status As VDS_PATH_STATUS
        '// subsystem-side endpoint of the path
        '[switch_is(type)] union
        '{
        '    [case(VDS_HWT_FIBRE_CHANNEL, VDS_HWT_SAS)]
        '        UUID       controllerPortId;
        '    [case(VDS_HWT_ISCSI)]
        '        UUID       targetPortalId;
        '    [default] ;
        '};
        u1 As UUID
        '// local server-side endpoint of the path
        '[switch_is(type)] union
        '{
        '    [case(VDS_HWT_FIBRE_CHANNEL, VDS_HWT_SAS)]
        '        UUID       hbaPortId;
        '    [case(VDS_HWT_ISCSI)]
        '        UUID       initiatorAdapterId;
        '    [default] ;
        '};
        u2 As UUID
        '// additional information about the local server-side endpoint of the path
        '[switch_is(type)] union
        '{
        '    [case(VDS_HWT_FIBRE_CHANNEL, VDS_HWT_SAS)]
        '        VDS_HBAPORT_PROP* pHbaPortProp;
        '    [case(VDS_HWT_ISCSI)]
        '        VDS_IPADDRESS* pInitiatorPortalIpAddr;
        '    [default] ;
        '};
        u3 As LongPtr
    End Type
    
    Public Type VDS_PATH_POLICY
        pathId As VDS_PATH_ID
        bPrimaryPath As BOOL
        ulWeight As Long ' only relevant for VDS_LBP_WEIGHTED_PATHS
    End Type
    
    Public Enum VDS_STORAGE_IDENTIFIER_CODE_SET
        VDSStorageIdCodeSetReserved = 0
        VDSStorageIdCodeSetBinary = 1
        VDSStorageIdCodeSetAscii = 2
        VDSStorageIdCodeSetUtf8 = 3
    End Enum
    
    Public Enum VDS_STORAGE_IDENTIFIER_TYPE
        VDSStorageIdTypeVendorSpecific = 0
        VDSStorageIdTypeVendorId = 1
        VDSStorageIdTypeEUI64 = 2
        VDSStorageIdTypeFCPHName = 3
        VDSStorageIdTypePortRelative = 4
        VDSStorageIdTypeTargetPortGroup = 5
        VDSStorageIdTypeLogicalUnitGroup = 6
        VDSStorageIdTypeMD5LogicalUnitIdentifier = 7
        VDSStorageIdTypeScsiNameString = 8
    End Enum
    
    Public Enum VDS_STORAGE_BUS_TYPE
        VDSBusTypeUnknown = &H00
        VDSBusTypeScsi = &H01
        VDSBusTypeAtapi = &H02
        VDSBusTypeAta = &H03
        VDSBusType1394 = &H04
        VDSBusTypeSsa = &H05
        VDSBusTypeFibre = &H06
        VDSBusTypeUsb = &H07
        VDSBusTypeRAID = &H08
        VDSBusTypeiScsi = &H09
        VDSBusTypeSas = &H0A
        VDSBusTypeSata = &H0B
        VDSBusTypeSd = &H0C
        VDSBusTypeMmc = &H0D
        VDSBusTypeMax = &H0E ' Keeping it for Legacy. Applications should migrate to assuming BusTypeVirtual is 0x0E
        VDSBusTypeVirtual = &H0E
        VDSBusTypeFileBackedVirtual = &H0F
        VDSBusTypeSpaces = &H10
        VDSBusTypeNVMe = &H11
        VDSBusTypeScm = &H12
        VDSBusTypeUfs = &H13
        VDSBusTypeMaxReserved = &H7F
    End Enum
    
    Public Type VDS_STORAGE_IDENTIFIER
        ' whether ascii or binary data
        m_CodeSet As VDS_STORAGE_IDENTIFIER_CODE_SET
        ' type of identifier
        m_Type As VDS_STORAGE_IDENTIFIER_TYPE
        ' length of identifier in bytes
        m_cbIdentifier As Long
        ' actual identintifier
        '[size_is(m_cbIdentifier)] BYTE* m_rgbIdentifier;
        m_rgbIdentifier As LongPtr
    End Type
    
    Public Type VDS_STORAGE_DEVICE_ID_DESCRIPTOR
        ' version of structure
        m_version As Long
        ' number of identifiers
        m_cIdentifiers As Long
        '[size_is(m_cIdentifiers)] VDS_STORAGE_IDENTIFIER* m_rgIdentifiers;
        m_rgIdentifiers As LongPtr
    End Type
    
    Public Enum VDS_INTERCONNECT_ADDRESS_TYPE
        VDS_IA_UNKNOWN = 0
        VDS_IA_FCFS = 1
        VDS_IA_FCPH = 2
        VDS_IA_FCPH3 = 3
        VDS_IA_MAC = 4
        VDS_IA_SCSI = 5
    End Enum
    
    Public Type VDS_INTERCONNECT
        ' address type
        m_addressType As VDS_INTERCONNECT_ADDRESS_TYPE
        ' port that address refers to
        m_cbPort As Long
        ' actual address of port
        m_pbPort As LongPtr '[size_is(m_cbPort)] BYTE*
        ' size of address
        m_cbAddress As Long
        ' address relative to the port
        m_pbAddress As LongPtr '[size_is(m_cbAddress)] BYTE* 
    End Type
    
    Public Type VDS_LUN_INFORMATION
        ' version of structure
        m_version As Long
        ' The SCSI-2 device type
        m_DeviceType As Byte
        ' The SCSI-2 device type modifier (if any) - this may be zero
        m_DeviceTypeModifier As Byte
        ' Flag indicating whether the device can support mulitple outstanding
        ' commands.  The actual synchronization in this case is the responsibility
        ' of the port driver.
        m_bCommandQueueing As BOOL
        ' Contains the bus type (as defined above) of the device.  It should be
        ' used to interpret the raw device properties at the end of this structure
        ' (if any).
        ' The bus type for mode page 0x83 is currently determined by looking at the
        ' registry, which is set by the inf.
        ' This results in the bus type being bogus if the driver writer did not set
        ' this property correctly.
        m_BusType As VDS_STORAGE_BUS_TYPE
        ' vendor id string.  For devices with no such ID this will be zero
        '[string] char* m_szVendorId;
        m_szVendorId As LongPtr '[string] char*
        ' device's product id string.  For devices with no such ID this will be zero
        m_szProductId As LongPtr '[string] char*
        ' zero-terminated ascii string containing the device's
        ' product revision string.  For devices with no such string this will be
        ' zero
        m_szProductRevision As LongPtr '[string] char*
        ' zero-terminated ascii string containing the device's
        ' serial number.  For devices with no serial number this will be zero.
        ' Mode page 0x80, optional
        m_szSerialNumber As LongPtr '[string] char*
        ' disk signature
        m_diskSignature As UUID
        ' device id descriptor
        m_deviceIdDescriptor As VDS_STORAGE_DEVICE_ID_DESCRIPTOR
        ' number of interconnects
        m_cInterconnects As Long
        ' array of interconnects
        m_rgInterconnects As LongPtr ' [size_is(m_cInterconnects)] VDS_INTERCONNECT*
    End Type
    
    Public Enum VDS_PACK_STATUS
        VDS_PS_UNKNOWN = STATUS_UNKNOWN
        VDS_PS_ONLINE = STATUS_ONLINE
        VDS_PS_OFFLINE = STATUS_OFFLINE
    End Enum
    
    Public Enum VDS_PACK_FLAG
        VDS_PKF_FOREIGN = &H1
        '  Set on all packs that are not the primary\online pack.
        VDS_PKF_NOQUORUM = &H2
        '  This flag was not used on W2K3 and will not be used on LH either.
        VDS_PKF_POLICY = &H4
        '  Will be set on personal SKU for the dynamic provider - pack is offline
        '  because dyanmic disks are not supported on the OS SKU.
        VDS_PKF_CORRUPTED = &H8
        '  This flag indicates the disk contained in the pack has a corrupted
        '  database.
        VDS_PKF_ONLINE_ERROR = &H10
        '  This flag indicates the pack is offline because error happened when
        '  trying to online it. The config will be offline if 1) we do not have quorum,
        '  or, 2) there were online errors. For both of these cases, we will set the
        '  VDS_PKF_ONLINE_ERROR flag on the pack.
    End Enum
    
    Public Enum VDS_DISK_STATUS
        VDS_DS_UNKNOWN = STATUS_UNKNOWN
        VDS_DS_ONLINE = STATUS_ONLINE
        VDS_DS_NOT_READY = STATUS_NOT_READY ' One example is with ACPI Power Management. You can ask a disk to
        '  hibernate (spin down).
        VDS_DS_NO_MEDIA = STATUS_NO_MEDIA ' This flag is for removable media, CDROM.
        VDS_DS_FAILED = STATUS_FAILED
        VDS_DS_MISSING = STATUS_MISSING
        VDS_DS_OFFLINE = STATUS_OFFLINE ' Added to W2K8
    End Enum
    
    Public Enum VDS_PARTITION_STYLE
        VDS_PST_UNKNOWN = 0
        VDS_PST_MBR = 1
        VDS_PST_GPT = 2
    End Enum
    
    Public Enum VDS_DISK_FLAG
        VDS_DF_AUDIO_CD = &H1
        VDS_DF_HOTSPARE = &H2
        VDS_DF_RESERVE_CAPABLE = &H4
        VDS_DF_MASKED = &H8
        VDS_DF_STYLE_CONVERTIBLE = &H10
        VDS_DF_CLUSTERED = &H20
        VDS_DF_READ_ONLY = &H40 ' Added to Vista SP1, Windows Server 2008
        VDS_DF_SYSTEM_DISK = &H80 ' Added to Vista SP1, Windows Server 2008
        VDS_DF_BOOT_DISK = &H100 ' Added to Vista SP1, Windows Server 2008
        VDS_DF_PAGEFILE_DISK = &H200 ' Added to Vista SP1, Windows Server 2008
        VDS_DF_HIBERNATIONFILE_DISK = &H400 ' Added to Vista SP1, Windows Server 2008
        VDS_DF_CRASHDUMP_DISK = &H800 ' Added to Vista SP1, Windows Server 2008
        VDS_DF_HAS_ARC_PATH = &H1000 ' Added to Vista SP1, Windows Server 2008
        VDS_DF_DYNAMIC = &H2000 ' Added to Vista SP1, Windows Server 2008
        VDS_DF_BOOT_FROM_DISK = &H4000 ' Added to Windows7, indicates the disk from
        '  which the machine will boot.
        '  Note that this is BIOS disk 0 on MBR, not
        '  the CURRENT system volume disk.
        '  for example if you are booted to WinPE,
        '  this flag is set on BIOS disk 0. For EFI
        '  machines, this flag is set on disk containing
        '  the ESP used to boot the machine.
        VDS_DF_CURRENT_READ_ONLY = &H8000& ' Added to Windows7, indicates that the
        '  current read-only state of the disk.
        VDS_DF_REFS_NOT_SUPPORTED = &H10000 ' Added to WindowsBLUE.
    End Enum
    
    Public Enum VDS_PARTITION_FLAG
        VDS_PTF_SYSTEM = &H1 ' whether this partition is a system
        '  partition. We need this flag because
        '  we don't return ESP partitions as
        '  volumes.
    End Enum
    
    Public Enum VDS_LUN_RESERVE_MODE
        VDS_LRM_NONE = 0
        VDS_LRM_EXCLUSIVE_RW = 1
        VDS_LRM_EXCLUSIVE_RO = 2
        VDS_LRM_SHARED_RO = 3
        VDS_LRM_SHARED_RW = 4
    End Enum
    
    Public Enum VDS_VOLUME_STATUS
        VDS_VS_UNKNOWN = STATUS_UNKNOWN
        VDS_VS_ONLINE = STATUS_ONLINE
        VDS_VS_NO_MEDIA = STATUS_NO_MEDIA
        VDS_VS_FAILED = STATUS_FAILED
        VDS_VS_OFFLINE = STATUS_OFFLINE ' Added for Win7
    End Enum
    
    Public Enum VDS_VOLUME_TYPE
        VDS_VT_UNKNOWN = 0
        VDS_VT_SIMPLE = 10
        VDS_VT_SPAN = 11
        VDS_VT_STRIPE = 12
        VDS_VT_MIRROR = 13
        VDS_VT_PARITY = 14
        '    Each volume has one or more plexes.
        '    Each plex has one or more members.
        '       e.g. a simple volume has one VDS_VPT_SIMPLE plex,
        '                   which in turn has one member,
        '                   with one or more extents on the same disk.
        '            a spanned volume has one VDS_VPT_SPAN plex,
        '                   which in turn has one member,
        '                   with one or more extents on more than one disk.
        '            a stripped volume has one VDS_VPT_STRIPE plex,
        '                   which in turn has two or more members,
        '                   with each member having one or more extents on
        '                   the same disk. (allowing on different disks?)
        '            a RAID5 volume has one VDS_VPT_PARITY plex,
        '                   which in turn has three or more members,
        '                   with each member having one or more extents on
        '                   the same disk. (allowing on different disks?)
        '            a mirrorred volume has two or more plexes of any type.
        ' 
    End Enum
     
    Public Enum VDS_VOLUME_FLAG
        VDS_VF_SYSTEM_VOLUME = &H1
        VDS_VF_BOOT_VOLUME = &H2
        VDS_VF_ACTIVE = &H4
        VDS_VF_READONLY = &H8
        VDS_VF_HIDDEN = &H10
        VDS_VF_CAN_EXTEND = &H20
        VDS_VF_CAN_SHRINK = &H40
        VDS_VF_PAGEFILE = &H80
        VDS_VF_HIBERNATION = &H100
        VDS_VF_CRASHDUMP = &H200
        VDS_VF_INSTALLABLE = &H400
        VDS_VF_LBN_REMAP_ENABLED = &H800
        VDS_VF_FORMATTING = &H1000
        VDS_VF_NOT_FORMATTABLE = &H2000
        VDS_VF_NTFS_NOT_SUPPORTED = &H4000
        VDS_VF_FAT32_NOT_SUPPORTED = &H8000&
        VDS_VF_FAT_NOT_SUPPORTED = &H10000
        VDS_VF_NO_DEFAULT_DRIVE_LETTER = &H20000
        '  This flag behaves similarly to VDS_VF_HIDDEN and VDS_VF_READONLY
        '  flags. On a MBR basic disk, these flags apply to all partitions.
        '  But setting VDS_VF_NO_DEFAULT_DRIVE_LETTER flag does not delete
        '  drive letters on other partitions on the same disk that already
        '  have them. Yet setting VDS_VF_HIDDEN or VDS_VF_READONLY flag makes
        '  other partitions HIDDEN or READONLY immediately at the same time.
        VDS_VF_PERMANENTLY_DISMOUNTED = &H40000
        '  This flag means the volume is offlined by IOCTL_VOLUME_OFFLINE.
        '  It can be made mountable by IOCTL_VOLUME_ONLINE, or assigning
        '  a mount point explicitely. A volume will have this flag
        '  after IVdsVolumeMF::Dismount( bForce, bPermanent=TRUE ) is called.
        VDS_VF_PERMANENT_DISMOUNT_SUPPORTED = &H80000
        '  Whether this volume supports the bPermanent flag in IVdsVolumeMF::
        '  Dismount() method.
        VDS_VF_SHADOW_COPY = &H100000
        '  Whether this volume is a shadow copy of another volume.
        VDS_VF_FVE_ENABLED = &H200000
        '  Whether this volume has full volume encryption enabled.
        VDS_VF_DIRTY = &H400000
        '  Whether this volume has dirty flag set
        VDS_VF_REFS_NOT_SUPPORTED = &H800000
        '  Whether this volume backs a boot volume.
        VDS_VF_BACKS_BOOT_VOLUME = &H1000000
        '  Whether this volume is backed by a wimboot image
        VDS_VF_BACKED_BY_WIM_IMAGE = &H2000000
    End Enum
    
    Public Enum VDS_VOLUME_PLEX_TYPE
        VDS_VPT_UNKNOWN = 0
        VDS_VPT_SIMPLE = VDS_VT_SIMPLE
        VDS_VPT_SPAN = VDS_VT_SPAN
        VDS_VPT_STRIPE = VDS_VT_STRIPE
        VDS_VPT_PARITY = VDS_VT_PARITY
    End Enum

    Public Enum VDS_VOLUME_PLEX_STATUS
        VDS_VPS_UNKNOWN = STATUS_UNKNOWN
        VDS_VPS_ONLINE = STATUS_ONLINE
        VDS_VPS_NO_MEDIA = STATUS_NO_MEDIA
        VDS_VPS_FAILED = STATUS_FAILED
    End Enum
    
    Public Enum VDS_DISK_EXTENT_TYPE
        VDS_DET_UNKNOWN = 0
        '  extent of any unknown partition.
        VDS_DET_FREE = 1
        '  extent of free space, including free space inside extended partition.
        VDS_DET_DATA = 2
        '  extent of any volume (other than OEM partition, unknown partition and
        '  ESP partition)
        VDS_DET_OEM = 3
        '  extent of OEM partition.
        VDS_DET_ESP = 4
        '  extent of ESP partition.
        VDS_DET_MSR = 5
        '  extent of MSR partition.
        VDS_DET_LDM = 6
        '  extent of LDM meta data partition.
        VDS_DET_CLUSTER = 7
        '  extent of Cluster meta data partition.
        VDS_DET_UNUSABLE = &H7FFF
        '  extent of unusable space on a disk. (e.g. space outside 4 primary
        '  primary partitions on a basic MBR disk)
    End Enum
    
    Public Type VDS_PACK_PROP
        id As UUID
        pwszName As LongPtr
        ' leave blank for basic pack.
        status As VDS_PACK_STATUS
        ulFlags As VDS_PACK_FLAG
    End Type
    
    Public Enum STORAGE_MEDIA_TYPE
        ' 
        '  Following are defined in ntdddisk.h in the MEDIA_TYPE enum
        ' 
        '  Unknown,                // Format is unknown
        '  F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
        '  F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
        '  F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
        '  F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
        '  F3_720_512,             // 3.5",  720KB,  512 bytes/sector
        '  F5_360_512,             // 5.25", 360KB,  512 bytes/sector
        '  F5_320_512,             // 5.25", 320KB,  512 bytes/sector
        '  F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
        '  F5_180_512,             // 5.25", 180KB,  512 bytes/sector
        '  F5_160_512,             // 5.25", 160KB,  512 bytes/sector
        '  RemovableMedia,         // Removable media other than floppy
        '  FixedMedia,             // Fixed hard disk media
        '  F3_120M_512,            // 3.5", 120M Floppy
        '  F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
        '  F5_640_512,             // 5.25",  640KB,  512 bytes/sector
        '  F5_720_512,             // 5.25",  720KB,  512 bytes/sector
        '  F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
        '  F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
        '  F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
        '  F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
        '  F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
        '  F8_256_128,             // 8",     256KB,  128 bytes/sector
        ' 
        DDS_4mm = &H20 ' Tape - DAT DDS1,2,... (all vendors)
        MiniQic = 0 ' Tape - miniQIC Tape
        Travan = 1 ' Tape - Travan TR-1,2,3,...
        QIC = 2 ' Tape - QIC
        MP_8mm = 3 ' Tape - 8mm Exabyte Metal Particle
        AME_8mm = 4 ' Tape - 8mm Exabyte Advanced Metal Evap
        AIT1_8mm = 5 ' Tape - 8mm Sony AIT1
        DLT = 6 ' Tape - DLT Compact IIIxt, IV
        NCTP = 7 ' Tape - Philips NCTP
        IBM_3480 = 8 ' Tape - IBM 3480
        IBM_3490E = 9 ' Tape - IBM 3490E
        IBM_Magstar_3590 = 10 ' Tape - IBM Magstar 3590
        IBM_Magstar_MP = 11 ' Tape - IBM Magstar MP
        STK_DATA_D3 = 12 ' Tape - STK Data D3
        SONY_DTF = 13 ' Tape - Sony DTF
        DV_6mm = 14 ' Tape - 6mm Digital Video
        DMI = 15 ' Tape - Exabyte DMI and compatibles
        SONY_D2 = 16 ' Tape - Sony D2S and D2L
        CLEANER_CARTRIDGE = 17 ' Cleaner - All Drive types that support Drive Cleaners
        CD_ROM = 18 ' Opt_Disk - CD
        CD_R = 19 ' Opt_Disk - CD-Recordable (Write Once)
        CD_RW = 20 ' Opt_Disk - CD-Rewriteable
        DVD_ROM = 21 ' Opt_Disk - DVD-ROM
        DVD_R = 22 ' Opt_Disk - DVD-Recordable (Write Once)
        DVD_RW = 23 ' Opt_Disk - DVD-Rewriteable
        MO_3_RW = 24 ' Opt_Disk - 3.5" Rewriteable MO Disk
        MO_5_WO = 25 ' Opt_Disk - MO 5.25" Write Once
        MO_5_RW = 26 ' Opt_Disk - MO 5.25" Rewriteable (not LIMDOW)
        MO_5_LIMDOW = 27 ' Opt_Disk - MO 5.25" Rewriteable (LIMDOW)
        PC_5_WO = 28 ' Opt_Disk - Phase Change 5.25" Write Once Optical
        PC_5_RW = 29 ' Opt_Disk - Phase Change 5.25" Rewriteable
        PD_5_RW = 30 ' Opt_Disk - PhaseChange Dual Rewriteable
        ABL_5_WO = 31 ' Opt_Disk - Ablative 5.25" Write Once Optical
        PINNACLE_APEX_5_RW = 32 ' Opt_Disk - Pinnacle Apex 4.6GB Rewriteable Optical
        SONY_12_WO = 33 ' Opt_Disk - Sony 12" Write Once
        PHILIPS_12_WO = 34 ' Opt_Disk - Philips/LMS 12" Write Once
        HITACHI_12_WO = 35 ' Opt_Disk - Hitachi 12" Write Once
        CYGNET_12_WO = 36 ' Opt_Disk - Cygnet/ATG 12" Write Once
        KODAK_14_WO = 37 ' Opt_Disk - Kodak 14" Write Once
        MO_NFR_525 = 38 ' Opt_Disk - Near Field Recording (Terastor)
        NIKON_12_RW = 39 ' Opt_Disk - Nikon 12" Rewriteable
        IOMEGA_ZIP = 40 ' Mag_Disk - Iomega Zip
        IOMEGA_JAZ = 41 ' Mag_Disk - Iomega Jaz
        SYQUEST_EZ135 = 42 ' Mag_Disk - Syquest EZ135
        SYQUEST_EZFLYER = 43 ' Mag_Disk - Syquest EzFlyer
        SYQUEST_SYJET = 44 ' Mag_Disk - Syquest SyJet
        AVATAR_F2 = 45 ' Mag_Disk - 2.5" Floppy
        MP2_8mm = 46 ' Tape - 8mm Hitachi
        DST_S = 47 ' Ampex DST Small Tapes
        DST_M = 48 ' Ampex DST Medium Tapes
        DST_L = 49 ' Ampex DST Large Tapes
        VXATape_1 = 50 ' Ecrix 8mm Tape
        VXATape_2 = 51 ' Ecrix 8mm Tape
        STK_EAGLE = 52 ' STK Eagle
        LTO_Ultrium = 53 ' IBM, HP, Seagate LTO Ultrium
        LTO_Accelis = 54 ' IBM, HP, Seagate LTO Accelis
    End Enum
    
    
    Public Type VDS_DISK_PROP
        id As UUID
        status As VDS_DISK_STATUS
        ReserveMode As VDS_LUN_RESERVE_MODE ' to be filled by the VDS service.
        health As VDS_HEALTH
        dwDeviceType As DEVICE_TYPE ' Values: (defined in winioctl.h)
        '         FILE_DEVICE_DISK
        '         FILE_DEVICE_CDROM
        '         FILE_DEVICE_DVD
        '         etc.
        dwMediaType As STORAGE_MEDIA_TYPE ' Values: (STORAGE_MEDIA_TYPE values)
        '         RemovableMedia
        '         FixedMedia
        '         CD_ROM
        '         etc.
        ullSize As LongLong
        ulBytesPerSector As Long
        ulSectorsPerTrack As Long
        ulTracksPerCylinder As Long
        ulFlags As VDS_DISK_FLAG
        BusType As VDS_STORAGE_BUS_TYPE
        PartitionStyle As VDS_PARTITION_STYLE
        '[switch_is(PartitionStyle)] union
        '{
        '    [case(VDS_PST_MBR)]
        '        DWORD           dwSignature;    // not guaranteed to be unique.
        '    [case(VDS_PST_GPT)]
        '        GUID            DiskGuid;
        '    [default] ;
        '};
        GuidOrSig(0 To 15) As Byte
        pwszDiskAddress As LongPtr
        ' The address is for displaying purpose. It's only meaningful if
        ' the disk has a SCSI-like address, which contains some configuration
        ' information (port number, target id, etc):
        '     SCSI, IDE: Port#Path#Target#Lun#.
        '     1394, USB: None
        '     Fibre Channel: ?
        pwszName As LongPtr
        ' This is the name that can be used to open a handle to the object
        ' by CreateFile(). Examples:
        '      Cdrom:  \\?\CdRom1
        '      Disk:   \\?\PhysicalDrive3
        pwszFriendlyName As LongPtr
        ' This is a name returned from PnP. This name is maintained in
        ' registry by PnP. Example:
        '      SEAGATE ST34573N SCSI Disk Device
        pwszAdaptorName As LongPtr
        ' This is the name of the adaptor on which this disk is attached.
        ' It is returned from PnP, and maintained in registry.
        '      Adaptec AHA-2940U2W - Ultra2 SCSI.
        pwszDevicePath As LongPtr
        ' This is returned by PnP. This id can be used to uniquely identify
        ' a device on a machine by PnP. To bring up the disk property page
        ' using an internal routine exported by device manager, we need to
        ' pass in device instance id.
    End Type
    
    Public Enum VDS_DISK_OFFLINE_REASON
        VDSDiskOfflineReasonNone = 0
        VDSDiskOfflineReasonPolicy = 1
        VDSDiskOfflineReasonRedundantPath = 2
        VDSDiskOfflineReasonSnapshot = 3
        VDSDiskOfflineReasonCollision = 4
        VDSDiskOfflineReasonResourceExhaustion = 5
        VDSDiskOfflineReasonWriteFailure = 6
        VDSDiskOfflineReasonDIScan = 7
        VDSDiskOfflineReasonLostDataPersistence = 8
    End Enum

    Public Type VDS_DISK_PROP2
        id As UUID
        status As VDS_DISK_STATUS
        OfflineReason As VDS_DISK_OFFLINE_REASON
        ReserveMode As VDS_LUN_RESERVE_MODE ' to be filled by the VDS service.
        health As VDS_HEALTH
        dwDeviceType As DEVICE_TYPE ' Values: (defined in winioctl.h)
        '         FILE_DEVICE_DISK
        '         FILE_DEVICE_CDROM
        '         FILE_DEVICE_DVD
        '         etc.
        dwMediaType As STORAGE_MEDIA_TYPE ' Values: (STORAGE_MEDIA_TYPE values)
        '         RemovableMedia
        '         FixedMedia
        '         CD_ROM
        '         etc.
        ullSize As LongLong
        ulBytesPerSector As Long
        ulSectorsPerTrack As Long
        ulTracksPerCylinder As Long
        ulFlags As VDS_DISK_FLAG ' audio CD, hotspare,
        BusType As VDS_STORAGE_BUS_TYPE
        PartitionStyle As VDS_PARTITION_STYLE
        '[switch_is(PartitionStyle)] union
        '{
        '    [case(VDS_PST_MBR)]
        '        DWORD               dwSignature;    // not guaranteed to be unique.
        '    [case(VDS_PST_GPT)]
        '        GUID                DiskGuid;
        '    [default] ;
        '};
        SigOrGuid(0 To 15) As Byte
        pwszDiskAddress As LongPtr
        ' The address is for displaying purpose. It's only meaningful if
        ' the disk has a SCSI-like address, which contains some configuration
        ' information (port number, target id, etc):
        '     SCSI, IDE: Port#Path#Target#Lun#.
        '     1394, USB: None
        '     Fibre Channel: ?
        pwszName As LongPtr
        ' This is the name that can be used to open a handle to the object
        ' by CreateFile(). Examples:
        '      Cdrom:  \\?\CdRom1
        '      Disk:   \\?\PhysicalDrive3
        pwszFriendlyName As LongPtr
        ' This is a name returned from PnP. This name is maintained in
        ' registry by PnP. Example:
        '      SEAGATE ST34573N SCSI Disk Device
        pwszAdaptorName As LongPtr
        ' This is the name of the adaptor on which this disk is attached.
        ' It is returned from PnP, and maintained in registry.
        '      Adaptec AHA-2940U2W - Ultra2 SCSI.
        pwszDevicePath As LongPtr
        ' This is returned by PnP. This id can be used to uniquely identify
        ' a device on a machine by PnP. To bring up the disk property page
        ' using an internal routine exported by device manager, we need to
        ' pass in device instance id.
        pwszLocationPath As LongPtr
        ' This string is built from a combination of the SCSI address and
        ' the DEVPKEY_Device_LocationPaths value for the disk's adapter.
    End Type
    
    Public Type VDS_ADVANCEDDISK_PROP
        pwszId As LongPtr
        pwszPathname As LongPtr
        pwszLocation As LongPtr
        pwszFriendlyName As LongPtr
        pswzIdentifier As LongPtr
        usIdentifierFormat As Integer
        ulNumber As Long
        pwszSerialNumber As LongPtr
        pwszFirmwareVersion As LongPtr
        pwszManufacturer As LongPtr
        pwszModel As LongPtr
        ullTotalSize As LongLong
        ullAllocatedSize As LongLong
        ulLogicalSectorSize As Long
        ulPhysicalSectorSize As Long
        ulPartitionCount As Long
        status As VDS_DISK_STATUS
        health As VDS_HEALTH
        BusType As VDS_STORAGE_BUS_TYPE
        PartitionStyle As VDS_PARTITION_STYLE
        '[switch_is(PartitionStyle)] union
        '{
        '    [case(VDS_PST_MBR)]
        '        DWORD               dwSignature;    // not guaranteed to be unique.
        '    [case(VDS_PST_GPT)]
        '        GUID                DiskGuid;
        '    [default] ;
        '};
        SigOrGuid(0 To 15) As Byte
        ulFlags As VDS_DISK_FLAG
        dwDeviceType As DEVICE_TYPE
    End Type
    
    Public Type VDS_VOLUME_PROP
        id As UUID
        type As VDS_VOLUME_TYPE
        status As VDS_VOLUME_STATUS
        health As VDS_HEALTH
        TransitionState As VDS_TRANSITION_STATE
        ullSize As LongLong
        ulFlags As VDS_VOLUME_FLAG
        RecommendedFileSystemType As VDS_FILE_SYSTEM_TYPE
        pwszName As LongPtr
        ' This is the name that can be used to open a handle to the object
        ' by CreateFile(). Example:
        '     \\?\GLOBALROOT\Device\HarddiskVolume#
    End Type

    Public Type VDS_VOLUME_PROP2
        id As UUID
        type As VDS_VOLUME_TYPE
        status As VDS_VOLUME_STATUS
        health As VDS_HEALTH
        TransitionState As VDS_TRANSITION_STATE
        ullSize As LongLong
        ulFlags As VDS_VOLUME_FLAG
        RecommendedFileSystemType As VDS_FILE_SYSTEM_TYPE
        cbUniqueId As Long
        pwszName As LongPtr
        ' This is the name that can be used to open a handle to the object
        ' by CreateFile(). Example:
        '     \\?\GLOBALROOT\Device\HarddiskVolume#
        pUniqueId As LongPtr '[size_is(cbUniqueId)]  BYTE* 
    End Type

    Public Type VDS_VOLUME_PLEX_PROP
        id As UUID
        type As VDS_VOLUME_PLEX_TYPE
        status As VDS_VOLUME_PLEX_STATUS
        health As VDS_HEALTH
        TransitionState As VDS_TRANSITION_STATE
        ullSize As LongLong
        ulStripeSize As Long
        ulNumberOfMembers As Long
        ' No flags.
    End Type
    
    Public Type VDS_DISK_EXTENT
        diskId As UUID
        type As VDS_DISK_EXTENT_TYPE
        ullOffset As LongLong
        ullSize As LongLong
        volumeId As UUID
        ' the volume the extent belongs to.
        plexId As UUID
        ' if the extent belongs to a volume, it's the id of the plex
        ' it belongs to. An extent can belong to a partition (e.g.
        ' MSR, LDM Meta Data), but not a volume.
        memberIdx As Long
        ' if the extent belongs to a plex of a volume, it's the index
        ' of the member it belongs to. Member index is 0 based.
    End Type

    Public Type VDS_DISK_FREE_EXTENT
        diskId As UUID
        ullOffset As LongLong
        ullSize As LongLong
    End Type
    
    Public Type VDS_INPUT_DISK
        diskId As UUID ' This field is required.
        ullSize As LongLong ' This field is required.
        plexId As UUID
        ' When extending a volume, specify which plex the disk belongs to.
        ' It is ignored when creating a volume and repair a RAID-5 volume.
        memberIdx As Long
        ' This field specifies which member the extent should belong to.
        ' either all disks' memberIdx are specified, or none is specified.
        ' It must not be specified when repairing a RAID-5 volume.
    End Type
        
    Public Type VDS_PARTITION_INFO_GPT
        partitionType As UUID
        partitionId As UUID
        attributes As LongLong
        name(0 To (GPT_PARTITION_NAME_LENGTH - 1)) As Integer
    End Type

    Public Type VDS_PARTITION_INFO_MBR
        ' and convertible to each other
        partitionType As Byte
        bootIndicator As Byte
        recognizedPartition As Byte
        hiddenSectors As Long
    End Type
    
    Public Type VDS_PARTITION_PROP
        PartitionStyle As VDS_PARTITION_STYLE
        ulFlags As VDS_PARTITION_FLAG
        ulPartitionNumber As Long
        ullOffset As LongLong
        ullSize As LongLong
        '[switch_is(PartitionStyle)] union
        '{
        '    [case(VDS_PST_MBR)]
        '        VDS_PARTITION_INFO_MBR Mbr;  // For MBR disk
        '    [case(VDS_PST_GPT)]
        '        VDS_PARTITION_INFO_GPT Gpt; // For GPT disk
        '    [default] ;
        '};
        PartitionUnion(0 To 111) As Byte
    End Type
    
    Public Enum VDS_PARTITION_STYLE2
        VDS_PARTITION_STYLE_MBR
        VDS_PARTITION_STYLE_GPT
        VDS_PARTITION_STYLE_RAW
    End Enum
    
    Public Type VDS_PARTITION_INFORMATION_EX
        dwPartitionStyle As VDS_PARTITION_STYLE2
        ullStartingOffset As LongLong ' LARGE_INTEGER
        ullPartitionLength As LongLong ' LARGE_INTEGER
        dwPartitionNumber As Long
        bRewritePartition As Byte
        '[switch_is(dwPartitionStyle)] union
        '{
        '    [case (VDS_PARTITION_STYLE_MBR)]
        '        VDS_PARTITION_INFO_MBR Mbr;
        '    [case (VDS_PARTITION_STYLE_GPT)]
        '        VDS_PARTITION_INFO_GPT Gpt;
        '};
        PartitionUnion(0 To 111) As Byte
    End Type
    
    Public Type CREATE_PARTITION_PARAMETERS
        style As VDS_PARTITION_STYLE ' legal values: MBR or GPT
        '[switch_is(style)] union
        '{
        '    [case(VDS_PST_MBR)]
        '        struct
        '    {
        '        BYTE        partitionType;
        '        BOOLEAN     bootIndicator;
        '    } MbrPartInfo;
        '    [case(VDS_PST_GPT)]
        '        struct
        '    {
        '        GUID        partitionType;
        '        GUID        partitionId;    // Pass zero to generate, ASR needs to set this.
        '        ULONGLONG   attributes;
        '        WCHAR       name[GPT_PARTITION_NAME_LENGTH];
        '    } GptPartInfo;
        '    [default] ;
        '};
        pad As Long
        PartitionUnion(0 To 111) As Byte
        ' These two union structs are based on PARTITION_INFORMATION_MBR,
        ' PARTITION_INFORMATION_GPT, which are used in IOCTL_DISK_SET_
        ' DRIVE_LAYOUT_EX.
    End Type
    
    Public Type CHANGE_ATTRIBUTES_PARAMETERS
        style As VDS_PARTITION_STYLE ' legal values: MBR or GPT
        '[switch_is(style)] union
        '{
        '    [case(VDS_PST_MBR)]
        '        struct
        '    {
        '        BOOLEAN     bootIndicator;
        '    } MbrPartInfo;
        '    [case(VDS_PST_GPT)]
        '        struct
        '    {
        '        ULONGLONG   attributes; // Includes a boot indicator flag
        '    } GptPartInfo;
        '    [default] ;
        '};
        PartInfoUnion As LongLong
    End Type
    
    Public Type CHANGE_PARTITION_TYPE_PARAMETERS
        style As VDS_PARTITION_STYLE ' legal values: MBR or GPT
        '[switch_is(style)] union
        '{
        '    [case(VDS_PST_MBR)]
        '        struct
        '    {
        '        BYTE        partitionType;
        '    } MbrPartInfo;
        '    [case(VDS_PST_GPT)]
        '        struct
        '    {
        '        GUID        partitionType;
        '    } GptPartInfo;
        '    [default] ;
        '};
        PartitionType As UUID
    End Type
    
    Public Enum VDS_SUB_SYSTEM_STATUS
        VDS_SSS_UNKNOWN = STATUS_UNKNOWN
        VDS_SSS_ONLINE = STATUS_ONLINE
        VDS_SSS_NOT_READY = STATUS_NOT_READY
        VDS_SSS_OFFLINE = STATUS_OFFLINE
        VDS_SSS_FAILED = STATUS_FAILED
        VDS_SSS_PARTIALLY_MANAGED = STATUS_PARTIALLY_MANAGED
    End Enum
    
    Public Enum VDS_SUB_SYSTEM_FLAG
        VDS_SF_LUN_MASKING_CAPABLE = &H00001
        VDS_SF_LUN_PLEXING_CAPABLE = &H00002
        VDS_SF_LUN_REMAPPING_CAPABLE = &H00004
        VDS_SF_DRIVE_EXTENT_CAPABLE = &H00008
        VDS_SF_HARDWARE_CHECKSUM_CAPABLE = &H00010
        '  VDS 1.1 specific flags
        VDS_SF_RADIUS_CAPABLE = &H00020
        VDS_SF_READ_BACK_VERIFY_CAPABLE = &H00040
        VDS_SF_WRITE_THROUGH_CACHING_CAPABLE = &H00080
        VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS = &H00200
        VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS = &H00400
        VDS_SF_SUPPORTS_SIMPLE_LUNS = &H00800
        VDS_SF_SUPPORTS_SPAN_LUNS = &H01000
        VDS_SF_SUPPORTS_STRIPE_LUNS = &H02000
        VDS_SF_SUPPORTS_MIRROR_LUNS = &H04000
        VDS_SF_SUPPORTS_PARITY_LUNS = &H08000&
        '  iSCSI specific flags
        VDS_SF_SUPPORTS_AUTH_CHAP = &H10000
        VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP = &H20000
        VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG = &H40000
        '  Win7 flags
        VDS_SF_SUPPORTS_LUN_NUMBER = &H80000
        VDS_SF_SUPPORTS_MIRRORED_CACHE = &H100000
        VDS_SF_READ_CACHING_CAPABLE = &H200000
        VDS_SF_WRITE_CACHING_CAPABLE = &H400000
        VDS_SF_MEDIA_SCAN_CAPABLE = &H800000
        VDS_SF_CONSISTENCY_CHECK_CAPABLE = &H1000000
    End Enum
    
    Public Enum VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG
        VDS_SF_SUPPORTS_RAID2_LUNS = &H00001
        VDS_SF_SUPPORTS_RAID3_LUNS = &H00002
        VDS_SF_SUPPORTS_RAID4_LUNS = &H00004
        VDS_SF_SUPPORTS_RAID5_LUNS = &H00008
        VDS_SF_SUPPORTS_RAID6_LUNS = &H00010
        VDS_SF_SUPPORTS_RAID01_LUNS = &H00020
        VDS_SF_SUPPORTS_RAID03_LUNS = &H00040
        VDS_SF_SUPPORTS_RAID05_LUNS = &H00080
        VDS_SF_SUPPORTS_RAID10_LUNS = &H00100
        VDS_SF_SUPPORTS_RAID15_LUNS = &H00200
        VDS_SF_SUPPORTS_RAID30_LUNS = &H00400
        VDS_SF_SUPPORTS_RAID50_LUNS = &H00800
        VDS_SF_SUPPORTS_RAID51_LUNS = &H01000
        VDS_SF_SUPPORTS_RAID53_LUNS = &H02000
        VDS_SF_SUPPORTS_RAID60_LUNS = &H04000
        VDS_SF_SUPPORTS_RAID61_LUNS = &H08000&
    End Enum
    
    Public Enum VDS_INTERCONNECT_FLAG
        VDS_ITF_PCI_RAID = &H01
        VDS_ITF_FIBRE_CHANNEL = &H02
        VDS_ITF_ISCSI = &H04
        VDS_ITF_SAS = &H08
    End Enum
    
    Public Enum VDS_CONTROLLER_STATUS
        VDS_CS_UNKNOWN = STATUS_UNKNOWN
        VDS_CS_ONLINE = STATUS_ONLINE
        VDS_CS_NOT_READY = STATUS_NOT_READY
        VDS_CS_OFFLINE = STATUS_OFFLINE
        VDS_CS_FAILED = STATUS_FAILED
        VDS_CS_REMOVED = STATUS_REMOVED
    End Enum
    
    Public Enum VDS_PORT_STATUS
        VDS_PRS_UNKNOWN = STATUS_UNKNOWN
        VDS_PRS_ONLINE = STATUS_ONLINE
        VDS_PRS_NOT_READY = STATUS_NOT_READY
        VDS_PRS_OFFLINE = STATUS_OFFLINE
        VDS_PRS_FAILED = STATUS_FAILED
        VDS_PRS_REMOVED = STATUS_REMOVED
    End Enum
    
    Public Enum VDS_DRIVE_STATUS
        VDS_DRS_UNKNOWN = STATUS_UNKNOWN
        VDS_DRS_ONLINE = STATUS_ONLINE
        VDS_DRS_NOT_READY = STATUS_NOT_READY
        VDS_DRS_OFFLINE = STATUS_OFFLINE
        VDS_DRS_FAILED = STATUS_FAILED
        VDS_DRS_REMOVED = STATUS_REMOVED
    End Enum
    
    Public Enum VDS_DRIVE_FLAG
        VDS_DRF_HOTSPARE = &H01
        VDS_DRF_ASSIGNED = &H02
        VDS_DRF_UNASSIGNED = &H04
        VDS_DRF_HOTSPARE_IN_USE = &H08
        VDS_DRF_HOTSPARE_STANDBY = &H10
    End Enum
    
    Public Enum VDS_LUN_TYPE
        VDS_LT_UNKNOWN = 0
        '  automagic types (used as input parameters only)
        VDS_LT_DEFAULT = 1
        VDS_LT_FAULT_TOLERANT = 2
        VDS_LT_NON_FAULT_TOLERANT = 3
        '  actual types (used as input and query return)
        VDS_LT_SIMPLE = 10
        VDS_LT_SPAN = 11
        VDS_LT_STRIPE = 12
        VDS_LT_MIRROR = 13
        VDS_LT_PARITY = 14
        VDS_LT_RAID2 = 15
        VDS_LT_RAID3 = 16
        VDS_LT_RAID4 = 17
        VDS_LT_RAID5 = 18
        VDS_LT_RAID6 = 19
        VDS_LT_RAID01 = 20
        VDS_LT_RAID03 = 21
        VDS_LT_RAID05 = 22
        VDS_LT_RAID10 = 23
        VDS_LT_RAID15 = 24
        VDS_LT_RAID30 = 25
        VDS_LT_RAID50 = 26
        VDS_LT_RAID51 = 27
        VDS_LT_RAID53 = 28
        VDS_LT_RAID60 = 29
        VDS_LT_RAID61 = 30
    End Enum
    
    Public Enum VDS_LUN_STATUS
        VDS_LS_UNKNOWN = STATUS_UNKNOWN
        VDS_LS_ONLINE = STATUS_ONLINE
        VDS_LS_NOT_READY = STATUS_NOT_READY
        VDS_LS_OFFLINE = STATUS_OFFLINE
        VDS_LS_FAILED = STATUS_FAILED
    End Enum
    
    Public Enum VDS_LUN_FLAG
        VDS_LF_LBN_REMAP_ENABLED = &H01
        VDS_LF_READ_BACK_VERIFY_ENABLED = &H02
        VDS_LF_WRITE_THROUGH_CACHING_ENABLED = &H04
        VDS_LF_HARDWARE_CHECKSUM_ENABLED = &H08
        VDS_LF_READ_CACHE_ENABLED = &H10
        VDS_LF_WRITE_CACHE_ENABLED = &H20
        VDS_LF_MEDIA_SCAN_ENABLED = &H40
        VDS_LF_CONSISTENCY_CHECK_ENABLED = &H80
        VDS_LF_SNAPSHOT = &H100
    End Enum
    
    Public Enum VDS_LUN_PLEX_TYPE
        VDS_LPT_UNKNOWN = 0
        VDS_LPT_SIMPLE = VDS_LT_SIMPLE
        VDS_LPT_SPAN = VDS_LT_SPAN
        VDS_LPT_STRIPE = VDS_LT_STRIPE
        VDS_LPT_PARITY = VDS_LT_PARITY
        VDS_LPT_RAID2 = VDS_LT_RAID2
        VDS_LPT_RAID3 = VDS_LT_RAID3
        VDS_LPT_RAID4 = VDS_LT_RAID4
        VDS_LPT_RAID5 = VDS_LT_RAID5
        VDS_LPT_RAID6 = VDS_LT_RAID6
        VDS_LPT_RAID03 = VDS_LT_RAID03
        VDS_LPT_RAID05 = VDS_LT_RAID05
        VDS_LPT_RAID10 = VDS_LT_RAID10
        VDS_LPT_RAID15 = VDS_LT_RAID15
        VDS_LPT_RAID30 = VDS_LT_RAID30
        VDS_LPT_RAID50 = VDS_LT_RAID50
        VDS_LPT_RAID53 = VDS_LT_RAID53
        VDS_LPT_RAID60 = VDS_LT_RAID60
    End Enum
    
    Public Enum VDS_LUN_PLEX_STATUS
        VDS_LPS_UNKNOWN = STATUS_UNKNOWN
        VDS_LPS_ONLINE = STATUS_ONLINE
        VDS_LPS_NOT_READY = STATUS_NOT_READY
        VDS_LPS_OFFLINE = STATUS_OFFLINE
        VDS_LPS_FAILED = STATUS_FAILED
    End Enum
    
    Public Enum VDS_LUN_PLEX_FLAG
        VDS_LPF_LBN_REMAP_ENABLED = VDS_LF_LBN_REMAP_ENABLED
    End Enum
    
    Public Enum VDS_ISCSI_PORTAL_STATUS
        VDS_IPS_UNKNOWN = STATUS_UNKNOWN
        VDS_IPS_ONLINE = STATUS_ONLINE
        VDS_IPS_NOT_READY = STATUS_NOT_READY
        VDS_IPS_OFFLINE = STATUS_OFFLINE
        VDS_IPS_FAILED = STATUS_FAILED
    End Enum
    
    Public Enum VDS_STORAGE_POOL_STATUS
        VDS_SPS_UNKNOWN = STATUS_UNKNOWN
        VDS_SPS_ONLINE = STATUS_ONLINE
        VDS_SPS_NOT_READY = STATUS_NOT_READY
        VDS_SPS_OFFLINE = STATUS_OFFLINE
    End Enum
    
    Public Enum VDS_STORAGE_POOL_TYPE
        VDS_SPT_UNKNOWN = &H00
        VDS_SPT_PRIMORDIAL = &H01
        VDS_SPT_CONCRETE = &H02
    End Enum
    
    Public Enum VDS_MAINTENANCE_OPERATION
        VDSMO_BlinkLight = 1
        VDSMO_BeepAlarm = 2
        VDSMO_SpinDown = 3
        VDSMO_SpinUp = 4
        VDSMO_Ping = 5
    End Enum
    
    Public Type VDS_HINTS
        ullHintMask As LongLong
        ullExpectedMaximumSize As LongLong
        ulOptimalReadSize As Long ' 0 indicates no optimal size
        ulOptimalReadAlignment As Long ' 0 indicates no optimal alignment
        ulOptimalWriteSize As Long ' 0 indicates no optimal size
        ulOptimalWriteAlignment As Long ' 0 indicates no optimal alignment
        ulMaximumDriveCount As Long ' 0 indicates no maximum
        ulStripeSize As Long ' 0 indicates unspecified stripe size
        bFastCrashRecoveryRequired As BOOL
        bMostlyReads As BOOL
        bOptimizeForSequentialReads As BOOL
        bOptimizeForSequentialWrites As BOOL
        bRemapEnabled As BOOL
        bReadBackVerifyEnabled As BOOL
        bWriteThroughCachingEnabled As BOOL
        bHardwareChecksumEnabled As BOOL
        bIsYankable As BOOL ' No migration prior to media
        sRebuildPriority As Integer
    End Type
    
    Public Const VDS_HINT_FASTCRASHRECOVERYREQUIRED As LongLong = &H0000000000000001
    Public Const VDS_HINT_MOSTLYREADS As LongLong = &H0000000000000002
    Public Const VDS_HINT_OPTIMIZEFORSEQUENTIALREADS As LongLong = &H0000000000000004
    Public Const VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES As LongLong = &H0000000000000008

    Public Const VDS_HINT_READBACKVERIFYENABLED As LongLong = &H0000000000000010
    Public Const VDS_HINT_REMAPENABLED As LongLong = &H0000000000000020
    Public Const VDS_HINT_WRITETHROUGHCACHINGENABLED As LongLong = &H0000000000000040
    Public Const VDS_HINT_HARDWARECHECKSUMENABLED As LongLong = &H0000000000000080

    Public Const VDS_HINT_ISYANKABLE As LongLong = &H0000000000000100
    
    Public Type VDS_HINTS2
        ullHintMask As LongLong
        ullExpectedMaximumSize As LongLong
        ulOptimalReadSize As Long ' 0 indicates no optimal size
        ulOptimalReadAlignment As Long ' 0 indicates no optimal alignment
        ulOptimalWriteSize As Long ' 0 indicates no optimal size
        ulOptimalWriteAlignment As Long ' 0 indicates no optimal alignment
        ulMaximumDriveCount As Long ' 0 indicates no maximum
        ulStripeSize As Long ' 0 indicates unspecified stripe size
        ' reserved for future use
        ulReserved1 As Long
        ulReserved2 As Long
        ulReserved3 As Long
        bFastCrashRecoveryRequired As BOOL
        bMostlyReads As BOOL
        bOptimizeForSequentialReads As BOOL
        bOptimizeForSequentialWrites As BOOL
        bRemapEnabled As BOOL
        bReadBackVerifyEnabled As BOOL
        bWriteThroughCachingEnabled As BOOL
        bHardwareChecksumEnabled As BOOL
        bIsYankable As BOOL ' No migration prior to media
        ' new additions
        bAllocateHotSpare As BOOL
        bUseMirroredCache As BOOL
        bReadCachingEnabled As BOOL
        bWriteCachingEnabled As BOOL
        bMediaScanEnabled As BOOL
        bConsistencyCheckEnabled As BOOL
        BusType As VDS_STORAGE_BUS_TYPE
        ' reserved for future use
        bReserved1 As BOOL
        bReserved2 As BOOL
        bReserved3 As BOOL
        sRebuildPriority As Integer
    End Type
    
    Public Const VDS_HINT_ALLOCATEHOTSPARE As LongLong = &H0000000000000200
    Public Const VDS_HINT_BUSTYPE As LongLong = &H0000000000000400
    Public Const VDS_HINT_USEMIRROREDCACHE As LongLong = &H0000000000000800
    Public Const VDS_HINT_READCACHINGENABLED As LongLong = &H0000000000001000
    Public Const VDS_HINT_WRITECACHINGENABLED As LongLong = &H0000000000002000
    Public Const VDS_HINT_MEDIASCANENABLED As LongLong = &H0000000000004000
    Public Const VDS_HINT_CONSISTENCYCHECKENABLED As LongLong = &H0000000000008000&
    
    Public Type VDS_SUB_SYSTEM_PROP
        id As UUID
        pwszFriendlyName As LongPtr
        pwszIdentification As LongPtr ' The disk array's serial number, the subsystem's identifier.
        ulFlags As VDS_SUB_SYSTEM_FLAG
        ulStripeSizeFlags As Long
        status As VDS_SUB_SYSTEM_STATUS
        health As VDS_HEALTH ' Healthy, Failed
        sNumberOfInternalBuses As Integer
        sMaxNumberOfSlotsEachBus As Integer
        sMaxNumberOfControllers As Integer
        sRebuildPriority As Integer
    End Type
    
    Public Type VDS_SUB_SYSTEM_PROP2
        id As UUID
        pwszFriendlyName As LongPtr
        pwszIdentification As LongPtr ' The disk array's serial number, the subsystem's identifier.
        ulFlags As VDS_SUB_SYSTEM_FLAG
        ulStripeSizeFlags As Long
        ulSupportedRaidTypeFlags As VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG
        status As VDS_SUB_SYSTEM_STATUS
        health As VDS_HEALTH ' Healthy, Failed
        sNumberOfInternalBuses As Integer
        sMaxNumberOfSlotsEachBus As Integer
        sMaxNumberOfControllers As Integer
        sRebuildPriority As Integer
        ulNumberOfEnclosures As Long
    End Type

    Public Type VDS_CONTROLLER_PROP
        id As UUID
        pwszFriendlyName As LongPtr
        pwszIdentification As LongPtr
        status As VDS_CONTROLLER_STATUS
        health As VDS_HEALTH ' HEALTHY, FAILED
        sNumberOfPorts As Integer ' always >= 1.
        ' ports are numbered starting from 0.
    End Type
    
    Public Type VDS_DRIVE_PROP
        id As UUID
        ullSize As LongLong
        pwszFriendlyName As LongPtr
        pwszIdentification As LongPtr
        ulFlags As VDS_DRIVE_FLAG
        status As VDS_DRIVE_STATUS
        health As VDS_HEALTH
        sInternalBusNumber As Integer
        sSlotNumber As Integer
    End Type

    Public Type VDS_DRIVE_PROP2
        id As UUID
        ullSize As LongLong
        pwszFriendlyName As LongPtr
        pwszIdentification As LongPtr
        ulFlags As VDS_DRIVE_FLAG
        status As VDS_DRIVE_STATUS
        health As VDS_HEALTH
        sInternalBusNumber As Integer
        sSlotNumber As Integer
        ulEnclosureNumber As Long
        busType As VDS_STORAGE_BUS_TYPE
        ulSpindleSpeed As Long
    End Type
    
    Public Type VDS_DRIVE_EXTENT
        id As UUID
        LunId As UUID
        ullSize As LongLong
        bUsed As BOOL
    End Type
        
    Public Type VDS_LUN_PROP
        id As UUID
        ullSize As LongLong
        pwszFriendlyName As LongPtr
        pwszIdentification As LongPtr
        ' This is a list of masks (or one mask) of the LUN. It specifies
        ' which node(s) (designated by a string meaningful to the provider)
        ' can access the LUN. If the LUN is not masked, pwszUnmaskingList
        ' should be NULL.
        pwszUnmaskingList As LongPtr
        ulFlags As VDS_LUN_FLAG
        type As VDS_LUN_TYPE
        status As VDS_LUN_STATUS
        health As VDS_HEALTH
        TransitionState As VDS_TRANSITION_STATE
        sRebuildPriority As Integer
    End Type
    
    Public Type VDS_LUN_PLEX_PROP
        id As UUID
        ullSize As LongLong
        type As VDS_LUN_PLEX_TYPE
        status As VDS_LUN_PLEX_STATUS
        health As VDS_HEALTH
        TransitionState As VDS_TRANSITION_STATE
        ulFlags As VDS_LUN_PLEX_FLAG
        ' These properties are returned by the provider.  They are
        ' set using VDS_HINTS as part of CreateLun or ApplyHints.
        ulStripeSize As Long
        sRebuildPriority As Integer
    End Type
        
    Public Type VDS_PORT_PROP
        id As UUID
        pwszFriendlyName As LongPtr
        pwszIdentification As LongPtr
        status As VDS_PORT_STATUS
    End Type
    
    Public Type VDS_ISCSI_PORTAL_PROP
        id As UUID
        address As VDS_IPADDRESS
        status As VDS_ISCSI_PORTAL_STATUS
    End Type
    
    Public Type VDS_ISCSI_TARGET_PROP
        id As UUID
        pwszIscsiName As LongPtr
        pwszFriendlyName As LongPtr
        bChapEnabled As BOOL
    End Type
    
    Public Type VDS_ISCSI_PORTALGROUP_PROP
        id As UUID
        tag As Integer
    End Type
    
    Public Enum VDS_RAID_TYPE
        VDS_RT_UNKNOWN = 0
        VDS_RT_RAID0 = 10
        VDS_RT_RAID1 = 11
        VDS_RT_RAID2 = 12
        VDS_RT_RAID3 = 13
        VDS_RT_RAID4 = 14
        VDS_RT_RAID5 = 15
        VDS_RT_RAID6 = 16
        VDS_RT_RAID01 = 17
        VDS_RT_RAID03 = 18
        VDS_RT_RAID05 = 19
        VDS_RT_RAID10 = 20
        VDS_RT_RAID15 = 21
        VDS_RT_RAID30 = 22
        VDS_RT_RAID50 = 23
        VDS_RT_RAID51 = 24
        VDS_RT_RAID53 = 25
        VDS_RT_RAID60 = 26
        VDS_RT_RAID61 = 27
    End Enum
    
    Public Type VDS_POOL_CUSTOM_ATTRIBUTES
        pwszName As LongPtr
        pwszValue As LongPtr
    End Type
    
    Public Type VDS_POOL_ATTRIBUTES
        ullAttributeMask As LongLong
        raidType As VDS_RAID_TYPE
        busType As VDS_STORAGE_BUS_TYPE
        pwszIntendedUsage As LongPtr
        bSpinDown As BOOL
        bIsThinProvisioned As BOOL
        ullProvisionedSpace As LongLong
        bNoSinglePointOfFailure As BOOL
        ulDataRedundancyMax As Long
        ulDataRedundancyMin As Long
        ulDataRedundancyDefault As Long
        ulPackageRedundancyMax As Long
        ulPackageRedundancyMin As Long
        ulPackageRedundancyDefault As Long
        ulStripeSize As Long
        ulStripeSizeMax As Long
        ulStripeSizeMin As Long
        ulDefaultStripeSize As Long
        ulNumberOfColumns As Long
        ulNumberOfColumnsMax As Long
        ulNumberOfColumnsMin As Long
        ulDefaultNumberofColumns As Long
        ulDataAvailabilityHint As Long
        ulAccessRandomnessHint As Long
        ulAccessDirectionHint As Long
        ulAccessSizeHint As Long
        ulAccessLatencyHint As Long
        ulAccessBandwidthWeightHint As Long
        ulStorageCostHint As Long
        ulStorageEfficiencyHint As Long
        ' Custom attributes array
        ulNumOfCustomAttributes As Long
        '[size_is(ulNumOfCustomAttributes)] VDS_POOL_CUSTOM_ATTRIBUTES* pPoolCustomAttributes;
        pPoolCustomAttributes As LongPtr
        ' Reserved for future use
        bReserved1 As BOOL
        bReserved2 As BOOL
        ulReserved1 As Long
        ulReserved2 As Long
        ullReserved1 As LongLong
        ullReserved2 As LongLong
    End Type
            
    Public Const VDS_POOL_ATTRIB_RAIDTYPE As LongLong = &H0000000000000001
    Public Const VDS_POOL_ATTRIB_BUSTYPE As LongLong = &H0000000000000002
    Public Const VDS_POOL_ATTRIB_ALLOW_SPINDOWN As LongLong = &H0000000000000004
    Public Const VDS_POOL_ATTRIB_THIN_PROVISION As LongLong = &H0000000000000008

    Public Const VDS_POOL_ATTRIB_NO_SINGLE_POF As LongLong = &H0000000000000010
    Public Const VDS_POOL_ATTRIB_DATA_RDNCY_MAX As LongLong = &H0000000000000020
    Public Const VDS_POOL_ATTRIB_DATA_RDNCY_MIN As LongLong = &H0000000000000040
    Public Const VDS_POOL_ATTRIB_DATA_RDNCY_DEF As LongLong = &H0000000000000080
    Public Const VDS_POOL_ATTRIB_PKG_RDNCY_MAX As LongLong = &H0000000000000100
    Public Const VDS_POOL_ATTRIB_PKG_RDNCY_MIN As LongLong = &H0000000000000200
    Public Const VDS_POOL_ATTRIB_PKG_RDNCY_DEF As LongLong = &H0000000000000400
    Public Const VDS_POOL_ATTRIB_STRIPE_SIZE As LongLong = &H0000000000000800
    Public Const VDS_POOL_ATTRIB_STRIPE_SIZE_MAX As LongLong = &H0000000000001000
    Public Const VDS_POOL_ATTRIB_STRIPE_SIZE_MIN As LongLong = &H0000000000002000
    Public Const VDS_POOL_ATTRIB_STRIPE_SIZE_DEF As LongLong = &H0000000000004000
    Public Const VDS_POOL_ATTRIB_NUM_CLMNS As LongLong = &H0000000000008000&
    Public Const VDS_POOL_ATTRIB_NUM_CLMNS_MAX As LongLong = &H0000000000010000
    Public Const VDS_POOL_ATTRIB_NUM_CLMNS_MIN As LongLong = &H0000000000020000
    Public Const VDS_POOL_ATTRIB_NUM_CLMNS_DEF As LongLong = &H0000000000040000

    Public Const VDS_POOL_ATTRIB_DATA_AVL_HINT As LongLong = &H0000000000080000
    Public Const VDS_POOL_ATTRIB_ACCS_RNDM_HINT As LongLong = &H0000000000100000
    Public Const VDS_POOL_ATTRIB_ACCS_DIR_HINT As LongLong = &H0000000000200000
    Public Const VDS_POOL_ATTRIB_ACCS_SIZE_HINT As LongLong = &H0000000000400000
    Public Const VDS_POOL_ATTRIB_ACCS_LTNCY_HINT As LongLong = &H0000000000800000
    Public Const VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT As LongLong = &H0000000001000000
    Public Const VDS_POOL_ATTRIB_STOR_COST_HINT As LongLong = &H0000000002000000
    Public Const VDS_POOL_ATTRIB_STOR_EFFCY_HINT As LongLong = &H0000000004000000

    Public Const VDS_POOL_ATTRIB_CUSTOM_ATTRIB As LongLong = &H0000000008000000
            
    Public Type VDS_STORAGE_POOL_PROP
        id As UUID
        status As VDS_STORAGE_POOL_STATUS
        health As VDS_HEALTH
        type As VDS_STORAGE_POOL_TYPE
        pwszName As LongPtr
        pwszDescription As LongPtr
        ullTotalConsumedSpace As LongLong
        ullTotalManagedSpace As LongLong
        ullRemainingFreeSpace As LongLong
    End Type

    Public Type VDS_STORAGE_POOL_DRIVE_EXTENT
        id As UUID
        ullSize As LongLong
        bUsed As BOOL
    End Type
            
    Public Type VDS_CREATE_VDISK_PARAMETERS
        UniqueId As UUID
        MaximumSize As LongLong
        BlockSizeInBytes As Long
        SectorSizeInBytes As Long
        pParentPath As LongPtr
        pSourcePath As LongPtr
    End Type

    Public Enum VDS_VDISK_STATE
        VDS_VST_UNKNOWN = 0
        VDS_VST_ADDED
        VDS_VST_OPEN
        VDS_VST_ATTACH_PENDING
        VDS_VST_ATTACHED_NOT_OPEN
        VDS_VST_ATTACHED
        VDS_VST_DETACH_PENDING
        VDS_VST_COMPACTING
        VDS_VST_MERGING
        VDS_VST_EXPANDING
        VDS_VST_DELETED
        VDS_VST_MAX
    End Enum
            
    Public Type VDS_VDISK_PROPERTIES
        Id As UUID
        State As VDS_VDISK_STATE
        VirtualDeviceType As VIRTUAL_STORAGE_TYPE
        VirtualSize As LongLong
        PhysicalSize As LongLong
        pPath As LongPtr
        pDeviceName As LongPtr
        DiskFlag As DEPENDENT_DISK_FLAG
        bIsChild As BOOL
        pParentPath As LongPtr
    End Type
            
    Public Enum VDS_SERVICE_FLAG
        VDS_SVF_SUPPORT_DYNAMIC = &H00000001 ' Dynamic is not supported on all SKUs. Laptops did not support dynamic until Vista.
        VDS_SVF_SUPPORT_FAULT_TOLERANT = &H00000002 ' SKU supports both mirrors and RAID5 (server SKUs).
        VDS_SVF_SUPPORT_GPT = &H00000004 ' GPT disks are supported.
        VDS_SVF_SUPPORT_DYNAMIC_1394 = &H00000008 ' 1394 dynamic disks are supported.
        VDS_SVF_CLUSTER_SERVICE_CONFIGURED = &H00000010 ' Server is part of a cluster configuration.
        VDS_SVF_AUTO_MOUNT_OFF = &H00000020 ' NoAutoMount is enabled.
        VDS_SVF_OS_UNINSTALL_VALID = &H00000040
        VDS_SVF_EFI = &H00000080 ' Server boots EFI (from GPT disk).
        VDS_SVF_SUPPORT_MIRROR = &H00000100 ' Added for Windows7 - SKU supports mirrors (Windows7 client and server SKUs).
        VDS_SVF_SUPPORT_RAID5 = &H00000200 ' Added for Windows7 - SKU supports RAID5 (server SKUs).
        VDS_SVF_SUPPORT_REFS = &H00000400 ' Added for Windows8 - SKU supports ReFS (server SKUs).
    End Enum
    
    Public Type VDS_SERVICE_PROP
        pwszVersion As LongPtr
        ulFlags As VDS_SERVICE_FLAG
    End Type
            
    Public Enum VDS_SAN_POLICY
        VDS_SP_UNKNOWN = &H0 '
        VDS_SP_ONLINE = &H1 ' All newly discovered disks are brought ONLINE and made WRITABLE
        VDS_SP_OFFLINE_SHARED = &H2 ' All newly discovered disks not residing on a shared bus are
        '  brought ONLINE and made WRITABLE.
        VDS_SP_OFFLINE = &H3 ' All newly discovered disks remain OFFLINE and READ-ONLY.
        VDS_SP_OFFLINE_INTERNAL = &H4 ' All newly discovered internal disks remain OFFLINE and READ-ONLY.
        VDS_SP_MAX = &H5
    End Enum
    
    Public Type VDS_REPARSE_POINT_PROP
        SourceVolumeId As UUID
        pwszPath As LongPtr
    End Type
    
    Public Enum VDS_DRIVE_LETTER_FLAG
        VDS_DLF_NON_PERSISTENT = &H1
    End Enum
    
    Public Type VDS_DRIVE_LETTER_PROP
        wcLetter As Integer
        volumeId As UUID
        ulFlags As VDS_DRIVE_LETTER_FLAG ' pending removal
        bUsed As BOOL
    End Type
    
    Public Enum VDS_FILE_SYSTEM_FLAG
        VDS_FSF_SUPPORT_FORMAT = &H1
        '  A UI's drop down list should only have
        '  those file systems that support format.
        VDS_FSF_SUPPORT_QUICK_FORMAT = &H2
        VDS_FSF_SUPPORT_COMPRESS = &H4
        VDS_FSF_SUPPORT_SPECIFY_LABEL = &H8
        VDS_FSF_SUPPORT_MOUNT_POINT = &H10
        VDS_FSF_SUPPORT_REMOVABLE_MEDIA = &H20
        VDS_FSF_SUPPORT_EXTEND = &H40
        VDS_FSF_ALLOCATION_UNIT_512 = &H10000
        VDS_FSF_ALLOCATION_UNIT_1K = &H20000
        VDS_FSF_ALLOCATION_UNIT_2K = &H40000
        VDS_FSF_ALLOCATION_UNIT_4K = &H80000
        VDS_FSF_ALLOCATION_UNIT_8K = &H100000
        VDS_FSF_ALLOCATION_UNIT_16K = &H200000
        VDS_FSF_ALLOCATION_UNIT_32K = &H400000
        VDS_FSF_ALLOCATION_UNIT_64K = &H800000
        VDS_FSF_ALLOCATION_UNIT_128K = &H1000000
        VDS_FSF_ALLOCATION_UNIT_256K = &H2000000
    End Enum
    
    Public Type VDS_FILE_SYSTEM_TYPE_PROP
        type As VDS_FILE_SYSTEM_TYPE ' FAT, FAT32, NTFS, ...
        wszName(0 To 7) As Integer 'MAX_FS_NAME_SIZE
        ulFlags As VDS_FILE_SYSTEM_FLAG
        ulCompressionFlags As Long
        ' legal alloc unit sizes valid for compression
        ulMaxLableLength As Long
        pwszIllegalLabelCharSet As LongPtr
    End Type
    
    Public Enum VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG
        VDS_FSS_DEFAULT = &H1
        VDS_FSS_PREVIOUS_REVISION = &H2
        VDS_FSS_RECOMMENDED = &H4
    End Enum
    
    Public Type VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP
        ulFlags As VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG
        usRevision As Integer
        ulDefaultUnitAllocationSize As Long
        rgulAllowedUnitAllocationSizes(0 To (MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE - 1)) As Long
        wszName(0 To (MAX_FS_FORMAT_SUPPORT_NAME_SIZE - 1)) As Integer
    End Type
    
    Public Enum VDS_FILE_SYSTEM_PROP_FLAG
        VDS_FPF_COMPRESSED = &H1
    End Enum
    
    Public Enum VDS_FORMAT_OPTION_FLAGS
        VDS_FSOF_NONE = &H00000000
        VDS_FSOF_FORCE = &H00000001
        VDS_FSOF_QUICK = &H00000002
        VDS_FSOF_COMPRESSION = &H00000004
        VDS_FSOF_DUPLICATE_METADATA = &H00000008
    End Enum
    
    Public Type VDS_FILE_SYSTEM_PROP
        type As VDS_FILE_SYSTEM_TYPE
        ' It is recommended that GetFileSystemTypeName be used instead of this
        ' type field so that unknown file systems types can be retrieved too.
        volumeId As UUID
        ulFlags As VDS_FILE_SYSTEM_PROP_FLAG
        ' When this flag is set/cleared, there is no notification sent.
        ' This is indeed a flag for the root directory of the volume.
        ' There is no notification sent on the volume by PnP if it changed.
        ullTotalAllocationUnits As LongLong
        ullAvailableAllocationUnits As LongLong
        ulAllocationUnitSize As Long
        pwszLabel As LongPtr
    End Type
    
    Public Enum VDS_QUERY_PROVIDER_FLAG
        VDS_QUERY_SOFTWARE_PROVIDERS = &H1
        VDS_QUERY_HARDWARE_PROVIDERS = &H2
        VDS_QUERY_VIRTUALDISK_PROVIDERS = &H4
    End Enum
    
    
End Module

Module mVDS
'mVDS - Common defs for both tB and VB
 #Region "vdserr.h"
 [Description("The operation is not supported by the object.")] Public Const VDS_E_NOT_SUPPORTED = &H80042400
 [Description("The service failed to initialize.")] Public Const VDS_E_INITIALIZED_FAILED = &H80042401
 [Description("The initialization method was not called.")] Public Const VDS_E_INITIALIZE_NOT_CALLED = &H80042402
 [Description("The provider is already registered.")] Public Const VDS_E_ALREADY_REGISTERED = &H80042403
 [Description("A concurrent second call is made on an object before the first is completed.")] Public Const VDS_E_ANOTHER_CALL_IN_PROGRESS = &H80042404
 [Description("The object is not found.")] Public Const VDS_E_OBJECT_NOT_FOUND = &H80042405
 [Description("The specified space is not free or not valid.")] Public Const VDS_E_INVALID_SPACE = &H80042406
 [Description("The number of partitions has reached the limit on a disk.")] Public Const VDS_E_PARTITION_LIMIT_REACHED = &H80042407
 [Description("The extended partition is not empty.")] Public Const VDS_E_PARTITION_NOT_EMPTY = &H80042408
 [Description("The operation has not been completed yet.")] Public Const VDS_E_OPERATION_PENDING = &H80042409
 [Description("the boot, system or pagefile volume. ")] Public Const VDS_E_OPERATION_DENIED = &H8004240A
 [Description("The object has been deleted.")] Public Const VDS_E_OBJECT_DELETED = &H8004240B
 [Description("The operation cannot be cancelled.")] Public Const VDS_E_CANCEL_TOO_LATE = &H8004240C
 [Description("The operation has been cancelled.")] Public Const VDS_E_OPERATION_CANCELED = &H8004240D
 [Description("The volume cannot be extended because the file system does not support it.")] Public Const VDS_E_CANNOT_EXTEND = &H8004240E
 [Description("There is not enough usable space for this operation.")] Public Const VDS_E_NOT_ENOUGH_SPACE = &H8004240F
 [Description("Not enough drives are specified to complete this operation.")] Public Const VDS_E_NOT_ENOUGH_DRIVE = &H80042410
 [Description("The cookie is not found.")] Public Const VDS_E_BAD_COOKIE = &H80042411
 [Description("There is no media in the device.")] Public Const VDS_E_NO_MEDIA = &H80042412
 [Description("The device is in use.")] Public Const VDS_E_DEVICE_IN_USE = &H80042413
 [Description("The disk is not empty.")] Public Const VDS_E_DISK_NOT_EMPTY = &H80042414
 [Description("Invalid operation.")] Public Const VDS_E_INVALID_OPERATION = &H80042415
 [Description("The path is not found.")] Public Const VDS_E_PATH_NOT_FOUND = &H80042416
 [Description("The disk is not initialized.")] Public Const VDS_E_DISK_NOT_INITIALIZED = &H80042417
 [Description("The disk is not unallocated.")] Public Const VDS_E_NOT_AN_UNALLOCATED_DISK = &H80042418
 [Description("An unrecoverable error occurred. The service must shut down.")] Public Const VDS_E_UNRECOVERABLE_ERROR = &H80042419
 [Description("The disk is not fully cleaned due to I/O error.")] Public Const VDS_S_DISK_PARTIALLY_CLEANED = &H0004241A
 [Description("Administrative service.")] Public Const VDS_E_DMADMIN_SERVICE_CONNECTION_FAILED = &H8004241B
 [Description("The provider failed to initialize.")] Public Const VDS_E_PROVIDER_INITIALIZATION_FAILED = &H8004241C
 [Description("The object already exists.")] Public Const VDS_E_OBJECT_EXISTS = &H8004241D
 [Description("No disks were found on the target machine.")] Public Const VDS_E_NO_DISKS_FOUND = &H8004241E
 [Description("The provider's cache has become corrupt.")] Public Const VDS_E_PROVIDER_CACHE_CORRUPT = &H8004241F
 [Description("A method call to the Logical Disk Management Administrative service failed.")] Public Const VDS_E_DMADMIN_METHOD_CALL_FAILED = &H80042420
 [Description("See the NT Event Log for more information.")] Public Const VDS_S_PROVIDER_ERROR_LOADING_CACHE = &H00042421
 [Description("The device form of the volume pathname could not be retrieved.")] Public Const VDS_E_PROVIDER_VOL_DEVICE_NAME_NOT_FOUND = &H80042422
 [Description("Failed to open the volume device.")] Public Const VDS_E_PROVIDER_VOL_OPEN = &H80042423
 [Description("Administrative service.")] Public Const VDS_E_DMADMIN_CORRUPT_NOTIFICATION = &H80042424
 [Description("The file system is incompatible.")] Public Const VDS_E_INCOMPATIBLE_FILE_SYSTEM = &H80042425
 [Description("The media is incompatible.")] Public Const VDS_E_INCOMPATIBLE_MEDIA = &H80042426
 [Description("Access is denied.")] Public Const VDS_E_ACCESS_DENIED = &H80042427
 [Description("The media is write protected.")] Public Const VDS_E_MEDIA_WRITE_PROTECTED = &H80042428
 [Description("The label is illegal.")] Public Const VDS_E_BAD_LABEL = &H80042429
 [Description("Can not quick format the volume.")] Public Const VDS_E_CANT_QUICK_FORMAT = &H8004242A
 [Description("IO error occured during format.")] Public Const VDS_E_IO_ERROR = &H8004242B
 [Description("The volume size is too small.")] Public Const VDS_E_VOLUME_TOO_SMALL = &H8004242C
 [Description("The volume size is too big.")] Public Const VDS_E_VOLUME_TOO_BIG = &H8004242D
 [Description("The cluster size is too small.")] Public Const VDS_E_CLUSTER_SIZE_TOO_SMALL = &H8004242E
 [Description("The cluster size is too big.")] Public Const VDS_E_CLUSTER_SIZE_TOO_BIG = &H8004242F
 [Description("The number of clusters is too big for 32 bit integer.")] Public Const VDS_E_CLUSTER_COUNT_BEYOND_32BITS = &H80042430
 [Description("The object is in failed status.")] Public Const VDS_E_OBJECT_STATUS_FAILED = &H80042431
 [Description("All extents for the volume could not be found.")] Public Const VDS_E_VOLUME_INCOMPLETE = &H80042432
 [Description("The size of the extent is less than the minimum.")] Public Const VDS_E_EXTENT_SIZE_LESS_THAN_MIN = &H80042433
 [Description("Failed to update the boot configuration data.")] Public Const VDS_S_UPDATE_BOOTFILE_FAILED = &H00042434
 [Description("The boot partition's partition number will change as a result of the operation.")] Public Const VDS_S_BOOT_PARTITION_NUMBER_CHANGE = &H00042436
 [Description("migration operation.")] Public Const VDS_E_BOOT_PARTITION_NUMBER_CHANGE = &H80042436
 [Description("The selected disk does not have enough free space to complete the operation.")] Public Const VDS_E_NO_FREE_SPACE = &H80042437
 [Description("An active partition was detected on the selected disk, and it is not the active partition used to boot the currently running OS.")] Public Const VDS_E_ACTIVE_PARTITION = &H80042438
 [Description("Cannot read partition information.")] Public Const VDS_E_PARTITION_OF_UNKNOWN_TYPE = &H80042439
 [Description("A partition with an unknown type was detected on the selected disk.")] Public Const VDS_E_LEGACY_VOLUME_FORMAT = &H8004243A
 [Description("of type 'PARTITION_BASIC_DATA_GUID'.")] Public Const VDS_E_NON_CONTIGUOUS_DATA_PARTITIONS = &H8004243B
 [Description("A volume on the selected disk could not be opened.")] Public Const VDS_E_MIGRATE_OPEN_VOLUME = &H8004243C
 [Description("The volume is not online.")] Public Const VDS_E_VOLUME_NOT_ONLINE = &H8004243D
 [Description("The volume is not healthy.")] Public Const VDS_E_VOLUME_NOT_HEALTHY = &H8004243E
 [Description("The volume spans multiple disks.")] Public Const VDS_E_VOLUME_SPANS_DISKS = &H8004243F
 [Description("The volume requires contiguous disk extents.")] Public Const VDS_E_REQUIRES_CONTIGUOUS_DISK_SPACE = &H80042440
 [Description("A provider returned bad data.")] Public Const VDS_E_BAD_PROVIDER_DATA = &H80042441
 [Description("A provider failed to complete an operation.")] Public Const VDS_E_PROVIDER_FAILURE = &H80042442
 [Description("Failed to compress the volume.")] Public Const VDS_S_VOLUME_COMPRESS_FAILED = &H00042443
 [Description("The pack is not online.")] Public Const VDS_E_PACK_OFFLINE = &H80042444
 [Description("The volume is not a mirror.")] Public Const VDS_E_VOLUME_NOT_A_MIRROR = &H80042445
 [Description("No extents were found for the volume.")] Public Const VDS_E_NO_EXTENTS_FOR_VOLUME = &H80042446
 [Description("The disk failed to load to the cache.")] Public Const VDS_E_DISK_NOT_LOADED_TO_CACHE = &H80042447
 [Description("Check the event log for errors.")] Public Const VDS_E_INTERNAL_ERROR = &H80042448
 [Description("The access paths on the volume may not be deleted.")] Public Const VDS_S_ACCESS_PATH_NOT_DELETED = &H00044244
 [Description("The method call is not supported for the specified provider type.")] Public Const VDS_E_PROVIDER_TYPE_NOT_SUPPORTED = &H8004244A
 [Description("This disk is already offline. ")] Public Const VDS_E_DISK_NOT_ONLINE = &H8004244B
 [Description("The disk is already in use by the volume.")] Public Const VDS_E_DISK_IN_USE_BY_VOLUME = &H8004244C
 [Description("The asynchronous operation is in progress.")] Public Const VDS_S_IN_PROGRESS = &H0004244D
 [Description("Failure initializing the asynchronous object.")] Public Const VDS_E_ASYNC_OBJECT_FAILURE = &H8004244E
 [Description("A file system is not mounted on the volume.")] Public Const VDS_E_VOLUME_NOT_MOUNTED = &H8004244F
 [Description("The pack was not found.")] Public Const VDS_E_PACK_NOT_FOUND = &H80042450
 [Description("Import failed. Attempt to import a subset of the disks in the foreign pack.")] Public Const VDS_E_IMPORT_SET_INCOMPLETE = &H80042451
 [Description("A disk in the import's source pack was not imported.")] Public Const VDS_E_DISK_NOT_IMPORTED = &H80042452
 [Description("The system's information about the object may not be up to date.")] Public Const VDS_E_OBJECT_OUT_OF_SYNC = &H80042453
 [Description("The disk is missing.")] Public Const VDS_E_MISSING_DISK = &H80042454
 [Description("The provider's list of Pnp registered disks has become corrupt.")] Public Const VDS_E_DISK_PNP_REG_CORRUPT = &H80042455
 [Description("The provider does not support the LBN REMAP ENABLED volume flag.")] Public Const VDS_E_LBN_REMAP_ENABLED_FLAG = &H80042456
 [Description("The provider does not support the NO DRIVELETTER volume flag.")] Public Const VDS_E_NO_DRIVELETTER_FLAG = &H80042457
 [Description("NO DRIVE LETTER or SHADOW COPY.")] Public Const VDS_E_REVERT_ON_CLOSE = &H80042458
 [Description("The REVERT ON CLOSE volume flag is already set for this volume.")] Public Const VDS_E_REVERT_ON_CLOSE_SET = &H80042459
 [Description("You will not be able to boot your machine from the secondary plex.")] Public Const VDS_E_IA64_BOOT_MIRRORED_TO_MBR = &H8004245A
 [Description("You will not be able to boot your machine from the secondary plex.")] Public Const VDS_S_IA64_BOOT_MIRRORED_TO_MBR = &H0004245A
 [Description("and no drive letter).")] Public Const VDS_S_UNABLE_TO_GET_GPT_ATTRIBUTES = &H0004245B
 [Description("The volume is temporarily dismounted.")] Public Const VDS_E_VOLUME_TEMPORARILY_DISMOUNTED = &H8004245C
 [Description("The volume is permanently dismounted.")] Public Const VDS_E_VOLUME_PERMANENTLY_DISMOUNTED = &H8004245D
 [Description("The volume still has access path to it.")] Public Const VDS_E_VOLUME_HAS_PATH = &H8004245E
 [Description("The operation timed out.")] Public Const VDS_E_TIMEOUT = &H8004245F
 [Description("healthy or rebuilding.")] Public Const VDS_E_REPAIR_VOLUMESTATE = &H80042460
 [Description("Retry the operation.")] Public Const VDS_E_LDM_TIMEOUT = &H80042461
 [Description("flags must be passed to both the SetFlags and ClearFlags calls.")] Public Const VDS_E_REVERT_ON_CLOSE_MISMATCH = &H80042462
 [Description("The operation failed. Retry the operation.")] Public Const VDS_E_RETRY = &H80042463
 [Description("Create pack operation failed. An online pack already exists.")] Public Const VDS_E_ONLINE_PACK_EXISTS = &H80042464
 [Description("The volume was extended successfully but the file system failed to extend.")] Public Const VDS_S_EXTEND_FILE_SYSTEM_FAILED = &H00042465
 [Description("The file system failed to extend.")] Public Const VDS_E_EXTEND_FILE_SYSTEM_FAILED = &H80042466
 [Description("You will not be able to boot your machine from the secondary plex.")] Public Const VDS_S_MBR_BOOT_MIRRORED_TO_GPT = &H00042467
 [Description("the disk to dynamic.")] Public Const VDS_E_MAX_USABLE_MBR = &H80042468
 [Description("You will not be able to boot your machine from the secondary plex.")] Public Const VDS_S_GPT_BOOT_MIRRORED_TO_MBR = &H80042469
 [Description("There are no software provders loaded.")] Public Const VDS_E_NO_SOFTWARE_PROVIDERS_LOADED = &H80042500
 [Description("The disk is not missing.")] Public Const VDS_E_DISK_NOT_MISSING = &H80042501
 [Description("Failed to retrieve the volume's layout. Operations on the volume will fail.")] Public Const VDS_E_NO_VOLUME_LAYOUT = &H80042502
 [Description("The volume's driver information is corrupt. Operations on the volume will fail.")] Public Const VDS_E_CORRUPT_VOLUME_INFO = &H80042503
 [Description("The enumerator is corrupted.")] Public Const VDS_E_INVALID_ENUMERATOR = &H80042504
 [Description("Internal error in the volume management driver.")] Public Const VDS_E_DRIVER_INTERNAL_ERROR = &H80042505
 [Description("The volume name is invalid.")] Public Const VDS_E_VOLUME_INVALID_NAME = &H80042507
 [Description("The disk is missing, not all information could be returned.")] Public Const VDS_S_DISK_IS_MISSING = &H00042508
 [Description("The disk's partition information is corrupted.")] Public Const VDS_E_CORRUPT_PARTITION_INFO = &H80042509
 [Description("on a dynamic disk.")] Public Const VDS_S_NONCONFORMANT_PARTITION_INFO = &H0004250A
 [Description("The disk's extent information is corrupted.")] Public Const VDS_E_CORRUPT_EXTENT_INFO = &H8004250B
 [Description("creating another empty pack.")] Public Const VDS_E_DUP_EMPTY_PACK_GUID = &H8004250C
 [Description("Internal driver error.")] Public Const VDS_E_DRIVER_NO_PACK_NAME = &H8004250D
 [Description("Warning, there was a failure while checking for the system partition.")] Public Const VDS_S_SYSTEM_PARTITION = &H0004250E
 [Description("The PNP service sent a corrupted notification to the provider.")] Public Const VDS_E_BAD_PNP_MESSAGE = &H8004250F
 [Description("No disk arrival notification was received.")] Public Const VDS_E_NO_PNP_DISK_ARRIVE = &H80042510
 [Description("No volume arrival notification was received.")] Public Const VDS_E_NO_PNP_VOLUME_ARRIVE = &H80042511
 [Description("No disk removal notification was received.")] Public Const VDS_E_NO_PNP_DISK_REMOVE = &H80042512
 [Description("No volume removal notification was received.")] Public Const VDS_E_NO_PNP_VOLUME_REMOVE = &H80042513
 [Description("The provider is exiting.")] Public Const VDS_E_PROVIDER_EXITING = &H80042514
 [Description("The specified disk extent size exceeds the size of free disk space.")] Public Const VDS_E_EXTENT_EXCEEDS_DISK_FREE_SPACE = &H80042515
 [Description("The size of the plex member is invalid.")] Public Const VDS_E_MEMBER_SIZE_INVALID = &H80042516
 [Description("Refresh the Disk Management display.")] Public Const VDS_S_NO_NOTIFICATION = &H00042517
 [Description("Defaults have been used for the member ids or plex ids.")] Public Const VDS_S_DEFAULT_PLEX_MEMBER_IDS = &H00042518
 [Description("because it is OFFLINE.")] Public Const VDS_E_INVALID_DISK = &H80042519
 [Description("This operation is not allowed on the invalid disk pack.")] Public Const VDS_E_INVALID_PACK = &H8004251A
 [Description("This operation is not allowed on disks with volumes.")] Public Const VDS_E_VOLUME_ON_DISK = &H8004251B
 [Description("The driver returned an invalid parameter error.")] Public Const VDS_E_DRIVER_INVALID_PARAM = &H8004251C
 [Description("The target pack is not empty.")] Public Const VDS_E_TARGET_PACK_NOT_EMPTY = &H8004251D
 [Description("The volume cannot be shrunk because the file system does not support it.")] Public Const VDS_E_CANNOT_SHRINK = &H8004251E
 [Description("Specified disks are not all from the same pack.")] Public Const VDS_E_MULTIPLE_PACKS = &H8004251F
 [Description("This operation is not allowed on online packs. The pack must be offline.")] Public Const VDS_E_PACK_ONLINE = &H80042520
 [Description("The plex count for the volume must be non-zero.")] Public Const VDS_E_INVALID_PLEX_COUNT = &H80042521
 [Description("The member count for the volume must be non-zero.")] Public Const VDS_E_INVALID_MEMBER_COUNT = &H80042522
 [Description("The plex indexes must be monotonically increasing and begin with zero.")] Public Const VDS_E_INVALID_PLEX_ORDER = &H80042523
 [Description("The member indexes must be monotonically increasing and begin with zero.")] Public Const VDS_E_INVALID_MEMBER_ORDER = &H80042524
 [Description("volume types.")] Public Const VDS_E_INVALID_STRIPE_SIZE = &H80042525
 [Description("The number of disks specified is invalid for this operation.")] Public Const VDS_E_INVALID_DISK_COUNT = &H80042526
 [Description("An invalid number of extents was specified for at least one disk.")] Public Const VDS_E_INVALID_EXTENT_COUNT = &H80042527
 [Description("The source and target packs must be distinct.")] Public Const VDS_E_SOURCE_IS_TARGET_PACK = &H80042528
 [Description("The disk count for the volume exceeds the maximum.")] Public Const VDS_E_VOLUME_DISK_COUNT_MAX_EXCEEDED = &H80042529
 [Description("The driver's notification info is corrupt.")] Public Const VDS_E_CORRUPT_NOTIFICATION_INFO = &H8004252A
 [Description("GUID_NULL is not a valid plex GUID.")] Public Const VDS_E_INVALID_PLEX_GUID = &H8004252C
 [Description("The specified disks do not belong to the same pack.")] Public Const VDS_E_DISK_NOT_FOUND_IN_PACK = &H8004252D
 [Description("The same disk was specified more than once.")] Public Const VDS_E_DUPLICATE_DISK = &H8004252E
 [Description("The operation cannot be completed because there is only one valid disk in the pack.")] Public Const VDS_E_LAST_VALID_DISK = &H8004252F
 [Description("sector size, and the sector size must be valid.")] Public Const VDS_E_INVALID_SECTOR_SIZE = &H80042530
 [Description("same volume.")] Public Const VDS_E_ONE_EXTENT_PER_DISK = &H80042531
 [Description("Neither the volume stripe size or disk sector size was found to be non-zero.")] Public Const VDS_E_INVALID_BLOCK_SIZE = &H80042532
 [Description("The size of the volume plex is invalid.")] Public Const VDS_E_PLEX_SIZE_INVALID = &H80042533
 [Description("No extents were found for the plex.")] Public Const VDS_E_NO_EXTENTS_FOR_PLEX = &H80042534
 [Description("The plex type is invalid.")] Public Const VDS_E_INVALID_PLEX_TYPE = &H80042535
 [Description("The plex block size must be non-zero.")] Public Const VDS_E_INVALID_PLEX_BLOCK_SIZE = &H80042536
 [Description("All of the disks involved in the operation are either missing or failed.")] Public Const VDS_E_NO_HEALTHY_DISKS = &H80042537
 [Description("The Logical Disk Manangement database is full, no more volumes or disks may be configured.")] Public Const VDS_E_CONFIG_LIMIT = &H80042538
 [Description("The disk configuration data is corrupted.")] Public Const VDS_E_DISK_CONFIGURATION_CORRUPTED = &H80042539
 [Description("The disk configuration is not insync with the in-memory configuration.")] Public Const VDS_E_DISK_CONFIGURATION_NOT_IN_SYNC = &H8004253A
 [Description("One or more disks failed to be updated with the new configuration.")] Public Const VDS_E_DISK_CONFIGURATION_UPDATE_FAILED = &H8004253B
 [Description("The disk is already dynamic.")] Public Const VDS_E_DISK_DYNAMIC = &H8004253C
 [Description("The object was not found in the driver cache.")] Public Const VDS_E_DRIVER_OBJECT_NOT_FOUND = &H8004253D
 [Description("The disk layout contains partitions which are not cylinder aligned.")] Public Const VDS_E_PARTITION_NOT_CYLINDER_ALIGNED = &H8004253E
 [Description("The disk layout contains partitions which less than the minimum required size.")] Public Const VDS_E_DISK_LAYOUT_PARTITIONS_TOO_SMALL = &H8004253F
 [Description("The IO to the disk is failing.")] Public Const VDS_E_DISK_IO_FAILING = &H80042540
 [Description("Dynamic disks are not supported by this operating system or server configuration. Dynamic disks are not supported on clusters.")] Public Const VDS_E_DYNAMIC_DISKS_NOT_SUPPORTED = &H80042541
 [Description("The fault tolerant disks are not supported by this operating system.")] Public Const VDS_E_FAULT_TOLERANT_DISKS_NOT_SUPPORTED = &H80042542
 [Description("Invalid GPT attributes were specified.")] Public Const VDS_E_GPT_ATTRIBUTES_INVALID = &H80042543
 [Description("The member is not stale or detached.")] Public Const VDS_E_MEMBER_IS_HEALTHY = &H80042544
 [Description("The member is regenerating.")] Public Const VDS_E_MEMBER_REGENERATING = &H80042545
 [Description("The pack name is invalid.")] Public Const VDS_E_PACK_NAME_INVALID = &H80042546
 [Description("The plex is not stale or detached.")] Public Const VDS_E_PLEX_IS_HEALTHY = &H80042547
 [Description("The last healthy plex cannot be removed.")] Public Const VDS_E_PLEX_LAST_ACTIVE = &H80042548
 [Description("The plex is missing.")] Public Const VDS_E_PLEX_MISSING = &H80042549
 [Description("The member is missing.")] Public Const VDS_E_MEMBER_MISSING = &H8004254A
 [Description("The plex is regenerating.")] Public Const VDS_E_PLEX_REGENERATING = &H8004254B
 [Description("An unexpected layout change occurred external to the volume manager.")] Public Const VDS_E_UNEXPECTED_DISK_LAYOUT_CHANGE = &H8004254D
 [Description("The volume length is invalid.")] Public Const VDS_E_INVALID_VOLUME_LENGTH = &H8004254E
 [Description("The volume length is not a multiple of the sector size.")] Public Const VDS_E_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = &H8004254F
 [Description("The volume does not have a retained partition association.")] Public Const VDS_E_VOLUME_NOT_RETAINED = &H80042550
 [Description("The volume already has a retained partition association.")] Public Const VDS_E_VOLUME_RETAINED = &H80042551
 [Description("The specified alignment is beyond the first cylinder.")] Public Const VDS_E_ALIGN_BEYOND_FIRST_CYLINDER = &H80042553
 [Description("The specified alignment is not a multiple of the sector size.")] Public Const VDS_E_ALIGN_NOT_SECTOR_SIZE_MULTIPLE = &H80042554
 [Description("The specified partition type cannot be created with a non-zero alignment.")] Public Const VDS_E_ALIGN_NOT_ZERO = &H80042555
 [Description("The service's cache has become corrupt.")] Public Const VDS_E_CACHE_CORRUPT = &H80042556
 [Description("The specified volume flag cannot be cleared.")] Public Const VDS_E_CANNOT_CLEAR_VOLUME_FLAG = &H80042557
 [Description("The operation is not allowed on a disk that is in the process of being cleaned.")] Public Const VDS_E_DISK_BEING_CLEANED = &H80042558
 [Description("are examples of disks that are not convertable.")] Public Const VDS_E_DISK_NOT_CONVERTIBLE = &H80042559
 [Description("The operation is not supported on removable media.")] Public Const VDS_E_DISK_REMOVEABLE = &H8004255A
 [Description("The operation is not supported on a non-empty removable disk.")] Public Const VDS_E_DISK_REMOVEABLE_NOT_EMPTY = &H8004255B
 [Description("The specified drive letter is not free to be assigned.")] Public Const VDS_E_DRIVE_LETTER_NOT_FREE = &H8004255C
 [Description("Extending the volume onto multiple disks is not supported by this provider.")] Public Const VDS_E_EXTEND_MULTIPLE_DISKS_NOT_SUPPORTED = &H8004255D
 [Description("The specified drive letter is invalid.")] Public Const VDS_E_INVALID_DRIVE_LETTER = &H8004255E
 [Description("The specified number of drive letters to retrieve is invalid.")] Public Const VDS_E_INVALID_DRIVE_LETTER_COUNT = &H8004255F
 [Description("The specified file system flag is invalid.")] Public Const VDS_E_INVALID_FS_FLAG = &H80042560
 [Description("The specified file system is invalid.")] Public Const VDS_E_INVALID_FS_TYPE = &H80042561
 [Description("The specified object type is invalid.")] Public Const VDS_E_INVALID_OBJECT_TYPE = &H80042562
 [Description("The specified partition layout is invalid.")] Public Const VDS_E_INVALID_PARTITION_LAYOUT = &H80042563
 [Description("VDS only supports MBR or GPT partition style disks.")] Public Const VDS_E_INVALID_PARTITION_STYLE = &H80042564
 [Description("The specified partition type is not valid for this operation.")] Public Const VDS_E_INVALID_PARTITION_TYPE = &H80042565
 [Description("The specified provider clsid cannot be a NULL GUID.")] Public Const VDS_E_INVALID_PROVIDER_CLSID = &H80042566
 [Description("The specified provider id cannot be a NULL GUID.")] Public Const VDS_E_INVALID_PROVIDER_ID = &H80042567
 [Description("The specified provider name is invalid.")] Public Const VDS_E_INVALID_PROVIDER_NAME = &H80042568
 [Description("The specified provider type is invalid.")] Public Const VDS_E_INVALID_PROVIDER_TYPE = &H80042569
 [Description("The specified provider version GUID cannot be a NULL GUID.")] Public Const VDS_E_INVALID_PROVIDER_VERSION_GUID = &H8004256A
 [Description("The specified provider version string is invalid.")] Public Const VDS_E_INVALID_PROVIDER_VERSION_STRING = &H8004256B
 [Description("The specified query provider flag is invalid.")] Public Const VDS_E_INVALID_QUERY_PROVIDER_FLAG = &H8004256C
 [Description("The specified service flag is invalid.")] Public Const VDS_E_INVALID_SERVICE_FLAG = &H8004256D
 [Description("The specified volume flag is invalid.")] Public Const VDS_E_INVALID_VOLUME_FLAG = &H8004256E
 [Description("The operation is not supported on non-OEM partitions.")] Public Const VDS_E_PARTITION_NOT_OEM = &H8004256F
 [Description("Cannot delete a protected partition without the force protected parameter set.")] Public Const VDS_E_PARTITION_PROTECTED = &H80042570
 [Description("The specified partition style does not match that of the disk.")] Public Const VDS_E_PARTITION_STYLE_MISMATCH = &H80042571
 [Description("An internal error has occurred in the provider.")] Public Const VDS_E_PROVIDER_INTERNAL_ERROR = &H80042572
 [Description("The specified shrink size is less than then minimum shrink size allowed.")] Public Const VDS_E_SHRINK_SIZE_LESS_THAN_MIN = &H80042573
 [Description("smaller than the minimum volume size.")] Public Const VDS_E_SHRINK_SIZE_TOO_BIG = &H80042574
 [Description("The service must be shut down to regain full functionality.")] Public Const VDS_E_UNRECOVERABLE_PROVIDER_ERROR = &H80042575
 [Description("Cannot assign a mount point to a hidden volume.")] Public Const VDS_E_VOLUME_HIDDEN = &H80042576
 [Description("Failed to dismount the volume after setting the volume flags.")] Public Const VDS_S_DISMOUNT_FAILED = &H00042577
 [Description("Failed to remount the volume after setting the volume flags.")] Public Const VDS_S_REMOUNT_FAILED = &H00042578
 [Description("Can't set the specified flag as revert-on-close, because it is already set.")] Public Const VDS_E_FLAG_ALREADY_SET = &H80042579
 [Description("resynchronization notifications will be sent.")] Public Const VDS_S_RESYNC_NOTIFICATION_TASK_FAILED = &H0004257A
 [Description("the operation.")] Public Const VDS_E_DISTINCT_VOLUME = &H8004257B
 [Description("The specified volumes do not belong to the same pack.")] Public Const VDS_E_VOLUME_NOT_FOUND_IN_PACK = &H8004257C
 [Description("The specified partition is a not a primary or logical volume.")] Public Const VDS_E_PARTITION_NON_DATA = &H8004257D
 [Description("The specified plex is a the current system or boot plex.")] Public Const VDS_E_CRITICAL_PLEX = &H8004257E
 [Description("The operation cannot be completed because the volume is synchronizing.")] Public Const VDS_E_VOLUME_SYNCHRONIZING = &H8004257F
 [Description("The operation cannot be completed because the volume is regenerating.")] Public Const VDS_E_VOLUME_REGENERATING = &H80042580
 [Description("Failed to flush and hold Volume Snapshot Service writes.")] Public Const VDS_S_VSS_FLUSH_AND_HOLD_WRITES = &H00042581
 [Description("Failed to release Volume Snapshot Service writes.")] Public Const VDS_S_VSS_RELEASE_WRITES = &H00042582
 [Description("Failed to obtain a file system lock.")] Public Const VDS_S_FS_LOCK = &H00042583
 [Description("The volume is read only.")] Public Const VDS_E_READONLY = &H80042584
 [Description("The volume type is invalid for this operation.")] Public Const VDS_E_INVALID_VOLUME_TYPE = &H80042585
 [Description("the pack.")] Public Const VDS_E_BAD_BOOT_DISK = &H80042586
 [Description("The driver failed to update the log on at least one disk.")] Public Const VDS_E_LOG_UPDATE = &H80042587
 [Description("This operation is not supported on a mirrored volume.")] Public Const VDS_E_VOLUME_MIRRORED = &H80042588
 [Description("This operation is only supported on simple or spanned volumes.")] Public Const VDS_E_VOLUME_SIMPLE_SPANNED = &H80042589
 [Description("This pack has no valid log copies.")] Public Const VDS_E_NO_VALID_LOG_COPIES = &H8004258A
 [Description("once the plex has been loaded to the provider cache.")] Public Const VDS_S_PLEX_NOT_LOADED_TO_CACHE = &H0004258B
 [Description("once the plex has been loaded to the provider cache.")] Public Const VDS_E_PLEX_NOT_LOADED_TO_CACHE = &H8004258B
 [Description("This operation is not supported on MSR partitions.")] Public Const VDS_E_PARTITION_MSR = &H8004258C
 [Description("This operation is not supported on LDM partitions.")] Public Const VDS_E_PARTITION_LDM = &H8004258D
 [Description("to manually update the boot entry for any installed operating systems.")] Public Const VDS_S_WINPE_BOOTENTRY = &H0004258E
 [Description("The specified alignment is not a power of two.")] Public Const VDS_E_ALIGN_NOT_A_POWER_OF_TWO = &H8004258F
 [Description("The specified alignment is zero.")] Public Const VDS_E_ALIGN_IS_ZERO = &H80042590
 [Description("Only one of these operations can run at a time.")] Public Const VDS_E_SHRINK_IN_PROGRESS = &H80042591
 [Description("BitLocker encryption on the volume could not be removed.")] Public Const VDS_E_CANT_INVALIDATE_FVE = &H80042592
 [Description("The default file system could not be determined.")] Public Const VDS_E_FS_NOT_DETERMINED = &H80042593
 [Description("This disk is already online. ")] Public Const VDS_E_DISK_NOT_OFFLINE = &H80042595
 [Description("The online operation failed.")] Public Const VDS_E_FAILED_TO_ONLINE_DISK = &H80042596
 [Description("The offline operation failed.")] Public Const VDS_E_FAILED_TO_OFFLINE_DISK = &H80042597
 [Description("is not supported.")] Public Const VDS_E_BAD_REVISION_NUMBER = &H80042598
 [Description("The shrink operation was cancelled by the user.")] Public Const VDS_E_SHRINK_USER_CANCELLED = &H80042599
 [Description("volume again.")] Public Const VDS_E_SHRINK_DIRTY_VOLUME = &H8004259A
 [Description("The name was accepted but had to be truncated.")] Public Const VDS_S_NAME_TRUNCATED = &H00042700
 [Description("The name is not unique.")] Public Const VDS_E_NAME_NOT_UNIQUE = &H80042701
 [Description("for example the status conflicts with the current load balance policy.")] Public Const VDS_S_STATUSES_INCOMPLETELY_SET = &H00042702
 [Description("At least one portal's tunnel address is not set successfully.")] Public Const VDS_E_ADDRESSES_INCOMPLETELY_SET = &H80042703
 [Description("At least one portal's security settings are not set successfully.")] Public Const VDS_E_SECURITY_INCOMPLETELY_SET = &H80042705
 [Description("The initiator does not support setting target-specific shared secrets.")] Public Const VDS_E_TARGET_SPECIFIC_NOT_SUPPORTED = &H80042706
 [Description("The target does not support setting initiator-specific shared secrets.")] Public Const VDS_E_INITIATOR_SPECIFIC_NOT_SUPPORTED = &H80042707
 [Description("An iSCSI login session could not be established.")] Public Const VDS_E_ISCSI_LOGIN_FAILED = &H80042708
 [Description("The attempt to log out from the specified iSCSI session failed.")] Public Const VDS_E_ISCSI_LOGOUT_FAILED = &H80042709
 [Description("target portal, and/or initiator portal could not be found.")] Public Const VDS_E_ISCSI_SESSION_NOT_FOUND = &H8004270A
 [Description("deassociated before the target can be deleted.")] Public Const VDS_E_ASSOCIATED_LUNS_EXIST = &H8004270B
 [Description("deassociated before the portal group can be deleted.")] Public Const VDS_E_ASSOCIATED_PORTALS_EXIST = &H8004270C
 [Description("The initiator does not exist in a iSNS discovery domain.")] Public Const VDS_E_NO_DISCOVERY_DOMAIN = &H8004270D
 [Description("The initiator exists in more than one iSNS discovery domain.")] Public Const VDS_E_MULTIPLE_DISCOVERY_DOMAINS = &H8004270E
 [Description("Failed to retrieve the disk's pathname. Some operations on the disk may fail.")] Public Const VDS_E_NO_DISK_PATHNAME = &H8004270F
 [Description("At least one session did not logout successfully.")] Public Const VDS_E_ISCSI_LOGOUT_INCOMPLETE = &H80042710
 [Description("Failed to retrieve the volume's pathname.")] Public Const VDS_E_NO_VOLUME_PATHNAME = &H80042711
 [Description("The provider's cache is not in-sync with the driver cache.")] Public Const VDS_E_PROVIDER_CACHE_OUTOFSYNC = &H80042712
 [Description("No import target was set for this subsystem in the registry.")] Public Const VDS_E_NO_IMPORT_TARGET = &H80042713
 [Description("The object already exists and does not need to be further created or added.")] Public Const VDS_S_ALREADY_EXISTS = &H00042714
 [Description("Some attributes may be incomplete or missing.")] Public Const VDS_S_PROPERTIES_INCOMPLETE = &H00042715
 [Description("setup to the target was removed.")] Public Const VDS_S_ISCSI_SESSION_NOT_FOUND_PERSISTENT_LOGIN_REMOVED = &H00042800
 [Description("removed. Check the iSCSI Initiator Control Panel to remove it if necessary.")] Public Const VDS_S_ISCSI_PERSISTENT_LOGIN_MAY_NOT_BE_REMOVED = &H00042801
 [Description("Login failed because the target is already logged in.")] Public Const VDS_S_ISCSI_LOGIN_ALREAD_EXISTS = &H00042802
 [Description("A system error occurred while retrieving the boot disk information.")] Public Const VDS_E_UNABLE_TO_FIND_BOOT_DISK = &H80042803
 [Description("Multiple disk extents reported for the boot volume - system error.")] Public Const VDS_E_INCORRECT_BOOT_VOLUME_EXTENT_INFO = &H80042804
 [Description("A driver error was reported when getting the SAN policy.")] Public Const VDS_E_GET_SAN_POLICY = &H80042805
 [Description("A driver error was reported when setting the SAN policy.")] Public Const VDS_E_SET_SAN_POLICY = &H80042806
 [Description("Disk attributes may not be changed on the boot disk.")] Public Const VDS_E_BOOT_DISK = &H80042807
 [Description("Failed to mount one or more of the volumes on the disk.")] Public Const VDS_S_DISK_MOUNT_FAILED = &H00042808
 [Description("Failed to dismount one or more of the volumes on the disk.")] Public Const VDS_S_DISK_DISMOUNT_FAILED = &H00042809
 [Description("The operation is not allowed on a disk that is offline.")] Public Const VDS_E_DISK_IS_OFFLINE = &H8004280A
 [Description("The operation is not allowed on a disk that is read only.")] Public Const VDS_E_DISK_IS_READ_ONLY = &H8004280B
 [Description("The operation is not allowed on a disk that contains a pagefile volume.")] Public Const VDS_E_PAGEFILE_DISK = &H8004280C
 [Description("The operation is not allowed on a disk that contains a hibernation file volume.")] Public Const VDS_E_HIBERNATION_FILE_DISK = &H8004280D
 [Description("The operation is not allowed on a disk that contains a crashdump file volume.")] Public Const VDS_E_CRASHDUMP_DISK = &H8004280E
 [Description("A system error occurred while retrieving the system disk information.")] Public Const VDS_E_UNABLE_TO_FIND_SYSTEM_DISK = &H8004280F
 [Description("Multiple disk extents reported for the system volume - system error.")] Public Const VDS_E_INCORRECT_SYSTEM_VOLUME_EXTENT_INFO = &H80042810
 [Description("Disk attributes may not be changed on the current system disk or BIOS disk 0.")] Public Const VDS_E_SYSTEM_DISK = &H80042811
 [Description("Unlock the volume and try again.")] Public Const VDS_E_VOLUME_SHRINK_FVE_LOCKED = &H80042812
 [Description("Use BitLocker tools to recover the volume and try again.")] Public Const VDS_E_VOLUME_SHRINK_FVE_CORRUPT = &H80042813
 [Description("Use BitLocker tools to recover the volume and try again.")] Public Const VDS_E_VOLUME_SHRINK_FVE_RECOVERY = &H80042814
 [Description("succeed, Fveapi.dll must be available in %SystemRoot%\System32\.")] Public Const VDS_E_VOLUME_SHRINK_FVE = &H80042815
 [Description("overwrite volumes containing user data.")] Public Const VDS_E_SHRINK_OVER_DATA = &H80042816
 [Description("The specified size is greater than the size of the LUN.")] Public Const VDS_E_INVALID_SHRINK_SIZE = &H80042817
 [Description("The current state of the disk associated with the LUN is MISSING.")] Public Const VDS_E_LUN_DISK_MISSING = &H80042818
 [Description("The current state of the disk associated with the LUN is FAILED.")] Public Const VDS_E_LUN_DISK_FAILED = &H80042819
 [Description("The current state of the disk associated with the LUN is NOT READY.")] Public Const VDS_E_LUN_DISK_NOT_READY = &H8004281A
 [Description("The current state of the disk associated with the LUN is NO MEDIA.")] Public Const VDS_E_LUN_DISK_NO_MEDIA = &H8004281B
 [Description("The current state of the LUN is NOT READY.")] Public Const VDS_E_LUN_NOT_READY = &H8004281C
 [Description("The current state of the LUN is OFFLINE.")] Public Const VDS_E_LUN_OFFLINE = &H8004281D
 [Description("The current state of the LUN is FAILED.")] Public Const VDS_E_LUN_FAILED = &H8004281E
 [Description("Unlock the volume and retry the operation.")] Public Const VDS_E_VOLUME_EXTEND_FVE_LOCKED = &H8004281F
 [Description("error. Use BitLocker tools to recover the volume and retry the operation.")] Public Const VDS_E_VOLUME_EXTEND_FVE_CORRUPT = &H80042820
 [Description("recovery. Use BitLocker tools to recover the volume and retry the operation.")] Public Const VDS_E_VOLUME_EXTEND_FVE_RECOVERY = &H80042821
 [Description("succeed, Fveapi.dll must be available in %SystemRoot%\System32\.")] Public Const VDS_E_VOLUME_EXTEND_FVE = &H80042822
 [Description("maximum sector size.")] Public Const VDS_E_SECTOR_SIZE_ERROR = &H80042823
 [Description("initiator adapater is associated with the path end point.")] Public Const VDS_E_INITIATOR_ADAPTER_NOT_FOUND = &H80042900
 [Description("is associated with the path end point.")] Public Const VDS_E_TARGET_PORTAL_NOT_FOUND = &H80042901
 [Description("specified, or, the HBA port properties structure is NULL.")] Public Const VDS_E_INVALID_PORT_PATH = &H80042902
 [Description("An invalid iSCSI target name was returned from the provider.")] Public Const VDS_E_INVALID_ISCSI_TARGET_NAME = &H80042903
 [Description("Call to set the iSCSI tunnel mode outer address failed.")] Public Const VDS_E_SET_TUNNEL_MODE_OUTER_ADDRESS = &H80042904
 [Description("Call to get the iSCSI IKE info failed.")] Public Const VDS_E_ISCSI_GET_IKE_INFO = &H80042905
 [Description("Call to set the iSCSI IKE info failed.")] Public Const VDS_E_ISCSI_SET_IKE_INFO = &H80042906
 [Description("The provider returned a NULL subsystem identification string.")] Public Const VDS_E_SUBSYSTEM_ID_IS_NULL = &H80042907
 [Description("Failed to get the iSCSI initiator node name.")] Public Const VDS_E_ISCSI_INITIATOR_NODE_NAME = &H80042908
 [Description("Failed to set iSCSI group preshared key.")] Public Const VDS_E_ISCSI_GROUP_PRESHARE_KEY = &H80042909
 [Description("Failed to set iSCSI initiator CHAP secret.")] Public Const VDS_E_ISCSI_CHAP_SECRET = &H8004290A
 [Description("An invalid IP address was encountered.")] Public Const VDS_E_INVALID_IP_ADDRESS = &H8004290B
 [Description("for any further operations.")] Public Const VDS_E_REBOOT_REQUIRED = &H8004290C
 [Description("Volume GUID pathnames are not valid input to this method.")] Public Const VDS_E_VOLUME_GUID_PATHNAME_NOT_ALLOWED = &H8004290D
 [Description("volume is not allowed. ")] Public Const VDS_E_BOOT_PAGEFILE_DRIVE_LETTER = &H8004290E
 [Description("crashdump or hibernation volume. ")] Public Const VDS_E_DELETE_WITH_CRITICAL = &H8004290F
 [Description("that contains a data volume. ")] Public Const VDS_E_CLEAN_WITH_DATA = &H80042910
 [Description("that contains an OEM volume. ")] Public Const VDS_E_CLEAN_WITH_OEM = &H80042911
 [Description("system, pagefile, crashdump or hibernation volume. ")] Public Const VDS_E_CLEAN_WITH_CRITICAL = &H80042912
 [Description("crashdump or hibernation volume. ")] Public Const VDS_E_FORMAT_CRITICAL = &H80042913
 [Description("The NTFS file system format is not supported on this volume. ")] Public Const VDS_E_NTFS_FORMAT_NOT_SUPPORTED = &H80042914
 [Description("The FAT32 file system format is not supported on this volume. ")] Public Const VDS_E_FAT32_FORMAT_NOT_SUPPORTED = &H80042915
 [Description("The FAT file system format is not supported on this volume. ")] Public Const VDS_E_FAT_FORMAT_NOT_SUPPORTED = &H80042916
 [Description("The volume is not formattable.")] Public Const VDS_E_FORMAT_NOT_SUPPORTED = &H80042917
 [Description("The specified file system does not support compression.")] Public Const VDS_E_COMPRESSION_NOT_SUPPORTED = &H80042918
 [Description("The virtual disk object has not been open yet.")] Public Const VDS_E_VDISK_NOT_OPEN = &H80042919
 [Description("object, because it is not in a state that permits it.")] Public Const VDS_E_VDISK_INVALID_OP_STATE = &H8004291A
 [Description("specified.")] Public Const VDS_E_INVALID_PATH = &H8004291B
 [Description("is NULL.")] Public Const VDS_E_INVALID_ISCSI_PATH = &H8004291C
 [Description("The LUN is not unmasked to the local server.")] Public Const VDS_E_SHRINK_LUN_NOT_UNMASKED = &H8004291D
 [Description("The current state of the disk associated with the LUN is READ ONLY.")] Public Const VDS_E_LUN_DISK_READ_ONLY = &H8004291E
 [Description("Call REFRESH to retry the status update for the disk.")] Public Const VDS_E_LUN_UPDATE_DISK = &H8004291F
 [Description("The current state of the disk associated with the LUN is DYNAMIC.")] Public Const VDS_E_LUN_DYNAMIC = &H80042920
 [Description("OFFLINE.")] Public Const VDS_E_LUN_DYNAMIC_OFFLINE = &H80042921
 [Description("Please increase the resulting lun size.")] Public Const VDS_E_LUN_SHRINK_GPT_HEADER = &H80042922
 [Description("Mirrored volumes are not supported by this operating system.")] Public Const VDS_E_MIRROR_NOT_SUPPORTED = &H80042923
 [Description("RAID-5 volumes are not supported by this operating system.")] Public Const VDS_E_RAID5_NOT_SUPPORTED = &H80042924
 [Description("the minimum size required for GPT disks.")] Public Const VDS_E_DISK_NOT_CONVERTIBLE_SIZE = &H80042925
 [Description("The volume does not support offlining.")] Public Const VDS_E_OFFLINE_NOT_SUPPORTED = &H80042926
 [Description("The pathname for a virtual disk must be fully qualified.")] Public Const VDS_E_VDISK_PATHNAME_INVALID = &H80042927
 [Description("exceed the maximum number of clusters supported by the file system.")] Public Const VDS_E_EXTEND_TOO_MANY_CLUSTERS = &H80042928
 [Description("a recognized file system.")] Public Const VDS_E_EXTEND_UNKNOWN_FILESYSTEM = &H80042929
 [Description("a recognized file system.")] Public Const VDS_E_SHRINK_UNKNOWN_FILESYSTEM = &H8004292A
 [Description("The requested operation requires that the virtual disk be opened.")] Public Const VDS_E_VD_DISK_NOT_OPEN = &H8004292B
 [Description("is expanding.")] Public Const VDS_E_VD_DISK_IS_EXPANDING = &H8004292C
 [Description("is compacting.")] Public Const VDS_E_VD_DISK_IS_COMPACTING = &H8004292D
 [Description("is merging.")] Public Const VDS_E_VD_DISK_IS_MERGING = &H8004292E
 [Description("is attached.")] Public Const VDS_E_VD_IS_ATTACHED = &H8004292F
 [Description("the virtual disk and retry.")] Public Const VDS_E_VD_DISK_ALREADY_OPEN = &H80042930
 [Description("The virtual disk is already in the process of expanding.")] Public Const VDS_E_VD_DISK_ALREADY_EXPANDING = &H80042931
 [Description("The virtual disk is already in the process of compacting.")] Public Const VDS_E_VD_ALREADY_COMPACTING = &H80042932
 [Description("The virtual disk is already in the process of merging.")] Public Const VDS_E_VD_ALREADY_MERGING = &H80042933
 [Description("The virtual disk is already attached.")] Public Const VDS_E_VD_ALREADY_ATTACHED = &H80042934
 [Description("The virtual disk is already detached.")] Public Const VDS_E_VD_ALREADY_DETACHED = &H80042935
 [Description("attached read only.")] Public Const VDS_E_VD_NOT_ATTACHED_READONLY = &H80042936
 [Description("is being attached.")] Public Const VDS_E_VD_IS_BEING_ATTACHED = &H80042937
 [Description("is being detached.")] Public Const VDS_E_VD_IS_BEING_DETACHED = &H80042938
 [Description("The drive is not contained in a pool.")] Public Const VDS_E_NO_POOL = &H80042A00
 [Description("No pool is created. ")] Public Const VDS_E_NO_POOL_CREATED = &H80042A01
 [Description("The specified disk or volume is managed by the Microsoft Failover Clustering component. The disk must be in cluster maintenance mode and the cluster resource status must be online to perform this operation. ")] Public Const VDS_E_NO_MAINTENANCE_MODE = &H80042A02
 [Description("The specified disk or volume is managed by Microsoft Failover Clustering. The disk must be removed from the cluster to perform this operation. ")] Public Const VDS_E_BLOCK_CLUSTERED = &H80042A03
 [Description("on one or more partitions. ")] Public Const VDS_E_DISK_HAS_BANDS = &H80042A04
 [Description("Call Refresh and retry the operation.")] Public Const VDS_E_INVALID_STATE = &H80042A05
 [Description("The ReFS file system format is not supported on this volume. ")] Public Const VDS_E_REFS_FORMAT_NOT_SUPPORTED = &H80042A06
 [Description("Delete is not allowed on the volume that backs your Windows boot volume. ")] Public Const VDS_E_DELETE_WITH_BOOTBACKING = &H80042A07
 [Description("Format is not allowed on the volume that backs your Windows boot volume. ")] Public Const VDS_E_FORMAT_WITH_BOOTBACKING = &H80042A08
 [Description("Clean is not allowed on the disk containing volume that backs your Windows boot volume.")] Public Const VDS_E_CLEAN_WITH_BOOTBACKING = &H80042A09
 [Description("The specified shrink or extend size does not meet alignment requirements for the device.")] Public Const VDS_E_SHRINK_EXTEND_UNALIGNED = &H80042B00
 #End Region
 
 ' //
    ' // pack notifications
    ' //
    Public Enum VdsNotify
         VDS_NF_PACK_ARRIVE = 1
    ' // When a pack is created
         VDS_NF_PACK_DEPART = 2
    ' // When a pack is deleted
         VDS_NF_PACK_MODIFY = 3
    ' // When a pack is modified(including online, offline)
    
    ' //
    ' // volume notifications
    ' //
         VDS_NF_VOLUME_ARRIVE = 4
    ' // When a volume is created or discovered.
         VDS_NF_VOLUME_DEPART = 5
    ' // When a volume is deleted or disappears.
         VDS_NF_VOLUME_MODIFY = 6
    ' // When something changed in the volume's VDS_VOLUME_PROP structure.
         VDS_NF_VOLUME_REBUILDING_PROGRESS = 7
    ' // When a volume is in rebuilding process.


    ' //
    ' // disk notifications
    ' //
         VDS_NF_DISK_ARRIVE = 8
    ' // When a spindle is plugged in, or a RAID controller surfaced a LUN
    ' // that is local to the host.
         VDS_NF_DISK_DEPART = 9
    ' // When a spindle is unplugged, or a RAID controller unbound a LUN
    ' // that was local to the host.
         VDS_NF_DISK_MODIFY = 10
    ' // When something changed in the disk's VDS_DISK_PROP structure.

    ' //
    ' // partition notifications
    ' //
         VDS_NF_PARTITION_ARRIVE = 11
    ' // When a partition is created. If the partition is also a volume,
    ' // a volume arrival notification will also be sent.
         VDS_NF_PARTITION_DEPART = 12
    ' // When a partition is deleted. If the partition is also a volume,
    ' // a volume removal notification will also be sent.
         VDS_NF_PARTITION_MODIFY = 13
    ' // When a partition is changed. If the partition is also a volume,
    ' // and if the partition attributes change, a volume change notification
    ' // will also be sent.

    ' //
    ' // subsystem notifications
    ' //

             VDS_NF_SUB_SYSTEM_ARRIVE = 101
    ' // When a new subsystem is discovered.
             VDS_NF_SUB_SYSTEM_DEPART = 102
    ' // When a subsystem is disconnected.
    ' // NOTE: more subystem notifications continue below starting at 151

    ' //
    ' // controller notifications
    ' //
             VDS_NF_CONTROLLER_ARRIVE = 103 ' ONLINE
    ' // When a controller goes online.
             VDS_NF_CONTROLLER_DEPART = 104 ' OFFLINE
    ' // When a controller goes offline.

    ' //
    ' // drive notifications
    ' //
             VDS_NF_DRIVE_ARRIVE = 105
    ' // When a spindle is plugged in behind a RAID controller.
             VDS_NF_DRIVE_DEPART = 106
    ' // When a spindle is unplugged behind a RAID controller.
             VDS_NF_DRIVE_MODIFY = 107
    ' // When something changed in the spindle's VDS_DRIVE_PROP structure.

    ' //
    ' // LUN notifications
    ' //     The three LUN notifications will be sent only when the LUN is not
    ' //     local to the machine. Otherwise, disk notifications will be sent.
    ' //
             VDS_NF_LUN_ARRIVE = 108
    ' // When a LUN is created.
             VDS_NF_LUN_DEPART = 109
    ' // When a LUN is deleted.
             VDS_NF_LUN_MODIFY = 110
    ' // When something changed in the LUN's VDS_LUN_PROP structure.
    ' // TODO: add VDS_NF_LUN_REBUILDING_PROGRESS?

    ' //
    ' // controller port notifications
    ' //
             VDS_NF_PORT_ARRIVE = 121 ' ONLINE
    ' // When a controller port goes online.
             VDS_NF_PORT_DEPART = 122 ' OFFLINE
    ' // When a controller port goes offline.

    ' //
    ' // portal notifications
    ' //
             VDS_NF_PORTAL_ARRIVE = 123
    ' // When an iSCSI portal is created.
             VDS_NF_PORTAL_DEPART = 124
    ' // When an iSCSI portal is removed.
             VDS_NF_PORTAL_MODIFY = 125
    ' // When something changed in the iSCSI portal's VDS_ISCSI_PORTAL_PROP structure.

    ' //
    ' // target notifications
    ' //
             VDS_NF_TARGET_ARRIVE = 126
    ' // When an iSCSI target is created.
             VDS_NF_TARGET_DEPART = 127
    ' // When an iSCSI target is deleted.
             VDS_NF_TARGET_MODIFY = 128
    ' // When something changed in the iSCSI portal's VDS_ISCSI_TARGET_PROP structure.

    ' //
    ' // portal group notifications
    ' //
             VDS_NF_PORTAL_GROUP_ARRIVE = 129
    ' // When an iSCSI portal group is created.
             VDS_NF_PORTAL_GROUP_DEPART = 130
    ' // When an iSCSI portal group is deleted.
             VDS_NF_PORTAL_GROUP_MODIFY = 131
    ' // When something changed in the iSCSI portal group's VDS_ISCSI_PORTALGROUP_PROP structure.

    ' //
    ' // more subsystem notifications
    ' //
             VDS_NF_SUB_SYSTEM_MODIFY = 151
    ' // When something changed in the subsystem's VDS_SUB_SYSTEM_PROP structure.

    ' //
    ' // drive letter notifications
    ' //
               VDS_NF_DRIVE_LETTER_FREE = 201
    ' // When a drive letter is freed.
               VDS_NF_DRIVE_LETTER_ASSIGN = 202
    ' // When a drive letter is assigned.

    ' //
    ' // file system notifications
    ' //
               VDS_NF_FILE_SYSTEM_MODIFY = 203
    ' // When a volume gets a new label, or file system is extended or shrunk.
    ' // Note, this does not include change of file system comression flags.
               VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS = 204
    ' // When a file system is being formated.
    ' // NOTE: more file system notifications continue below starting at 206

    ' //
    ' // mount point notification
    ' //
               VDS_NF_MOUNT_POINTS_CHANGE = 205

    ' //
    ' // more file system notifications
    ' //
               VDS_NF_FILE_SYSTEM_SHRINKING_PROGRESS = 206
    ' // When a file system is in the process of shrinking

    ' //
    ' // common notifications
    ' //
             VDS_NF_SERVICE_OUT_OF_SYNC = 301

    ' //
    ' // Windows 7 notifications
    ' //

    ' //
    ' // controller notifications
    ' //
             VDS_NF_CONTROLLER_MODIFY = 350
    ' // When something changed in controller's properties.
             VDS_NF_CONTROLLER_REMOVED = 351
    ' // When a controller is removed.

    ' //
    ' // controller port notifications
    ' //
             VDS_NF_PORT_MODIFY = 352
    ' // When something changed in controller port's properties.
             VDS_NF_PORT_REMOVED = 353
    ' // When a controller port is removed.


    ' //
    ' // drive notifications
    ' //
             VDS_NF_DRIVE_REMOVED = 354
    ' // When a drive is removed.
    End Enum
    
Public Const VER_VDS_LUN_INFORMATION = 1

Public Const INVALID_MEMBER_IDX     = (&HFFFFFFFF)

Public Const GPT_PARTITION_NAME_LENGTH = 36

Public Const VDS_REBUILD_PRIORITY_MIN  = 0
Public Const VDS_REBUILD_PRIORITY_MAX  = 16

Public Const VDS_ATTACH_VIRTUAL_DISK_FLAG_USE_FILE_ACL = 1

Public Const MAX_FS_NAME_SIZE = 8
Public Const MAX_FS_FORMAT_SUPPORT_NAME_SIZE = 32
Public Const MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE = 32

Public Const MAX_PROVIDERNAME_LENGTH  = 200
Public Const MAX_VERSIONSTRING_LENGTH  = 16


Public Function CLSID_VdsLoader() As UUID
Static iid As UUID
    If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H9C38ED61, &HD565, &H4728, &HAE, &HEE, &HC8, &H09, &H52, &HF0, &HEC, &HDE)
CLSID_VdsLoader = iid
End Function
Public Function CLSID_VdsService() As UUID
Static iid As UUID
    If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7D1933CB, &H86F6, &H4A98, &H86, &H28, &H01, &HBE, &H94, &HC9, &HA5, &H75)
CLSID_VdsService = iid
End Function
Public Function IID_IEnumVdsObject() As UUID
'{118610b7-8d94-4030-b5b8-500889788e4e}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H118610b7, CInt(&H8d94), CInt(&H4030), &Hb5, &Hb8, &H50, &H08, &H89, &H78, &H8e, &H4e)
IID_IEnumVdsObject = iid
End Function
Public Function IID_IVdsAsync() As UUID
'{d5d23b6d-5a55-4492-9889-397a3c2d2dbc}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hd5d23b6d, CInt(&H5a55), CInt(&H4492), &H98, &H89, &H39, &H7a, &H3c, &H2d, &H2d, &Hbc)
IID_IVdsAsync = iid
End Function
Public Function IID_IVdsAdviseSink() As UUID
'{8326cd1d-cf59-4936-b786-5efc08798e25}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H8326cd1d, CInt(&Hcf59), CInt(&H4936), &Hb7, &H86, &H5e, &Hfc, &H08, &H79, &H8e, &H25)
IID_IVdsAdviseSink = iid
End Function
Public Function IID_IVdsProvider() As UUID
'{10c5e575-7984-4e81-a56b-431f5f92ae42}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H10c5e575, CInt(&H7984), CInt(&H4e81), &Ha5, &H6b, &H43, &H1f, &H5f, &H92, &Hae, &H42)
IID_IVdsProvider = iid
End Function
Public Function IID_IVdsProviderSupport() As UUID
'{1732be13-e8f9-4a03-bfbc-5f616aa66ce1}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H1732be13, CInt(&He8f9), CInt(&H4a03), &Hbf, &Hbc, &H5f, &H61, &H6a, &Ha6, &H6c, &He1)
IID_IVdsProviderSupport = iid
End Function
Public Function IID_IVdsSwProvider() As UUID
'{9aa58360-ce33-4f92-b658-ed24b14425b8}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9aa58360, CInt(&Hce33), CInt(&H4f92), &Hb6, &H58, &Hed, &H24, &Hb1, &H44, &H25, &Hb8)
IID_IVdsSwProvider = iid
End Function
Public Function IID_IVdsPack() As UUID
'{3b69d7f5-9d94-4648-91ca-79939ba263bf}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H3b69d7f5, CInt(&H9d94), CInt(&H4648), &H91, &Hca, &H79, &H93, &H9b, &Ha2, &H63, &Hbf)
IID_IVdsPack = iid
End Function
Public Function IID_IVdsPack2() As UUID
'{13B50BFF-290A-47DD-8558-B7C58DB1A71A}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H13B50BFF, CInt(&H290A), CInt(&H47DD), &H85, &H58, &HB7, &HC5, &H8D, &HB1, &HA7, &H1A)
IID_IVdsPack2 = iid
End Function
Public Function IID_IVdsDisk() As UUID
'{07e5c822-f00c-47a1-8fce-b244da56fd06}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H07e5c822, CInt(&Hf00c), CInt(&H47a1), &H8f, &Hce, &Hb2, &H44, &Hda, &H56, &Hfd, &H06)
IID_IVdsDisk = iid
End Function
Public Function IID_IVdsDisk2() As UUID
'{40F73C8B-687D-4a13-8D96-3D7F2E683936}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H40F73C8B, CInt(&H687D), CInt(&H4a13), &H8D, &H96, &H3D, &H7F, &H2E, &H68, &H39, &H36)
IID_IVdsDisk2 = iid
End Function
Public Function IID_IVdsDiskOnline() As UUID
'{90681B1D-6A7F-48e8-9061-31B7AA125322}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H90681B1D, CInt(&H6A7F), CInt(&H48e8), &H90, &H61, &H31, &HB7, &HAA, &H12, &H53, &H22)
IID_IVdsDiskOnline = iid
End Function
Public Function IID_IVdsAdvancedDisk() As UUID
'{6e6f6b40-977c-4069-bddd-ac710059f8c0}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H6e6f6b40, CInt(&H977c), CInt(&H4069), &Hbd, &Hdd, &Hac, &H71, &H00, &H59, &Hf8, &Hc0)
IID_IVdsAdvancedDisk = iid
End Function
Public Function IID_IVdsAdvancedDisk2() As UUID
'{9723f420-9355-42de-ab66-e31bb15beeac}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9723f420, CInt(&H9355), CInt(&H42de), &Hab, &H66, &He3, &H1b, &Hb1, &H5b, &Hee, &Hac)
IID_IVdsAdvancedDisk2 = iid
End Function
Public Function IID_IVdsAdvancedDisk3() As UUID
'{3858C0D5-0F35-4BF5-9714-69874963BC36}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H3858C0D5, CInt(&H0F35), CInt(&H4BF5), &H97, &H14, &H69, &H87, &H49, &H63, &HBC, &H36)
IID_IVdsAdvancedDisk3 = iid
End Function
Public Function IID_IVdsCreatePartitionEx() As UUID
'{9882f547-cfc3-420b-9750-00dfbec50662}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9882f547, CInt(&Hcfc3), CInt(&H420b), &H97, &H50, &H00, &Hdf, &Hbe, &Hc5, &H06, &H62)
IID_IVdsCreatePartitionEx = iid
End Function
Public Function IID_IVdsRemovable() As UUID
'{0316560b-5db4-4ed9-bbb5-213436ddc0d9}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H0316560b, CInt(&H5db4), CInt(&H4ed9), &Hbb, &Hb5, &H21, &H34, &H36, &Hdd, &Hc0, &Hd9)
IID_IVdsRemovable = iid
End Function
Public Function IID_IVdsVolume() As UUID
'{88306bb2-e71f-478c-86a2-79da200a0f11}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H88306bb2, CInt(&He71f), CInt(&H478c), &H86, &Ha2, &H79, &Hda, &H20, &H0a, &H0f, &H11)
IID_IVdsVolume = iid
End Function
Public Function IID_IVdsVolume2() As UUID
'{72AE6713-DCBB-4a03-B36B-371F6AC6B53D}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H72AE6713, CInt(&HDCBB), CInt(&H4a03), &HB3, &H6B, &H37, &H1F, &H6A, &HC6, &HB5, &H3D)
IID_IVdsVolume2 = iid
End Function
Public Function IID_IVdsVolumeOnline() As UUID
'{1BE2275A-B315-4f70-9E44-879B3A2A53F2}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H1BE2275A, CInt(&HB315), CInt(&H4f70), &H9E, &H44, &H87, &H9B, &H3A, &H2A, &H53, &HF2)
IID_IVdsVolumeOnline = iid
End Function
Public Function IID_IVdsVolumePlex() As UUID
'{4daa0135-e1d1-40f1-aaa5-3cc1e53221c3}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H4daa0135, CInt(&He1d1), CInt(&H40f1), &Haa, &Ha5, &H3c, &Hc1, &He5, &H32, &H21, &Hc3)
IID_IVdsVolumePlex = iid
End Function
Public Function IID_IVdsDisk3() As UUID
'{8F4B2F5D-EC15-4357-992F-473EF10975B9}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H8F4B2F5D, CInt(&HEC15), CInt(&H4357), &H99, &H2F, &H47, &H3E, &HF1, &H09, &H75, &HB9)
IID_IVdsDisk3 = iid
End Function
Public Function IID_IVdsHwProvider() As UUID
'{d99bdaae-b13a-4178-9fdb-e27f16b4603e}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hd99bdaae, CInt(&Hb13a), CInt(&H4178), &H9f, &Hdb, &He2, &H7f, &H16, &Hb4, &H60, &H3e)
IID_IVdsHwProvider = iid
End Function
Public Function IID_IVdsHwProviderType() As UUID
'{3e0f5166-542d-4fc6-947a-012174240b7e}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H3e0f5166, CInt(&H542d), CInt(&H4fc6), &H94, &H7a, &H01, &H21, &H74, &H24, &H0b, &H7e)
IID_IVdsHwProviderType = iid
End Function
Public Function IID_IVdsHwProviderType2() As UUID
'{8190236f-c4d0-4e81-8011-d69512fcc984}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H8190236f, CInt(&Hc4d0), CInt(&H4e81), &H80, &H11, &Hd6, &H95, &H12, &Hfc, &Hc9, &H84)
IID_IVdsHwProviderType2 = iid
End Function
Public Function IID_IVdsHwProviderStoragePools() As UUID
'{d5b5937a-f188-4c79-b86c-11c920ad11b8}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hd5b5937a, CInt(&Hf188), CInt(&H4c79), &Hb8, &H6c, &H11, &Hc9, &H20, &Had, &H11, &Hb8)
IID_IVdsHwProviderStoragePools = iid
End Function
Public Function IID_IVdsSubSystem() As UUID
'{6fcee2d3-6d90-4f91-80e2-a5c7caaca9d8}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H6fcee2d3, CInt(&H6d90), CInt(&H4f91), &H80, &He2, &Ha5, &Hc7, &Hca, &Hac, &Ha9, &Hd8)
IID_IVdsSubSystem = iid
End Function
Public Function IID_IVdsSubSystem2() As UUID
'{be666735-7800-4a77-9d9c-40f85b87e292}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hbe666735, CInt(&H7800), CInt(&H4a77), &H9d, &H9c, &H40, &Hf8, &H5b, &H87, &He2, &H92)
IID_IVdsSubSystem2 = iid
End Function
Public Function IID_IVdsSubSystemNaming() As UUID
'{0d70faa3-9cd4-4900-aa20-6981b6aafc75}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H0d70faa3, CInt(&H9cd4), CInt(&H4900), &Haa, &H20, &H69, &H81, &Hb6, &Haa, &Hfc, &H75)
IID_IVdsSubSystemNaming = iid
End Function
Public Function IID_IVdsSubSystemIscsi() As UUID
'{0027346f-40d0-4b45-8cec-5906dc0380c8}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H0027346f, CInt(&H40d0), CInt(&H4b45), &H8c, &Hec, &H59, &H06, &Hdc, &H03, &H80, &Hc8)
IID_IVdsSubSystemIscsi = iid
End Function
Public Function IID_IVdsSubSystemInterconnect() As UUID
'{9e6fa560-c141-477b-83ba-0b6c38f7febf}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9e6fa560, CInt(&Hc141), CInt(&H477b), &H83, &Hba, &H0b, &H6c, &H38, &Hf7, &Hfe, &Hbf)
IID_IVdsSubSystemInterconnect = iid
End Function
Public Function IID_IVdsControllerPort() As UUID
'{18691d0d-4e7f-43e8-92e4-cf44beeed11c}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H18691d0d, CInt(&H4e7f), CInt(&H43e8), &H92, &He4, &Hcf, &H44, &Hbe, &Hee, &Hd1, &H1c)
IID_IVdsControllerPort = iid
End Function
Public Function IID_IVdsController() As UUID
'{cb53d96e-dffb-474a-a078-790d1e2bc082}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hcb53d96e, CInt(&Hdffb), CInt(&H474a), &Ha0, &H78, &H79, &H0d, &H1e, &H2b, &Hc0, &H82)
IID_IVdsController = iid
End Function
Public Function IID_IVdsControllerControllerPort() As UUID
'{ca5d735f-6bae-42c0-b30e-f2666045ce71}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hca5d735f, CInt(&H6bae), CInt(&H42c0), &Hb3, &H0e, &Hf2, &H66, &H60, &H45, &Hce, &H71)
IID_IVdsControllerControllerPort = iid
End Function
Public Function IID_IVdsDrive() As UUID
'{ff24efa4-aade-4b6b-898b-eaa6a20887c7}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hff24efa4, CInt(&Haade), CInt(&H4b6b), &H89, &H8b, &Hea, &Ha6, &Ha2, &H08, &H87, &Hc7)
IID_IVdsDrive = iid
End Function
Public Function IID_IVdsDrive2() As UUID
'{60b5a730-addf-4436-8ca7-5769e2d1ffa4}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H60b5a730, CInt(&Haddf), CInt(&H4436), &H8c, &Ha7, &H57, &H69, &He2, &Hd1, &Hff, &Ha4)
IID_IVdsDrive2 = iid
End Function
Public Function IID_IVdsLun() As UUID
'{3540a9c7-e60f-4111-a840-8bba6c2c83d8}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H3540a9c7, CInt(&He60f), CInt(&H4111), &Ha8, &H40, &H8b, &Hba, &H6c, &H2c, &H83, &Hd8)
IID_IVdsLun = iid
End Function
Public Function IID_IVdsLun2() As UUID
'{e5b3a735-9efb-499a-8071-4394d9ee6fcb}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &He5b3a735, CInt(&H9efb), CInt(&H499a), &H80, &H71, &H43, &H94, &Hd9, &Hee, &H6f, &Hcb)
IID_IVdsLun2 = iid
End Function
Public Function IID_IVdsLunNaming() As UUID
'{907504cb-6b4e-4d88-a34d-17ba661fbb06}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H907504cb, CInt(&H6b4e), CInt(&H4d88), &Ha3, &H4d, &H17, &Hba, &H66, &H1f, &Hbb, &H06)
IID_IVdsLunNaming = iid
End Function
Public Function IID_IVdsLunNumber() As UUID
'{d3f95e46-54b3-41f9-b678-0f1871443a08}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hd3f95e46, CInt(&H54b3), CInt(&H41f9), &Hb6, &H78, &H0f, &H18, &H71, &H44, &H3a, &H08)
IID_IVdsLunNumber = iid
End Function
Public Function IID_IVdsLunControllerPorts() As UUID
'{451fe266-da6d-406a-bb60-82e534f85aeb}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H451fe266, CInt(&Hda6d), CInt(&H406a), &Hbb, &H60, &H82, &He5, &H34, &Hf8, &H5a, &Heb)
IID_IVdsLunControllerPorts = iid
End Function
Public Function IID_IVdsLunMpio() As UUID
'{7c5fbae3-333a-48a1-a982-33c15788cde3}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H7c5fbae3, CInt(&H333a), CInt(&H48a1), &Ha9, &H82, &H33, &Hc1, &H57, &H88, &Hcd, &He3)
IID_IVdsLunMpio = iid
End Function
Public Function IID_IVdsLunIscsi() As UUID
'{0d7c1e64-b59b-45ae-b86a-2c2cc6a42067}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H0d7c1e64, CInt(&Hb59b), CInt(&H45ae), &Hb8, &H6a, &H2c, &H2c, &Hc6, &Ha4, &H20, &H67)
IID_IVdsLunIscsi = iid
End Function
Public Function IID_IVdsLunPlex() As UUID
'{0ee1a790-5d2e-4abb-8c99-c481e8be2138}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H0ee1a790, CInt(&H5d2e), CInt(&H4abb), &H8c, &H99, &Hc4, &H81, &He8, &Hbe, &H21, &H38)
IID_IVdsLunPlex = iid
End Function
Public Function IID_IVdsIscsiPortal() As UUID
'{7fa1499d-ec85-4a8a-a47b-ff69201fcd34}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H7fa1499d, CInt(&Hec85), CInt(&H4a8a), &Ha4, &H7b, &Hff, &H69, &H20, &H1f, &Hcd, &H34)
IID_IVdsIscsiPortal = iid
End Function
Public Function IID_IVdsIscsiTarget() As UUID
'{aa8f5055-83e5-4bcc-aa73-19851a36a849}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Haa8f5055, CInt(&H83e5), CInt(&H4bcc), &Haa, &H73, &H19, &H85, &H1a, &H36, &Ha8, &H49)
IID_IVdsIscsiTarget = iid
End Function
Public Function IID_IVdsIscsiPortalGroup() As UUID
'{fef5f89d-a3dd-4b36-bf28-e7dde045c593}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hfef5f89d, CInt(&Ha3dd), CInt(&H4b36), &Hbf, &H28, &He7, &Hdd, &He0, &H45, &Hc5, &H93)
IID_IVdsIscsiPortalGroup = iid
End Function
Public Function IID_IVdsStoragePool() As UUID
'{932ca8cf-0eb3-4ba8-9620-22665d7f8450}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H932ca8cf, CInt(&H0eb3), CInt(&H4ba8), &H96, &H20, &H22, &H66, &H5d, &H7f, &H84, &H50)
IID_IVdsStoragePool = iid
End Function
Public Function IID_IVdsMaintenance() As UUID
'{daebeef3-8523-47ed-a2b9-05cecce2a1ae}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hdaebeef3, CInt(&H8523), CInt(&H47ed), &Ha2, &Hb9, &H05, &Hce, &Hcc, &He2, &Ha1, &Hae)
IID_IVdsMaintenance = iid
End Function
Public Function IID_IVdsVdProvider() As UUID
'{b481498c-8354-45f9-84a0-0bdd2832a91f}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hb481498c, CInt(&H8354), CInt(&H45f9), &H84, &Ha0, &H0b, &Hdd, &H28, &H32, &Ha9, &H1f)
IID_IVdsVdProvider = iid
End Function
Public Function IID_IVdsVDisk() As UUID
'{1e062b84-e5e6-4b4b-8a25-67b81e8f13e8}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H1e062b84, CInt(&He5e6), CInt(&H4b4b), &H8a, &H25, &H67, &Hb8, &H1e, &H8f, &H13, &He8)
IID_IVdsVDisk = iid
End Function
Public Function IID_IVdsOpenVDisk() As UUID
'{75c8f324-f715-4fe3-a28e-f9011b61a4a1}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H75c8f324, CInt(&Hf715), CInt(&H4fe3), &Ha2, &H8e, &Hf9, &H01, &H1b, &H61, &Ha4, &Ha1)
IID_IVdsOpenVDisk = iid
End Function
Public Function IID_IVdsServiceLoader() As UUID
'{e0393303-90d4-4a97-ab71-e9b671ee2729}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &He0393303, CInt(&H90d4), CInt(&H4a97), &Hab, &H71, &He9, &Hb6, &H71, &Hee, &H27, &H29)
IID_IVdsServiceLoader = iid
End Function
Public Function IID_IVdsService() As UUID
'{0818a8ef-9ba9-40d8-a6f9-e22833cc771e}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H0818a8ef, CInt(&H9ba9), CInt(&H40d8), &Ha6, &Hf9, &He2, &H28, &H33, &Hcc, &H77, &H1e)
IID_IVdsService = iid
End Function
Public Function IID_IVdsServiceUninstallDisk() As UUID
'{B6B22DA8-F903-4be7-B492-C09D875AC9DA}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HB6B22DA8, CInt(&HF903), CInt(&H4be7), &HB4, &H92, &HC0, &H9D, &H87, &H5A, &HC9, &HDA)
IID_IVdsServiceUninstallDisk = iid
End Function
Public Function IID_IVdsServiceHba() As UUID
'{0ac13689-3134-47c6-a17c-4669216801be}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H0ac13689, CInt(&H3134), CInt(&H47c6), &Ha1, &H7c, &H46, &H69, &H21, &H68, &H01, &Hbe)
IID_IVdsServiceHba = iid
End Function
Public Function IID_IVdsServiceIscsi() As UUID
'{14fbe036-3ed7-4e10-90e9-a5ff991aff01}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H14fbe036, CInt(&H3ed7), CInt(&H4e10), &H90, &He9, &Ha5, &Hff, &H99, &H1a, &Hff, &H01)
IID_IVdsServiceIscsi = iid
End Function
Public Function IID_IVdsServiceInitialization() As UUID
'{4afc3636-db01-4052-80c3-03bbcb8d3c69}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H4afc3636, CInt(&Hdb01), CInt(&H4052), &H80, &Hc3, &H03, &Hbb, &Hcb, &H8d, &H3c, &H69)
IID_IVdsServiceInitialization = iid
End Function
Public Function IID_IVdsHbaPort() As UUID
'{2abd757f-2851-4997-9a13-47d2a885d6ca}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H2abd757f, CInt(&H2851), CInt(&H4997), &H9a, &H13, &H47, &Hd2, &Ha8, &H85, &Hd6, &Hca)
IID_IVdsHbaPort = iid
End Function
Public Function IID_IVdsIscsiInitiatorAdapter() As UUID
'{b07fedd4-1682-4440-9189-a39b55194dc5}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hb07fedd4, CInt(&H1682), CInt(&H4440), &H91, &H89, &Ha3, &H9b, &H55, &H19, &H4d, &Hc5)
IID_IVdsIscsiInitiatorAdapter = iid
End Function
Public Function IID_IVdsIscsiInitiatorPortal() As UUID
'{38a0a9ab-7cc8-4693-ac07-1f28bd03c3da}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H38a0a9ab, CInt(&H7cc8), CInt(&H4693), &Hac, &H07, &H1f, &H28, &Hbd, &H03, &Hc3, &Hda)
IID_IVdsIscsiInitiatorPortal = iid
End Function
Public Function IID_IVdsDiskPartitionMF() As UUID
'{538684e0-ba3d-4bc0-aca9-164aff85c2a9}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H538684e0, CInt(&Hba3d), CInt(&H4bc0), &Hac, &Ha9, &H16, &H4a, &Hff, &H85, &Hc2, &Ha9)
IID_IVdsDiskPartitionMF = iid
End Function
Public Function IID_IVdsVolumeMF() As UUID
'{ee2d5ded-6236-4169-931d-b9778ce03dc6}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hee2d5ded, CInt(&H6236), CInt(&H4169), &H93, &H1d, &Hb9, &H77, &H8c, &He0, &H3d, &Hc6)
IID_IVdsVolumeMF = iid
End Function
Public Function IID_IVdsVolumeMF2() As UUID
'{4dbcee9a-6343-4651-b85f-5e75d74d983c}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H4dbcee9a, CInt(&H6343), CInt(&H4651), &Hb8, &H5f, &H5e, &H75, &Hd7, &H4d, &H98, &H3c)
IID_IVdsVolumeMF2 = iid
End Function
Public Function IID_IVdsVolumeShrink() As UUID
'{d68168c9-82a2-4f85-b6e9-74707c49a58f}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hd68168c9, CInt(&H82a2), CInt(&H4f85), &Hb6, &He9, &H74, &H70, &H7c, &H49, &Ha5, &H8f)
IID_IVdsVolumeShrink = iid
End Function
Public Function IID_IVdsSubSystemImportTarget() As UUID
'{83bfb87f-43fb-4903-baa6-127f01029eec}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H83bfb87f, CInt(&H43fb), CInt(&H4903), &Hba, &Ha6, &H12, &H7f, &H01, &H02, &H9e, &Hec)
IID_IVdsSubSystemImportTarget = iid
End Function
Public Function IID_IVdsIscsiPortalLocal() As UUID
'{ad837c28-52c1-421d-bf04-fae7da665396}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Had837c28, CInt(&H52c1), CInt(&H421d), &Hbf, &H04, &Hfa, &He7, &Hda, &H66, &H53, &H96)
IID_IVdsIscsiPortalLocal = iid
End Function
Public Function IID_IVdsServiceSAN() As UUID
'{FC5D23E8-A88B-41a5-8DE0-2D2F73C5A630}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HFC5D23E8, CInt(&HA88B), CInt(&H41a5), &H8D, &HE0, &H2D, &H2F, &H73, &HC5, &HA6, &H30)
IID_IVdsServiceSAN = iid
End Function
Public Function IID_IVdsVolumeMF3() As UUID
'{6788FAF9-214E-4b85-BA59-266953616E09}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H6788FAF9, CInt(&H214E), CInt(&H4b85), &HBA, &H59, &H26, &H69, &H53, &H61, &H6E, &H09)
IID_IVdsVolumeMF3 = iid
End Function
Public Function IID_IVdsDiskPartitionMF2() As UUID
'{9CBE50CA-F2D2-4bf4-ACE1-96896B729625}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9CBE50CA, CInt(&HF2D2), CInt(&H4bf4), &HAC, &HE1, &H96, &H89, &H6B, &H72, &H96, &H25)
IID_IVdsDiskPartitionMF2 = iid
End Function
Public Function IID_IVdsServiceSw() As UUID
'{15fc031c-0652-4306-b2c3-f558b8f837e2}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H15fc031c, CInt(&H0652), CInt(&H4306), &Hb2, &Hc3, &Hf5, &H58, &Hb8, &Hf8, &H37, &He2)
IID_IVdsServiceSw = iid
End Function
Public Function IID_IVdsProviderPrivate() As UUID
'{11f3cd41-b7e8-48ff-9472-9dff018aa292}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H11f3cd41, CInt(&Hb7e8), CInt(&H48ff), &H94, &H72, &H9d, &Hff, &H01, &H8a, &Ha2, &H92)
IID_IVdsProviderPrivate = iid
End Function
Public Function IID_IVdsHwProviderPrivate() As UUID
'{98f17bf3-9f33-4f12-8714-8b4075092c2e}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H98f17bf3, CInt(&H9f33), CInt(&H4f12), &H87, &H14, &H8b, &H40, &H75, &H09, &H2c, &H2e)
IID_IVdsHwProviderPrivate = iid
End Function
Public Function IID_IVdsHwProviderPrivateMpio() As UUID
'{310a7715-ac2b-4c6f-9827-3d742f351676}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H310a7715, CInt(&Hac2b), CInt(&H4c6f), &H98, &H27, &H3d, &H74, &H2f, &H35, &H16, &H76)
IID_IVdsHwProviderPrivateMpio = iid
End Function
Public Function IID_IVdsAdmin() As UUID
'{d188e97d-85aa-4d33-abc6-26299a10ffc1}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hd188e97d, CInt(&H85aa), CInt(&H4d33), &Hab, &Hc6, &H26, &H29, &H9a, &H10, &Hff, &Hc1)
IID_IVdsAdmin = iid
End Function
    
End Module