//touch-related APIs
//TipAutoComplete.h
//tpcerror.h
// tpcshrd.h
//msinkaut.h
//rtscom.h


//Tipautocomplete

[
    odl,
        uuid(7C6CF46D-8404-46b9-AD33-F5B6036D4007)
]
interface ITipAutoCompleteProvider : stdole.IUnknown
{

    HRESULT   UpdatePendingText(
        [in] BSTR bstrPendingText);

        HRESULT   Show(
        [in] BOOL fShow);

};

[
    odl,
        uuid(5E078E03-8265-4bbe-9487-D242EDBEF910)
]
interface ITipAutoCompleteClient : stdole.IUnknown
{

    HRESULT   AdviseProvider(
        [in] HWND hWndField,
        [in] ITipAutoCompleteProvider * pIProvider);

    HRESULT   UnadviseProvider(
        [in] HWND hWndField,
        [in] ITipAutoCompleteProvider* pIProvider);

    HRESULT   UserSelection(void);

    HRESULT   PreferredRects(
        [in] RECT* prcACList,
        [in] RECT* prcField,
        [in, out] RECT* prcModifiedACList,
        [in, out] BOOL* pfShownAboveTip);

    HRESULT   RequestShowUI(
        [in] HWND hWndList,
        [in, out] BOOL* pfAllowShowing);

};


// CLSID_TipAutoCompleteClient
[uuid(807C1E6C-1D00-453f-B920-B61BB7CDD997)] coclass TipAutoCompleteClient { interface ITipAutoCompleteClient; }


//msinkaut.h
interface IInkRectangle;
interface IInkExtendedProperty;
interface IInkExtendedProperties;
interface IInkDrawingAttributes;
interface IInkTransform;
interface IInkGesture;
interface IInkCursor;
interface IInkCursorButton;
interface IInkCursorButtons;
interface IInkTablet;
interface IInkTablet2;
interface IInkTablet3;
interface IInkTablets;
interface IInkStrokeDisp;
interface IInkStrokes;
interface IInkCustomStrokes;
interface _IInkStrokesEvents;
interface IInkDisp;
interface _IInkEvents;
interface IInkRenderer;
interface IInkCollector;
interface _IInkCollectorEvents;
interface IInkOverlay;
interface _IInkOverlayEvents;
interface IInkPicture;
interface _IInkPictureEvents;
interface IInkRecognizer;
interface IInkRecognizer2;
interface IInkRecognizer3;
interface IInkRecognizers;
interface _IInkRecognitionEvents;
interface IInkRecognizerContext;
interface IInkRecognizerContext2;
interface IInkRecognitionResult;
interface IInkRecognitionAlternate;
interface IInkRecognitionAlternates;
interface IInkRecognizerGuide;
interface IInkWordList;
interface IInkWordList2;

//tpcerror.h
typedef enum MSInkErrors
{
    E_INK_EXCEPTION = 0x80280001,
    E_INK_MISMATCHED_INK_OBJECT                       = 0x80280002,
    E_INK_COLLECTOR_BUSY                              = 0x80280003,
    E_INK_INCOMPATIBLE_OBJECT                          = 0x80280004,
    E_INK_WINDOW_NOT_SET                              = 0x80280005,
    E_INK_INVALID_MODE                                = 0x80280006,
    E_INK_COLLECTOR_ENABLED                           = 0x80280007,
    E_INK_NO_STROKES_TO_RECOGNIZE                     = 0x80280008,
    E_INK_EMPTY_RECOGNITION_RESULT                    = 0x80280009,
    E_INK_OVERLAPPING_INPUT_RECT                    = 0x80280010,
    TPC_E_INVALID_PROPERTY                = 0x80040241,
    TPC_E_NO_DEFAULT_TABLET               = 0x80040212,
    TPC_E_UNKNOWN_PROPERTY                = 0x8004021b,
    TPC_E_INVALID_INPUT_RECT              = 0x80040219,
    TPC_E_INVALID_STROKE                  = 0x80040222,
    TPC_E_INITIALIZE_FAIL                 = 0x80040223,
    TPC_E_NOT_RELEVANT                    = 0x80040232,
    TPC_E_RECOGNIZER_NOT_REGISTERED       = 0x80040235,
    TPC_E_INVALID_RIGHTS                  = 0x80040236,
    TPC_E_OUT_OF_ORDER_CALL               = 0x80040237,
    TPC_E_QUEUE_FULL                      = 0x80040238,
    TPC_E_INVALID_CONFIGURATION           = 0x80040239,
    TPC_E_INVALID_DATA_FROM_RECOGNIZER    = 0x8004023A,
    TPC_E_INVALID_PACKET_DESCRIPTION      = 0x80040233,
    TPC_S_TRUNCATED                       = 0x00040252,
    TPC_S_INTERRUPTED                     = 0x00040253,
    TPC_S_NO_DATA_TO_PROCESS              = 0x00040254,

    TPC_E_INSUFFICIENT_BUFFER = 0x8007007A // __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)

} MSInkErrors;

//
//tpcshrd.h
//WDL ADDED
typedef enum TabletWindowMessages
{
     WM_TABLET_DEFBASE = 0x02C0,
     WM_TABLET_MAXOFFSET = 0x20,
     WM_TABLET_ADDED = 0x02C8, //(WM_TABLET_DEFBASE + 8)
     WM_TABLET_DELETED = 0x02C9, // (WM_TABLET_DEFBASE + 9)
     WM_TABLET_FLICK = 0x02CB, // (WM_TABLET_DEFBASE + 11)
     WM_TABLET_QUERYSYSTEMGESTURESTATUS = 0x02CB // (WM_TABLET_DEFBASE + 12)
} TabletWindowMessages;

//#define MICROSOFT_TABLETPENSERVICE_PROPERTY _T("MicrosoftTabletPenServiceProperty")
typedef enum TabletEnableDisableFlags
{
     TABLET_DISABLE_PRESSANDHOLD        = 0x00000001,
     TABLET_DISABLE_PENTAPFEEDBACK      = 0x00000008,
     TABLET_DISABLE_PENBARRELFEEDBACK   = 0x00000010,
     TABLET_DISABLE_TOUCHUIFORCEON      = 0x00000100,
     TABLET_DISABLE_TOUCHUIFORCEOFF     = 0x00000200,
     TABLET_DISABLE_TOUCHSWITCH         = 0x00008000,
     TABLET_DISABLE_FLICKS              = 0x00010000,
     TABLET_ENABLE_FLICKSONCONTEXT      = 0x00020000,
     TABLET_ENABLE_FLICKLEARNINGMODE    = 0x00040000,
     TABLET_DISABLE_SMOOTHSCROLLING     = 0x00080000,
     TABLET_DISABLE_FLICKFALLBACKKEYS   = 0x00100000,
     TABLET_ENABLE_MULTITOUCHDATA       = 0x01000000
} TabletEnableDisableFlags;

//#define MAX_PACKET_PROPERTY_COUNT    32
//#define MAX_PACKET_BUTTON_COUNT      32

typedef enum TabletIpFlags
{
     IP_CURSOR_DOWN = 0x00000001,
     IP_INVERTED = 0x00000002,
     IP_MARGIN = 0x00000004
} TabletIpFlags;

typedef DWORD CURSOR_ID;

typedef USHORT SYSTEM_EVENT;

typedef DWORD TABLET_CONTEXT_ID;
//
typedef enum PROPERTY_UNITS
{
    PROPERTY_UNITS_DEFAULT = 0,
    PROPERTY_UNITS_INCHES = 1,
    PROPERTY_UNITS_CENTIMETERS = 2,
    PROPERTY_UNITS_DEGREES = 3,
    PROPERTY_UNITS_RADIANS = 4,
    PROPERTY_UNITS_SECONDS = 5,
    PROPERTY_UNITS_POUNDS = 6,
    PROPERTY_UNITS_GRAMS = 7,
    PROPERTY_UNITS_SILINEAR = 8,
    PROPERTY_UNITS_SIROTATION = 9,
    PROPERTY_UNITS_ENGLINEAR = 10,
    PROPERTY_UNITS_ENGROTATION = 11,
    PROPERTY_UNITS_SLUGS = 12,
    PROPERTY_UNITS_KELVIN = 13,
    PROPERTY_UNITS_FAHRENHEIT = 14,
    PROPERTY_UNITS_AMPERE = 15,
    PROPERTY_UNITS_CANDELA = 16
} 	PROPERTY_UNITS;
//
////typedef enum _PROPERTY_UNITS* PPROPERTY_UNITS;
//
////#ifndef _XFORM_
////#define _XFORM_
////WDL ADDED
typedef /* [hidden] */ struct XFORM
{
    float eM11;
    float eM12;
    float eM21;
    float eM22;
    float eDx;
    float eDy;
} 	XFORM;
//
////#endif
typedef struct SYSTEM_EVENT_DATA
{
    BYTE bModifier;
    WCHAR wKey;
    LONG xPos;
    LONG yPos;
    BYTE bCursorMode;
    DWORD dwButtonState;
} 	SYSTEM_EVENT_DATA;

typedef struct STROKE_RANGE
{
    ULONG iStrokeBegin;
    ULONG iStrokeEnd;
} 	STROKE_RANGE;

typedef struct PROPERTY_METRICS
{
    LONG nLogicalMin;
    LONG nLogicalMax;
    PROPERTY_UNITS Units;
    FLOAT fResolution;
} 	PROPERTY_METRICS;

//typedef struct _PROPERTY_METRICS* PPROPERTY_METRICS;

typedef struct PACKET_PROPERTY
{
    UUID guid;
    PROPERTY_METRICS PropertyMetrics;
} 	PACKET_PROPERTY;
//
////typedef struct _PACKET_PROPERTY* PPACKET_PROPERTY;
//
typedef struct PACKET_DESCRIPTION
{
    ULONG cbPacketSize;
    ULONG cPacketProperties;
    LongPtr pPacketProperties; //PACKET_PROPERTY*
    ULONG cButtons;
    LongPtr pguidButtons; //GUID*
} PACKET_DESCRIPTION;
//
////typedef struct _PACKET_DESCRIPTION* PPACKET_DESCRIPTION;
//
////#endif // __WISPSHRD_H
////#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
////#pragma endregion
////
////#pragma region APP Family
////#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
////#ifndef __WISPSHRD_H
////#define __WISPSHRD_H



//msinkaut.h
typedef enum INK_METRIC_FLAGS
{
    IMF_FONT_SELECTED_IN_HDC = 0x1,
    IMF_ITALIC = 0x2,
    IMF_BOLD = 0x4
} 	INK_METRIC_FLAGS;

typedef enum GET_DANDIDATE_FLAGS
{
    TCF_ALLOW_RECOGNITION = 0x1,
    TCF_FORCE_RECOGNITION = 0x2
} 	GET_DANDIDATE_FLAGS;

typedef struct INKMETRIC
{
    INT iHeight;
    INT iFontAscent;
    INT iFontDescent;
    INK_METRIC_FLAGS dwFlags;
    COLORREF color;
} 	INKMETRIC;

//#define INK_SERIALIZED_FORMAT	L"Ink Serialized Format"
typedef enum ItemSelectionConstants
{
    ISC_FirstElement = 0,
    ISC_AllElements = -1
} 	InkSelectionConstants;

//#define STR_GUID_X                         "{598A6A8F-52C0-4BA0-93AF-AF357411A561}"
//#define STR_GUID_Y                         "{B53F9F75-04E0-4498-A7EE-C30DBB5A9011}"
//#define STR_GUID_Z                         "{735ADB30-0EBB-4788-A0E4-0F316490055D}"
//#define STR_GUID_PAKETSTATUS               "{6E0E07BF-AFE7-4CF7-87D1-AF6446208418}"
//#define STR_GUID_TIMERTICK                 "{436510C5-FED3-45D1-8B76-71D3EA7A829D}"
//#define STR_GUID_SERIALNUMBER              "{78A81B56-0935-4493-BAAE-00541A8A16C4}"
//#define STR_GUID_NORMALPRESSURE            "{7307502D-F9F4-4E18-B3F2-2CE1B1A3610C}"
//#define STR_GUID_TANGENTPRESSURE           "{6DA4488B-5244-41EC-905B-32D89AB80809}"
//#define STR_GUID_BUTTONPRESSURE            "{8B7FEFC4-96AA-4BFE-AC26-8A5F0BE07BF5}"
//#define STR_GUID_XTILTORIENTATION          "{A8D07B3A-8BF0-40B0-95A9-B80A6BB787BF}"
//#define STR_GUID_YTILTORIENTATION          "{0E932389-1D77-43AF-AC00-5B950D6D4B2D}"
//#define STR_GUID_AZIMUTHORIENTATION        "{029123B4-8828-410B-B250-A0536595E5DC}"
//#define STR_GUID_ALTITUDEORIENTATION       "{82DEC5C7-F6BA-4906-894F-66D68DFC456C}"
//#define STR_GUID_TWISTORIENTATION          "{0D324960-13B2-41E4-ACE6-7AE9D43D2D3B}"
//#define STR_GUID_PITCHROTATION             "{7F7E57B7-BE37-4BE1-A356-7A84160E1893}"
//#define STR_GUID_ROLLROTATION              "{5D5D5E56-6BA9-4C5B-9FB0-851C91714E56}"
//#define STR_GUID_YAWROTATION               "{6A849980-7C3A-45B7-AA82-90A262950E89}"
//#define STR_GUID_WIDTH                     "{BAABE94D-2712-48F5-BE9D-8F8B5EA0711A}"
//#define STR_GUID_HEIGHT                    "{E61858D2-E447-4218-9D3F-18865C203DF4}"
//#define STR_GUID_FINGERCONTACTCONFIDENCE   "{E706C804-57F0-4F00-8A0C-853D57789BE9}"
//#define STR_GUID_DEVICE_CONTACT_ID         "{02585B91-049B-4750-9615-DF8948AB3C9C}"
//const GUID GUID_PACKETPROPERTY_GUID_X = { 0x598a6a8f, 0x52c0, 0x4ba0, { 0x93, 0xaf, 0xaf, 0x35, 0x74, 0x11, 0xa5, 0x61} };
//const GUID GUID_PACKETPROPERTY_GUID_Y = { 0xb53f9f75, 0x04e0, 0x4498, { 0xa7, 0xee, 0xc3, 0x0d, 0xbb, 0x5a, 0x90, 0x11} };
//const GUID GUID_PACKETPROPERTY_GUID_Z = { 0x735adb30, 0x0ebb, 0x4788, { 0xa0, 0xe4, 0x0f, 0x31, 0x64, 0x90, 0x05, 0x5d} };
//const GUID GUID_PACKETPROPERTY_GUID_PACKET_STATUS = { 0x6e0e07bf, 0xafe7, 0x4cf7, { 0x87, 0xd1, 0xaf, 0x64, 0x46, 0x20, 0x84, 0x18} };
//const GUID GUID_PACKETPROPERTY_GUID_TIMER_TICK = { 0x436510c5, 0xfed3, 0x45d1, { 0x8b, 0x76, 0x71, 0xd3, 0xea, 0x7a, 0x82, 0x9d} };
//const GUID GUID_PACKETPROPERTY_GUID_SERIAL_NUMBER = { 0x78a81b56, 0x0935, 0x4493, { 0xba, 0xae, 0x00, 0x54, 0x1a, 0x8a, 0x16, 0xc4} };
//const GUID GUID_PACKETPROPERTY_GUID_NORMAL_PRESSURE = { 0x7307502d, 0xf9f4, 0x4e18, { 0xb3, 0xf2, 0x2c, 0xe1, 0xb1, 0xa3, 0x61, 0x0c} };
//const GUID GUID_PACKETPROPERTY_GUID_TANGENT_PRESSURE = { 0x6da4488b, 0x5244, 0x41ec, { 0x90, 0x5b, 0x32, 0xd8, 0x9a, 0xb8, 0x08, 0x09} };
//const GUID GUID_PACKETPROPERTY_GUID_BUTTON_PRESSURE = { 0x8b7fefc4, 0x96aa, 0x4bfe, { 0xac, 0x26, 0x8a, 0x5f, 0x0b, 0xe0, 0x7b, 0xf5} };
//const GUID GUID_PACKETPROPERTY_GUID_X_TILT_ORIENTATION = { 0xa8d07b3a, 0x8bf0, 0x40b0, { 0x95, 0xa9, 0xb8, 0x0a, 0x6b, 0xb7, 0x87, 0xbf} };
//const GUID GUID_PACKETPROPERTY_GUID_Y_TILT_ORIENTATION = { 0x0e932389, 0x1d77, 0x43af, { 0xac, 0x00, 0x5b, 0x95, 0x0d, 0x6d, 0x4b, 0x2d} };
//const GUID GUID_PACKETPROPERTY_GUID_AZIMUTH_ORIENTATION = { 0x029123b4, 0x8828, 0x410b, { 0xb2, 0x50, 0xa0, 0x53, 0x65, 0x95, 0xe5, 0xdc} };
//const GUID GUID_PACKETPROPERTY_GUID_ALTITUDE_ORIENTATION = { 0x82dec5c7, 0xf6ba, 0x4906, { 0x89, 0x4f, 0x66, 0xd6, 0x8d, 0xfc, 0x45, 0x6c} };
//const GUID GUID_PACKETPROPERTY_GUID_TWIST_ORIENTATION = { 0x0d324960, 0x13b2, 0x41e4, { 0xac, 0xe6, 0x7a, 0xe9, 0xd4, 0x3d, 0x2d, 0x3b} };
//const GUID GUID_PACKETPROPERTY_GUID_PITCH_ROTATION = { 0x7f7e57b7, 0xbe37, 0x4be1, { 0xa3, 0x56, 0x7a, 0x84, 0x16, 0x0e, 0x18, 0x93} };
//const GUID GUID_PACKETPROPERTY_GUID_ROLL_ROTATION = { 0x5d5d5e56, 0x6ba9, 0x4c5b, { 0x9f, 0xb0, 0x85, 0x1c, 0x91, 0x71, 0x4e, 0x56} };
//const GUID GUID_PACKETPROPERTY_GUID_YAW_ROTATION = { 0x6a849980, 0x7c3a, 0x45b7, { 0xaa, 0x82, 0x90, 0xa2, 0x62, 0x95, 0x0e, 0x89} };
//const GUID GUID_PACKETPROPERTY_GUID_WIDTH = { 0xbaabe94d, 0x2712, 0x48f5, { 0xbe, 0x9d, 0x8f, 0x8b, 0x5e, 0xa0, 0x71, 0x1a} };
//const GUID GUID_PACKETPROPERTY_GUID_HEIGHT = { 0xe61858d2, 0xe447, 0x4218, { 0x9d, 0x3f, 0x18, 0x86, 0x5c, 0x20, 0x3d, 0xf4} };
//const GUID GUID_PACKETPROPERTY_GUID_FINGERCONTACTCONFIDENCE = { 0xe706c804, 0x57f0, 0x4f00, { 0x8a, 0x0c, 0x85, 0x3d, 0x57, 0x78, 0x9b, 0xe9} };
//const GUID GUID_PACKETPROPERTY_GUID_DEVICE_CONTACT_ID = { 0x02585b91, 0x049b, 0x4750, { 0x96, 0x15, 0xdf, 0x89, 0x48, 0xab, 0x3c, 0x9c} };
//#define INKRECOGNITIONPROPERTY_LINENUMBER		 "{DBF29F2C-5289-4BE8-B3D8-6EF63246253E}"
//#define INKRECOGNITIONPROPERTY_BOXNUMBER		 "{2C243E3A-F733-4EB6-B1F8-B5DC5C2C4CDA}"
//#define INKRECOGNITIONPROPERTY_SEGMENTATION      "{B3C0FE6C-FB51-4164-BA2F-844AF8F983DA}"
//#define INKRECOGNITIONPROPERTY_HOTPOINT          "{CA6F40DC-5292-452a-91FB-2181C0BEC0DE}"
//#define INKRECOGNITIONPROPERTY_MAXIMUMSTROKECOUNT"{BF0EEC4E-4B7D-47a9-8CFA-234DD24BD22A}"
//#define INKRECOGNITIONPROPERTY_POINTSPERINCH     "{7ED16B76-889C-468e-8276-0021B770187E}"
//#define INKRECOGNITIONPROPERTY_CONFIDENCELEVEL   "{7DFE11A7-FB5D-4958-8765-154ADF0D833F}"
//#define INKRECOGNITIONPROPERTY_LINEMETRICS       "{8CC24B27-30A9-4b96-9056-2D3A90DA0727}"
//#define FACTOID_NONE				"NONE"
//#define FACTOID_DEFAULT				"DEFAULT"
//#define FACTOID_SYSTEMDICTIONARY	"SYSDICT"
//#define FACTOID_WORDLIST			"WORDLIST"
//#define FACTOID_EMAIL				"EMAI"
//#define FACTOID_WEB					"WEB"
//#define FACTOID_ONECHAR				"ONECHAR"
//#define FACTOID_NUMBER				"NUMBER"
//#define FACTOID_DIGIT				"DIGIT"
//#define FACTOID_NUMBERSIMPLE		"NUMSIMPLE"
//#define FACTOID_CURRENCY			"CURRENCY"
//#define FACTOID_POSTALCODE			"POSTALCODE"
//#define FACTOID_PERCENT				"PERCENT"
//#define FACTOID_DATE				"DATE"
//#define FACTOID_TIME				"TIME"
//#define FACTOID_TELEPHONE			"TELEPHONE"
//#define FACTOID_FILENAME			"FILENAME"
//#define FACTOID_UPPERCHAR			"UPPERCHAR"
//#define FACTOID_LOWERCHAR			"LOWERCHAR"
//#define FACTOID_PUNCCHAR			"PUNCCHAR"
//#define FACTOID_JAPANESECOMMON		"JPN_COMMON"
//#define FACTOID_CHINESESIMPLECOMMON	"CHS_COMMON"
//#define FACTOID_CHINESETRADITIONALCOMMON "CHT_COMMON"
//#define FACTOID_KOREANCOMMON		"KOR_COMMON"
//#define FACTOID_HIRAGANA			"HIRAGANA"
//#define FACTOID_KATAKANA			"KATAKANA"
//#define FACTOID_KANJICOMMON		   "KANJI_COMMON"
//#define FACTOID_KANJIRARE			"KANJI_RARE"
//#define FACTOID_BOPOMOFO	       "BOPOMOFO"
//#define FACTOID_JAMO				"JAMO"
//#define FACTOID_HANGULCOMMON		"HANGUL_COMMON"
//#define FACTOID_HANGULRARE			"HANGUL_RARE"
typedef /* [helpcontext][helpstring] */
enum InkBoundingBoxMode
{
    IBBM_Default = 0,
    IBBM_NoCurveFit = 1,
    IBBM_CurveFit = 2,
    IBBM_PointsOnly = 3,
    IBBM_Union = 4,
    IBBM_Last
} 	InkBoundingBoxMode;
//
//#define IBBM_Last IBBM_Union + 1
typedef /* [helpcontext][helpstring] */
enum InkExtractFlags
{
    IEF_CopyFromOriginal = 0,
    IEF_RemoveFromOriginal = 0x1,
    IEF_Default  = 0x1, //IEF_RemoveFromOriginal,
    IEF_All = 0x1,// (IEF_RemoveFromOriginal | IEF_CopyFromOriginal)
} 	InkExtractFlags;

 
typedef /* [helpcontext][helpstring] */
enum InkPersistenceFormat
{
    IPF_InkSerializedFormat = 0,
    IPF_Base64InkSerializedFormat = 1,
    IPF_GIF = 2,
    IPF_Base64GIF = 3,
    IPF_Last
} 	InkPersistenceFormat;

//#define IPF_Last     IPF_Base64GIF + 1 
typedef /* [helpcontext][helpstring] */
enum InkPersistenceCompressionMode
{
    IPCM_Default = 0,
    IPCM_MaximumCompression = 1,
    IPCM_NoCompression = 2
} 	InkPersistenceCompressionMode;

typedef /* [helpcontext][helpstring] */
enum InkPenTip
{
    IPT_Ball = 0,
    IPT_Rectangle = 1,
    IPT_Last
} 	InkPenTip;

//#define IPT_Last     IPT_Rectangle + 1 
typedef /* [helpcontext][helpstring] */
enum InkRasterOperation
{
    IRO_Black = 1,
    IRO_NotMergePen = 2,
    IRO_MaskNotPen = 3,
    IRO_NotCopyPen = 4,
    IRO_MaskPenNot = 5,
    IRO_Not = 6,
    IRO_XOrPen = 7,
    IRO_NotMaskPen = 8,
    IRO_MaskPen = 9,
    IRO_NotXOrPen = 10,
    IRO_NoOperation = 11,
    IRO_MergeNotPen = 12,
    IRO_CopyPen = 13,
    IRO_MergePenNot = 14,
    IRO_MergePen = 15,
    IRO_White = 16,
    IRO_Last
} 	InkRasterOperation;

//#define IRO_Last IRO_White+1
typedef /* [helpcontext][helpstring] */
enum InkMousePointer
{
    IMP_Default = 0,
    IMP_Arrow = 1,
    IMP_Crosshair = 2,
    IMP_Ibeam = 3,
    IMP_SizeNESW = 4,
    IMP_SizeNS = 5,
    IMP_SizeNWSE = 6,
    IMP_SizeWE = 7,
    IMP_UpArrow = 8,
    IMP_Hourglass = 9,
    IMP_NoDrop = 10,
    IMP_ArrowHourglass = 11,
    IMP_ArrowQuestion = 12,
    IMP_SizeAll = 13,
    IMP_Hand = 14,
    IMP_Custom = 99
} 	InkMousePointer;

typedef /* [helpcontext][helpstring] */
enum InkClipboardModes
{
    ICB_Copy = 0,
    ICB_Cut = 0x1,
    ICB_ExtractOnly = 0x30,
    ICB_DelayedCopy = 0x20,
    ICB_Default = 0, //ICB_Copy
    ICB_Last = 0x21, // ICB_DelayedCopy + 1
} 	InkClipboardModes;

//#define ICB_Last ICB_DelayedCopy+1
typedef /* [helpcontext][helpstring] */
enum InkClipboardFormats
{
    ICF_None = 0,
    ICF_InkSerializedFormat = 0x1,
    ICF_SketchInk = 0x2,
    ICF_TextInk = 0x6,
    ICF_EnhancedMetafile = 0x8,
    ICF_Metafile = 0x20,
    ICF_Bitmap = 0x40,
    ICF_PasteMask = 0x7,
    ICF_CopyMask = 0x7f,
    ICF_Default = 0x7f, //ICF_CopyMask,
    ICF_Last //= ICF_CopyMask + 1
} 	InkClipboardFormats;

//#define ICF_Last ICF_CopyMask+1
typedef /* [helpcontext][helpstring] */
enum SelectionHitResult
{
    SHR_None = 0,
    SHR_NW, // = (SHR_None + 1),
    SHR_SE, // = (SHR_NW + 1),
    SHR_NE, // = (SHR_SE + 1),
    SHR_SW, // = (SHR_NE + 1),
    SHR_E, // = (SHR_SW + 1),
    SHR_W, // = (SHR_E + 1),
    SHR_N, // = (SHR_W + 1),
    SHR_S, // = (SHR_N + 1),
    SHR_Selection, // = (SHR_S + 1)
} 	SelectionHitResult;

typedef /* [helpcontext][helpstring] */
enum InkRecognitionStatus
{
    IRS_NoError = 0,
    IRS_Interrupted = 0x1,
    IRS_ProcessFailed = 0x2,
    IRS_InkAddedFailed = 0x4,
    IRS_SetAutoCompletionModeFailed = 0x8,
    IRS_SetStrokesFailed = 0x10,
    IRS_SetGuideFailed = 0x20,
    IRS_SetFlagsFailed = 0x40,
    IRS_SetFactoidFailed = 0x80,
    IRS_SetPrefixSuffixFailed = 0x100,
    IRS_SetWordListFailed = 0x200
} 	InkRecognitionStatus;

typedef /* [hidden] */
enum DISPID_InkRectangle
{
    DISPID_IRTop = 1,
    DISPID_IRLeft, // = (DISPID_IRTop + 1),
    DISPID_IRBottom, // = (DISPID_IRLeft + 1),
    DISPID_IRRight, // = (DISPID_IRBottom + 1),
    DISPID_IRGetRectangle, // = (DISPID_IRRight + 1),
    DISPID_IRSetRectangle, // = (DISPID_IRGetRectangle + 1),
    DISPID_IRData // = (DISPID_IRSetRectangle + 1)
} 	DISPID_InkRectangle;

typedef /* [hidden] */
enum DISPID_InkExtendedProperty
{
    DISPID_IEPGuid = 1,
    DISPID_IEPData = 2 //(DISPID_IEPGuid + 1)
} 	DISPID_InkExtendedProperty;

typedef /* [hidden] */
enum DISPID_InkExtendedProperties
{
    DISPID_IEPs_NewEnum = (-4), //DISPID_NEWENUM,
    DISPID_IEPsItem = 0, // DISPID_VALUE,
    DISPID_IEPsCount = 1,
    DISPID_IEPsAdd, // = (DISPID_IEPsCount + 1),
    DISPID_IEPsRemove, // = (DISPID_IEPsAdd + 1),
    DISPID_IEPsClear, // = (DISPID_IEPsRemove + 1),
    DISPID_IEPsDoesPropertyExist, // = (DISPID_IEPsClear + 1)
} 	DISPID_InkExtendedProperties;

typedef /* [hidden] */
enum DISPID_InkDrawingAttributes
{
    DISPID_DAHeight = 1,
    DISPID_DAColor, // = (DISPID_DAHeight + 1),
    DISPID_DAWidth, // = (DISPID_DAColor + 1),
    DISPID_DAFitToCurve, // = (DISPID_DAWidth + 1),
    DISPID_DAIgnorePressure, // = (DISPID_DAFitToCurve + 1),
    DISPID_DAAntiAliased, // = (DISPID_DAIgnorePressure + 1),
    DISPID_DATransparency, // = (DISPID_DAAntiAliased + 1),
    DISPID_DARasterOperation, // = (DISPID_DATransparency + 1),
    DISPID_DAPenTip, // = (DISPID_DARasterOperation + 1),
    DISPID_DAClone, // = (DISPID_DAPenTip + 1),
    DISPID_DAExtendedProperties, // = (DISPID_DAClone + 1)
} 	DISPID_InkDrawingAttributes;

typedef /* [hidden] */
enum DISPID_InkTransform
{
    DISPID_ITReset = 1,
    DISPID_ITTranslate, // = (DISPID_ITReset + 1),
    DISPID_ITRotate, // = (DISPID_ITTranslate + 1),
    DISPID_ITReflect, // = (DISPID_ITRotate + 1),
    DISPID_ITShear, // = (DISPID_ITReflect + 1),
    DISPID_ITScale, // = (DISPID_ITShear + 1),
    DISPID_ITeM11, // = (DISPID_ITScale + 1),
    DISPID_ITeM12, // = (DISPID_ITeM11 + 1),
    DISPID_ITeM21, // = (DISPID_ITeM12 + 1),
    DISPID_ITeM22, // = (DISPID_ITeM21 + 1),
    DISPID_ITeDx, // = (DISPID_ITeM22 + 1),
    DISPID_ITeDy, // = (DISPID_ITeDx + 1),
    DISPID_ITGetTransform, // = (DISPID_ITeDy + 1),
    DISPID_ITSetTransform, // = (DISPID_ITGetTransform + 1),
    DISPID_ITData, // = (DISPID_ITSetTransform + 1)
} 	DISPID_InkTransform;

typedef
enum InkApplicationGesture
{
    IAG_AllGestures = 0,
    IAG_NoGesture = 0xf000,
    IAG_Scratchout = 0xf001,
    IAG_Triangle = 0xf002,
    IAG_Square = 0xf003,
    IAG_Star = 0xf004,
    IAG_Check = 0xf005,
    IAG_Curlicue = 0xf010,
    IAG_DoubleCurlicue = 0xf011,
    IAG_Circle = 0xf020,
    IAG_DoubleCircle = 0xf021,
    IAG_SemiCircleLeft = 0xf028,
    IAG_SemiCircleRight = 0xf029,
    IAG_ChevronUp = 0xf030,
    IAG_ChevronDown = 0xf031,
    IAG_ChevronLeft = 0xf032,
    IAG_ChevronRight = 0xf033,
    IAG_ArrowUp = 0xf038,
    IAG_ArrowDown = 0xf039,
    IAG_ArrowLeft = 0xf03a,
    IAG_ArrowRight = 0xf03b,
    IAG_Up = 0xf058,
    IAG_Down = 0xf059,
    IAG_Left = 0xf05a,
    IAG_Right = 0xf05b,
    IAG_UpDown = 0xf060,
    IAG_DownUp = 0xf061,
    IAG_LeftRight = 0xf062,
    IAG_RightLeft = 0xf063,
    IAG_UpLeftLong = 0xf064,
    IAG_UpRightLong = 0xf065,
    IAG_DownLeftLong = 0xf066,
    IAG_DownRightLong = 0xf067,
    IAG_UpLeft = 0xf068,
    IAG_UpRight = 0xf069,
    IAG_DownLeft = 0xf06a,
    IAG_DownRight = 0xf06b,
    IAG_LeftUp = 0xf06c,
    IAG_LeftDown = 0xf06d,
    IAG_RightUp = 0xf06e,
    IAG_RightDown = 0xf06f,
    IAG_Exclamation = 0xf0a4,
    IAG_Tap = 0xf0f0,
    IAG_DoubleTap = 0xf0f1
} 	InkApplicationGesture;

typedef
enum InkSystemGesture
{
    ISG_Tap = 0x10,
    ISG_DoubleTap = 0x11,
    ISG_RightTap = 0x12,
    ISG_Drag = 0x13,
    ISG_RightDrag = 0x14,
    ISG_HoldEnter = 0x15,
    ISG_HoldLeave = 0x16,
    ISG_HoverEnter = 0x17,
    ISG_HoverLeave = 0x18,
    ISG_Flick = 0x1f,
    ISG_First = 0x10, //ISG_Tap,
    ISG_Last = 0x1f //ISG_Flick
} 	InkSystemGesture;


typedef
enum InkRecognitionConfidence
{
    IRC_Strong = 0,
    IRC_Intermediate = 1,
    IRC_Poor = 2
} 	InkRecognitionConfidence;

typedef /* [hidden] */
enum DISPID_InkGesture
{
    DISPID_IGId = 0, //DISPID_VALUE,
    DISPID_IGGetHotPoint, // = (DISPID_IGId + 1),
    DISPID_IGConfidence, // = (DISPID_IGGetHotPoint + 1)
} 	DISPID_InkGesture;

typedef /* [hidden] */
enum DISPID_InkCursor
{
    DISPID_ICsrName = 0, //DISPID_VALUE,
    DISPID_ICsrId = 1,
    DISPID_ICsrDrawingAttributes, // = (DISPID_ICsrId + 1),
    DISPID_ICsrButtons, // = (DISPID_ICsrDrawingAttributes + 1),
    DISPID_ICsrInverted, // = (DISPID_ICsrButtons + 1),
    DISPID_ICsrTablet, // = (DISPID_ICsrInverted + 1)
} 	DISPID_InkCursor;

typedef /* [hidden] */
enum DISPID_InkCursors
{
    DISPID_ICs_NewEnum = -4, //DISPID_NEWENUM,
    DISPID_ICsItem = 0, //DISPID_VALUE,
    DISPID_ICsCount = 1
} 	DISPID_InkCursors;

typedef
enum InkCursorButtonState
{
    ICBS_Unavailable = 0,
    ICBS_Up = 1, //(ICBS_Unavailable + 1),
    ICBS_Down = 2, //(ICBS_Up + 1)
    ICBS_Last = 2 //ICBS_Down
} 	InkCursorButtonState;

 
typedef /* [hidden] */
enum DISPID_InkCursorButton
{
    DISPID_ICBName = 0, //DISPID_VALUE,
    DISPID_ICBId = 1,
    DISPID_ICBState = 2 //(DISPID_ICBId + 1)
} 	DISPID_InkCursorButton;

typedef /* [hidden] */
enum DISPID_InkCursorButtons
{
    DISPID_ICBs_NewEnum = (-4), // DISPID_NEWENUM,
    DISPID_ICBsItem = 0, //DISPID_VALUE,
    DISPID_ICBsCount = 1
} 	DISPID_InkCursorButtons;

typedef
enum TabletHardwareCapabilities
{
    THWC_Integrated = 0x1,
    THWC_CursorMustTouch = 0x2,
    THWC_HardProximity = 0x4,
    THWC_CursorsHavePhysicalIds = 0x8
} 	TabletHardwareCapabilities;

typedef
enum TabletPropertyMetricUnit
{
    TPMU_Default = 0,
    TPMU_Inches, // = (TPMU_Default + 1),
    TPMU_Centimeters, // = (TPMU_Inches + 1),
    TPMU_Degrees, // = (TPMU_Centimeters + 1),
    TPMU_Radians, // = (TPMU_Degrees + 1),
    TPMU_Seconds, // = (TPMU_Radians + 1),
    TPMU_Pounds, // = (TPMU_Seconds + 1),
    TPMU_Grams, // = (TPMU_Pounds + 1)
} 	TabletPropertyMetricUnit;

typedef /* [hidden] */
enum DISPID_InkTablet
{
    DISPID_ITName = 0, //DISPID_VALUE,
    DISPID_ITPlugAndPlayId = 1,
    DISPID_ITPropertyMetrics, // = (DISPID_ITPlugAndPlayId + 1),
    DISPID_ITIsPacketPropertySupported, // = (DISPID_ITPropertyMetrics + 1),
    DISPID_ITMaximumInputRectangle, // = (DISPID_ITIsPacketPropertySupported + 1),
    DISPID_ITHardwareCapabilities, // = (DISPID_ITMaximumInputRectangle + 1)
} 	DISPID_InkTablet;

typedef
enum TabletDeviceKind
{
    TDK_Mouse = 0,
    TDK_Pen, // = (TDK_Mouse + 1),
    TDK_Touch, // = (TDK_Pen + 1)
} 	TabletDeviceKind;

typedef /* [hidden] */
enum DISPID_InkTablet2
{
    DISPID_IT2DeviceKind = 0 //DISPID_VALUE
} 	DISPID_InkTablet2;

typedef /* [hidden] */
enum DISPID_InkTablet3
{
    DISPID_IT3IsMultiTouch = 0, //DISPID_VALUE,
    DISPID_IT3MaximumCursors, // = (DISPID_IT3IsMultiTouch + 1)
} 	DISPID_InkTablet3;

typedef /* [hidden] */
enum DISPID_InkTablets
{
    DISPID_ITs_NewEnum, // = (-4), //DISPID_NEWENUM,
    DISPID_ITsItem = 0, //DISPID_VALUE,
    DISPID_ITsDefaultTablet = 1,
    DISPID_ITsCount, // = (DISPID_ITsDefaultTablet + 1),
    DISPID_ITsIsPacketPropertySupported, // = (DISPID_ITsCount + 1)
} 	DISPID_InkTablets;

typedef /* [hidden] */
enum DISPID_InkStrokeDisp
{
    DISPID_ISDInkIndex = 1,
    DISPID_ISDID, // = (DISPID_ISDInkIndex + 1),
    DISPID_ISDGetBoundingBox, // = (DISPID_ISDID + 1),
    DISPID_ISDDrawingAttributes, // = (DISPID_ISDGetBoundingBox + 1),
    DISPID_ISDFindIntersections, // = (DISPID_ISDDrawingAttributes + 1),
    DISPID_ISDGetRectangleIntersections, // = (DISPID_ISDFindIntersections + 1),
    DISPID_ISDClip, // = (DISPID_ISDGetRectangleIntersections + 1),
    DISPID_ISDHitTestCircle, // = (DISPID_ISDClip + 1),
    DISPID_ISDNearestPoint, // = (DISPID_ISDHitTestCircle + 1),
    DISPID_ISDSplit, // = (DISPID_ISDNearestPoint + 1),
    DISPID_ISDExtendedProperties, // = (DISPID_ISDSplit + 1),
    DISPID_ISDInk, // = (DISPID_ISDExtendedProperties + 1),
    DISPID_ISDBezierPoints, // = (DISPID_ISDInk + 1),
    DISPID_ISDPolylineCusps, // = (DISPID_ISDBezierPoints + 1),
    DISPID_ISDBezierCusps, // = (DISPID_ISDPolylineCusps + 1),
    DISPID_ISDSelfIntersections, // = (DISPID_ISDBezierCusps + 1),
    DISPID_ISDPacketCount, // = (DISPID_ISDSelfIntersections + 1),
    DISPID_ISDPacketSize, // = (DISPID_ISDPacketCount + 1),
    DISPID_ISDPacketDescription, // = (DISPID_ISDPacketSize + 1),
    DISPID_ISDDeleted, // = (DISPID_ISDPacketDescription + 1),
    DISPID_ISDGetPacketDescriptionPropertyMetrics, // = (DISPID_ISDDeleted + 1),
    DISPID_ISDGetPoints, // = (DISPID_ISDGetPacketDescriptionPropertyMetrics + 1),
    DISPID_ISDSetPoints, // = (DISPID_ISDGetPoints + 1),
    DISPID_ISDGetPacketData, // = (DISPID_ISDSetPoints + 1),
    DISPID_ISDGetPacketValuesByProperty, // = (DISPID_ISDGetPacketData + 1),
    DISPID_ISDSetPacketValuesByProperty, // = (DISPID_ISDGetPacketValuesByProperty + 1),
    DISPID_ISDGetFlattenedBezierPoints, // = (DISPID_ISDSetPacketValuesByProperty + 1),
    DISPID_ISDScaleToRectangle, // = (DISPID_ISDGetFlattenedBezierPoints + 1),
    DISPID_ISDTransform, // = (DISPID_ISDScaleToRectangle + 1),
    DISPID_ISDMove, // = (DISPID_ISDTransform + 1),
    DISPID_ISDRotate, // = (DISPID_ISDMove + 1),
    DISPID_ISDShear, // = (DISPID_ISDRotate + 1),
    DISPID_ISDScale, // = (DISPID_ISDShear + 1)
} 	DISPID_InkStrokeDisp;

typedef /* [hidden] */
enum DISPID_InkStrokes
{
    DISPID_ISs_NewEnum = (-4), //DISPID_NEWENUM,
    DISPID_ISsItem = 0, //DISPID_VALUE,
    DISPID_ISsCount = 1,
    DISPID_ISsValid, // = (DISPID_ISsCount + 1),
    DISPID_ISsInk, // = (DISPID_ISsValid + 1),
    DISPID_ISsAdd, // = (DISPID_ISsInk + 1),
    DISPID_ISsAddStrokes, // = (DISPID_ISsAdd + 1),
    DISPID_ISsRemove, // = (DISPID_ISsAddStrokes + 1),
    DISPID_ISsRemoveStrokes, // = (DISPID_ISsRemove + 1),
    DISPID_ISsToString, // = (DISPID_ISsRemoveStrokes + 1),
    DISPID_ISsModifyDrawingAttributes, // = (DISPID_ISsToString + 1),
    DISPID_ISsGetBoundingBox, // = (DISPID_ISsModifyDrawingAttributes + 1),
    DISPID_ISsScaleToRectangle, // = (DISPID_ISsGetBoundingBox + 1),
    DISPID_ISsTransform, // = (DISPID_ISsScaleToRectangle + 1),
    DISPID_ISsMove, // = (DISPID_ISsTransform + 1),
    DISPID_ISsRotate, // = (DISPID_ISsMove + 1),
    DISPID_ISsShear, // = (DISPID_ISsRotate + 1),
    DISPID_ISsScale, // = (DISPID_ISsShear + 1),
    DISPID_ISsClip, // = (DISPID_ISsScale + 1),
    DISPID_ISsRecognitionResult, // = (DISPID_ISsClip + 1),
    DISPID_ISsRemoveRecognitionResult, // = (DISPID_ISsRecognitionResult + 1)
} 	DISPID_InkStrokes;

typedef /* [hidden] */
enum DISPID_InkCustomStrokes
{
    DISPID_ICSs_NewEnum = (-4), //DISPID_NEWENUM,
    DISPID_ICSsItem = 0, //DISPID_VALUE,
    DISPID_ICSsCount = 1,
    DISPID_ICSsAdd, // = (DISPID_ICSsCount + 1),
    DISPID_ICSsRemove, // = (DISPID_ICSsAdd + 1),
    DISPID_ICSsClear, // = (DISPID_ICSsRemove + 1)
} 	DISPID_InkCustomStrokes;

typedef /* [hidden] */
enum DISPID_StrokeEvent
{
    DISPID_SEStrokesAdded = 1,
    DISPID_SEStrokesRemoved, // = (DISPID_SEStrokesAdded + 1)
} 	DISPID_StrokeEvent;

typedef /* [hidden] */
enum DISPID_Ink
{
    DISPID_IStrokes = 1,
    DISPID_IExtendedProperties, // = (DISPID_IStrokes + 1),
    DISPID_IGetBoundingBox, // = (DISPID_IExtendedProperties + 1),
    DISPID_IDeleteStrokes, // = (DISPID_IGetBoundingBox + 1),
    DISPID_IDeleteStroke, // = (DISPID_IDeleteStrokes + 1),
    DISPID_IExtractStrokes, // = (DISPID_IDeleteStroke + 1),
    DISPID_IExtractWithRectangle, // = (DISPID_IExtractStrokes + 1),
    DISPID_IDirty, // = (DISPID_IExtractWithRectangle + 1),
    DISPID_ICustomStrokes, // = (DISPID_IDirty + 1),
    DISPID_IClone, // = (DISPID_ICustomStrokes + 1),
    DISPID_IHitTestCircle, // = (DISPID_IClone + 1),
    DISPID_IHitTestWithRectangle, // = (DISPID_IHitTestCircle + 1),
    DISPID_IHitTestWithLasso, // = (DISPID_IHitTestWithRectangle + 1),
    DISPID_INearestPoint, // = (DISPID_IHitTestWithLasso + 1),
    DISPID_ICreateStrokes, // = (DISPID_INearestPoint + 1),
    DISPID_ICreateStroke, // = (DISPID_ICreateStrokes + 1),
    DISPID_IAddStrokesAtRectangle, // = (DISPID_ICreateStroke + 1),
    DISPID_IClip, // = (DISPID_IAddStrokesAtRectangle + 1),
    DISPID_ISave, // = (DISPID_IClip + 1),
    DISPID_ILoad, // = (DISPID_ISave + 1),
    DISPID_ICreateStrokeFromPoints, // = (DISPID_ILoad + 1),
    DISPID_IClipboardCopyWithRectangle, // = (DISPID_ICreateStrokeFromPoints + 1),
    DISPID_IClipboardCopy, // = (DISPID_IClipboardCopyWithRectangle + 1),
    DISPID_ICanPaste, // = (DISPID_IClipboardCopy + 1),
    DISPID_IClipboardPaste //= (DISPID_ICanPaste + 1)
} 	DISPID_Ink;

typedef /* [hidden] */
enum DISPID_InkEvent
{
    DISPID_IEInkAdded = 1,
    DISPID_IEInkDeleted //= (DISPID_IEInkAdded + 1)
} 	DISPID_InkEvent;

typedef /* [hidden] */
enum DISPID_InkRenderer
{
    DISPID_IRGetViewTransform = 1,
    DISPID_IRSetViewTransform, // = (DISPID_IRGetViewTransform + 1),
    DISPID_IRGetObjectTransform, // = (DISPID_IRSetViewTransform + 1),
    DISPID_IRSetObjectTransform, // = (DISPID_IRGetObjectTransform + 1),
    DISPID_IRDraw, // = (DISPID_IRSetObjectTransform + 1),
    DISPID_IRDrawStroke, // = (DISPID_IRDraw + 1),
    DISPID_IRPixelToInkSpace, // = (DISPID_IRDrawStroke + 1),
    DISPID_IRInkSpaceToPixel, // = (DISPID_IRPixelToInkSpace + 1),
    DISPID_IRPixelToInkSpaceFromPoints, // = (DISPID_IRInkSpaceToPixel + 1),
    DISPID_IRInkSpaceToPixelFromPoints, // = (DISPID_IRPixelToInkSpaceFromPoints + 1),
    DISPID_IRMeasure, // = (DISPID_IRInkSpaceToPixelFromPoints + 1),
    DISPID_IRMeasureStroke, // = (DISPID_IRMeasure + 1),
    DISPID_IRMove, // = (DISPID_IRMeasureStroke + 1),
    DISPID_IRRotate, // = (DISPID_IRMove + 1),
    DISPID_IRScale, // = (DISPID_IRRotate + 1)
} 	DISPID_InkRenderer;

typedef
enum InkCollectorEventInterest
{
    ICEI_DefaultEvents = -1,
    ICEI_CursorDown, // = (ICEI_DefaultEvents + 1),
    ICEI_Stroke, // = (ICEI_CursorDown + 1),
    ICEI_NewPackets, // = (ICEI_Stroke + 1),
    ICEI_NewInAirPackets, // = (ICEI_NewPackets + 1),
    ICEI_CursorButtonDown, // = (ICEI_NewInAirPackets + 1),
    ICEI_CursorButtonUp, // = (ICEI_CursorButtonDown + 1),
    ICEI_CursorInRange, // = (ICEI_CursorButtonUp + 1),
    ICEI_CursorOutOfRange, // = (ICEI_CursorInRange + 1),
    ICEI_SystemGesture, // = (ICEI_CursorOutOfRange + 1),
    ICEI_TabletAdded, // = (ICEI_SystemGesture + 1),
    ICEI_TabletRemoved, // = (ICEI_TabletAdded + 1),
    ICEI_MouseDown, // = (ICEI_TabletRemoved + 1),
    ICEI_MouseMove, // = (ICEI_MouseDown + 1),
    ICEI_MouseUp, // = (ICEI_MouseMove + 1),
    ICEI_MouseWheel, // = (ICEI_MouseUp + 1),
    ICEI_DblClick, // = (ICEI_MouseWheel + 1),
    ICEI_AllEvents, // = (ICEI_DblClick + 1)
} 	InkCollectorEventInterest;

typedef
enum InkMouseButton
{
    IMF_Left = 1,
    IMF_Right = 2,
    IMF_Middle = 4
} 	InkMouseButton;

typedef
enum InkShiftKeyModifierFlags
{
    IKM_Shift = 0x1,
    IKM_Control = 0x2,
    IKM_Alt = 0x4
} 	InkShiftKeyModifierFlags;

typedef /* [hidden] */
enum DISPID_InkCollectorEvent
{
    DISPID_ICEStroke = 1,
    DISPID_ICECursorDown, // = (DISPID_ICEStroke + 1),
    DISPID_ICENewPackets, // = (DISPID_ICECursorDown + 1),
    DISPID_ICENewInAirPackets, // = (DISPID_ICENewPackets + 1),
    DISPID_ICECursorButtonDown, // = (DISPID_ICENewInAirPackets + 1),
    DISPID_ICECursorButtonUp, // = (DISPID_ICECursorButtonDown + 1),
    DISPID_ICECursorInRange, // = (DISPID_ICECursorButtonUp + 1),
    DISPID_ICECursorOutOfRange, // = (DISPID_ICECursorInRange + 1),
    DISPID_ICESystemGesture, // = (DISPID_ICECursorOutOfRange + 1),
    DISPID_ICEGesture, // = (DISPID_ICESystemGesture + 1),
    DISPID_ICETabletAdded, // = (DISPID_ICEGesture + 1),
    DISPID_ICETabletRemoved, // = (DISPID_ICETabletAdded + 1),
    DISPID_IOEPainting, // = (DISPID_ICETabletRemoved + 1),
    DISPID_IOEPainted, // = (DISPID_IOEPainting + 1),
    DISPID_IOESelectionChanging, // = (DISPID_IOEPainted + 1),
    DISPID_IOESelectionChanged, // = (DISPID_IOESelectionChanging + 1),
    DISPID_IOESelectionMoving, // = (DISPID_IOESelectionChanged + 1),
    DISPID_IOESelectionMoved, // = (DISPID_IOESelectionMoving + 1),
    DISPID_IOESelectionResizing, // = (DISPID_IOESelectionMoved + 1),
    DISPID_IOESelectionResized, // = (DISPID_IOESelectionResizing + 1),
    DISPID_IOEStrokesDeleting, // = (DISPID_IOESelectionResized + 1),
    DISPID_IOEStrokesDeleted, // = (DISPID_IOEStrokesDeleting + 1),
    DISPID_IPEChangeUICues, // = (DISPID_IOEStrokesDeleted + 1),
    DISPID_IPEClick, // = (DISPID_IPEChangeUICues + 1),
    DISPID_IPEDblClick, // = (DISPID_IPEClick + 1),
    DISPID_IPEInvalidated, // = (DISPID_IPEDblClick + 1),
    DISPID_IPEMouseDown, // = (DISPID_IPEInvalidated + 1),
    DISPID_IPEMouseEnter, // = (DISPID_IPEMouseDown + 1),
    DISPID_IPEMouseHover, // = (DISPID_IPEMouseEnter + 1),
    DISPID_IPEMouseLeave, // = (DISPID_IPEMouseHover + 1),
    DISPID_IPEMouseMove, // = (DISPID_IPEMouseLeave + 1),
    DISPID_IPEMouseUp, // = (DISPID_IPEMouseMove + 1),
    DISPID_IPEMouseWheel, // = (DISPID_IPEMouseUp + 1),
    DISPID_IPESizeModeChanged, // = (DISPID_IPEMouseWheel + 1),
    DISPID_IPEStyleChanged, // = (DISPID_IPESizeModeChanged + 1),
    DISPID_IPESystemColorsChanged, // = (DISPID_IPEStyleChanged + 1),
    DISPID_IPEKeyDown, // = (DISPID_IPESystemColorsChanged + 1),
    DISPID_IPEKeyPress, // = (DISPID_IPEKeyDown + 1),
    DISPID_IPEKeyUp, // = (DISPID_IPEKeyPress + 1),
    DISPID_IPEResize, // = (DISPID_IPEKeyUp + 1),
    DISPID_IPESizeChanged, // = (DISPID_IPEResize + 1)
} 	DISPID_InkCollectorEvent;

typedef /* [helpcontext][helpstring] */
enum InkOverlayEditingMode
{
    IOEM_Ink = 0,
    IOEM_Delete = 1,
    IOEM_Select = 2,
    IOEM_Last = 3 //IOEM_Select + 1
} 	InkOverlayEditingMode;

 
typedef /* [helpcontext][helpstring] */
enum InkOverlayAttachMode
{
    IOAM_Behind = 0,
    IOAM_InFront = 1,
    IOAM_Last = 2 //IOAM_InFront + 1
} 	InkOverlayAttachMode;

 
typedef /* [helpcontext][helpstring] */
enum InkPictureSizeMode
{
    IPSM_AutoSize = 0,
    IPSM_CenterImage = 1,
    IPSM_Normal = 2,
    IPSM_StretchImage = 3,
    IPSM_Last = 4 //IPSM_StretchImage + 1
} 	InkPictureSizeMode;
 
typedef /* [helpcontext][helpstring] */
enum InkOverlayEraserMode
{
    IOERM_StrokeErase = 0,
    IOERM_PointErase = 1,
    IOERM_Last = 2 //IOERM_PointErase + 1
} 	InkOverlayEraserMode;

 
typedef
enum InkCollectionMode
{
    ICM_InkOnly = 0,
    ICM_GestureOnly, // = (ICM_InkOnly + 1),
    ICM_InkAndGesture, // = (ICM_GestureOnly + 1)
    ICM_Last = 2 //ICM_InkAndGesture
} 	InkCollectionMode;

 
typedef /* [hidden] */
enum DISPID_InkCollector
{
    DISPID_ICEnabled = 1,
    DISPID_ICHwnd, // = (DISPID_ICEnabled + 1),
    DISPID_ICPaint, // = (DISPID_ICHwnd + 1),
    DISPID_ICText, // = (DISPID_ICPaint + 1),
    DISPID_ICDefaultDrawingAttributes, // = (DISPID_ICText + 1),
    DISPID_ICRenderer, // = (DISPID_ICDefaultDrawingAttributes + 1),
    DISPID_ICInk, // = (DISPID_ICRenderer + 1),
    DISPID_ICAutoRedraw, // = (DISPID_ICInk + 1),
    DISPID_ICCollectingInk, // = (DISPID_ICAutoRedraw + 1),
    DISPID_ICSetEventInterest, // = (DISPID_ICCollectingInk + 1),
    DISPID_ICGetEventInterest, // = (DISPID_ICSetEventInterest + 1),
    DISPID_IOEditingMode, // = (DISPID_ICGetEventInterest + 1),
    DISPID_IOSelection, // = (DISPID_IOEditingMode + 1),
    DISPID_IOAttachMode, // = (DISPID_IOSelection + 1),
    DISPID_IOHitTestSelection, // = (DISPID_IOAttachMode + 1),
    DISPID_IODraw, // = (DISPID_IOHitTestSelection + 1),
    DISPID_IPPicture, // = (DISPID_IODraw + 1),
    DISPID_IPSizeMode, // = (DISPID_IPPicture + 1),
    DISPID_IPBackColor, // = (DISPID_IPSizeMode + 1),
    DISPID_ICCursors, // = (DISPID_IPBackColor + 1),
    DISPID_ICMarginX, // = (DISPID_ICCursors + 1),
    DISPID_ICMarginY, // = (DISPID_ICMarginX + 1),
    DISPID_ICSetWindowInputRectangle, // = (DISPID_ICMarginY + 1),
    DISPID_ICGetWindowInputRectangle, // = (DISPID_ICSetWindowInputRectangle + 1),
    DISPID_ICTablet, // = (DISPID_ICGetWindowInputRectangle + 1),
    DISPID_ICSetAllTabletsMode, // = (DISPID_ICTablet + 1),
    DISPID_ICSetSingleTabletIntegratedMode, // = (DISPID_ICSetAllTabletsMode + 1),
    DISPID_ICCollectionMode, // = (DISPID_ICSetSingleTabletIntegratedMode + 1),
    DISPID_ICSetGestureStatus, // = (DISPID_ICCollectionMode + 1),
    DISPID_ICGetGestureStatus, // = (DISPID_ICSetGestureStatus + 1),
    DISPID_ICDynamicRendering, // = (DISPID_ICGetGestureStatus + 1),
    DISPID_ICDesiredPacketDescription, // = (DISPID_ICDynamicRendering + 1),
    DISPID_IOEraserMode, // = (DISPID_ICDesiredPacketDescription + 1),
    DISPID_IOEraserWidth, // = (DISPID_IOEraserMode + 1),
    DISPID_ICMouseIcon, // = (DISPID_IOEraserWidth + 1),
    DISPID_ICMousePointer, // = (DISPID_ICMouseIcon + 1),
    DISPID_IPInkEnabled, // = (DISPID_ICMousePointer + 1),
    DISPID_ICSupportHighContrastInk, // = (DISPID_IPInkEnabled + 1),
    DISPID_IOSupportHighContrastSelectionUI, // = (DISPID_ICSupportHighContrastInk + 1)
} 	DISPID_InkCollector;

typedef /* [hidden] */
enum DISPID_InkRecognizer
{
    DISPID_RecoClsid = 1,
    DISPID_RecoName, // = (DISPID_RecoClsid + 1),
    DISPID_RecoVendor, // = (DISPID_RecoName + 1),
    DISPID_RecoCapabilities, // = (DISPID_RecoVendor + 1),
    DISPID_RecoLanguageID, // = (DISPID_RecoCapabilities + 1),
    DISPID_RecoPreferredPacketDescription, // = (DISPID_RecoLanguageID + 1),
    DISPID_RecoCreateRecognizerContext, // = (DISPID_RecoPreferredPacketDescription + 1),
    DISPID_RecoSupportedProperties, // = (DISPID_RecoCreateRecognizerContext + 1)
} 	DISPID_InkRecognizer;

typedef
enum InkRecognizerCapabilities
{
    IRC_DontCare = 1,
    IRC_Object = 2,
    IRC_FreeInput = 4,
    IRC_LinedInput = 8,
    IRC_BoxedInput = 16,
    IRC_CharacterAutoCompletionInput = 32,
    IRC_RightAndDown = 64,
    IRC_LeftAndDown = 128,
    IRC_DownAndLeft = 256,
    IRC_DownAndRight = 512,
    IRC_ArbitraryAngle = 1024,
    IRC_Lattice = 2048,
    IRC_AdviseInkChange = 4096,
    IRC_StrokeReorder = 8192,
    IRC_Personalizable = 16384,
    IRC_PrefersArbitraryAngle = 32768,
    IRC_PrefersParagraphBreaking = 65536,
    IRC_PrefersSegmentation = 131072,
    IRC_Cursive = 262144,
    IRC_TextPrediction = 524288,
    IRC_Alpha = 1048576,
    IRC_Beta = 2097152
} 	InkRecognizerCapabilities;

typedef /* [hidden] */
enum DISPID_InkRecognizer2
{
    DISPID_RecoId = 0, //DISPID_VALUE,
    DISPID_RecoUnicodeRanges = 1
} 	DISPID_InkRecognizer2;

typedef /* [hidden] */
enum DISPID_InkRecognizers
{
    DISPID_IRecos_NewEnum = (-4), //DISPID_NEWENUM,
    DISPID_IRecosItem = 0, //DISPID_VALUE,
    DISPID_IRecosCount = 1,
    DISPID_IRecosGetDefaultRecognizer //= (DISPID_IRecosCount + 1)
} 	DISPID_InkRecognizers;

typedef
enum InkRecognizerCharacterAutoCompletionMode
{
    IRCACM_Full = 0,
    IRCACM_Prefix = 1,// (IRCACM_Full + 1),
    IRCACM_Random = 2 //(IRCACM_Prefix + 1)
} 	InkRecognizerCharacterAutoCompletionMode;

typedef
enum InkRecognitionModes
{
    IRM_None = 0,
    IRM_WordModeOnly = 0x1,
    IRM_Coerce = 0x2,
    IRM_TopInkBreaksOnly = 0x4,
    IRM_PrefixOk = 0x8,
    IRM_LineMode = 0x10,
    IRM_DisablePersonalization = 0x20,
    IRM_AutoSpace = 0x40,
    IRM_Max = 0x80
} 	InkRecognitionModes;

typedef /* [hidden] */
enum DISPID_InkRecognitionEvent
{
    DISPID_IRERecognitionWithAlternates = 1,
    DISPID_IRERecognition, // = (DISPID_IRERecognitionWithAlternates + 1)
} 	DISPID_InkRecognitionEvent;

typedef /* [hidden] */
enum DISPID_InkRecoContext
{
    DISPID_IRecoCtx_Strokes = 1,
    DISPID_IRecoCtx_CharacterAutoCompletionMode, // = (DISPID_IRecoCtx_Strokes + 1),
    DISPID_IRecoCtx_Factoid, // = (DISPID_IRecoCtx_CharacterAutoCompletionMode + 1),
    DISPID_IRecoCtx_WordList, // = (DISPID_IRecoCtx_Factoid + 1),
    DISPID_IRecoCtx_Recognizer, // = (DISPID_IRecoCtx_WordList + 1),
    DISPID_IRecoCtx_Guide, // = (DISPID_IRecoCtx_Recognizer + 1),
    DISPID_IRecoCtx_Flags, // = (DISPID_IRecoCtx_Guide + 1),
    DISPID_IRecoCtx_PrefixText, // = (DISPID_IRecoCtx_Flags + 1),
    DISPID_IRecoCtx_SuffixText, // = (DISPID_IRecoCtx_PrefixText + 1),
    DISPID_IRecoCtx_StopRecognition, // = (DISPID_IRecoCtx_SuffixText + 1),
    DISPID_IRecoCtx_Clone, // = (DISPID_IRecoCtx_StopRecognition + 1),
    DISPID_IRecoCtx_Recognize, // = (DISPID_IRecoCtx_Clone + 1),
    DISPID_IRecoCtx_StopBackgroundRecognition, // = (DISPID_IRecoCtx_Recognize + 1),
    DISPID_IRecoCtx_EndInkInput, // = (DISPID_IRecoCtx_StopBackgroundRecognition + 1),
    DISPID_IRecoCtx_BackgroundRecognize, // = (DISPID_IRecoCtx_EndInkInput + 1),
    DISPID_IRecoCtx_BackgroundRecognizeWithAlternates, // = (DISPID_IRecoCtx_BackgroundRecognize + 1),
    DISPID_IRecoCtx_IsStringSupported, // = (DISPID_IRecoCtx_BackgroundRecognizeWithAlternates + 1)
} 	DISPID_InkRecoContext;

typedef /* [hidden] */
enum DISPID_InkRecoContext2
{
    DISPID_IRecoCtx2_EnabledUnicodeRanges = 0 //DISPID_VALUE
} 	DISPID_InkRecoContext2;

typedef /* [helpcontext][helpstring] */
enum InkRecognitionAlternatesSelection
{
    IRAS_Start = 0,
    IRAS_DefaultCount = 10,
    IRAS_All = -1
} 	InkRecognitionAlternatesSelection;

typedef /* [hidden] */
enum DISPID_InkRecognitionResult
{
    DISPID_InkRecognitionResult_TopString = 1,
    DISPID_InkRecognitionResult_TopAlternate, // = (DISPID_InkRecognitionResult_TopString + 1),
    DISPID_InkRecognitionResult_Strokes, // = (DISPID_InkRecognitionResult_TopAlternate + 1),
    DISPID_InkRecognitionResult_TopConfidence, // = (DISPID_InkRecognitionResult_Strokes + 1),
    DISPID_InkRecognitionResult_AlternatesFromSelection, // = (DISPID_InkRecognitionResult_TopConfidence + 1),
    DISPID_InkRecognitionResult_ModifyTopAlternate, // = (DISPID_InkRecognitionResult_AlternatesFromSelection + 1),
    DISPID_InkRecognitionResult_SetResultOnStrokes, // = (DISPID_InkRecognitionResult_ModifyTopAlternate + 1)
} 	DISPID_InkRecognitionResult;

typedef /* [hidden] */
enum DISPID_InkRecoAlternate
{
    DISPID_InkRecoAlternate_String = 1,
    DISPID_InkRecoAlternate_LineNumber, // = (DISPID_InkRecoAlternate_String + 1),
    DISPID_InkRecoAlternate_Baseline, // = (DISPID_InkRecoAlternate_LineNumber + 1),
    DISPID_InkRecoAlternate_Midline, // = (DISPID_InkRecoAlternate_Baseline + 1),
    DISPID_InkRecoAlternate_Ascender, // = (DISPID_InkRecoAlternate_Midline + 1),
    DISPID_InkRecoAlternate_Descender, // = (DISPID_InkRecoAlternate_Ascender + 1),
    DISPID_InkRecoAlternate_Confidence, // = (DISPID_InkRecoAlternate_Descender + 1),
    DISPID_InkRecoAlternate_Strokes, // = (DISPID_InkRecoAlternate_Confidence + 1),
    DISPID_InkRecoAlternate_GetStrokesFromStrokeRanges, // = (DISPID_InkRecoAlternate_Strokes + 1),
    DISPID_InkRecoAlternate_GetStrokesFromTextRange, // = (DISPID_InkRecoAlternate_GetStrokesFromStrokeRanges + 1),
    DISPID_InkRecoAlternate_GetTextRangeFromStrokes, // = (DISPID_InkRecoAlternate_GetStrokesFromTextRange + 1),
    DISPID_InkRecoAlternate_GetPropertyValue, // = (DISPID_InkRecoAlternate_GetTextRangeFromStrokes + 1),
    DISPID_InkRecoAlternate_LineAlternates, // = (DISPID_InkRecoAlternate_GetPropertyValue + 1),
    DISPID_InkRecoAlternate_ConfidenceAlternates, // = (DISPID_InkRecoAlternate_LineAlternates + 1),
    DISPID_InkRecoAlternate_AlternatesWithConstantPropertyValues, // = (DISPID_InkRecoAlternate_ConfidenceAlternates + 1)
} 	DISPID_InkRecoAlternate;

typedef /* [hidden] */
enum DISPID_InkRecognitionAlternates
{
    DISPID_InkRecognitionAlternates_NewEnum = (-4), //DISPID_NEWENUM,
    DISPID_InkRecognitionAlternates_Item = 0, //DISPID_VALUE,
    DISPID_InkRecognitionAlternates_Count = 1,
    DISPID_InkRecognitionAlternates_Strokes = 2 //(DISPID_InkRecognitionAlternates_Count + 1)
} 	DISPID_InkRecognitionAlternates;

typedef /* [hidden] */ struct InkRecoGuide
{
    RECT rectWritingBox;
    RECT rectDrawnBox;
    long cRows;
    long cColumns;
    long midline;
} 	InkRecoGuide;

typedef /* [hidden] */
enum DISPID_InkRecognizerGuide
{
    DISPID_IRGWritingBox = 1,
    DISPID_IRGDrawnBox, // = (DISPID_IRGWritingBox + 1),
    DISPID_IRGRows, // = (DISPID_IRGDrawnBox + 1),
    DISPID_IRGColumns, // = (DISPID_IRGRows + 1),
    DISPID_IRGMidline, // = (DISPID_IRGColumns + 1),
    DISPID_IRGGuideData, // = (DISPID_IRGMidline + 1)
} 	DISPID_InkRecognizerGuide;

typedef /* [hidden] */
enum DISPID_InkWordList
{
    DISPID_InkWordList_AddWord = 0,
    DISPID_InkWordList_RemoveWord, // = (DISPID_InkWordList_AddWord + 1),
    DISPID_InkWordList_Merge, // = (DISPID_InkWordList_RemoveWord + 1)
} 	DISPID_InkWordList;

typedef /* [hidden] */
enum DISPID_InkWordList2
{
    DISPID_InkWordList2_AddWords, // = (DISPID_InkWordList_Merge + 1)
} 	DISPID_InkWordList2;

//const LONG InkMinTransparencyValue = 0;
//
//const LONG InkMaxTransparencyValue = 255;
//
//const LONG InkCollectorClipInkToMargin = 0;
//
//const LONG InkCollectorDefaultMargin = (-2147483647L - 1);



[
    odl,
        uuid(9794FF82-6071-4717-8A8B-6AC7C64A686E),
        helpstring("IInkRectangle Interface"),
        helpcontext(0x00000066),
        dual,
        oleautomation
]
interface IInkRectangle : IDispatch
{
    [id(0x00000001), propget, helpstring("Represents access to a rectangle for Automation users."), helpcontext(0x00000067)]
        HRESULT Top([out, retval] long* Units);
    [id(0x00000001), propput, helpstring("Represents access to a rectangle for Automation users."), helpcontext(0x00000067)]
        HRESULT Top([in] long Units);
    [id(0x00000002), propget, helpstring("Returns or sets the left position of the InkRectangle object."), helpcontext(0x00000068)]
        HRESULT Left([out, retval] long* Units);
    [id(0x00000002), propput, helpstring("Returns or sets the left position of the InkRectangle object."), helpcontext(0x00000068)]
        HRESULT Left([in] long Units);
    [id(0x00000003), propget, helpstring("Returns or sets the bottom position of the InkRectangle object."), helpcontext(0x00000069)]
        HRESULT Bottom([out, retval] long* Units);
    [id(0x00000003), propput, helpstring("Returns or sets the bottom position of the InkRectangle object."), helpcontext(0x00000069)]
        HRESULT Bottom([in] long Units);
    [id(0x00000004), propget, helpstring("Returns or sets the right position of the InkRectangle object."), helpcontext(0x0000006a)]
        HRESULT Right([out, retval] long* Units);
    [id(0x00000004), propput, helpstring("Returns or sets the right position of the InkRectangle object."), helpcontext(0x0000006a)]
        HRESULT Right([in] long Units);
    [id(0x00000007), propget, hidden, helpstring("Returns or sets access to the rectangle struct."), helpcontext(0x0000006b)]
        HRESULT Data([out, retval] RECT* Rect);
    [id(0x00000007), propput, hidden, helpstring("Returns or sets access to the rectangle struct."), helpcontext(0x0000006b)]
        HRESULT Data([in] RECT Rect);
    [id(0x00000005), helpstring("Specifies (returns) the elements of the InkRectangle object in a single call."), helpcontext(0x0000006c)]
        HRESULT GetRectangle(
            [out] long* Top,
            [out] long* Left,
            [out] long* Bottom,
            [out] long* Right);
    [id(0x00000006), helpstring("Specifies (sets) the elements of the InkRectangle object in a single call."), helpcontext(0x0000006d)]
        HRESULT SetRectangle(
            [in] long Top,
            [in] long Left,
            [in] long Bottom,
            [in] long Right);

};

[
    odl,
        uuid(DB489209-B7C3-411D-90F6-1548CFFF271E),
        helpstring("IInkExtendedProperty Interface"),
        helpcontext(0x0000006e),
        dual,
        oleautomation
]
interface IInkExtendedProperty : IDispatch 
{
    [id(0x00000001), propget, helpstring("Represents the ability to add your own data to a variety of objects within the Tablet PC object model."), helpcontext(0x0000006f)]
        HRESULT Guid([out, retval] BSTR* Guid);
    [id(0x00000002), propget, helpstring("Property's data"), helpcontext(0x00000070)]
        HRESULT Data([out, retval] VARIANT* Data);
    [id(0x00000002), propput, helpstring("Property's data"), helpcontext(0x00000070)]
        HRESULT Data([in] VARIANT Data);
};


[
    odl,
        uuid(89F2A8BE-95A9-4530-8B8F-88E971E3E25F),
        helpstring("IInkExtendedProperties Interface"),
        helpcontext(0x00000071),
        dual,
        oleautomation
]
interface IInkExtendedProperties : IDispatch 
{
    [id(0x00000001), propget, helpstring("Contains the ExtendedProperty objects that represent application-defined data that is stored with a stroke."), helpcontext(0x00000072)]
        HRESULT Count([out, retval] long* Count);
    [id(0xfffffffc), propget, restricted, helpstring("Enumerate next item in Properties"), helpcontext(0x00000073)]
        HRESULT _NewEnum([out, retval] IUnknown** _NewEnum);
    [id(00000000), helpstring("Specifies the object or collection to return at the given index in a collection."), helpcontext(0x00000074)]
        HRESULT Item(
            [in] VARIANT Identifier,
            [out, retval] IInkExtendedProperty** Item);
    [id(0x00000002), helpstring("Specifies the extended property to add to the collection of extended properties."), helpcontext(0x00000075)]
        HRESULT Add(
            [in] BSTR Guid,
            [in] VARIANT Data,
            [out, retval] IInkExtendedProperty** InkExtendedProperty);
    [id(0x00000003), helpstring("Specifies the extended property to remove from the collection."), helpcontext(0x00000076)]
        HRESULT Remove([in] VARIANT Identifier);
    [id(0x00000004), helpstring("Specifies the extended properties to clear from the collection."), helpcontext(0x00000077)]
        HRESULT Clear();
    [id(0x00000005), helpstring("Specifies whether an extended property exists within a collection of extended properties."), helpcontext(0x00000078)]
        HRESULT DoesPropertyExist(
            [in] BSTR Guid,
            [out, retval] VARIANT_BOOL* DoesPropertyExist);
};

[
    odl,
        uuid(BF519B75-0A15-4623-ADC9-C00D436A8092),
        helpstring("IInkDrawingAttributes Interface"),
        helpcontext(0x00000079),
        dual,
        oleautomation
]
interface IInkDrawingAttributes : IDispatch 
{
    [id(0x00000002), propget, helpstring("Represents the objects that are applied to ink when it is drawn."), helpcontext(0x0000007a)]
        HRESULT Color([out, retval] long* CurrentColor);
    [id(0x00000002), propput, helpstring("Represents the objects that are applied to ink when it is drawn."), helpcontext(0x0000007a)]
        HRESULT Color([in] long CurrentColor);
    [id(0x00000003), propget, helpstring("Returns or sets the width of the pen when drawing ink with this DrawingAttributes object."), helpcontext(0x0000007b)]
        HRESULT Width([out, retval] single* CurrentWidth);
    [id(0x00000003), propput, helpstring("Returns or sets the width of the pen when drawing ink with this DrawingAttributes object."), helpcontext(0x0000007b)]
        HRESULT Width([in] single CurrentWidth);
    [id(0x00000001), propget, helpstring("Returns or sets the height of the pen when drawing ink with this DrawingAttributes object."), helpcontext(0x0000007c)]
        HRESULT Height([out, retval] single* CurrentHeight);
    [id(0x00000001), propput, helpstring("Returns or sets the height of the pen when drawing ink with this DrawingAttributes object."), helpcontext(0x0000007c)]
        HRESULT Height([in] single CurrentHeight);
    [id(0x00000004), propget, helpstring("Returns or sets the value that specifies whether Bezier smoothing is used to render ink; this means that ink will be rendered as a series of curves instead of as lines between pen sample points."), helpcontext(0x0000007d)]
        HRESULT FitToCurve([out, retval] VARIANT_BOOL* Flag);
    [id(0x00000004), propput, helpstring("Returns or sets the value that specifies whether Bezier smoothing is used to render ink; this means that ink will be rendered as a series of curves instead of as lines between pen sample points."), helpcontext(0x0000007d)]
        HRESULT FitToCurve([in] VARIANT_BOOL Flag);
    [id(0x00000005), propget, helpstring("Returns or sets the value that specifies whether drawn ink will automatically get wider with increased pressure of the pen tip on the tablet surface."), helpcontext(0x0000007e)]
        HRESULT IgnorePressure([out, retval] VARIANT_BOOL* Flag);
    [id(0x00000005), propput, helpstring("Returns or sets the value that specifies whether drawn ink will automatically get wider with increased pressure of the pen tip on the tablet surface."), helpcontext(0x0000007e)]
        HRESULT IgnorePressure([in] VARIANT_BOOL Flag);
    [id(0x00000006), propget, helpstring("Returns or sets the value that specifies whether the foreground and background colors along the edge of the ink are blended to increase the smoothness of an ink stroke."), helpcontext(0x0000007f)]
        HRESULT AntiAliased([out, retval] VARIANT_BOOL* Flag);
    [id(0x00000006), propput, helpstring("Returns or sets the value that specifies whether the foreground and background colors along the edge of the ink are blended to increase the smoothness of an ink stroke."), helpcontext(0x0000007f)]
        HRESULT AntiAliased([in] VARIANT_BOOL Flag);
    [id(0x00000007), propget, helpstring("Returns or sets the transparency value of drawn ink."), helpcontext(0x00000080)]
        HRESULT Transparency([out, retval] long* CurrentTransparency);
    [id(0x00000007), propput, helpstring("Returns or sets the transparency value of drawn ink."), helpcontext(0x00000080)]
        HRESULT Transparency([in] long CurrentTransparency);
    [id(0x00000008), propget, helpstring("Returns or sets how the pen color interacts with the existing background colors on the display when ink is drawn."), helpcontext(0x00000081)]
        HRESULT RasterOperation([out, retval] InkRasterOperation* CurrentRasterOperation);
    [id(0x00000008), propput, helpstring("Returns or sets how the pen color interacts with the existing background colors on the display when ink is drawn."), helpcontext(0x00000081)]
        HRESULT RasterOperation([in] InkRasterOperation CurrentRasterOperation);
    [id(0x00000009), propget, helpstring("Returns or sets the pen tip to use, ball or rectangle, when drawing ink with this DrawingAttributes object."), helpcontext(0x00000082)]
        HRESULT PenTip([out, retval] InkPenTip* CurrentPenTip);
    [id(0x00000009), propput, helpstring("Returns or sets the pen tip to use, ball or rectangle, when drawing ink with this DrawingAttributes object."), helpcontext(0x00000082)]
        HRESULT PenTip([in] InkPenTip CurrentPenTip);
    [id(0x0000000b), propget, helpstring("Returns the collection of application-defined data stored in an object."), helpcontext(0x00000083)]
        HRESULT ExtendedProperties([out, retval] IInkExtendedProperties** Properties);
    [id(0x0000000a), helpstring("Specifies the creation of a duplicate object."), helpcontext(0x00000084)]
        HRESULT Clone([out, retval] IInkDrawingAttributes** DrawingAttributes);
};

[
    odl,
        uuid(615F1D43-8703-4565-88E2-8201D2ECD7B7),
        helpstring("IInkTransform Interface"),
        helpcontext(0x00000085),
        dual,
        oleautomation
]
interface IInkTransform : IDispatch 
{
    [id(0x00000001), helpstring("Represents a 3x3 matrix that, in turn, represents an affine transformation."), helpcontext(0x00000086)]
        HRESULT Reset();
    [id(0x00000002), helpstring("Specifies the translation to apply to the view transform."), helpcontext(0x00000087)]
        HRESULT Translate(
            [in] single HorizontalComponent,
            [in] single VerticalComponent);
    [id(0x00000003), helpstring("Specifies the amount, measured in degrees, to rotate the ink in the view transform around the specified point, or if no point is specified, the origin."), helpcontext(0x00000088)]
        HRESULT Rotate(
            [in] single Degrees,
            [in, defaultvalue(0)] single x,
            [in, defaultvalue(0)] single y);
    [id(0x00000004), helpstring("Specifies reflection in either horizontal or vertical directions."), helpcontext(0x00000089)]
        HRESULT Reflect(
            [in] VARIANT_BOOL Horizontally,
            [in] VARIANT_BOOL Vertically);
    [id(0x00000005), helpstring("Shears the stroke or strokes by the specified horizontal and vertical factors."), helpcontext(0x0000008a)]
        HRESULT Shear(
            [in] single HorizontalComponent,
            [in] single VerticalComponent);
    [id(0x00000006), helpstring("Specifies the X and Y factors to scale the transform."), helpcontext(0x0000008b)]
        HRESULT ScaleTransform(
            [in] single HorizontalMultiplier,
            [in] single VerticalMultiplier);
    [id(0x0000000d), helpstring("Gets the InkTransform member data."), helpcontext(0x0000008c)]
        HRESULT GetTransform(
            [out] single* eM11,
            [out] single* eM12,
            [out] single* eM21,
            [out] single* eM22,
            [out] single* eDx,
            [out] single* eDy);
    [id(0x0000000e), helpstring("Sets the InkTransform member data."), helpcontext(0x0000008d)]
        HRESULT SetTransform(
            [in] single eM11,
            [in] single eM12,
            [in] single eM21,
            [in] single eM22,
            [in] single eDx,
            [in] single eDy);
    [id(0x00000007), propget, hidden, helpstring("Returns or sets the element in the first row, first column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x0000008e)]
        HRESULT eM11([out, retval] single* Value);
    [id(0x00000007), propput, hidden, helpstring("Returns or sets the element in the first row, first column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x0000008e)]
        HRESULT eM11([in] single Value);
    [id(0x00000008), propget, hidden, helpstring("Returns or sets the element in the first row, second column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x0000008f)]
        HRESULT eM12([out, retval] single* Value);
    [id(0x00000008), propput, hidden, helpstring("Returns or sets the element in the first row, second column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x0000008f)]
        HRESULT eM12([in] single Value);
    [id(0x00000009), propget, hidden, helpstring("Returns or sets the element in the second row, first column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x00000090)]
        HRESULT eM21([out, retval] single* Value);
    [id(0x00000009), propput, hidden, helpstring("Returns or sets the element in the second row, first column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x00000090)]
        HRESULT eM21([in] single Value);
    [id(0x0000000a), propget, hidden, helpstring("Returns or sets the element in the second row, second column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x00000091)]
        HRESULT eM22([out, retval] single* Value);
    [id(0x0000000a), propput, hidden, helpstring("Returns or sets the element in the second row, second column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x00000091)]
        HRESULT eM22([in] single Value);
    [id(0x0000000b), propget, hidden, helpstring("Returns or sets the element in the third row, first column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x00000092)]
        HRESULT eDx([out, retval] single* Value);
    [id(0x0000000b), propput, hidden, helpstring("Returns or sets the element in the third row, first column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x00000092)]
        HRESULT eDx([in] single Value);
    [id(0x0000000c), propget, hidden, helpstring("Returns or sets the element in the third row, second column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x00000093)]
        HRESULT eDy([out, retval] single* Value);
    [id(0x0000000c), propput, hidden, helpstring("Returns or sets the element in the third row, second column of the affine transform matrix represented by an InkTransform object."), helpcontext(0x00000093)]
        HRESULT eDy([in] single Value);
    [id(0x0000000f), propget, hidden, helpstring("Returns or sets access to the XFORM struct (C++ only)."), helpcontext(0x00000094)]
        HRESULT Data([out, retval] XFORM* XFORM);
    [id(0x0000000f), propput, hidden, helpstring("Returns or sets access to the XFORM struct (C++ only)."), helpcontext(0x00000094)]
        HRESULT Data([in] XFORM XFORM);
};


[
    odl,
        uuid(3BDC0A97-04E5-4E26-B813-18F052D41DEF),
        helpstring("IInkGesture Interface"),
        helpcontext(0x00000095),
        dual,
        oleautomation
]
interface IInkGesture : IDispatch 
{
    [id(0x00000002), propget, helpstring("Represents the ability to query particular properties of a gesture returned from a gesture recognition."), helpcontext(0x00000096)]
        HRESULT Confidence([out, retval] InkRecognitionConfidence* Confidence);
    [id(00000000), propget, helpstring("Returns the identifier of an object."), helpcontext(0x00000097)]
        HRESULT Id([out, retval] InkApplicationGesture* Id);
    [id(0x00000001), helpstring("GetHotPoint property"), helpcontext(0x00000098)]
        HRESULT GetHotPoint(
            [in, out] long* x,
            [in, out] long* y);
};


[
    odl,
        uuid(AD30C630-40C5-4350-8405-9C71012FC558),
        helpstring("IInkCursor Interface"),
        helpcontext(0x00000099),
        dual,
        oleautomation
]
interface IInkCursor : IDispatch 
{
    [id(00000000), propget, helpstring("Represents general information about the tablet cursor."), helpcontext(0x0000009a)]
        HRESULT Name([out, retval] BSTR* Name);
    [id(0x00000001), propget, helpstring("Returns the identifier of an object."), helpcontext(0x0000009b)]
        HRESULT Id([out, retval] long* Id);
    [id(0x00000004), propget, helpstring("Returns the value that specifies whether the cursor is the inverted end of the pen."), helpcontext(0x0000009c)]
        HRESULT Inverted([out, retval] VARIANT_BOOL* Status);
    [id(0x00000002), propget, helpstring("Returns or sets the drawing attributes to apply to ink as it is drawn."), helpcontext(0x0000009d)]
        HRESULT DrawingAttributes([out, retval] IInkDrawingAttributes** Attributes);
    [id(0x00000002), propputref, helpstring("Returns or sets the drawing attributes to apply to ink as it is drawn."), helpcontext(0x0000009d)]
        HRESULT DrawingAttributes([in] IInkDrawingAttributes* Attributes);
    [id(0x00000005), propget, helpstring("Returns the tablet device to which a cursor belongs, or that an InkCollector object is currently using to collect cursor input."), helpcontext(0x0000009e)]
        HRESULT Tablet([out, retval] IInkTablet** Tablet);
    [id(0x00000003), propget, helpstring("Returns the collection of cursor buttons that are available on a given cursor."), helpcontext(0x0000009f)]
        HRESULT Buttons([out, retval] IInkCursorButtons** Buttons);
};

[
    odl,
        uuid(A248C1AC-C698-4E06-9E5C-D57F77C7E647),
        helpstring("IInkCursors Interface"),
        helpcontext(0x000000a0),
        dual,
        oleautomation
]
interface IInkCursors : IDispatch 
{
    [id(0x00000001), propget, helpstring("Contains the Cursor objects that represent general information about a tablet cursor."), helpcontext(0x000000a1)]
        HRESULT Count([out, retval] long* Count);
    [id(0xfffffffc), propget, restricted, helpstring("Enumerate next item in Cursors"), helpcontext(0x000000a2)]
        HRESULT _NewEnum([out, retval] IUnknown** _NewEnum);
    [id(00000000), helpstring("Specifies the object or collection to return at the given index in a collection."), helpcontext(0x000000a3)]
        HRESULT Item(
            [in] long Index,
            [out, retval] IInkCursor** Cursor);
};


[
    odl,
        uuid(85EF9417-1D59-49B2-A13C-702C85430894),
        helpstring("IInkCursorButton Interface"),
        helpcontext(0x000000a4),
        dual,
        oleautomation
]
interface IInkCursorButton : IDispatch 
{
    [id(00000000), propget, helpstring("Represents general information about a cursor button, such as the globally unique identifier (GUID) that uniquely identifies the button."), helpcontext(0x000000a5)]
        HRESULT Name([out, retval] BSTR* Name);
    [id(0x00000001), propget, helpstring("Returns the identifier of an object."), helpcontext(0x000000a6)]
        HRESULT Id([out, retval] BSTR* Id);
    [id(0x00000002), propget, helpstring("Returns the state of a cursor button, such as whether the button is unavailable, up, or down."), helpcontext(0x000000a7)]
        HRESULT State([out, retval] InkCursorButtonState* CurrentState);
};

[
    odl,
        uuid(3671CC40-B624-4671-9FA0-DB119D952D54),
        helpstring("IInkCursorButtons Interface"),
        helpcontext(0x000000a8),
        dual,
        oleautomation
]
interface IInkCursorButtons : IDispatch 
{
    [id(0x00000001), propget, helpstring("Contains a collection of CursorButton objects that represent the buttons on a given cursor."), helpcontext(0x000000a9)]
        HRESULT Count([out, retval] long* Count);
    [id(0xfffffffc), propget, restricted, helpstring("Enumerate next item in Buttons"), helpcontext(0x000000aa)]
        HRESULT _NewEnum([out, retval] IUnknown** _NewEnum);
    [id(00000000), helpstring("Specifies the object or collection to return at the given index in a collection."), helpcontext(0x000000ab)]
        HRESULT Item(
            [in] VARIANT Identifier,
            [out, retval] IInkCursorButton** Button);
};

[
    odl,
        uuid(2DE25EAA-6EF8-42D5-AEE9-185BC81B912D),
        helpstring("IInkTablet Interface"),
        helpcontext(0x000000ac),
        dual,
        oleautomation
]
interface IInkTablet : IDispatch 
{
    [id(00000000), propget, helpstring("Represents the digitizer device of the Tablet PC that receives tablet device messages or events."), helpcontext(0x000000ad)]
        HRESULT Name([out, retval] BSTR* Name);
    [id(0x00000001), propget, helpstring("Returns the plug-and-play identifier of the tablet."), helpcontext(0x000000ae)]
        HRESULT PlugAndPlayId([out, retval] BSTR* Id);
    [id(0x00000004), propget, helpstring("Returns the maximum input rectangle, in tablet device coordinates, that the tablet supports."), helpcontext(0x000000af)]
        HRESULT MaximumInputRectangle([out, retval] IInkRectangle** Rectangle);
    [id(0x00000005), propget, helpstring("Returns a bit mask that defines the hardware capabilities of the tablet, such as whether a cursor must be in physical contact with the tablet to report its position."), helpcontext(0x000000b0)]
        HRESULT HardwareCapabilities([out, retval] TabletHardwareCapabilities* Capabilities);
    [id(0x00000003), helpstring("Specifies whether a property of a tablet device or a collection of tablet devices, identified with a globally unique identifier (GUID), is supported."), helpcontext(0x000000b1)]
        HRESULT IsPacketPropertySupported(
            [in] BSTR packetPropertyName,
            [out, retval] VARIANT_BOOL* Supported);
    [id(0x00000002), helpstring("Specifies the metrics data for a given property."), helpcontext(0x000000b2)]
        HRESULT GetPropertyMetrics(
            [in] BSTR propertyName,
            [out] long* Minimum,
            [out] long* Maximum,
            [out] TabletPropertyMetricUnit* Units,
            [out] single* Resolution);
};

[
    odl,
        uuid(90C91AD2-FA36-49D6-9516-CE8D570F6F85),
        helpstring("IInkTablet2 Interface"),
        helpcontext(0x000001f0),
        dual,
        oleautomation
]
interface IInkTablet2 : IDispatch 
{
    [id(00000000), propget, helpstring("Represents the digitizer device kind of the tablet."), helpcontext(0x000001f1)]
        HRESULT DeviceKind([out, retval] TabletDeviceKind* Kind);
};

[
    odl,
        uuid(7E313997-1327-41DD-8CA9-79F24BE17250),
        helpstring("IInkTablet3 Interface"),
        helpcontext(0x000001f7),
        dual,
        oleautomation
]
interface IInkTablet3 : IDispatch 
{
    [id(00000000), propget, helpstring("Represents whether multi-touch is available."), helpcontext(0x000001f8)]
        HRESULT IsMultiTouch([out, retval] VARIANT_BOOL* pIsMultiTouch);
    [id(0x00000001), propget, helpstring("Returns maximum number of simultaneously active cursors."), helpcontext(0x000001f9)]
        HRESULT MaximumCursors([out, retval] long* pMaximumCursors);
};

[
    odl,
        uuid(112086D9-7779-4535-A699-862B43AC1863),
        helpstring("IInkTablets Interface"),
        helpcontext(0x000000b3),
        dual,
        oleautomation
]
interface IInkTablets : IDispatch 
{
    [id(0x00000002), propget, helpstring("Contains the Tablet objects that represent the hardware-specific properties of all tablets attached to the system."), helpcontext(0x000000b4)]
        HRESULT Count([out, retval] long* Count);
    [id(0xfffffffc), propget, restricted, helpstring("Enumerate next item in Tablets"), helpcontext(0x000000b5)]
        HRESULT _NewEnum([out, retval] IUnknown** _NewEnum);
    [id(0x00000001), propget, helpstring("Returns the default tablet within the set of available tablets."), helpcontext(0x000000b6)]
        HRESULT DefaultTablet([out, retval] IInkTablet** DefaultTablet);
    [id(00000000), helpstring("Specifies the object or collection to return at the given index in a collection."), helpcontext(0x000000b7)]
        HRESULT Item(
            [in] long Index,
            [out, retval] IInkTablet** Tablet);
    [id(0x00000003), helpstring("Specifies whether a property of a tablet device or a collection of tablet devices, identified with a globally unique identifier (GUID), is supported."), helpcontext(0x000000b8)]
        HRESULT IsPacketPropertySupported(
            [in] BSTR packetPropertyName,
            [out, retval] VARIANT_BOOL* Supported);
};

[
    odl,
        uuid(43242FEA-91D1-4A72-963E-FBB91829CFA2),
        helpstring("IInkStrokeDisp Interface"),
        helpcontext(0x000000b9),
        dual,
        oleautomation
]
interface IInkStrokeDisp : IDispatch 
{
    [id(0x00000002), propget, helpstring("Represents a single ink stroke."), helpcontext(0x000000ba)]
        HRESULT Id([out, retval] long* Id);
    [id(0x0000000d), propget, helpstring("property BezierPoints"), helpcontext(0x000000bb)]
        HRESULT BezierPoints([out, retval] VARIANT* Points);
    [id(0x00000004), propget, helpstring("property DrawingAttributes"), helpcontext(0x000000bc)]
        HRESULT DrawingAttributes([out, retval] IInkDrawingAttributes** DrawAttrs);
    [id(0x00000004), propputref, helpstring("property DrawingAttributes"), helpcontext(0x000000bc)]
        HRESULT DrawingAttributes([in] IInkDrawingAttributes* DrawAttrs);
    [id(0x0000000c), propget, helpstring("Ink property"), helpcontext(0x000000bd)]
        HRESULT Ink([out, retval] IInkDisp** Ink);
    [id(0x0000000b), propget, helpstring("ExtenedProperties collection"), helpcontext(0x000000be)]
        HRESULT ExtendedProperties([out, retval] IInkExtendedProperties** Properties);
    [id(0x0000000e), propget, helpstring("Polyline Cusps property"), helpcontext(0x000000bf)]
        HRESULT PolylineCusps([out, retval] VARIANT* Cusps);
    [id(0x0000000f), propget, helpstring("Bezier Cusps property"), helpcontext(0x000000c0)]
        HRESULT BezierCusps([out, retval] VARIANT* Cusps);
    [id(0x00000010), propget, helpstring("Self Intersections property"), helpcontext(0x000000c1)]
        HRESULT SelfIntersections([out, retval] VARIANT* Intersections);
    [id(0x00000011), propget, helpstring("PacketCount property"), helpcontext(0x000000c2)]
        HRESULT PacketCount([out, retval] long* plCount);
    [id(0x00000012), propget, helpstring("PacketSize property"), helpcontext(0x000000c3)]
        HRESULT PacketSize([out, retval] long* plSize);
    [id(0x00000013), propget, helpstring("PacketDescription property"), helpcontext(0x000000c4)]
        HRESULT PacketDescription([out, retval] VARIANT* PacketDescription);
    [id(0x00000014), propget, helpstring("Deleted property"), helpcontext(0x000000c5)]
        HRESULT Deleted([out, retval] VARIANT_BOOL* Deleted);
    [id(0x00000003), helpstring("BoundingBox property"), helpcontext(0x000000c6)]
        HRESULT GetBoundingBox(
            [in, optional, defaultvalue(0)] InkBoundingBoxMode BoundingBoxMode,
            [out, retval] IInkRectangle** Rectangle);
    [id(0x00000005), helpstring("method FindIntersections"), helpcontext(0x000000c7)]
        HRESULT FindIntersections(
            [in] IInkStrokes* Strokes,
            [out, retval] VARIANT* Intersections);
    [id(0x00000006), helpstring("method GetRectangleIntersections"), helpcontext(0x000000c8)]
        HRESULT GetRectangleIntersections(
            [in] IInkRectangle* Rectangle,
            [out, retval] VARIANT* Intersections);
    [id(0x00000007), helpstring("method Clip"), helpcontext(0x000000c9)]
        HRESULT Clip([in] IInkRectangle* Rectangle);
    [id(0x00000008), helpstring("method HitTestCircle"), helpcontext(0x000000ca)]
        HRESULT HitTestCircle(
            [in] long x,
            [in] long y,
            [in] single radius,
            [out, retval] VARIANT_BOOL* Intersects);
    [id(0x00000009), helpstring("method NearestPoint"), helpcontext(0x000000cb)]
        HRESULT NearestPoint(
            [in] long x,
            [in] long y,
            [in, out, optional, defaultvalue(0)] single* Distance,
            [out, retval] single* Point);
    [id(0x0000000a), helpstring("method Split"), helpcontext(0x000000cc)]
        HRESULT Split(
            [in] single SplitAt,
            [out, retval] IInkStrokeDisp** NewStroke);
    [id(0x00000015), helpstring("GetPacketDescriptionPropertyMetrics method"), helpcontext(0x000000cd)]
        HRESULT GetPacketDescriptionPropertyMetrics(
            [in] BSTR propertyName,
            [out] long* Minimum,
            [out] long* Maximum,
            [out] TabletPropertyMetricUnit* Units,
            [out] single* Resolution);
    [id(0x00000016), helpstring("method GetPoints"), helpcontext(0x000000ce)]
        HRESULT GetPoints(
            [in, optional, defaultvalue(0)] long Index,
            [in, optional, defaultvalue(-1)] long Count,
            [out, retval] VARIANT* Points);
    [id(0x00000017), helpstring("method SetPoints"), helpcontext(0x000000cf)]
        HRESULT SetPoints(
            [in] VARIANT Points,
            [in, optional, defaultvalue(0)] long Index,
            [in, optional, defaultvalue(-1)] long Count,
            [out, retval] long* NumberOfPointsSet);
    [id(0x00000018), helpstring("method GetPacketData"), helpcontext(0x000000d0)]
        HRESULT GetPacketData(
            [in, optional, defaultvalue(0)] long Index,
            [in, optional, defaultvalue(-1)] long Count,
            [out, retval] VARIANT* PacketData);
    [id(0x00000019), helpstring("method GetPacketValuesByProperty"), helpcontext(0x000000d1)]
        HRESULT GetPacketValuesByProperty(
            [in] BSTR propertyName,
            [in, optional, defaultvalue(0)] long Index,
            [in, optional, defaultvalue(-1)] long Count,
            [out, retval] VARIANT* PacketValues);
    [id(0x0000001a), helpstring("method SetPacketValuesByProperty"), helpcontext(0x000000d2)]
        HRESULT SetPacketValuesByProperty(
            [in] BSTR bstrPropertyName,
            [in] VARIANT PacketValues,
            [in, optional, defaultvalue(0)] long Index,
            [in, optional, defaultvalue(-1)] long Count,
            [out, retval] long* NumberOfPacketsSet);
    [id(0x0000001b), helpstring("method GetFlattenedBezierPoints"), helpcontext(0x000000d3)]
        HRESULT GetFlattenedBezierPoints(
            [in, optional, defaultvalue(0)] long FittingError,
            [out, retval] VARIANT* FlattenedBezierPoints);
    [id(0x0000001d), helpstring("Transform method"), helpcontext(0x000000d4)]
        HRESULT Transform(
            [in] IInkTransform* Transform,
            [in, optional, defaultvalue(0)] VARIANT_BOOL ApplyOnPenWidth);
    [id(0x0000001c), helpstring("ScaleToRectangle method"), helpcontext(0x000000d5)]
        HRESULT ScaleToRectangle([in] IInkRectangle* Rectangle);
    [id(0x0000001e), helpstring("Move method"), helpcontext(0x000000d6)]
        HRESULT Move(
            [in] single HorizontalComponent,
            [in] single VerticalComponent);
    [id(0x0000001f), helpstring("Rotate method"), helpcontext(0x000000d7)]
        HRESULT Rotate(
            [in] single Degrees,
            [in, optional, defaultvalue(0)] single x,
            [in, optional, defaultvalue(0)] single y);
    [id(0x00000020), helpstring("Shear method"), helpcontext(0x000000d8)]
        HRESULT Shear(
            [in] single HorizontalMultiplier,
            [in] single VerticalMultiplier);
    [id(0x00000021), helpstring("ScaleTransform method"), helpcontext(0x000000d9)]
        HRESULT ScaleTransform(
            [in] single HorizontalMultiplier,
            [in] single VerticalMultiplier);
};

[
    odl,
        uuid(F1F4C9D8-590A-4963-B3AE-1935671BB6F3),
        helpstring("IInkStrokes Interface"),
        helpcontext(0x000000da),
        dual,
        oleautomation
]
interface IInkStrokes : IDispatch 
{
    [id(0x00000001), propget, helpstring("Contains the collection of Stroke objects that represent a single ink stroke."), helpcontext(0x000000db)]
        HRESULT Count([out, retval] long* Count);
    [id(0xfffffffc), propget, restricted, helpstring("property _NewEnum"), helpcontext(0x000000dc)]
        HRESULT _NewEnum([out, retval] IUnknown** _NewEnum);
    [id(0x00000003), propget, helpstring("Returns the Ink object that contains a collection of strokes."), helpcontext(0x000000dd)]
        HRESULT Ink([out, retval] IInkDisp** Ink);
    [id(0x00000012), propget, helpstring("Returns the recognition result of the Strokes collection."), helpcontext(0x000000de)]
        HRESULT RecognitionResult([out, retval] IInkRecognitionResult** RecognitionResult);
    [id(0x00000008), helpstring("For a Strokes collection, returns the recognized text of the strokes."), helpcontext(0x000000df)]
        HRESULT ToString([out, retval] BSTR* ToString);
    [id(00000000), helpstring("Item method"), helpcontext(0x000000e0)]
        HRESULT Item(
            [in] long Index,
            [out, retval] IInkStrokeDisp** Stroke);
    [id(0x00000004), helpstring("Specifies the stroke to add to a collection of strokes."), helpcontext(0x000000e1)]
        HRESULT Add([in] IInkStrokeDisp* InkStroke);
    [id(0x00000005), helpstring("Specifies the collection of strokes to add to a collection of strokes."), helpcontext(0x000000e2)]
        HRESULT AddStrokes([in] IInkStrokes* InkStrokes);
    [id(0x00000006), helpstring("Specifies the stroke or collection of strokes to remove from the given collection of strokes."), helpcontext(0x000000e3)]
        HRESULT Remove([in] IInkStrokeDisp* InkStroke);
    [id(0x00000007), helpstring("Specifies the given Strokes collection to remove from the Strokes collection."), helpcontext(0x000000e4)]
        HRESULT RemoveStrokes([in] IInkStrokes* InkStrokes);
    [id(0x00000009), helpstring("Specifies the drawing attributes of all of the strokes in a collection of strokes."), helpcontext(0x000000e5)]
        HRESULT ModifyDrawingAttributes([in] IInkDrawingAttributes* DrawAttrs);
    [id(0x0000000a), helpstring("method GetBoundingBox"), helpcontext(0x000000e6)]
        HRESULT GetBoundingBox(
            [in, optional, defaultvalue(0)] InkBoundingBoxMode BoundingBoxMode,
            [out, retval] IInkRectangle** BoundingBox);
    [id(0x0000000c), helpstring("Specifies the application of scaling, rotation, translation and skewing of Stroke collections/Ink objects in a single operation, as opposed to individual operations."), helpcontext(0x000000e7)]
        HRESULT Transform(
            [in] IInkTransform* Transform,
            [in, optional, defaultvalue(0)] VARIANT_BOOL ApplyOnPenWidth);
    [id(0x0000000b), helpstring("Specifies the stroke or collection of strokes to be scaled to fit in the specified rectangle."), helpcontext(0x000000e8)]
        HRESULT ScaleToRectangle([in] IInkRectangle* Rectangle);
    [id(0x0000000d), helpstring("Move method"), helpcontext(0x000000e9)]
        HRESULT Move(
            [in] single HorizontalComponent,
            [in] single VerticalComponent);
    [id(0x0000000e), helpstring("Rotate method"), helpcontext(0x000000ea)]
        HRESULT Rotate(
            [in] single Degrees,
            [in, optional, defaultvalue(0)] single x,
            [in, optional, defaultvalue(0)] single y);
    [id(0x0000000f), helpstring("Shear method"), helpcontext(0x000000eb)]
        HRESULT Shear(
            [in] single HorizontalMultiplier,
            [in] single VerticalMultiplier);
    [id(0x00000010), helpstring("ScaleTransform method"), helpcontext(0x000000ec)]
        HRESULT ScaleTransform(
            [in] single HorizontalMultiplier,
            [in] single VerticalMultiplier);
    [id(0x00000011), helpstring("Clip method"), helpcontext(0x000000ed)]
        HRESULT Clip([in] IInkRectangle* Rectangle);
    [id(0x00000013), helpstring("Removes the RecognitionResult associated with the Strokes collection."), helpcontext(0x000000ee)]
        HRESULT RemoveRecognitionResult();
};

[
    odl,
        uuid(7E23A88F-C30E-420F-9BDB-28902543F0C1),
        helpstring("IInkCustomStrokes Interface"),
        helpcontext(0x000000ef),
        dual,
        oleautomation
]
interface IInkCustomStrokes : IDispatch 
{
    [id(0x00000001), propget, helpstring("Contains a collection of user-defined Strokes collections."), helpcontext(0x000000f0)]
        HRESULT Count([out, retval] long* Count);
    [id(0xfffffffc), propget, restricted, helpstring("property _NewEnum"), helpcontext(0x000000f1)]
        HRESULT _NewEnum([out, retval] IUnknown** _NewEnum);
    [id(00000000), helpstring("Specifies the object or collection to return at the given index in a collection."), helpcontext(0x000000f2)]
        HRESULT Item(
            [in] VARIANT Identifier,
            [out, retval] IInkStrokes** Strokes);
    [id(0x00000002), helpstring("Specifies the collection of strokes to add to the collection of custom strokes."), helpcontext(0x000000f3)]
        HRESULT Add(
            [in] BSTR Name,
            [in] IInkStrokes* Strokes);
    [id(0x00000003), helpstring("Specifies the stroke or collection of strokes to remove from the given collection of strokes."), helpcontext(0x000000f4)]
        HRESULT Remove([in] VARIANT Identifier);
    [id(0x00000004), helpstring("Specifies that all custom strokes be cleared from the collection of custom strokes."), helpcontext(0x000000f5)]
        HRESULT Clear();
};

[
    uuid(F33053EC-5D25-430A-928F-76A6491DDE15),
        helpstring("Ink Strokes Events Interface"),
        helpcontext(0x000000f6)
]
dispinterface _IInkStrokesEvents
{
    properties:
    methods:
        [id(0x00000001), helpstring("Strokes were added to this collection"), helpcontext(0x000000f7)]
        void StrokesAdded([in] VARIANT StrokeIds);
        [id(0x00000002), helpstring("Strokes were removed from this collection"), helpcontext(0x000000f8)]
        void StrokesRemoved([in] VARIANT StrokeIds);
};

[
    odl,
        uuid(9D398FA0-C4E2-4FCD-9973-975CAAF47EA6),
        helpstring("IInkDisp Interface"),
        helpcontext(0x000000f9),
        dual,
        oleautomation
]
interface IInkDisp : IDispatch 
{
    [id(0x00000001), propget, helpstring("property Strokes collection"), helpcontext(0x000000fa)]
        HRESULT Strokes([out, retval] IInkStrokes** Strokes);
    [id(0x00000002), propget, helpstring("property ExtendedProperties collection"), helpcontext(0x000000fb)]
        HRESULT ExtendedProperties([out, retval] IInkExtendedProperties** Properties);
    [id(0x00000008), propget, helpstring("Dirty property   "), helpcontext(0x000000fc)]
        HRESULT Dirty([out, retval] VARIANT_BOOL* Dirty);
    [id(0x00000008), propput, helpstring("Dirty property   "), helpcontext(0x000000fc)]
        HRESULT Dirty([in] VARIANT_BOOL Dirty);
    [id(0x00000009), propget, helpstring("property CustomStrokes"), helpcontext(0x000000fd)]
        HRESULT CustomStrokes([out, retval] IInkCustomStrokes** ppunkInkCustomStrokes);
    [id(0x00000003), helpstring("BoundingBox property"), helpcontext(0x000000fe)]
        HRESULT GetBoundingBox(
            [in, optional, defaultvalue(0)] InkBoundingBoxMode BoundingBoxMode,
            [out, retval] IInkRectangle** Rectangle);
    [id(0x00000004), helpstring("DeleteStrokes method"), helpcontext(0x000000ff)]
        HRESULT DeleteStrokes([in, optional, defaultvalue(0)] IInkStrokes* Strokes);
    [id(0x00000005), helpstring("DeleteStroke method"), helpcontext(0x00000100)]
        HRESULT DeleteStroke([in] IInkStrokeDisp* Stroke);
    [id(0x00000006), helpstring("ExtractStrokes method"), helpcontext(0x00000101)]
        HRESULT ExtractStrokes(
            [in, optional, defaultvalue(0)] IInkStrokes* Strokes,
            [in, optional, defaultvalue(1)] InkExtractFlags ExtractFlags,
            [out, retval] IInkDisp** ExtractedInk);
    [id(0x00000007), helpstring("ExtractWithRectangle method"), helpcontext(0x00000102)]
        HRESULT ExtractWithRectangle(
            [in] IInkRectangle* Rectangle,
            [in, optional, defaultvalue(1)] InkExtractFlags ExtractFlags,
            [out, retval] IInkDisp** ExtractedInk);
    [id(0x00000012), helpstring("Clip method"), helpcontext(0x00000103)]
        HRESULT Clip([in] IInkRectangle* Rectangle);
    [id(0x0000000a), helpstring("Clone method"), helpcontext(0x00000104)]
        HRESULT Clone([out, retval] IInkDisp** NewInk);
    [id(0x0000000b), helpstring("HitTestCircle method "), helpcontext(0x00000105)]
        HRESULT HitTestCircle(
            [in] long x,
            [in] long y,
            [in] single radius,
            [out, retval] IInkStrokes** Strokes);
    [id(0x0000000c), helpstring("HitTestWithRectangle method"), helpcontext(0x00000106)]
        HRESULT HitTestWithRectangle(
            [in] IInkRectangle* SelectionRectangle,
            [in] single IntersectPercent,
            [out, retval] IInkStrokes** Strokes);
    [id(0x0000000d), helpstring("method HitTestWithLasso"), helpcontext(0x00000107)]
        HRESULT HitTestWithLasso(
            [in] VARIANT Points,
            [in] single IntersectPercent,
            [in, out, optional, defaultvalue(0)] VARIANT* LassoPoints,
            [out, retval] IInkStrokes** Strokes);
    [id(0x0000000e), helpstring("method NearestPoint"), helpcontext(0x00000108)]
        HRESULT NearestPoint(
            [in] long x,
            [in] long y,
            [in, out, optional, defaultvalue(0)] single* PointOnStroke,
            [in, out, optional, defaultvalue(0)] single* DistanceFromPacket,
            [out, retval] IInkStrokeDisp** Stroke);
    [id(0x0000000f), helpstring("CreateStrokes method"), helpcontext(0x00000109)]
        HRESULT CreateStrokes(
            [in, optional, defaultvalue(0)] VARIANT StrokeIds,
            [out, retval] IInkStrokes** Strokes);
    [id(0x00000011), helpstring("AddStrokesAtRectangle method"), helpcontext(0x0000010a)]
        HRESULT AddStrokesAtRectangle(
            [in] IInkStrokes* SourceStrokes,
            [in] IInkRectangle* TargetRectangle);
    [id(0x00000013), helpstring("Save method"), helpcontext(0x0000010b)]
        HRESULT Save(
            [in, optional, defaultvalue(0)] InkPersistenceFormat PersistenceFormat,
            [in, optional, defaultvalue(0)] InkPersistenceCompressionMode CompressionMode,
            [out, retval] VARIANT* Data);
    [id(0x00000014), helpstring("Load method"), helpcontext(0x0000010c)]
        HRESULT Load([in] VARIANT Data);
    [id(0x00000010), helpstring("CreateStroke method"), helpcontext(0x0000010d)]
        HRESULT CreateStroke(
            [in] VARIANT PacketData,
            [in] VARIANT PacketDescription,
            [out, retval] IInkStrokeDisp** Stroke);
    [id(0x00000016), helpstring("ClipboardCopyWithRectangle"), helpcontext(0x0000010e)]
        HRESULT ClipboardCopyWithRectangle(
            [in] IInkRectangle* Rectangle,
            [in, optional, defaultvalue(127)] InkClipboardFormats ClipboardFormats,
            [in, optional, defaultvalue(0)] InkClipboardModes ClipboardModes,
            [out, retval] IDataObject** DataObject);
    [id(0x00000017), helpstring("ClipboardCopy"), helpcontext(0x0000010f)]
        HRESULT ClipboardCopy(
            [in, optional, defaultvalue(0)] IInkStrokes* Strokes,
            [in, optional, defaultvalue(127)] InkClipboardFormats ClipboardFormats,
            [in, optional, defaultvalue(0)] InkClipboardModes ClipboardModes,
            [out, retval] IDataObject** DataObject);
    [id(0x00000018), helpstring("CanPaste"), helpcontext(0x00000110)]
        HRESULT CanPaste(
            [in, optional, defaultvalue(0)] IDataObject* DataObject,
            [out, retval] VARIANT_BOOL* CanPaste);
    [id(0x00000019), helpstring("ClipboardPaste"), helpcontext(0x00000111)]
        HRESULT ClipboardPaste(
            [in, optional, defaultvalue(0)] long x,
            [in, optional, defaultvalue(0)] long y,
            [in, optional, defaultvalue(0)] IDataObject* DataObject,
            [out, retval] IInkStrokes** Strokes);
};


[
    uuid(427B1865-CA3F-479A-83A9-0F420F2A0073),
        helpstring("IInkEvents interface"),
        helpcontext(0x00000112)
]
dispinterface _IInkEvents
{
    properties:
    methods:
        [id(0x00000001), helpstring("Ink was added to the ink object"), helpcontext(0x00000113)]
        void InkAdded([in] VARIANT StrokeIds);
        [id(0x00000002), helpstring("Ink was deleted from the ink object"), helpcontext(0x00000114)]
        void InkDeleted([in] VARIANT StrokeIds);
};

[
    odl,
        uuid(E6257A9C-B511-4F4C-A8B0-A7DBC9506B83),
        helpstring("IInkRenderer Interface"),
        helpcontext(0x00000115),
        dual,
        oleautomation
]
interface IInkRenderer : IDispatch 
{
    [id(0x00000001), helpstring("Represents the management of mappings from ink to the display window."), helpcontext(0x00000116)]
        HRESULT GetViewTransform([in] IInkTransform* ViewTransform);
    [id(0x00000002), helpstring("Sets the System.Drawing.Drawing2d.Matrix object (in Automation, the InkTransform object) representing the view transform used for rendering ink."), helpcontext(0x00000117)]
        HRESULT SetViewTransform([in] IInkTransform* ViewTransform);
    [id(0x00000003), helpstring("Gets the System.Drawing.Drawing2d.Matrix object (in Automation, the InkTransform object) representing the object transform used for rendering ink."), helpcontext(0x00000118)]
        HRESULT GetObjectTransform([in] IInkTransform* ObjectTransform);
    [id(0x00000004), helpstring("Method SetbjectTransform"), helpcontext(0x00000119)]
        HRESULT SetObjectTransform([in] IInkTransform* ObjectTransform);
    [id(0x00000005), helpstring("Specifies the strokes to draw using the given Graphics object or device context."), helpcontext(0x0000011a)]
        HRESULT Draw(
            [in] LongPtr hDC,
            [in] IInkStrokes* Strokes);
    [id(0x00000006), helpstring("Specifies the strokes to draw using the given Graphics object or device context."), helpcontext(0x0000011b)]
        HRESULT DrawStroke(
            [in] LongPtr hDC,
            [in] IInkStrokeDisp* Stroke,
            [in, optional, defaultvalue(0)] IInkDrawingAttributes* DrawingAttributes);
    [id(0x00000007), helpstring("Specifies a location in ink space coordinates given a location in pixel coordinates."), helpcontext(0x0000011c)]
        HRESULT PixelToInkSpace(
            [in] LongPtr hDC,
            [in, out] long* x,
            [in, out] long* y);
    [id(0x00000008), helpstring("Specifies a location in pixel coordinates given a location in ink space coordinates."), helpcontext(0x0000011d)]
        HRESULT InkSpaceToPixel(
            [in] LongPtr hdcDisplay,
            [in, out] long* x,
            [in, out] long* y);
    [id(0x00000009), helpstring("Specifies a location in ink space coordinates given an array of points in pixel coordinates."), helpcontext(0x0000011e)]
        HRESULT PixelToInkSpaceFromPoints(
            [in] LongPtr hDC,
            [in, out] VARIANT* Points);
    [id(0x0000000a), helpstring("Specifies a location in pixel coordinates given an array of points in ink space coordinates."), helpcontext(0x0000011f)]
        HRESULT InkSpaceToPixelFromPoints(
            [in] LongPtr hDC,
            [in, out] VARIANT* Points);
    [id(0x0000000b), helpstring("Specifies the rectangle on the device context that would contain the stroke if the stroke were drawn with the Draw method of the Renderer object."), helpcontext(0x00000120)]
        HRESULT Measure(
            [in] IInkStrokes* Strokes,
            [out, retval] IInkRectangle** Rectangle);
    [id(0x0000000c), helpstring("Specifies the rectangle on the device context that would contain the stroke if the stroke were drawn with the Draw method."), helpcontext(0x00000121)]
        HRESULT MeasureStroke(
            [in] IInkStrokeDisp* Stroke,
            [in, optional, defaultvalue(0)] IInkDrawingAttributes* DrawingAttributes,
            [out, retval] IInkRectangle** Rectangle);
    [id(0x0000000d), helpstring("Move method"), helpcontext(0x00000122)]
        HRESULT Move(
            [in] single HorizontalComponent,
            [in] single VerticalComponent);
    [id(0x0000000e), helpstring("Rotate method"), helpcontext(0x00000123)]
        HRESULT Rotate(
            [in] single Degrees,
            [in, optional, defaultvalue(0)] single x,
            [in, optional, defaultvalue(0)] single y);
    [id(0x0000000f), helpstring("ScaleTransform method"), helpcontext(0x00000124)]
        HRESULT ScaleTransform(
            [in] single HorizontalMultiplier,
            [in] single VerticalMultiplier,
            [in, optional, defaultvalue(-1)] VARIANT_BOOL ApplyOnPenWidth);
};

[
    odl,
        uuid(F0F060B5-8B1F-4A7C-89EC-880692588A4F),
        helpstring("IInkCollector Interface"),
        helpcontext(0x00000136),
        dual,
        oleautomation
]
interface IInkCollector : IDispatch 
{
    [id(0x00000002), propget, helpstring("Gets the window handle that the control is bound to."), helpcontext(0x00000137)]
        HRESULT hWnd([out, retval] LongPtr* CurrentWindow);
    [id(0x00000002), propput, helpstring("Gets the window handle that the control is bound to."), helpcontext(0x00000137)]
        HRESULT hWnd([in] LongPtr CurrentWindow);
    [id(0x00000001), propget, helpstring("Returns or sets a value that specifies whether the InkCollector or InkOverlay objects will collect pen input (in-air packets, cursor in range events, and so on)."), helpcontext(0x00000138)]
        HRESULT Enabled([out, retval] VARIANT_BOOL* Collecting);
    [id(0x00000001), propput, helpstring("Returns or sets a value that specifies whether the InkCollector or InkOverlay objects will collect pen input (in-air packets, cursor in range events, and so on)."), helpcontext(0x00000138)]
        HRESULT Enabled([in] VARIANT_BOOL Collecting);
    [id(0x00000005), propget, helpstring("Returns or sets the default drawing attributes to use when drawing and displaying ink."), helpcontext(0x00000139)]
        HRESULT DefaultDrawingAttributes([out, retval] IInkDrawingAttributes** CurrentAttributes);
    [id(0x00000005), propputref, helpstring("Returns or sets the default drawing attributes to use when drawing and displaying ink."), helpcontext(0x00000139)]
        HRESULT DefaultDrawingAttributes([in] IInkDrawingAttributes* CurrentAttributes);
    [id(0x00000006), propget, helpstring("Returns or sets the Renderer object that is used to draw ink."), helpcontext(0x0000013a)]
        HRESULT Renderer([out, retval] IInkRenderer** CurrentInkRenderer);
    [id(0x00000006), propputref, helpstring("Returns or sets the Renderer object that is used to draw ink."), helpcontext(0x0000013a)]
        HRESULT Renderer([in] IInkRenderer* CurrentInkRenderer);
    [id(0x00000007), propget, helpstring("Returns or sets the Ink object that is associated with an InkCollector object, an InkOverlay object, or a InkPicture control."), helpcontext(0x0000013b)]
        HRESULT Ink([out, retval] IInkDisp** Ink);
    [id(0x00000007), propputref, helpstring("Returns or sets the Ink object that is associated with an InkCollector object, an InkOverlay object, or a InkPicture control."), helpcontext(0x0000013b)]
        HRESULT Ink([in] IInkDisp* Ink);
    [id(0x00000008), propget, helpstring("Returns or sets a value that specifies whether the object/control will repaint when the window is invalidated."), helpcontext(0x0000013c)]
        HRESULT AutoRedraw([out, retval] VARIANT_BOOL* AutoRedraw);
    [id(0x00000008), propput, helpstring("Returns or sets a value that specifies whether the object/control will repaint when the window is invalidated."), helpcontext(0x0000013c)]
        HRESULT AutoRedraw([in] VARIANT_BOOL AutoRedraw);
    [id(0x00000009), propget, helpstring("Returns the value that specifies whether ink is currently being drawn."), helpcontext(0x0000013d)]
        HRESULT CollectingInk([out, retval] VARIANT_BOOL* Collecting);
    [id(0x0000001c), propget, helpstring("Returns or sets the collection mode that determines whether ink, gestures, or both are recognized as the user writes."), helpcontext(0x0000013e)]
        HRESULT CollectionMode([out, retval] InkCollectionMode* Mode);
    [id(0x0000001c), propput, helpstring("Returns or sets the collection mode that determines whether ink, gestures, or both are recognized as the user writes."), helpcontext(0x0000013e)]
        HRESULT CollectionMode([in] InkCollectionMode Mode);
    [id(0x0000001f), propget, helpstring("Returns or sets the value that specifies whether ink is rendered as it is drawn."), helpcontext(0x0000013f)]
        HRESULT DynamicRendering([out, retval] VARIANT_BOOL* Enabled);
    [id(0x0000001f), propput, helpstring("Returns or sets the value that specifies whether ink is rendered as it is drawn."), helpcontext(0x0000013f)]
        HRESULT DynamicRendering([in] VARIANT_BOOL Enabled);
    [id(0x00000020), propget, helpstring("Returns or sets the desired packet description of the object/control."), helpcontext(0x00000140)]
        HRESULT DesiredPacketDescription([out, retval] VARIANT* PacketGuids);
    [id(0x00000020), propput, helpstring("Returns or sets the desired packet description of the object/control."), helpcontext(0x00000140)]
        HRESULT DesiredPacketDescription([in] VARIANT PacketGuids);
    [id(0x00000023), propget, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([out, retval] IPictureDisp** MouseIcon);
    [id(0x00000023), propput, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([in] IPictureDisp* MouseIcon);
    [id(0x00000023), propputref, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([in] IPictureDisp* MouseIcon);
    [id(0x00000024), propget, helpstring("Returns or sets a value indicating the type of mouse pointer to be displayed."), helpcontext(0x00000142)]
        HRESULT MousePointer([out, retval] InkMousePointer* MousePointer);
    [id(0x00000024), propput, helpstring("Returns or sets a value indicating the type of mouse pointer to be displayed."), helpcontext(0x00000142)]
        HRESULT MousePointer([in] InkMousePointer MousePointer);
    [id(0x00000014), propget, helpstring("Returns the number of cursors available for use in the inking region."), helpcontext(0x0000014b)]
        HRESULT Cursors([out, retval] IInkCursors** Cursors);
    [id(0x00000015), propget, helpstring("Returns or sets the x-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014c)]
        HRESULT MarginX([out, retval] long* MarginX);
    [id(0x00000015), propput, helpstring("Returns or sets the x-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014c)]
        HRESULT MarginX([in] long MarginX);
    [id(0x00000016), propget, helpstring("Returns or sets the y-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014d)]
        HRESULT MarginY([out, retval] long* MarginY);
    [id(0x00000016), propput, helpstring("Returns or sets the y-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014d)]
        HRESULT MarginY([in] long MarginY);
    [id(0x00000019), propget, helpstring("Returns the tablet device to which a cursor belongs, or that an object/control is currently using to collect cursor input."), helpcontext(0x0000014e)]
        HRESULT Tablet([out, retval] IInkTablet** SingleTablet);
    [id(0x00000026), propget, helpstring("Returns or sets a value that specifies whether ink will be rendered as just one color when the system is in High Contrast mode."), helpcontext(0x0000014f)]
        HRESULT SupportHighContrastInk([out, retval] VARIANT_BOOL* Support);
    [id(0x00000026), propput, helpstring("Returns or sets a value that specifies whether ink will be rendered as just one color when the system is in High Contrast mode."), helpcontext(0x0000014f)]
        HRESULT SupportHighContrastInk([in] VARIANT_BOOL Support);
    [id(0x0000001d), helpstring("Specifies (sets) the interest of the object/control in a given gesture."), helpcontext(0x00000153)]
        HRESULT SetGestureStatus(
            [in] InkApplicationGesture Gesture,
            [in] VARIANT_BOOL Listen);
    [id(0x0000001e), helpstring("Specifies (gets) the interest of the object/control in a given gesture."), helpcontext(0x00000154)]
        HRESULT GetGestureStatus(
            [in] InkApplicationGesture Gesture,
            [out, retval] VARIANT_BOOL* Listening);
    [id(0x00000018), helpstring("Specifies the window rectangle, in pixels, within which ink is drawn."), helpcontext(0x00000155)]
        HRESULT GetWindowInputRectangle([in, out] IInkRectangle** WindowInputRectangle);
    [id(0x00000017), helpstring("Specifies the window rectangle, in pixels, to use to map drawn ink to the window."), helpcontext(0x00000156)]
        HRESULT SetWindowInputRectangle([in] IInkRectangle* WindowInputRectangle);
    [id(0x0000001a), helpstring("Specifies setting the object/control into AllTablets mode."), helpcontext(0x00000157)]
        HRESULT SetAllTabletsMode([in, optional, defaultvalue(-1)] VARIANT_BOOL UseMouseForInput);
    [id(0x0000001b), helpstring("Specifies setting the object/control into SingleTabletIntegrated mode."), helpcontext(0x00000158)]
        HRESULT SetSingleTabletIntegratedMode([in] IInkTablet* Tablet);
    [id(0x0000000b), helpstring("Specifies the current state of a particular InkCollector, InkOverlay, or InkPicture event (whether the event is being listened for, or used)."), helpcontext(0x00000159)]
        HRESULT GetEventInterest(
            [in] InkCollectorEventInterest EventId,
            [out, retval] VARIANT_BOOL* Listen);
    [id(0x0000000a), helpstring("Specifies whether a specific event should be listened for, or used."), helpcontext(0x0000015a)]
        HRESULT SetEventInterest(
            [in] InkCollectorEventInterest EventId,
            [in] VARIANT_BOOL Listen);
};


[
    uuid(11A583F2-712D-4FEA-ABCF-AB4AF38EA06B),
        helpstring("InkCollector Events Interface"),
        helpcontext(0x0000015f)
]
dispinterface _IInkCollectorEvents 
{
    properties:
    methods:
        [id(0x00000001), helpstring("Occurs when the user draws a new stroke on any tablet."), helpcontext(0x00000160)]
        void Stroke(
                        [in] IInkCursor * Cursor,
                        [in] IInkStrokeDisp * Stroke,
                        [in, out] VARIANT_BOOL * Cancel);
        [id(0x00000002), helpstring("Occurs when the cursor tip contacts the digitizing tablet surface."), helpcontext(0x00000161)]
        void CursorDown(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokeDisp* Stroke);
        [id(0x00000003), helpstring("Occurs when the object/control receives packets."), helpcontext(0x00000162)]
        void NewPackets(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokeDisp* Stroke,
                        [in] long PacketCount,
                        [in, out] VARIANT* PacketData);
        [id(0x00000019), helpstring("Occurs when the user presses and releases a mouse button and then presses and releases it again over an object."), helpcontext(0x00000163)]
        void DblClick([in, out] VARIANT_BOOL* Cancel);
        [id(0x0000001f), helpstring("Occurs when the mouse pointer is moved over the object/control."), helpcontext(0x00000164)]
        void MouseMove(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x0000001b), helpstring("Occurs when the mouse pointer is over the object/control and a mouse button is pressed."), helpcontext(0x00000165)]
        void MouseDown(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x00000020), helpstring("Occurs when the mouse pointer is over the object/control and a mouse button is released."), helpcontext(0x00000166)]
        void MouseUp(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x00000021), helpstring("Occurs when the mouse wheel moves while the object/control object has focus."), helpcontext(0x00000167)]
        void MouseWheel(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long Delta,
                        [in] long x,
                        [in] long y,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x00000004), helpstring("This event occurs when an in-air packet is seen."), helpcontext(0x0000017f)]
        void NewInAirPackets(
                        [in] IInkCursor* Cursor,
                        [in] long lPacketCount,
                        [in, out] VARIANT* PacketData);
        [id(0x00000005), helpstring("Occurs when the object/control detects a cursor button that is down."), helpcontext(0x00000180)]
        void CursorButtonDown(
                        [in] IInkCursor* Cursor,
                        [in] IInkCursorButton* Button);
        [id(0x00000006), helpstring("Occurs when the object/control detects a cursor button that is up."), helpcontext(0x00000181)]
        void CursorButtonUp(
                        [in] IInkCursor* Cursor,
                        [in] IInkCursorButton* Button);
        [id(0x00000007), helpstring("Occurs when a cursor enters the physical detection range (proximity) of the tablet context."), helpcontext(0x00000182)]
        void CursorInRange(
                        [in] IInkCursor* Cursor,
                        [in] VARIANT_BOOL NewCursor,
                        [in] VARIANT ButtonsState);
        [id(0x00000008), helpstring("Occurs when the cursor leaves the physical detection range (proximity) of the tablet context."), helpcontext(0x00000183)]
        void CursorOutOfRange([in] IInkCursor* Cursor);
        [id(0x00000009), helpstring("Occurs when a system gesture is recognized."), helpcontext(0x00000184)]
        void SystemGesture(
                        [in] IInkCursor* Cursor,
                        [in] InkSystemGesture Id,
                        [in] long x,
                        [in] long y,
                        [in] long Modifier,
                        [in] BSTR Character,
                        [in] long CursorMode);
        [id(0x0000000a), helpstring("Occurs when an application-specific gesture is recognized."), helpcontext(0x00000185)]
        void Gesture(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokes* Strokes,
                        [in] VARIANT Gestures,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x0000000b), helpstring("Occurs when a tablet is added to the system."), helpcontext(0x00000186)]
        void TabletAdded([in] IInkTablet* Tablet);
        [id(0x0000000c), helpstring("Occurs when a tablet is removed from the system."), helpcontext(0x00000187)]
        void TabletRemoved([in] long TabletId);
};


[
    odl,
        uuid(B82A463B-C1C5-45A3-997C-DEAB5651B67A),
        helpstring("IInkOverlay Interface"),
        helpcontext(0x00000135),
        dual,
        oleautomation
]
interface IInkOverlay : IDispatch 
{
    [id(0x00000002), propget, helpstring("Gets the window handle that the control is bound to."), helpcontext(0x00000137)]
        HRESULT hWnd([out, retval] LongPtr* CurrentWindow);
    [id(0x00000002), propput, helpstring("Gets the window handle that the control is bound to."), helpcontext(0x00000137)]
        HRESULT hWnd([in] LongPtr CurrentWindow);
    [id(0x00000001), propget, helpstring("Returns or sets a value that specifies whether the InkCollector or InkOverlay objects will collect pen input (in-air packets, cursor in range events, and so on)."), helpcontext(0x00000138)]
        HRESULT Enabled([out, retval] VARIANT_BOOL* Collecting);
    [id(0x00000001), propput, helpstring("Returns or sets a value that specifies whether the InkCollector or InkOverlay objects will collect pen input (in-air packets, cursor in range events, and so on)."), helpcontext(0x00000138)]
        HRESULT Enabled([in] VARIANT_BOOL Collecting);
    [id(0x00000005), propget, helpstring("Returns or sets the default drawing attributes to use when drawing and displaying ink."), helpcontext(0x00000139)]
        HRESULT DefaultDrawingAttributes([out, retval] IInkDrawingAttributes** CurrentAttributes);
    [id(0x00000005), propputref, helpstring("Returns or sets the default drawing attributes to use when drawing and displaying ink."), helpcontext(0x00000139)]
        HRESULT DefaultDrawingAttributes([in] IInkDrawingAttributes* CurrentAttributes);
    [id(0x00000006), propget, helpstring("Returns or sets the Renderer object that is used to draw ink."), helpcontext(0x0000013a)]
        HRESULT Renderer([out, retval] IInkRenderer** CurrentInkRenderer);
    [id(0x00000006), propputref, helpstring("Returns or sets the Renderer object that is used to draw ink."), helpcontext(0x0000013a)]
        HRESULT Renderer([in] IInkRenderer* CurrentInkRenderer);
    [id(0x00000007), propget, helpstring("Returns or sets the Ink object that is associated with an InkCollector object, an InkOverlay object, or a InkPicture control."), helpcontext(0x0000013b)]
        HRESULT Ink([out, retval] IInkDisp** Ink);
    [id(0x00000007), propputref, helpstring("Returns or sets the Ink object that is associated with an InkCollector object, an InkOverlay object, or a InkPicture control."), helpcontext(0x0000013b)]
        HRESULT Ink([in] IInkDisp* Ink);
    [id(0x00000008), propget, helpstring("Returns or sets a value that specifies whether the object/control will repaint when the window is invalidated."), helpcontext(0x0000013c)]
        HRESULT AutoRedraw([out, retval] VARIANT_BOOL* AutoRedraw);
    [id(0x00000008), propput, helpstring("Returns or sets a value that specifies whether the object/control will repaint when the window is invalidated."), helpcontext(0x0000013c)]
        HRESULT AutoRedraw([in] VARIANT_BOOL AutoRedraw);
    [id(0x00000009), propget, helpstring("Returns the value that specifies whether ink is currently being drawn."), helpcontext(0x0000013d)]
        HRESULT CollectingInk([out, retval] VARIANT_BOOL* Collecting);
    [id(0x0000001c), propget, helpstring("Returns or sets the collection mode that determines whether ink, gestures, or both are recognized as the user writes."), helpcontext(0x0000013e)]
        HRESULT CollectionMode([out, retval] InkCollectionMode* Mode);
    [id(0x0000001c), propput, helpstring("Returns or sets the collection mode that determines whether ink, gestures, or both are recognized as the user writes."), helpcontext(0x0000013e)]
        HRESULT CollectionMode([in] InkCollectionMode Mode);
    [id(0x0000001f), propget, helpstring("Returns or sets the value that specifies whether ink is rendered as it is drawn."), helpcontext(0x0000013f)]
        HRESULT DynamicRendering([out, retval] VARIANT_BOOL* Enabled);
    [id(0x0000001f), propput, helpstring("Returns or sets the value that specifies whether ink is rendered as it is drawn."), helpcontext(0x0000013f)]
        HRESULT DynamicRendering([in] VARIANT_BOOL Enabled);
    [id(0x00000020), propget, helpstring("Returns or sets the desired packet description of the object/control."), helpcontext(0x00000140)]
        HRESULT DesiredPacketDescription([out, retval] VARIANT* PacketGuids);
    [id(0x00000020), propput, helpstring("Returns or sets the desired packet description of the object/control."), helpcontext(0x00000140)]
        HRESULT DesiredPacketDescription([in] VARIANT PacketGuids);
    [id(0x00000023), propget, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([out, retval] IPictureDisp** MouseIcon);
    [id(0x00000023), propput, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([in] IPictureDisp* MouseIcon);
    [id(0x00000023), propputref, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([in] IPictureDisp* MouseIcon);
    [id(0x00000024), propget, helpstring("Returns or sets a value indicating the type of mouse pointer to be displayed."), helpcontext(0x00000142)]
        HRESULT MousePointer([out, retval] InkMousePointer* MousePointer);
    [id(0x00000024), propput, helpstring("Returns or sets a value indicating the type of mouse pointer to be displayed."), helpcontext(0x00000142)]
        HRESULT MousePointer([in] InkMousePointer MousePointer);
    [id(0x0000000c), propget, helpstring("Returns or sets a value that specifies whether the object/control is in ink mode, deletion mode, or selecting/editing mode."), helpcontext(0x00000143)]
        HRESULT EditingMode([out, retval] InkOverlayEditingMode* EditingMode);
    [id(0x0000000c), propput, helpstring("Returns or sets a value that specifies whether the object/control is in ink mode, deletion mode, or selecting/editing mode."), helpcontext(0x00000143)]
        HRESULT EditingMode([in] InkOverlayEditingMode EditingMode);
    [id(0x0000000d), propget, helpstring("Returns the collection of strokes that are currently selected inside the control."), helpcontext(0x00000144)]
        HRESULT Selection([out, retval] IInkStrokes** Selection);
    [id(0x0000000d), propput, helpstring("Returns the collection of strokes that are currently selected inside the control."), helpcontext(0x00000144)]
        HRESULT Selection([in] IInkStrokes* Selection);
    [id(0x00000021), propget, helpstring("Returns or sets the value that specifies whether ink is erased by stroke or by point."), helpcontext(0x00000145)]
        HRESULT EraserMode([out, retval] InkOverlayEraserMode* EraserMode);
    [id(0x00000021), propput, helpstring("Returns or sets the value that specifies whether ink is erased by stroke or by point."), helpcontext(0x00000145)]
        HRESULT EraserMode([in] InkOverlayEraserMode EraserMode);
    [id(0x00000022), propget, helpstring("Returns or sets the value that specifies width of the eraser pen tip."), helpcontext(0x00000146)]
        HRESULT EraserWidth([out, retval] long* EraserWidth);
    [id(0x00000022), propput, helpstring("Returns or sets the value that specifies width of the eraser pen tip."), helpcontext(0x00000146)]
        HRESULT EraserWidth([in] long EraserWidth);
    [id(0x0000000e), propget, helpstring("Returns or sets the value that specifies whether the object is attached behind or in front of the given window."), helpcontext(0x0000014a)]
        HRESULT AttachMode([out, retval] InkOverlayAttachMode* AttachMode);
    [id(0x0000000e), propput, helpstring("Returns or sets the value that specifies whether the object is attached behind or in front of the given window."), helpcontext(0x0000014a)]
        HRESULT AttachMode([in] InkOverlayAttachMode AttachMode);
    [id(0x00000014), propget, helpstring("Returns the number of cursors available for use in the inking region."), helpcontext(0x0000014b)]
        HRESULT Cursors([out, retval] IInkCursors** Cursors);
    [id(0x00000015), propget, helpstring("Returns or sets the x-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014c)]
        HRESULT MarginX([out, retval] long* MarginX);
    [id(0x00000015), propput, helpstring("Returns or sets the x-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014c)]
        HRESULT MarginX([in] long MarginX);
    [id(0x00000016), propget, helpstring("Returns or sets the y-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014d)]
        HRESULT MarginY([out, retval] long* MarginY);
    [id(0x00000016), propput, helpstring("Returns or sets the y-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014d)]
        HRESULT MarginY([in] long MarginY);
    [id(0x00000019), propget, helpstring("Returns the tablet device to which a cursor belongs, or that an object/control is currently using to collect cursor input."), helpcontext(0x0000014e)]
        HRESULT Tablet([out, retval] IInkTablet** SingleTablet);
    [id(0x00000026), propget, helpstring("Returns or sets a value that specifies whether ink will be rendered as just one color when the system is in High Contrast mode."), helpcontext(0x0000014f)]
        HRESULT SupportHighContrastInk([out, retval] VARIANT_BOOL* Support);
    [id(0x00000026), propput, helpstring("Returns or sets a value that specifies whether ink will be rendered as just one color when the system is in High Contrast mode."), helpcontext(0x0000014f)]
        HRESULT SupportHighContrastInk([in] VARIANT_BOOL Support);
    [id(0x00000027), propget, helpstring("Returns or sets a value that specifies whether all selection UI (selection bounding box, selection handles) will be drawn in high contrast when the system is in High Contrast mode."), helpcontext(0x00000150)]
        HRESULT SupportHighContrastSelectionUI([out, retval] VARIANT_BOOL* Support);
    [id(0x00000027), propput, helpstring("Returns or sets a value that specifies whether all selection UI (selection bounding box, selection handles) will be drawn in high contrast when the system is in High Contrast mode."), helpcontext(0x00000150)]
        HRESULT SupportHighContrastSelectionUI([in] VARIANT_BOOL Support);
    [id(0x0000000f), helpstring("Specifies the set of strokes at a given coordinate that were hit during a hit test."), helpcontext(0x00000151)]
        HRESULT HitTestSelection(
            [in] long x,
            [in] long y,
            [out, retval] SelectionHitResult* SelArea);
    [id(0x00000010), helpstring("Specifies the ink and selection UI to draw for a specified rectangle in the provided Graphics object (screen, printer, and so on)."), helpcontext(0x00000152)]
        HRESULT Draw([in] IInkRectangle* Rect);
    [id(0x0000001d), helpstring("Specifies (sets) the interest of the object/control in a given gesture."), helpcontext(0x00000153)]
        HRESULT SetGestureStatus(
            [in] InkApplicationGesture Gesture,
            [in] VARIANT_BOOL Listen);
    [id(0x0000001e), helpstring("Specifies (gets) the interest of the object/control in a given gesture."), helpcontext(0x00000154)]
        HRESULT GetGestureStatus(
            [in] InkApplicationGesture Gesture,
            [out, retval] VARIANT_BOOL* Listening);
    [id(0x00000018), helpstring("Specifies the window rectangle, in pixels, within which ink is drawn."), helpcontext(0x00000155)]
        HRESULT GetWindowInputRectangle([in, out] IInkRectangle** WindowInputRectangle);
    [id(0x00000017), helpstring("Specifies the window rectangle, in pixels, to use to map drawn ink to the window."), helpcontext(0x00000156)]
        HRESULT SetWindowInputRectangle([in] IInkRectangle* WindowInputRectangle);
    [id(0x0000001a), helpstring("Specifies setting the object/control into AllTablets mode."), helpcontext(0x00000157)]
        HRESULT SetAllTabletsMode([in, optional, defaultvalue(-1)] VARIANT_BOOL UseMouseForInput);
    [id(0x0000001b), helpstring("Specifies setting the object/control into SingleTabletIntegrated mode."), helpcontext(0x00000158)]
        HRESULT SetSingleTabletIntegratedMode([in] IInkTablet* Tablet);
    [id(0x0000000b), helpstring("Specifies the current state of a particular InkCollector, InkOverlay, or InkPicture event (whether the event is being listened for, or used)."), helpcontext(0x00000159)]
        HRESULT GetEventInterest(
            [in] InkCollectorEventInterest EventId,
            [out, retval] VARIANT_BOOL* Listen);
    [id(0x0000000a), helpstring("Specifies whether a specific event should be listened for, or used."), helpcontext(0x0000015a)]
        HRESULT SetEventInterest(
            [in] InkCollectorEventInterest EventId,
            [in] VARIANT_BOOL Listen);
};

[
    uuid(31179B69-E563-489E-B16F-712F1E8A0651),
        helpstring("InkOverlay Events Interface"),
        helpcontext(0x0000015e)
]
dispinterface _IInkOverlayEvents
{
    properties:
    methods:
        [id(0x00000001), helpstring("Occurs when the user draws a new stroke on any tablet."), helpcontext(0x00000160)]
        void Stroke(
                        [in] IInkCursor * Cursor,
                        [in] IInkStrokeDisp * Stroke,
                        [in, out] VARIANT_BOOL * Cancel);
        [id(0x00000002), helpstring("Occurs when the cursor tip contacts the digitizing tablet surface."), helpcontext(0x00000161)]
        void CursorDown(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokeDisp* Stroke);
        [id(0x00000003), helpstring("Occurs when the object/control receives packets."), helpcontext(0x00000162)]
        void NewPackets(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokeDisp* Stroke,
                        [in] long PacketCount,
                        [in, out] VARIANT* PacketData);
        [id(0x00000019), helpstring("Occurs when the user presses and releases a mouse button and then presses and releases it again over an object."), helpcontext(0x00000163)]
        void DblClick([in, out] VARIANT_BOOL* Cancel);
        [id(0x0000001f), helpstring("Occurs when the mouse pointer is moved over the object/control."), helpcontext(0x00000164)]
        void MouseMove(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x0000001b), helpstring("Occurs when the mouse pointer is over the object/control and a mouse button is pressed."), helpcontext(0x00000165)]
        void MouseDown(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x00000020), helpstring("Occurs when the mouse pointer is over the object/control and a mouse button is released."), helpcontext(0x00000166)]
        void MouseUp(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x00000021), helpstring("Occurs when the mouse wheel moves while the object/control object has focus."), helpcontext(0x00000167)]
        void MouseWheel(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long Delta,
                        [in] long x,
                        [in] long y,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x0000000d), helpstring("Occurs before the InkOverlay object or InkPicture control redraws itself."), helpcontext(0x00000168)]
        void Painting(
                        [in] long hDC,
                        [in] IInkRectangle* Rect,
                        [in, out] VARIANT_BOOL* Allow);
        [id(0x0000000e), helpstring("Occurs when the InkOverlay object or InkPicture control has completed redrawing itself."), helpcontext(0x00000169)]
        void Painted(
                        [in] long hDC,
                        [in] IInkRectangle* Rect);
        [id(0x0000000f), helpstring("Occurs when the selection is about to change."), helpcontext(0x0000016a)]
        void SelectionChanging([in] IInkStrokes* NewSelection);
        [id(0x00000010), helpstring("Occurs when the selection has finished changing."), helpcontext(0x0000016b)]
        void SelectionChanged();
        [id(0x00000011), helpstring("Occurs when the position of the current selection is about to change."), helpcontext(0x0000016c)]
        void SelectionMoving([in] IInkRectangle* CurSelectionRect);
        [id(0x00000012), helpstring("Occurs when the position of the current selection has changed."), helpcontext(0x0000016d)]
        void SelectionMoved([in] IInkRectangle* OldSelectionRect);
        [id(0x00000013), helpstring("Occurs when the size of the current selection is about to change."), helpcontext(0x0000016e)]
        void SelectionResizing([in] IInkRectangle* CurSelectionRect);
        [id(0x00000014), helpstring("Occurs when the size of the current selection has changed."), helpcontext(0x0000016f)]
        void SelectionResized([in] IInkRectangle* OldSelectionRect);
        [id(0x00000015), helpstring("Occurs before strokes are deleted from the Ink property."), helpcontext(0x00000170)]
        void StrokesDeleting([in] IInkStrokes* Strokes);
        [id(0x00000016), helpstring("Occurs after strokes have been deleted from the Ink property."), helpcontext(0x00000171)]
        void StrokesDeleted();
        [id(0x00000004), helpstring("This event occurs when an in-air packet is seen."), helpcontext(0x0000017f)]
        void NewInAirPackets(
                        [in] IInkCursor* Cursor,
                        [in] long lPacketCount,
                        [in, out] VARIANT* PacketData);
        [id(0x00000005), helpstring("Occurs when the object/control detects a cursor button that is down."), helpcontext(0x00000180)]
        void CursorButtonDown(
                        [in] IInkCursor* Cursor,
                        [in] IInkCursorButton* Button);
        [id(0x00000006), helpstring("Occurs when the object/control detects a cursor button that is up."), helpcontext(0x00000181)]
        void CursorButtonUp(
                        [in] IInkCursor* Cursor,
                        [in] IInkCursorButton* Button);
        [id(0x00000007), helpstring("Occurs when a cursor enters the physical detection range (proximity) of the tablet context."), helpcontext(0x00000182)]
        void CursorInRange(
                        [in] IInkCursor* Cursor,
                        [in] VARIANT_BOOL NewCursor,
                        [in] VARIANT ButtonsState);
        [id(0x00000008), helpstring("Occurs when the cursor leaves the physical detection range (proximity) of the tablet context."), helpcontext(0x00000183)]
        void CursorOutOfRange([in] IInkCursor* Cursor);
        [id(0x00000009), helpstring("Occurs when a system gesture is recognized."), helpcontext(0x00000184)]
        void SystemGesture(
                        [in] IInkCursor* Cursor,
                        [in] InkSystemGesture Id,
                        [in] long x,
                        [in] long y,
                        [in] long Modifier,
                        [in] BSTR Character,
                        [in] long CursorMode);
        [id(0x0000000a), helpstring("Occurs when an application-specific gesture is recognized."), helpcontext(0x00000185)]
        void Gesture(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokes* Strokes,
                        [in] VARIANT Gestures,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x0000000b), helpstring("Occurs when a tablet is added to the system."), helpcontext(0x00000186)]
        void TabletAdded([in] IInkTablet* Tablet);
        [id(0x0000000c), helpstring("Occurs when a tablet is removed from the system."), helpcontext(0x00000187)]
        void TabletRemoved([in] long TabletId);
};


[
    odl,
        uuid(E85662E0-379A-40D7-9B5C-757D233F9923),
        helpstring("IInkPicture Interface"),
        helpcontext(0x00000134),
        dual,
        oleautomation
]
interface IInkPicture : IDispatch 
{
    [id(0x00000002), propget, helpstring("Gets the window handle that the control is bound to."), helpcontext(0x00000137)]
        HRESULT hWnd([out, retval] LongPtr* CurrentWindow);
    [id(0x00000005), propget, helpstring("Returns or sets the default drawing attributes to use when drawing and displaying ink."), helpcontext(0x00000139)]
        HRESULT DefaultDrawingAttributes([out, retval] IInkDrawingAttributes** CurrentAttributes);
    [id(0x00000005), propputref, helpstring("Returns or sets the default drawing attributes to use when drawing and displaying ink."), helpcontext(0x00000139)]
        HRESULT DefaultDrawingAttributes([in] IInkDrawingAttributes* CurrentAttributes);
    [id(0x00000006), propget, helpstring("Returns or sets the Renderer object that is used to draw ink."), helpcontext(0x0000013a)]
        HRESULT Renderer([out, retval] IInkRenderer** CurrentInkRenderer);
    [id(0x00000006), propputref, helpstring("Returns or sets the Renderer object that is used to draw ink."), helpcontext(0x0000013a)]
        HRESULT Renderer([in] IInkRenderer* CurrentInkRenderer);
    [id(0x00000007), propget, helpstring("Returns or sets the Ink object that is associated with an InkCollector object, an InkOverlay object, or a InkPicture control."), helpcontext(0x0000013b)]
        HRESULT Ink([out, retval] IInkDisp** Ink);
    [id(0x00000007), propputref, helpstring("Returns or sets the Ink object that is associated with an InkCollector object, an InkOverlay object, or a InkPicture control."), helpcontext(0x0000013b)]
        HRESULT Ink([in] IInkDisp* Ink);
    [id(0x00000008), propget, helpstring("Returns or sets a value that specifies whether the object/control will repaint when the window is invalidated."), helpcontext(0x0000013c)]
        HRESULT AutoRedraw([out, retval] VARIANT_BOOL* AutoRedraw);
    [id(0x00000008), propput, helpstring("Returns or sets a value that specifies whether the object/control will repaint when the window is invalidated."), helpcontext(0x0000013c)]
        HRESULT AutoRedraw([in] VARIANT_BOOL AutoRedraw);
    [id(0x00000009), propget, helpstring("Returns the value that specifies whether ink is currently being drawn."), helpcontext(0x0000013d)]
        HRESULT CollectingInk([out, retval] VARIANT_BOOL* Collecting);
    [id(0x0000001c), propget, helpstring("Returns or sets the collection mode that determines whether ink, gestures, or both are recognized as the user writes."), helpcontext(0x0000013e)]
        HRESULT CollectionMode([out, retval] InkCollectionMode* Mode);
    [id(0x0000001c), propput, helpstring("Returns or sets the collection mode that determines whether ink, gestures, or both are recognized as the user writes."), helpcontext(0x0000013e)]
        HRESULT CollectionMode([in] InkCollectionMode Mode);
    [id(0x0000001f), propget, helpstring("Returns or sets the value that specifies whether ink is rendered as it is drawn."), helpcontext(0x0000013f)]
        HRESULT DynamicRendering([out, retval] VARIANT_BOOL* Enabled);
    [id(0x0000001f), propput, helpstring("Returns or sets the value that specifies whether ink is rendered as it is drawn."), helpcontext(0x0000013f)]
        HRESULT DynamicRendering([in] VARIANT_BOOL Enabled);
    [id(0x00000020), propget, helpstring("Returns or sets the desired packet description of the object/control."), helpcontext(0x00000140)]
        HRESULT DesiredPacketDescription([out, retval] VARIANT* PacketGuids);
    [id(0x00000020), propput, helpstring("Returns or sets the desired packet description of the object/control."), helpcontext(0x00000140)]
        HRESULT DesiredPacketDescription([in] VARIANT PacketGuids);
    [id(0x00000023), propget, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([out, retval] IPictureDisp** MouseIcon);
    [id(0x00000023), propput, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([in] IPictureDisp* MouseIcon);
    [id(0x00000023), propputref, helpstring("Returns or sets the custom mouse icon."), helpcontext(0x00000141)]
        HRESULT MouseIcon([in] IPictureDisp* MouseIcon);
    [id(0x00000024), propget, helpstring("Returns or sets a value indicating the type of mouse pointer to be displayed."), helpcontext(0x00000142)]
        HRESULT MousePointer([out, retval] InkMousePointer* MousePointer);
    [id(0x00000024), propput, helpstring("Returns or sets a value indicating the type of mouse pointer to be displayed."), helpcontext(0x00000142)]
        HRESULT MousePointer([in] InkMousePointer MousePointer);
    [id(0x0000000c), propget, helpstring("Returns or sets a value that specifies whether the object/control is in ink mode, deletion mode, or selecting/editing mode."), helpcontext(0x00000143)]
        HRESULT EditingMode([out, retval] InkOverlayEditingMode* EditingMode);
    [id(0x0000000c), propput, helpstring("Returns or sets a value that specifies whether the object/control is in ink mode, deletion mode, or selecting/editing mode."), helpcontext(0x00000143)]
        HRESULT EditingMode([in] InkOverlayEditingMode EditingMode);
    [id(0x0000000d), propget, helpstring("Returns the collection of strokes that are currently selected inside the control."), helpcontext(0x00000144)]
        HRESULT Selection([out, retval] IInkStrokes** Selection);
    [id(0x0000000d), propput, helpstring("Returns the collection of strokes that are currently selected inside the control."), helpcontext(0x00000144)]
        HRESULT Selection([in] IInkStrokes* Selection);
    [id(0x00000021), propget, helpstring("Returns or sets the value that specifies whether ink is erased by stroke or by point."), helpcontext(0x00000145)]
        HRESULT EraserMode([out, retval] InkOverlayEraserMode* EraserMode);
    [id(0x00000021), propput, helpstring("Returns or sets the value that specifies whether ink is erased by stroke or by point."), helpcontext(0x00000145)]
        HRESULT EraserMode([in] InkOverlayEraserMode EraserMode);
    [id(0x00000022), propget, helpstring("Returns or sets the value that specifies width of the eraser pen tip."), helpcontext(0x00000146)]
        HRESULT EraserWidth([out, retval] long* EraserWidth);
    [id(0x00000022), propput, helpstring("Returns or sets the value that specifies width of the eraser pen tip."), helpcontext(0x00000146)]
        HRESULT EraserWidth([in] long EraserWidth);
    [id(0x00000011), propputref, helpstring("Returns the graphics file to be displayed on the control."), helpcontext(0x00000147)]
        HRESULT Picture([in] IPictureDisp* ppPicture);
    [id(0x00000011), propput, helpstring("Returns the graphics file to be displayed on the control."), helpcontext(0x00000147)]
        HRESULT Picture([in] IPictureDisp* ppPicture);
    [id(0x00000011), propget, helpstring("Returns the graphics file to be displayed on the control."), helpcontext(0x00000147)]
        HRESULT Picture([out, retval] IPictureDisp** ppPicture);
    [id(0x00000012), propput, helpstring("Returns or sets the manner in which background picture is displayed within the control."), helpcontext(0x00000148)]
        HRESULT SizeMode([in] InkPictureSizeMode smSizeMode);
    [id(0x00000012), propget, helpstring("Returns or sets the manner in which background picture is displayed within the control."), helpcontext(0x00000148)]
        HRESULT SizeMode([out, retval] InkPictureSizeMode* smSizeMode);
    [id(0x00000013), propput, helpstring("Returns or sets the background color used to display text and graphics in an object."), helpcontext(0x00000149)]
        HRESULT BackColor([in] OLE_COLOR pColor);
    [id(0x00000013), propget, helpstring("Returns or sets the background color used to display text and graphics in an object."), helpcontext(0x00000149)]
        HRESULT BackColor([out, retval] OLE_COLOR* pColor);
    [id(0x00000014), propget, helpstring("Returns the number of cursors available for use in the inking region."), helpcontext(0x0000014b)]
        HRESULT Cursors([out, retval] IInkCursors** Cursors);
    [id(0x00000015), propget, helpstring("Returns or sets the x-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014c)]
        HRESULT MarginX([out, retval] long* MarginX);
    [id(0x00000015), propput, helpstring("Returns or sets the x-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014c)]
        HRESULT MarginX([in] long MarginX);
    [id(0x00000016), propget, helpstring("Returns or sets the y-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014d)]
        HRESULT MarginY([out, retval] long* MarginY);
    [id(0x00000016), propput, helpstring("Returns or sets the y-axis margin around the window rectangle, in screen coordinates."), helpcontext(0x0000014d)]
        HRESULT MarginY([in] long MarginY);
    [id(0x00000019), propget, helpstring("Returns the tablet device to which a cursor belongs, or that an object/control is currently using to collect cursor input."), helpcontext(0x0000014e)]
        HRESULT Tablet([out, retval] IInkTablet** SingleTablet);
    [id(0x00000026), propget, helpstring("Returns or sets a value that specifies whether ink will be rendered as just one color when the system is in High Contrast mode."), helpcontext(0x0000014f)]
        HRESULT SupportHighContrastInk([out, retval] VARIANT_BOOL* Support);
    [id(0x00000026), propput, helpstring("Returns or sets a value that specifies whether ink will be rendered as just one color when the system is in High Contrast mode."), helpcontext(0x0000014f)]
        HRESULT SupportHighContrastInk([in] VARIANT_BOOL Support);
    [id(0x00000027), propget, helpstring("Returns or sets a value that specifies whether all selection UI (selection bounding box, selection handles) will be drawn in high contrast when the system is in High Contrast mode."), helpcontext(0x00000150)]
        HRESULT SupportHighContrastSelectionUI([out, retval] VARIANT_BOOL* Support);
    [id(0x00000027), propput, helpstring("Returns or sets a value that specifies whether all selection UI (selection bounding box, selection handles) will be drawn in high contrast when the system is in High Contrast mode."), helpcontext(0x00000150)]
        HRESULT SupportHighContrastSelectionUI([in] VARIANT_BOOL Support);
    [id(0x0000000f), helpstring("Specifies the set of strokes at a given coordinate that were hit during a hit test."), helpcontext(0x00000151)]
        HRESULT HitTestSelection(
            [in] long x,
            [in] long y,
            [out, retval] SelectionHitResult* SelArea);
    [id(0x0000001d), helpstring("Specifies (sets) the interest of the object/control in a given gesture."), helpcontext(0x00000153)]
        HRESULT SetGestureStatus(
            [in] InkApplicationGesture Gesture,
            [in] VARIANT_BOOL Listen);
    [id(0x0000001e), helpstring("Specifies (gets) the interest of the object/control in a given gesture."), helpcontext(0x00000154)]
        HRESULT GetGestureStatus(
            [in] InkApplicationGesture Gesture,
            [out, retval] VARIANT_BOOL* Listening);
    [id(0x00000018), helpstring("Specifies the window rectangle, in pixels, within which ink is drawn."), helpcontext(0x00000155)]
        HRESULT GetWindowInputRectangle([in, out] IInkRectangle** WindowInputRectangle);
    [id(0x00000017), helpstring("Specifies the window rectangle, in pixels, to use to map drawn ink to the window."), helpcontext(0x00000156)]
        HRESULT SetWindowInputRectangle([in] IInkRectangle* WindowInputRectangle);
    [id(0x0000001a), helpstring("Specifies setting the object/control into AllTablets mode."), helpcontext(0x00000157)]
        HRESULT SetAllTabletsMode([in, optional, defaultvalue(-1)] VARIANT_BOOL UseMouseForInput);
    [id(0x0000001b), helpstring("Specifies setting the object/control into SingleTabletIntegrated mode."), helpcontext(0x00000158)]
        HRESULT SetSingleTabletIntegratedMode([in] IInkTablet* Tablet);
    [id(0x0000000b), helpstring("Specifies the current state of a particular InkCollector, InkOverlay, or InkPicture event (whether the event is being listened for, or used)."), helpcontext(0x00000159)]
        HRESULT GetEventInterest(
            [in] InkCollectorEventInterest EventId,
            [out, retval] VARIANT_BOOL* Listen);
    [id(0x0000000a), helpstring("Specifies whether a specific event should be listened for, or used."), helpcontext(0x0000015a)]
        HRESULT SetEventInterest(
            [in] InkCollectorEventInterest EventId,
            [in] VARIANT_BOOL Listen);
    [id(0x00000025), propget, helpstring("Returns or sets a value that specifies whether the InkPicture control will collect pen input, such as in-air packets or cursor in range events."), helpcontext(0x0000015b)]
        HRESULT InkEnabled([out, retval] VARIANT_BOOL* Collecting);
    [id(0x00000025), propput, helpstring("Returns or sets a value that specifies whether the InkPicture control will collect pen input, such as in-air packets or cursor in range events."), helpcontext(0x0000015b)]
        HRESULT InkEnabled([in] VARIANT_BOOL Collecting);
    [id(0xfffffdfe), propget, helpstring("Returns or sets a value that determines whether the InkPicture or InkEdit control can respond to user-generated events."), helpcontext(0x0000015c)]
        HRESULT Enabled([out, retval] VARIANT_BOOL* pbool);
    [id(0xfffffdfe), propput, helpstring("Returns or sets a value that determines whether the InkPicture or InkEdit control can respond to user-generated events."), helpcontext(0x0000015c)]
        HRESULT Enabled([in] VARIANT_BOOL pbool);
};

[
    uuid(60FF4FEE-22FF-4484-ACC1-D308D9CD7EA3),
        helpstring("InkPicture Events Interface"),
        helpcontext(0x0000015d)
]
dispinterface _IInkPictureEvents
{
    properties:
    methods:
        [id(0x00000001), helpstring("Occurs when the user draws a new stroke on any tablet."), helpcontext(0x00000160)]
        void Stroke(
                        [in] IInkCursor * Cursor,
                        [in] IInkStrokeDisp * Stroke,
                        [in, out] VARIANT_BOOL * Cancel);
        [id(0x00000002), helpstring("Occurs when the cursor tip contacts the digitizing tablet surface."), helpcontext(0x00000161)]
        void CursorDown(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokeDisp* Stroke);
        [id(0x00000003), helpstring("Occurs when the object/control receives packets."), helpcontext(0x00000162)]
        void NewPackets(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokeDisp* Stroke,
                        [in] long PacketCount,
                        [in, out] VARIANT* PacketData);
        [id(0x00000019), helpstring("Occurs when the user presses and releases a mouse button and then presses and releases it again over an object."), helpcontext(0x00000163)]
        void DblClick([in, out] VARIANT_BOOL* Cancel);
        [id(0x0000001f), helpstring("Occurs when the mouse pointer is moved over the object/control."), helpcontext(0x00000164)]
        void MouseMove(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x0000001b), helpstring("Occurs when the mouse pointer is over the object/control and a mouse button is pressed."), helpcontext(0x00000165)]
        void MouseDown(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x00000020), helpstring("Occurs when the mouse pointer is over the object/control and a mouse button is released."), helpcontext(0x00000166)]
        void MouseUp(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long pX,
                        [in] long pY,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x00000021), helpstring("Occurs when the mouse wheel moves while the object/control object has focus."), helpcontext(0x00000167)]
        void MouseWheel(
                        [in] InkMouseButton Button,
                        [in] InkShiftKeyModifierFlags Shift,
                        [in] long Delta,
                        [in] long x,
                        [in] long y,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x0000000d), helpstring("Occurs before the InkOverlay object or InkPicture control redraws itself."), helpcontext(0x00000168)]
        void Painting(
                        [in] long hDC,
                        [in] IInkRectangle* Rect,
                        [in, out] VARIANT_BOOL* Allow);
        [id(0x0000000e), helpstring("Occurs when the InkOverlay object or InkPicture control has completed redrawing itself."), helpcontext(0x00000169)]
        void Painted(
                        [in] long hDC,
                        [in] IInkRectangle* Rect);
        [id(0x0000000f), helpstring("Occurs when the selection is about to change."), helpcontext(0x0000016a)]
        void SelectionChanging([in] IInkStrokes* NewSelection);
        [id(0x00000010), helpstring("Occurs when the selection has finished changing."), helpcontext(0x0000016b)]
        void SelectionChanged();
        [id(0x00000011), helpstring("Occurs when the position of the current selection is about to change."), helpcontext(0x0000016c)]
        void SelectionMoving([in] IInkRectangle* CurSelectionRect);
        [id(0x00000012), helpstring("Occurs when the position of the current selection has changed."), helpcontext(0x0000016d)]
        void SelectionMoved([in] IInkRectangle* OldSelectionRect);
        [id(0x00000013), helpstring("Occurs when the size of the current selection is about to change."), helpcontext(0x0000016e)]
        void SelectionResizing([in] IInkRectangle* CurSelectionRect);
        [id(0x00000014), helpstring("Occurs when the size of the current selection has changed."), helpcontext(0x0000016f)]
        void SelectionResized([in] IInkRectangle* OldSelectionRect);
        [id(0x00000015), helpstring("Occurs before strokes are deleted from the Ink property."), helpcontext(0x00000170)]
        void StrokesDeleting([in] IInkStrokes* Strokes);
        [id(0x00000016), helpstring("Occurs after strokes have been deleted from the Ink property."), helpcontext(0x00000171)]
        void StrokesDeleted();
        [id(0x0000001c), helpstring("Occurs when the mouse pointer enters the control."), helpcontext(0x00000172)]
        void MouseEnter();
        [id(0x00000018), helpstring("Occurs when the control is clicked."), helpcontext(0x00000173)]
        void Click();
        [id(0x0000001d), helpstring("Occurs when the mouse pointer hovers over the control."), helpcontext(0x00000174)]
        void MouseHover();
        [id(0x0000001e), helpstring("Occurs when the mouse pointer leaves the control."), helpcontext(0x00000175)]
        void MouseLeave();
        [id(0x00000025), helpstring("Occurs when a key is pressed and in the down position while the control has focus."), helpcontext(0x00000176)]
        void KeyDown(
                        [in, out] short* KeyCode,
                        [in, out] short* Shift);
        [id(0x00000027), helpstring("Occurs when a key is released while the control has focus."), helpcontext(0x00000177)]
        void KeyUp(
                        [in, out] short* KeyCode,
                        [in, out] short* Shift);
        [id(0x00000026), helpstring("Occurs when a key is pressed while the control has focus."), helpcontext(0x00000178)]
        void KeyPress([in, out] short* KeyAscii);
        [id(0x00000022), helpstring("Occurs after the SizeMode property of the control has been changed."), helpcontext(0x00000179)]
        void SizeModeChanged(
                        [in] InkPictureSizeMode NewMode,
                        [in] InkPictureSizeMode OldMode);
        [id(0x00000024), helpstring("Occurs after the system colors change."), helpcontext(0x0000017a)]
        void SystemColorsChanged();
        [id(0x00000028), helpstring("Occurs when the control is resized (when the Width and/or Height property values change)."), helpcontext(0x0000017b)]
        void Resize(
                        [in, out] long* Left,
                        [in, out] long* Top,
                        [in, out] long* Right,
                        [in, out] long* Bottom);
        [id(0x00000029), helpstring("Occurs after the control has been resized (after the Width and/or Height property values change)."), helpcontext(0x0000017c)]
        void SizeChanged(
                        [in] long Left,
                        [in] long Top,
                        [in] long Right,
                        [in] long Bottom);
        [id(0x00000023), helpstring("Not implemented."), helpcontext(0x0000017d)]
        void StyleChanged();
        [id(0x00000017), helpstring("Not implemented."), helpcontext(0x0000017e)]
        void ChangeUICues([in] long UICues);
        [id(0x00000004), helpstring("This event occurs when an in-air packet is seen."), helpcontext(0x0000017f)]
        void NewInAirPackets(
                        [in] IInkCursor* Cursor,
                        [in] long lPacketCount,
                        [in, out] VARIANT* PacketData);
        [id(0x00000005), helpstring("Occurs when the object/control detects a cursor button that is down."), helpcontext(0x00000180)]
        void CursorButtonDown(
                        [in] IInkCursor* Cursor,
                        [in] IInkCursorButton* Button);
        [id(0x00000006), helpstring("Occurs when the object/control detects a cursor button that is up."), helpcontext(0x00000181)]
        void CursorButtonUp(
                        [in] IInkCursor* Cursor,
                        [in] IInkCursorButton* Button);
        [id(0x00000007), helpstring("Occurs when a cursor enters the physical detection range (proximity) of the tablet context."), helpcontext(0x00000182)]
        void CursorInRange(
                        [in] IInkCursor* Cursor,
                        [in] VARIANT_BOOL NewCursor,
                        [in] VARIANT ButtonsState);
        [id(0x00000008), helpstring("Occurs when the cursor leaves the physical detection range (proximity) of the tablet context."), helpcontext(0x00000183)]
        void CursorOutOfRange([in] IInkCursor* Cursor);
        [id(0x00000009), helpstring("Occurs when a system gesture is recognized."), helpcontext(0x00000184)]
        void SystemGesture(
                        [in] IInkCursor* Cursor,
                        [in] InkSystemGesture Id,
                        [in] long x,
                        [in] long y,
                        [in] long Modifier,
                        [in] BSTR Character,
                        [in] long CursorMode);
        [id(0x0000000a), helpstring("Occurs when an application-specific gesture is recognized."), helpcontext(0x00000185)]
        void Gesture(
                        [in] IInkCursor* Cursor,
                        [in] IInkStrokes* Strokes,
                        [in] VARIANT Gestures,
                        [in, out] VARIANT_BOOL* Cancel);
        [id(0x0000000b), helpstring("Occurs when a tablet is added to the system."), helpcontext(0x00000186)]
        void TabletAdded([in] IInkTablet* Tablet);
        [id(0x0000000c), helpstring("Occurs when a tablet is removed from the system."), helpcontext(0x00000187)]
        void TabletRemoved([in] long TabletId);
};

[
    odl,
        uuid(782BF7CF-034B-4396-8A32-3A1833CF6B56),
        helpstring("IInkRecognizer Interface"),
        helpcontext(0x00000188),
        dual,
        oleautomation
]
interface IInkRecognizer : IDispatch 
{
    [id(0x00000002), propget, helpstring("Represents the ability to process ink, or handwriting, and translate the strokes into text or gestures."), helpcontext(0x00000189)]
        HRESULT Name([out, retval] BSTR* Name);
    [id(0x00000003), propget, helpstring("Returns the vendor name of the recognizer."), helpcontext(0x0000018a)]
        HRESULT Vendor([out, retval] BSTR* Vendor);
    [id(0x00000004), propget, helpstring("Returns the capabilities of the recognizer, such as whether the recognizer supports character Autocomplete, whether it supports free, lined, or boxed input, etc."), helpcontext(0x0000018b)]
        HRESULT Capabilities([out, retval] InkRecognizerCapabilities* CapabilitiesFlags);
    [id(0x00000005), propget, helpstring("Returns the list of language and sub-language combinations that the recognizer supports."), helpcontext(0x0000018c)]
        HRESULT Languages([out, retval] VARIANT* Languages);
    [id(0x00000008), propget, helpstring("Returns an array of identifiers that describe the properties that the recognizer supports."), helpcontext(0x0000018d)]
        HRESULT SupportedProperties([out, retval] VARIANT* SupportedProperties);
    [id(0x00000006), propget, helpstring("Returns a packet description that describes the packet properties of the recognizer."), helpcontext(0x0000018e)]
        HRESULT PreferredPacketDescription([out, retval] VARIANT* PreferredPacketDescription);
    [id(0x00000007), helpstring("Specifies the creation of a new RecognizerContext."), helpcontext(0x0000018f)]
        HRESULT CreateRecognizerContext([out, retval] IInkRecognizerContext** Context);
};

[
    odl,
        uuid(6110118A-3A75-4AD6-B2AA-04B2B72BBE65),
        helpstring("IInkRecognizer2 Interface"),
        helpcontext(0x000001f2),
        dual,
        oleautomation
]
interface IInkRecognizer2 : IDispatch 
{
    [id(00000000), propget, helpstring("Returns the id of the recognizer."), helpcontext(0x000001f3)]
        HRESULT Id([out, retval] BSTR* pbstrId);
    [id(0x00000001), propget, helpstring("Returns the supported Unicode code point ranges."), helpcontext(0x000001f4)]
        HRESULT UnicodeRanges([out, retval] VARIANT* UnicodeRanges);
};

[
    odl,
        uuid(9CCC4F12-B0B7-4A8B-BF58-4AECA4E8CEFD),
        helpstring("IInkRecognizers Interface"),
        helpcontext(0x00000190),
        dual,
        oleautomation
]
interface IInkRecognizers : IDispatch 
{
    [id(0x00000001), propget, helpstring("Contains the Recognizer objects that represent the ability to create a recognition context, retrieve its attributes and properties, and determine which packet properties the recognizer needs to perform recognition."), helpcontext(0x00000191)]
        HRESULT Count([out, retval] long* Count);
    [id(0xfffffffc), propget, restricted, helpstring("property _NewEnum"), helpcontext(0x00000192)]
        HRESULT _NewEnum([out, retval] IUnknown** _NewEnum);
    [id(0x00000002), helpstring("Returns the default recognizer for a given language, specified by an NLS locale identifier LCID."), helpcontext(0x00000193)]
        HRESULT GetDefaultRecognizer(
            [in, optional, defaultvalue(0)] long lcid,
            [out, retval] IInkRecognizer** DefaultRecognizer);
    [id(00000000), helpstring("Specifies the object or collection to return at the given index in a collection."), helpcontext(0x00000194)]
        HRESULT Item(
            [in] long Index,
            [out, retval] IInkRecognizer** InkRecognizer);
};

[
    uuid(17BCE92F-2E21-47FD-9D33-3C6AFBFD8C59),
        helpstring("_IInkRecognitionEvents Interface"),
        helpcontext(0x00000195)
]
dispinterface _IInkRecognitionEvents
{
    properties:
    methods:
        [id(0x00000001), helpstring("Recognition finished with alternate information"), helpcontext(0x00000196)]
        void RecognitionWithAlternates(
                        [in] IInkRecognitionResult * RecognitionResult,
                        [in] VARIANT CustomData,
                        [in] InkRecognitionStatus RecognitionStatus);
        [id(0x00000002), helpstring("Recognition finished"), helpcontext(0x00000197)]
        void Recognition(
                        [in] BSTR RecognizedString,
                        [in] VARIANT CustomData,
                        [in] InkRecognitionStatus RecognitionStatus);
};

[
    odl,
        uuid(C68F52F9-32A3-4625-906C-44FC23B40958),
        helpstring("IInkRecognizerContext Interface"),
        helpcontext(0x00000198),
        dual,
        oleautomation
]
interface IInkRecognizerContext : IDispatch 
{
    [id(0x00000001), propget, helpstring("Represents the ability to perform ink recognition, retrieve the recognition result, and retrieve alternates."), helpcontext(0x00000199)]
        HRESULT Strokes([out, retval] IInkStrokes** Strokes);
    [id(0x00000001), propputref, helpstring("Represents the ability to perform ink recognition, retrieve the recognition result, and retrieve alternates."), helpcontext(0x00000199)]
        HRESULT Strokes([in] IInkStrokes* Strokes);
    [id(0x00000002), propget, helpstring("Returns or sets the character Autocomplete mode that determines when characters or words are recognized."), helpcontext(0x0000019a)]
        HRESULT CharacterAutoCompletionMode([out, retval] InkRecognizerCharacterAutoCompletionMode* Mode);
    [id(0x00000002), propput, helpstring("Returns or sets the character Autocomplete mode that determines when characters or words are recognized."), helpcontext(0x0000019a)]
        HRESULT CharacterAutoCompletionMode([in] InkRecognizerCharacterAutoCompletionMode Mode);
    [id(0x00000003), propget, helpstring("Returns or sets the factoid that a recognizer uses to constrain its search for the recognition result."), helpcontext(0x0000019b)]
        HRESULT Factoid([out, retval] BSTR* Factoid);
    [id(0x00000003), propput, helpstring("Returns or sets the factoid that a recognizer uses to constrain its search for the recognition result."), helpcontext(0x0000019b)]
        HRESULT Factoid([in] BSTR Factoid);
    [id(0x00000006), propget, helpstring("Returns or sets the RecognizerGuide to use for ink input."), helpcontext(0x0000019c)]
        HRESULT Guide([out, retval] IInkRecognizerGuide** RecognizerGuide);
    [id(0x00000006), propputref, helpstring("Returns or sets the RecognizerGuide to use for ink input."), helpcontext(0x0000019c)]
        HRESULT Guide([in] IInkRecognizerGuide* RecognizerGuide);
    [id(0x00000008), propget, helpstring("Returns or sets the text string that helps improve recognition results by providing a context for newly entered text."), helpcontext(0x0000019d)]
        HRESULT PrefixText([out, retval] BSTR* Prefix);
    [id(0x00000008), propput, helpstring("Returns or sets the text string that helps improve recognition results by providing a context for newly entered text."), helpcontext(0x0000019d)]
        HRESULT PrefixText([in] BSTR Prefix);
    [id(0x00000009), propget, helpstring("Returns or sets the text string that helps improve recognition results by providing a context for newly entered text."), helpcontext(0x0000019e)]
        HRESULT SuffixText([out, retval] BSTR* Suffix);
    [id(0x00000009), propput, helpstring("Returns or sets the text string that helps improve recognition results by providing a context for newly entered text."), helpcontext(0x0000019e)]
        HRESULT SuffixText([in] BSTR Suffix);
    [id(0x00000007), propget, helpstring("Returns or sets the flags that specify how the recognizer interprets the ink and determines the result string."), helpcontext(0x0000019f)]
        HRESULT RecognitionFlags([out, retval] InkRecognitionModes* Modes);
    [id(0x00000007), propput, helpstring("Returns or sets the flags that specify how the recognizer interprets the ink and determines the result string."), helpcontext(0x0000019f)]
        HRESULT RecognitionFlags([in] InkRecognitionModes Modes);
    [id(0x00000004), propget, helpstring("Returns or sets the user-defined word list used in the recognition process to improve the recognition results."), helpcontext(0x000001a0)]
        HRESULT WordList([out, retval] IInkWordList** WordList);
    [id(0x00000004), propputref, helpstring("Returns or sets the user-defined word list used in the recognition process to improve the recognition results."), helpcontext(0x000001a0)]
        HRESULT WordList([in] IInkWordList* WordList);
    [id(0x00000005), propget, helpstring("Returns the recognizer used within the recognizer context."), helpcontext(0x000001a1)]
        HRESULT Recognizer([out, retval] IInkRecognizer** Recognizer);
    [id(0x0000000c), helpstring("Specifies that a collection of strokes should be recognized, and that recognition results are returned from the recognition."), helpcontext(0x000001a2)]
        HRESULT Recognize(
            [in, out] InkRecognitionStatus* RecognitionStatus,
            [out, retval] IInkRecognitionResult** RecognitionResult);
    [id(0x0000000d), helpstring("Specifies that background recognition be stopped when it was started with a call to BackgroundRecognize or BackgroundRecognizeWithAlternates."), helpcontext(0x000001a3)]
        HRESULT StopBackgroundRecognition();
    [id(0x0000000e), helpstring("Specifies that no more ink will be added to the context."), helpcontext(0x000001a4)]
        HRESULT EndInkInput();
    [id(0x0000000f), helpstring("Specifies that the recognizer should recognize the associated strokes and fire a recognition event when recognition is complete."), helpcontext(0x000001a5)]
        HRESULT BackgroundRecognize([in, optional] VARIANT CustomData);
    [id(0x00000010), helpstring("Specifies that the recognizer should recognize the associated strokes and fire recognition with alternates event when recognition is complete."), helpcontext(0x000001a6)]
        HRESULT BackgroundRecognizeWithAlternates([in, optional] VARIANT CustomData);
    [id(0x0000000b), helpstring("Specifies the creation of a duplicate object."), helpcontext(0x000001a7)]
        HRESULT Clone([out, retval] IInkRecognizerContext** RecoContext);
    [id(0x00000011), helpstring("Specifies whether the system dictionary, user dictionary, or word list contain a string."), helpcontext(0x000001a8)]
        HRESULT IsStringSupported(
            [in] BSTR String,
            [out, retval] VARIANT_BOOL* Supported);
};


[
    odl,
        uuid(D6F0E32F-73D8-408E-8E9F-5FEA592C363F),
        helpstring("IInkRecognizerContext2 Interface"),
        helpcontext(0x000001f5),
        dual,
        oleautomation
]
interface IInkRecognizerContext2 : IDispatch 
{
    [id(00000000), propget, helpstring("Returns or sets the enabled Unicode code point ranges."), helpcontext(0x000001f6)]
        HRESULT EnabledUnicodeRanges([out, retval] VARIANT* UnicodeRanges);
    [id(00000000), propput, helpstring("Returns or sets the enabled Unicode code point ranges."), helpcontext(0x000001f6)]
        HRESULT EnabledUnicodeRanges([in] VARIANT UnicodeRanges);
};

[
    odl,
        uuid(3BC129A8-86CD-45AD-BDE8-E0D32D61C16D),
        helpstring("IInkRecognitionResult Interface"),
        helpcontext(0x000001ad),
        dual,
        oleautomation
]
interface IInkRecognitionResult : IDispatch 
{
    [id(0x00000001), propget, helpstring("Represents the result of the recognition."), helpcontext(0x000001ae)]
        HRESULT TopString([out, retval] BSTR* TopString);
    [id(0x00000002), propget, helpstring("Returns the best alternate of the recognition result."), helpcontext(0x000001af)]
        HRESULT TopAlternate([out, retval] IInkRecognitionAlternate** TopAlternate);
    [id(0x00000004), propget, helpstring("Returns the level of confidence - strong, intermediate, or poor - of the recognition result."), helpcontext(0x000001b0)]
        HRESULT TopConfidence([out, retval] InkRecognitionConfidence* TopConfidence);
    [id(0x00000003), propget, helpstring("property Strokes"), helpcontext(0x000001b1)]
        HRESULT Strokes([out, retval] IInkStrokes** Strokes);
    [id(0x00000005), helpstring("method AlternatesFromSelection"), helpcontext(0x000001b2)]
        HRESULT AlternatesFromSelection(
            [in, optional, defaultvalue(0)] long selectionStart,
            [in, optional, defaultvalue(-1)] long selectionLength,
            [in, optional, defaultvalue(10)] long maximumAlternates,
            [out, retval] IInkRecognitionAlternates** AlternatesFromSelection);
    [id(0x00000006), helpstring("Specifies the recognition result to be modified with a given alternate."), helpcontext(0x000001b3)]
        HRESULT ModifyTopAlternate([in] IInkRecognitionAlternate* Alternate);
    [id(0x00000007), helpstring("Specifies the recognition results to assign to the strokes that were used to create the results."), helpcontext(0x000001b4)]
        HRESULT SetResultOnStrokes();
};

[
    odl,
        uuid(B7E660AD-77E4-429B-ADDA-873780D1FC4A),
        helpstring("IInkRecognitionAlternate Interface"),
        helpcontext(0x000001b5),
        dual,
        oleautomation
]
interface IInkRecognitionAlternate : IDispatch 
{
    [id(0x00000001), propget, helpstring("Returns the result string of the alternate."), helpcontext(0x000001b6)]
        HRESULT String([out, retval] BSTR* RecoString);
    [id(0x00000007), propget, helpstring("Returns the level of confidence - strong, intermediate, or poor - that a recognizer has in the recognition of a RecognitionAlternate object or of a gesture."), helpcontext(0x000001b7)]
        HRESULT Confidence([out, retval] InkRecognitionConfidence* Confidence);
    [id(0x00000003), propget, helpstring("Returns the baseline of a RecognitionAlternate object that exists on a single line."), helpcontext(0x000001b8)]
        HRESULT Baseline([out, retval] VARIANT* Baseline);
    [id(0x00000004), propget, helpstring("Returns the midline for a RecognitionAlternate object that exists on a single line."), helpcontext(0x000001b9)]
        HRESULT Midline([out, retval] VARIANT* Midline);
    [id(0x00000005), propget, helpstring("Returns the ascender line of a RecognitionAlternate object that exists on a single line."), helpcontext(0x000001ba)]
        HRESULT Ascender([out, retval] VARIANT* Ascender);
    [id(0x00000006), propget, helpstring("Returns the descender line of a RecognitionAlternate object that exists on a single line."), helpcontext(0x000001bb)]
        HRESULT Descender([out, retval] VARIANT* Descender);
    [id(0x00000002), propget, helpstring("Returns the line number of the ink that makes up the alternate."), helpcontext(0x000001bc)]
        HRESULT LineNumber([out, retval] long* LineNumber);
    [id(0x00000008), propget, helpstring("property Strokes"), helpcontext(0x000001bd)]
        HRESULT Strokes([out, retval] IInkStrokes** Strokes);
    [id(0x0000000d), propget, helpstring("Returns the collection of alternates where each alternate in the collection is on a separate line."), helpcontext(0x000001be)]
        HRESULT LineAlternates([out, retval] IInkRecognitionAlternates** LineAlternates);
    [id(0x0000000e), propget, helpstring("Returns the collection of alternates where each alternate in the collection consists of the segments with the same property values."), helpcontext(0x000001bf)]
        HRESULT ConfidenceAlternates([out, retval] IInkRecognitionAlternates** ConfidenceAlternates);
    [id(0x00000009), helpstring("Specifies the smallest collection of strokes that contains a given input collection of strokes, and for which the recognizer can provide alternates."), helpcontext(0x000001c0)]
        HRESULT GetStrokesFromStrokeRanges(
            [in] IInkStrokes* Strokes,
            [out, retval] IInkStrokes** GetStrokesFromStrokeRanges);
    [id(0x0000000a), helpstring("Returns the strokes that correspond to the smallest RecognitionAlternates collection that contains a specified range of recognized text within the alternate."), helpcontext(0x000001c1)]
        HRESULT GetStrokesFromTextRange(
            [in, out] long* selectionStart,
            [in, out] long* selectionLength,
            [out, retval] IInkStrokes** GetStrokesFromTextRange);
    [id(0x0000000b), helpstring("Specifies the smallest range of recognized text for which the recognizer can return an alternate that contains a given collection of strokes."), helpcontext(0x000001c2)]
        HRESULT GetTextRangeFromStrokes(
            [in] IInkStrokes* Strokes,
            [in, out] long* selectionStart,
            [in, out] long* selectionLength);
    [id(0x0000000f), helpstring("Specifies the collection of alternates that have the same value as this alternate for the given property type."), helpcontext(0x000001c3)]
        HRESULT AlternatesWithConstantPropertyValues(
            [in] BSTR PropertyType,
            [out, retval] IInkRecognitionAlternates** AlternatesWithConstantPropertyValues);
    [id(0x0000000c), helpstring("Specifies the value of a given property of the alternate, such as the recognizer's confidence in the alternate."), helpcontext(0x000001c4)]
        HRESULT GetPropertyValue(
            [in] BSTR PropertyType,
            [out, retval] VARIANT* PropertyValue);
};


[
    odl,
        uuid(286A167F-9F19-4C61-9D53-4F07BE622B84),
        helpstring("IInkRecognitionAlternates Interface"),
        helpcontext(0x000001c5),
        dual,
        oleautomation
]
interface IInkRecognitionAlternates : IDispatch 
{
    [id(0x00000001), propget, helpstring("Returns the number of objects or collections contained in a collection."), helpcontext(0x000001c6)]
        HRESULT Count([out, retval] long* Count);
    [id(0xfffffffc), propget, restricted, helpstring("property _NewEnum"), helpcontext(0x000001c7)]
        HRESULT _NewEnum([out, retval] IUnknown** _NewEnum);
    [id(0x00000002), propget, helpstring("property Strokes collection"), helpcontext(0x000001c8)]
        HRESULT Strokes([out, retval] IInkStrokes** Strokes);
    [id(00000000), helpstring("Specifies the object or collection to return at the given index in a collection."), helpcontext(0x000001c9)]
        HRESULT Item(
            [in] long Index,
            [out, retval] IInkRecognitionAlternate** InkRecoAlternate);
};

[
    odl,
        uuid(D934BE07-7B84-4208-9136-83C20994E905),
        helpstring("IInkRecognizerGuide Interface"),
        helpcontext(0x000001ca),
        dual,
        oleautomation
]
interface IInkRecognizerGuide : IDispatch 
{
    [id(0x00000001), propget, helpstring("Represents the area used by the recognizer in which ink can be drawn."), helpcontext(0x000001cb)]
        HRESULT WritingBox([out, retval] IInkRectangle** Rectangle);
    [id(0x00000001), propput, helpstring("Represents the area used by the recognizer in which ink can be drawn."), helpcontext(0x000001cb)]
        HRESULT WritingBox([in] IInkRectangle* Rectangle);
    [id(0x00000002), propget, helpstring("Returns or sets the box that is physically drawn on the tablet's screen, in which writing takes place."), helpcontext(0x000001cc)]
        HRESULT DrawnBox([out, retval] IInkRectangle** Rectangle);
    [id(0x00000002), propput, helpstring("Returns or sets the box that is physically drawn on the tablet's screen, in which writing takes place."), helpcontext(0x000001cc)]
        HRESULT DrawnBox([in] IInkRectangle* Rectangle);
    [id(0x00000003), propget, helpstring("Returns or sets the number of rows in the guide box."), helpcontext(0x000001cd)]
        HRESULT Rows([out, retval] long* Units);
    [id(0x00000003), propput, helpstring("Returns or sets the number of rows in the guide box."), helpcontext(0x000001cd)]
        HRESULT Rows([in] long Units);
    [id(0x00000004), propget, helpstring("Returns or sets the number of columns in the guide box."), helpcontext(0x000001ce)]
        HRESULT Columns([out, retval] long* Units);
    [id(0x00000004), propput, helpstring("Returns or sets the number of columns in the guide box."), helpcontext(0x000001ce)]
        HRESULT Columns([in] long Units);
    [id(0x00000005), propget, helpstring("Returns or sets the midline height, or distance from the baseline to the midline, of the guide box."), helpcontext(0x000001cf)]
        HRESULT Midline([out, retval] long* Units);
    [id(0x00000005), propput, helpstring("Returns or sets the midline height, or distance from the baseline to the midline, of the guide box."), helpcontext(0x000001cf)]
        HRESULT Midline([in] long Units);
    [id(0x00000006), propget, hidden, helpstring("Returns or sets the recognizer guide structure for Automation developers."), helpcontext(0x000001d0)]
        HRESULT GuideData([out, retval] InkRecoGuide* pRecoGuide);
    [id(0x00000006), propput, hidden, helpstring("Returns or sets the recognizer guide structure for Automation developers."), helpcontext(0x000001d0)]
        HRESULT GuideData([in] InkRecoGuide pRecoGuide);
};


[
    odl,
        uuid(76BA3491-CB2F-406B-9961-0E0C4CDAAEF2),
        helpstring("IInkWordList Interface"),
        helpcontext(0x000001d1),
        dual,
        oleautomation
]
interface IInkWordList : IDispatch 
{
    [id(00000000), helpstring("Represents the word list that can be used to improve the recognition result."), helpcontext(0x000001d2)]
        HRESULT AddWord([in] BSTR NewWord);
    [id(0x00000001), helpstring("Specifies the single word to remove from a word list."), helpcontext(0x000001d3)]
        HRESULT RemoveWord([in] BSTR RemoveWord);
    [id(0x00000002), helpstring("Specifies another word list to merge into a given word list."), helpcontext(0x000001d4)]
        HRESULT Merge([in] IInkWordList* MergeWordList);
};

[
    odl,
        uuid(14542586-11BF-4F5F-B6E7-49D0744AAB6E),
        helpstring("IInkWordList2 Interface"),
        helpcontext(0x000001ee),
        dual,
        oleautomation
]
interface IInkWordList2 : IDispatch 
{
    [id(0x00000003), helpstring("Represents the word list that can be used to improve the recognition result."), helpcontext(0x000001ef)]
        HRESULT AddWords([in] BSTR NewWords);
};

[
    uuid(937C1A34-151D-4610-9CA6-A8CC9BDB5D83),
        helpstring("Represents the collected strokes of ink within an ink space."),
        helpcontext(0x000001d5)
]
coclass InkDisp {
    [default] interface IInkDisp;
    [default, source] dispinterface _IInkEvents;
};

[
    uuid(65D00646-CDE3-4A88-9163-6769F0F1A97D),
        helpstring("Represents a transparent COM or .NET object useful for annotation scenarios where end users are not concerned with performing recognition on ink but instead are interested in the size, shape, color, and position of the ink."),
        helpcontext(0x000001d6)
]
coclass InkOverlay {
    [default] interface IInkOverlay;
    [default, source] dispinterface _IInkOverlayEvents;
};

[
    uuid(04A1E553-FE36-4FDE-865E-344194E69424),
        helpstring("Represents the ability to place an image in an application or web page to which users can add ink."),
        helpcontext(0x000001d7)
]
coclass InkPicture {
    [default] interface IInkPicture;
    [default, source] dispinterface _IInkPictureEvents;
};


[
    uuid(43FB1553-AD74-4EE8-88E4-3E6DAAC915DB),
        helpstring("Represents the object used to capture ink from available tablet devices."),
        helpcontext(0x000001d8)
]
coclass InkCollector {
    [default] interface IInkCollector;
    [default, source] dispinterface _IInkCollectorEvents;
};

[
    uuid(D8BF32A2-05A5-44C3-B3AA-5E80AC7D2576),
        helpstring("Represents the objects that are applied to ink when it is drawn."),
        helpcontext(0x000001d9)
]
coclass InkDrawingAttributes {
    [default] interface IInkDrawingAttributes;
};

[
    uuid(43B07326-AAE0-4B62-A83D-5FD768B7353C),
        helpstring("Represents access to a rectangle for Automation users."),
        helpcontext(0x000001da)
]
coclass InkRectangle {
    [default] interface IInkRectangle;
};

[
    uuid(9C1CC6E4-D7EB-4EEB-9091-15A7C8791ED9),
        helpstring("Represents the management of mappings from ink to the display window."),
        helpcontext(0x000001db)
]
coclass InkRenderer {
    [default] interface IInkRenderer;
};

[
    uuid(E3D5D93C-1663-4A78-A1A7-22375DFEBAEE),
        helpstring("Represents a 3x3 matrix that, in turn, represents an affine transformation."),
        helpcontext(0x000001dc)
]
coclass InkTransform {
    [default] interface IInkTransform;
};

[
    uuid(9FD4E808-F6E6-4E65-98D3-AA39054C1255),
        helpstring("Represents the ability to process ink, or handwriting, and translate the strokes into text or gestures."),
        helpcontext(0x000001dd)
]
coclass InkRecognizers {
    [default] interface IInkRecognizers;
};

[
    uuid(AAC46A37-9229-4FC0-8CCE-4497569BF4D1),
        helpstring("Represents the ability to perform ink recognition, retrieve the recognition result, and retrieve alternates."),
        helpcontext(0x000001de)
]
coclass InkRecognizerContext {
    [default] interface IInkRecognizerContext;
    [default, source] dispinterface _IInkRecognitionEvents;
};

[
    uuid(8770D941-A63A-4671-A375-2855A18EBA73),
        helpstring("Represents the area used by the recognizer in which ink can be drawn."),
        helpcontext(0x000001df)
]
coclass InkRecognizerGuide {
    [default] interface IInkRecognizerGuide;
};

[
    uuid(6E4FCB12-510A-4D40-9304-1DA10AE9147C),
        helpstring("Represents the digitizer device of the Tablet PC that receives tablet device messages or events."),
        helpcontext(0x000001e0)
]
coclass InkTablets {
    [default] interface IInkTablets;
};


[
    uuid(9DE85094-F71F-44F1-8471-15A2FA76FCF3),
        helpstring("Represents the word list that can be used to improve the recognition result."),
        helpcontext(0x000001e1)
]
coclass InkWordList {
    [default] interface IInkWordList;
};

[
    uuid(48F491BC-240E-4860-B079-A1E94D3D2C86),
        helpstring("Represents a single ink stroke."),
        helpcontext(0x000001e2),
        noncreatable
]
coclass InkStrokes {
    [default] interface IInkStrokes;
    [default, source] dispinterface _IInkStrokesEvents;
};

[
    odl,
        uuid(03F8E511-43A1-11D3-8BB6-0080C7D6BAD5),
        helpstring("IInk Interface"),
        helpcontext(0x000001e3),
        hidden,
        dual,
        oleautomation
]
interface IInk : IDispatch 
{
};

[
    odl,
        uuid(9C1C5AD6-F22F-4DE4-B453-A2CC482E7C33),
        helpstring("IInkLineInfo Interface"),
        helpcontext(0x000001e4),
        hidden
]
interface IInkLineInfo : stdole.IUnknown 
{
    [helpstring("method SetFormat	"), helpcontext(0x000001e5)]
        HRESULT _stdcall SetFormat(INKMETRIC* pim);
    [helpstring("method GetFormat	"), helpcontext(0x000001e6)]
        HRESULT _stdcall GetFormat(INKMETRIC* pim);
    [helpstring("method GetInkExtent "), helpcontext(0x000001e7)]
        HRESULT _stdcall GetInkExtent(
            INKMETRIC* pim,
              int* pnWidth);
    [helpstring("method GetCandidate "), helpcontext(0x000001e8)]
        HRESULT _stdcall GetCandidate(
              int nCandidateNum,
            LongPtr pwcRecogWord,
              int* pcwcRecogWord,
             long dwFlags);
    [helpstring("method SetCandidate "), helpcontext(0x000001e9)]
        HRESULT _stdcall SetCandidate(
              int nCandidateNum,
            LongPtr strRecogWord);
    [helpstring("method Recognize	"), helpcontext(0x000001ea)]
        HRESULT _stdcall Recognize();
};

[
    odl,
        uuid(B4563688-98EB-4646-B279-44DA14D45748),
        helpstring("ISketchInk Interface"),
        helpcontext(0x000001eb),
        hidden,
        dual,
        oleautomation
]
interface ISketchInk : IDispatch 
{
};

[
    uuid(13DE4A42-8D21-4C8E-BF9C-8F69CB068FCA),
        helpstring("Ink"),
        helpcontext(0x000001ec),
        hidden
]
coclass Ink {
    [default] interface IInk;
    interface IInkLineInfo;
};

[
    uuid(F0291081-E87C-4E07-97DA-A0A03761E586),
        helpstring("SketchInk Class"),
        helpcontext(0x000001ed),
        hidden
]
coclass SketchInk {
    [default] interface ISketchInk;
};



//peninputpanel.h

interface IPenInputPanel;
interface _IPenInputPanelEvents;
interface IHandwrittenTextInsertion;
interface ITextInputPanelEventSink;
interface ITextInputPanel;
interface IInputPanelWindowHandle;
interface ITextInputPanelRunInfo;


//#define MICROSOFT_PENINPUT_PANEL_PROPERTY_T    L"Microsoft PenInputPanel 1.5"
typedef /* [hidden] */
enum DISPID_PenInputPanel
{
    DISPID_PIPAttachedEditWindow, //DISPID_VALUE,
    DISPID_PIPFactoid, //(DISPID_PIPAttachedEditWindow + 1),
    DISPID_PIPCurrentPanel, //(DISPID_PIPFactoid + 1),
    DISPID_PIPDefaultPanel, //(DISPID_PIPCurrentPanel + 1),
    DISPID_PIPVisible, //(DISPID_PIPDefaultPanel + 1),
    DISPID_PIPTop, //(DISPID_PIPVisible + 1),
    DISPID_PIPLeft, //(DISPID_PIPTop + 1),
    DISPID_PIPWidth, //(DISPID_PIPLeft + 1),
    DISPID_PIPHeight, //(DISPID_PIPWidth + 1),
    DISPID_PIPMoveTo, //(DISPID_PIPHeight + 1),
    DISPID_PIPCommitPendingInput, //(DISPID_PIPMoveTo + 1),
    DISPID_PIPRefresh, //(DISPID_PIPCommitPendingInput + 1),
    DISPID_PIPBusy, //(DISPID_PIPRefresh + 1),
    DISPID_PIPVerticalOffset, //(DISPID_PIPBusy + 1),
    DISPID_PIPHorizontalOffset, //(DISPID_PIPVerticalOffset + 1),
    DISPID_PIPEnableTsf, //(DISPID_PIPHorizontalOffset + 1),
    DISPID_PIPAutoShow, //(DISPID_PIPEnableTsf + 1)
}     DISPID_PenInputPanel;

typedef /* [hidden] */
enum DISPID_PenInputPanelEvents
{
    DISPID_PIPEVisibleChanged, //0,
    DISPID_PIPEPanelChanged, //(DISPID_PIPEVisibleChanged + 1),
    DISPID_PIPEInputFailed, //(DISPID_PIPEPanelChanged + 1),
    DISPID_PIPEPanelMoving, //(DISPID_PIPEInputFailed + 1)
}     DISPID_PenInputPanelEvents;

typedef /* [uuid]  DECLSPEC_UUID("7fd1134a-b2ba-4673-8d64-e28be4168e5d") */
enum PIP_VisualState
{
    PIP_InPlace = 0,
    PIP_Floating = 1,
    PIP_DockedTop = 2,
    PIP_DockedBottom = 3,
    PIP_Closed = 4
}     PIP_VisualState;

typedef /* [public][public][uuid]  DECLSPEC_UUID("500f9c5a-6739-449b-9cfa-5fc2f2e9ddce") */
enum PIP_InteractionMode;
{
    InteractionMode_InPlace = 0,
        InteractionMode_Floating = 1,
        InteractionMode_DockedTop = 2,
        InteractionMode_DockedBottom = 3
}     PIP_InteractionMode;

typedef /* [public][public][public][public][public][public][public][public][uuid]  DECLSPEC_UUID("aa9bda6b-fc6a-49a3-9d7c-26b233690583") */
enum PIP_InPlaceState
{
    PIP_InPlaceState_Auto = 0,
    PIP_InPlaceState_HoverTarget = 1,
    PIP_InPlaceState_Expanded = 2
}     PIP_InPlaceState;

typedef /* [public][public][public][public][public][public][public][public][uuid]  DECLSPEC_UUID("8b4f78bf-4253-4467-a006-670419caa993") */
enum PIP_PanelInputArea
{
    PIP_PanelInputArea_Auto = 0,
    PIP_PanelInputArea_Keyboard = 1,
    PIP_PanelInputArea_WritingPad = 2,
    PIP_PanelInputArea_CharacterPad = 3
}     PIP_PanelInputArea;

typedef /* [public][public][public][public][public][public][uuid] DECLSPEC_UUID("d708f745-981e-4e9b-afa0-98082aadb421") */ 
enum PIP_CorrectionMode
{
    PIP_CorrectionMode_NotVisible = 0,
    PIP_CorrectionMode_PreInsertion = 1,
    PIP_CorrectionMode_PostInsertionCollapsed = 2,
    PIP_CorrectionMode_PostInsertionExpanded = 3
}     PIP_CorrectionMode;

typedef /* [public][public][uuid]  DECLSPEC_UUID("84ccefd0-9212-44e4-94e6-91562a94016e") */
enum PIP_CorrectionPosition
{
    PIP_CorrectionPosition_Auto = 0,
    PIP_CorrectionPosition_Bottom = 1,
    PIP_CorrectionPosition_Top = 2
}     PIP_CorrectionPosition;

typedef /* [public][public][public][uuid]  DECLSPEC_UUID("619eab37-412f-44ca-996f-0f415fb8bc12") */
enum InPlaceDirection
{
    InPlaceDirection_Auto = 0,
    InPlaceDirection_Bottom = 1,
    InPlaceDirection_Top = 2
}     PIP_InPlaceDirection;

typedef /* [public][uuid]  DECLSPEC_UUID("1ad3e1f7-4dd0-48c3-a89b-dfccba13d6f7") */
enum PIP_EventMask
{
    EventMask_InPlaceStateChanging = 1,
    EventMask_InPlaceStateChanged = 2,
    EventMask_InPlaceSizeChanging = 4,
    EventMask_InPlaceSizeChanged = 8,
    EventMask_InputAreaChanging = 16,
    EventMask_InputAreaChanged = 32,
    EventMask_CorrectionModeChanging = 64,
    EventMask_CorrectionModeChanged = 128,
    EventMask_InPlaceVisibilityChanging = 256,
    EventMask_InPlaceVisibilityChanged = 512,
    EventMask_TextInserting = 1024,
    EventMask_TextInserted = 2048,
    EventMask_All = (((((((((((EventMask_InPlaceStateChanging + EventMask_InPlaceStateChanged) + EventMask_InPlaceSizeChanging) + EventMask_InPlaceSizeChanged) + EventMask_InputAreaChanging) + EventMask_InputAreaChanged) + EventMask_CorrectionModeChanging) + EventMask_CorrectionModeChanged) + EventMask_InPlaceVisibilityChanging) + EventMask_InPlaceVisibilityChanged) + EventMask_TextInserting) + EventMask_TextInserted)
}     PIP_EventMask;

//const WCHAR MICROSOFT_URL_EXPERIENCE_PROPERTY[] = L"Microsoft TIP URL Experience";
//const WCHAR MICROSOFT_TIP_NO_INSERT_BUTTON_PROPERTY[] = L"Microsoft TIP No Insert Option";
//const WCHAR MICROSOFT_TIP_COMBOBOXLIST_PROPERTY[] = L"Microsoft TIP ComboBox List Window Identifier";
//const WCHAR MICROSOFT_TIP_OPENING_MSG[] = L"TabletInputPanelOpening";

//EXTERN_C const IID LIBID_PenInputPanelLib;
//
//#ifndef __IPenInputPanel_INTERFACE_DEFINED__
//#define __IPenInputPanel_INTERFACE_DEFINED__

/* interface IPenInputPanel */
/* [helpcontext][helpstring][unique][dual][uuid][object] */

typedef /* [helpcontext][helpstring] */
enum PIP_PanelType
{
    PT_Default, //0,
    PT_Inactive, //(PT_Default + 1),
    PT_Handwriting, //(PT_Inactive + 1),
    PT_Keyboard, //(PT_Handwriting + 1)
}     PIP_PanelType;

//
//EXTERN_C const IID IID_IPenInputPanel;
//
//#if defined(__cplusplus) && !defined(CINTERFACE)

[
    odl,
        uuid(FA7A4083-5747-4040-A182-0B0E9FD4FAC7),
        helpstring("The PenInputPanel allows you to add in-place pen input to your applications."),
        helpcontext(0x000003ea),
        dual,
        oleautomation
]
interface IPenInputPanel : IDispatch 
{
    [id(0x0000000c), propget, helpstring("Retrieves a Boolean value that specifies whether the PenInputPanel object is currently processing ink."), helpcontext(0x000003f2)]
        HRESULT Busy([out, retval] VARIANT_BOOL* Busy);
    [id(0x00000001), propget, helpstring("Returns or sets the factoid that a recognizer uses to constrain its search for the recognition result."), helpcontext(0x00000400)]
        HRESULT Factoid([out, retval] BSTR* Factoid);
    [id(0x00000001), propput, helpstring("Returns or sets the factoid that a recognizer uses to constrain its search for the recognition result."), helpcontext(0x00000400)]
        HRESULT Factoid([in] BSTR Factoid);
    [id(00000000), propget, helpstring("Sets or retrieves the window handle of the object that the PenInputPanel object is attached to."), helpcontext(0x000003f4)]
        HRESULT AttachedEditWindow([out, retval] int* AttachedEditWindow);
    [id(00000000), propput, helpstring("Sets or retrieves the window handle of the object that the PenInputPanel object is attached to."), helpcontext(0x000003f4)]
        HRESULT AttachedEditWindow([in] int AttachedEditWindow);
    [id(0x00000002), propget, helpstring("Sets or retrieves which panel is currently active in the pen input panel."), helpcontext(0x000003f5)]
        HRESULT CurrentPanel([out, retval] PanelType* CurrentPanel);
    [id(0x00000002), propput, helpstring("Sets or retrieves which panel is currently active in the pen input panel."), helpcontext(0x000003f5)]
        HRESULT CurrentPanel([in] PanelType CurrentPanel);
    [id(0x00000003), propget, helpstring("Sets or retrieves which panel shows in the pen input panel by default."), helpcontext(0x000003f6)]
        HRESULT DefaultPanel([out, retval] PanelType* pDefaultPanel);
    [id(0x00000003), propput, helpstring("Sets or retrieves which panel shows in the pen input panel by default."), helpcontext(0x000003f6)]
        HRESULT DefaultPanel([in] PanelType pDefaultPanel);
    [id(0x00000004), propget, helpstring("Sets or retrieves the visible state of the PenInputPanel object."), helpcontext(0x000003f7)]
        HRESULT Visible([out, retval] VARIANT_BOOL* Visible);
    [id(0x00000004), propput, helpstring("Sets or retrieves the visible state of the PenInputPanel object."), helpcontext(0x000003f7)]
        HRESULT Visible([in] VARIANT_BOOL Visible);
    [id(0x00000005), propget, helpstring("Retrieves the vertical location of the top edge of the pen input panel."), helpcontext(0x000003f8)]
        HRESULT Top([out, retval] long* Top);
    [id(0x00000006), propget, helpstring("Retrieves the horizontal location of the left edge of the pen input panel."), helpcontext(0x000003f9)]
        HRESULT Left([out, retval] long* Left);
    [id(0x00000007), propget, helpstring("Retrieves the width of the pen input panel in client coordinates."), helpcontext(0x000003fa)]
        HRESULT Width([out, retval] long* Width);
    [id(0x00000008), propget, helpstring("Retrieves the height of the pen input panel in client coordinates."), helpcontext(0x000003fb)]
        HRESULT Height([out, retval] long* Height);
    [id(0x0000000d), propget, helpstring("Sets or retrieves the offset between the closest horizontal edge of the pen input panel and the closest horizontal edge of the control to which it is attached."), helpcontext(0x000003fc)]
        HRESULT VerticalOffset([out, retval] long* VerticalOffset);
    [id(0x0000000d), propput, helpstring("Sets or retrieves the offset between the closest horizontal edge of the pen input panel and the closest horizontal edge of the control to which it is attached."), helpcontext(0x000003fc)]
        HRESULT VerticalOffset([in] long VerticalOffset);
    [id(0x0000000e), propget, helpstring("Sets or retrieves the offset between the left edge of the pen input panel and the left edge of the control to which it is attached."), helpcontext(0x000003fd)]
        HRESULT HorizontalOffset([out, retval] long* HorizontalOffset);
    [id(0x0000000e), propput, helpstring("Sets or retrieves the offset between the left edge of the pen input panel and the left edge of the control to which it is attached."), helpcontext(0x000003fd)]
        HRESULT HorizontalOffset([in] long HorizontalOffset);
    [id(0x00000010), propget, helpstring("Sets or retrieves a Boolean value that specifies if the pen input panel appears when focus is set using the pen."), helpcontext(0x00000410)]
        HRESULT AutoShow([out, retval] VARIANT_BOOL* pAutoShow);
    [id(0x00000010), propput, helpstring("Sets or retrieves a Boolean value that specifies if the pen input panel appears when focus is set using the pen."), helpcontext(0x00000410)]
        HRESULT AutoShow([in] VARIANT_BOOL pAutoShow);
    [id(0x00000009), helpstring("Sets the position of the PenInputPanel object to a static screen position."), helpcontext(0x000003ff)]
        HRESULT MoveTo(
            [in] long Left,
            [in] long Top);
    [id(0x0000000a), helpstring("Sends collected ink to the recognizer."), helpcontext(0x00000400)]
        HRESULT CommitPendingInput();
    [id(0x0000000b), helpstring("Forces a complete repaint of a control."), helpcontext(0x00000435)]
        HRESULT Refresh();
    [id(0x0000000f), helpstring("When passed TRUE, the PenInputPanel object attempts to send text to the attached control through the Text Services Framework (TSF) and enables the use of the correction user interface."), helpcontext(0x00000402)]
        HRESULT EnableTsf([in] VARIANT_BOOL Enable);

    [
        uuid(B7E489DA-3719-439F-848F-E7ACBD820F17),
            helpstring("PenInputPanel Event Interface"),
            helpcontext(0x00000406)
    ]
        dispinterface _IPenInputPanelEvents
    {
            properties:
            methods:
                [id(0x00000002), helpstring("Occurs when input focus changes before the PenInputPanel object was able to insert user input into the attached control."), helpcontext(0x0000040a)]
                HRESULT InputFailed(
                                [in] int hWnd,
                                [in] long Key,
                                [in] BSTR Text,
                                [in] short ShiftKey);
                [id(00000000), helpstring("Occurs when the PenInputPanel object has shown or hidden itself."), helpcontext(0x00000407)]
                HRESULT VisibleChanged([in] VARIANT_BOOL NewVisibility);
                [id(0x00000001), helpstring("Occurs when the PenInputPanel object changes between layouts."), helpcontext(0x00000409)]
                HRESULT PanelChanged([in] PanelType NewPanelType);
                [id(0x00000003), helpstring("Occurs when the PenInputPanel object is moving."), helpcontext(0x00000408)]
                HRESULT PanelMoving(
                                [in, out] long* Left,
                                [in, out] long* Top);
    };


    [
        odl,
            uuid(56FDEA97-ECD6-43E7-AA3A-816BE7785860),
            helpstring("IHandwrittenTextInsertion interface")
    ]
        interface IHandwrittenTextInsertion : stdole.IUnknown 
    {
        HRESULT _stdcall InsertRecognitionResultsArray(
            [in] SAFEARRAY(BSTR) psaAlternates,
            [in] long locale,
            [in] long fAlternateContainsAutoSpacingInformation);
        HRESULT _stdcall InsertInkRecognitionResult(
            [in] IInkRecognitionResult* pIInkRecoResult,
            [in] long locale,
            [in] long fAlternateContainsAutoSpacingInformation);
    };

    [
        uuid(9F074EE2-E6E9-4D8A-A047-EB5B5C3C55DA)
    ]
        coclass HandwrittenTextInsertion {
        [default] interface IHandwrittenTextInsertion;
    };



    [
        uuid(F744E496-1B5A-489E-81DC-FBD7AC6298A8),
            helpstring("The PenInputPanel allows you to add in-place pen input to your applications."),
            helpcontext(0x0000040d)
    ]
        coclass PenInputPanel {
        [default] interface IPenInputPanel;
        [default, source] dispinterface _IPenInputPanelEvents;
    };


//#ifndef __ITextInputPanelEventSink_INTERFACE_DEFINED__
//#define __ITextInputPanelEventSink_INTERFACE_DEFINED__
//
///* interface ITextInputPanelEventSink */
///* [oleautomation][unique][uuid][object] */
//
//
//EXTERN_C const IID IID_ITextInputPanelEventSink;
//
//#if defined(__cplusplus) && !defined(CINTERFACE)

    [
        odl,
            uuid(27560408-8E64-4FE1-804E-421201584B31),
            oleautomation
    ]
    interface ITextInputPanelEventSink : stdole.IUnknown 
    {
        HRESULT _stdcall InPlaceStateChanging(
            [in] PIP_InPlaceState oldInPlaceState,
            [in] PIP_InPlaceState newInPlaceState);
        HRESULT _stdcall InPlaceStateChanged(
            [in] PIP_InPlaceState oldInPlaceState,
            [in] PIP_InPlaceState newInPlaceState);
        HRESULT _stdcall InPlaceSizeChanging(
/*            [in] RECT oldBoundingRectangle,
            [in] RECT newBoundingRectangle*/
              [in] long oldBoundingRectangleLeft, [in] long oldBoundingRectangleTop, [in] long oldBoundingRectangleRight, [in] long oldBoundingRectangleBottom,
            [in] long newBoundingRectangleLeft, [in] long newBoundingRectangleTop, [in] long newBoundingRectangleRight, [in] long newBoundingRectangleBottom);
        HRESULT _stdcall InPlaceSizeChanged(
            /*            [in] RECT oldBoundingRectangle,
                        [in] RECT newBoundingRectangle*/
            [in] long oldBoundingRectangleLeft, [in] long oldBoundingRectangleTop, [in] long oldBoundingRectangleRight, [in] long oldBoundingRectangleBottom,
            [in] long newBoundingRectangleLeft, [in] long newBoundingRectangleTop, [in] long newBoundingRectangleRight, [in] long newBoundingRectangleBottom);
        HRESULT _stdcall InputAreaChanging(
            [in] PIP_PanelInputArea oldInputArea,
            [in] PIP_PanelInputArea newInputArea);
        HRESULT _stdcall InputAreaChanged(
            [in] PIP_PanelInputArea oldInputArea,
            [in] PIP_PanelInputArea newInputArea);
        HRESULT _stdcall CorrectionModeChanging(
            [in] PIP_CorrectionMode oldCorrectionMode,
            [in] PIP_CorrectionMode newCorrectionMode);
        HRESULT _stdcall CorrectionModeChanged(
            [in] PIP_CorrectionMode oldCorrectionMode,
            [in] PIP_CorrectionMode newCorrectionMode);
        HRESULT _stdcall InPlaceVisibilityChanging(
            [in] long oldVisible,
            [in] long newVisible);
        HRESULT _stdcall InPlaceVisibilityChanged(
            [in] long oldVisible,
            [in] long newVisible);
        HRESULT _stdcall TextInserting([in] SAFEARRAY(IInkDisp*) Ink);
        HRESULT _stdcall TextInserted([in] SAFEARRAY(IInkDisp*) Ink);
    };
    [
        odl,
            uuid(6B6A65A5-6AF3-46C2-B6EA-56CD1F80DF71),
            helpstring("ITextInputPanel Interface"),
            oleautomation
    ]
        interface ITextInputPanel : stdole.IUnknown 
    {
        [propget]
            HRESULT _stdcall AttachedEditWindow([out, retval] LongPtr* AttachedEditWindow);
        [propput]
            HRESULT _stdcall AttachedEditWindow([in] LongPtr AttachedEditWindow);
        [propget]
            HRESULT _stdcall CurrentInteractionMode([out, retval] PIP_InteractionMode* CurrentInteractionMode);
        [propget]
            HRESULT _stdcall DefaultInPlaceState([out, retval] PIP_InPlaceState* State);
        [propput]
            HRESULT _stdcall DefaultInPlaceState([in] PIP_InPlaceState State);
        [propget]
            HRESULT _stdcall CurrentInPlaceState([out, retval] PIP_InPlaceState* State);
        [propget]
            HRESULT _stdcall DefaultInputArea([out, retval] PIP_PanelInputArea* Area);
        [propput]
            HRESULT _stdcall DefaultInputArea([in] PIP_PanelInputArea Area);
        [propget]
            HRESULT _stdcall CurrentInputArea([out, retval] PIP_PanelInputArea* Area);
        [propget]
            HRESULT _stdcall CurrentCorrectionMode([out, retval] PIP_CorrectionMode* Mode);
        [propget]
            HRESULT _stdcall PreferredInPlaceDirection([out, retval] PIP_InPlaceDirection* Direction);
        [propput]
            HRESULT _stdcall PreferredInPlaceDirection([in] PIP_InPlaceDirection Direction);
        [propget]
            HRESULT _stdcall ExpandPostInsertionCorrection([out, retval] long* Expand);
        [propput]
            HRESULT _stdcall ExpandPostInsertionCorrection([in] long Expand);
        [propget]
            HRESULT _stdcall InPlaceVisibleOnFocus([out, retval] long* Visible);
        [propput]
            HRESULT _stdcall InPlaceVisibleOnFocus([in] long Visible);
        [propget]
            HRESULT _stdcall InPlaceBoundingRectangle([out, retval] RECT* BoundingRectangle);
        [propget]
            HRESULT _stdcall PopUpCorrectionHeight([out, retval] int* Height);
        [propget]
            HRESULT _stdcall PopDownCorrectionHeight([out, retval] int* Height);
        HRESULT _stdcall CommitPendingInput();
        HRESULT _stdcall SetInPlaceVisibility([in] long Visible);
        HRESULT _stdcall SetInPlacePosition(
            [in]  int xPosition,
            [in] int yPosition,
            [in] PIP_CorrectionPosition position);
        HRESULT _stdcall SetInPlaceHoverTargetPosition(
            [in] int xPosition,
            [in] int yPosition);
        HRESULT _stdcall Advise(
            [in] ITextInputPanelEventSink* EventSink,
            [in] long EventMask);
        HRESULT _stdcall Unadvise([in] ITextInputPanelEventSink* EventSink);
    };

    [
        odl,
            uuid(4AF81847-FDC4-4FC3-AD0B-422479C1B935),
            helpstring("IInputPanelWindowHandle Interface"),
            oleautomation
    ]
        interface IInputPanelWindowHandle : stdole.IUnknown 
    {
        [propget]
            HRESULT _stdcall AttachedEditWindow32([out, retval] int* AttachedEditWindow);
        [propput]
            HRESULT _stdcall AttachedEditWindow32([in] int AttachedEditWindow);
        [propget]
            HRESULT _stdcall AttachedEditWindow64([out, retval] int64* AttachedEditWindow);
        [propput]
            HRESULT _stdcall AttachedEditWindow64([in] int64 AttachedEditWindow);
    };

    [
        odl,
            uuid(9F424568-1920-48CC-9811-A993CBF5ADBA),
            helpstring("ITextInputPanelRunInfo"),
            oleautomation
    ]
        interface ITextInputPanelRunInfo : stdole.IUnknown 
    {
        HRESULT _stdcall IsTipRunning([out] long* pfRunning);
    };

    [
        uuid(F9B189D7-228B-4F2B-8650-B97F59E02C8C)
    ]
        coclass TextInputPanel {
        [default] interface ITextInputPanel;
        interface IInputPanelWindowHandle;
        interface ITextInputPanelRunInfo;
    };

    [
        uuid(802B1FB9-056B-4720-B0CC-80D23B71171E)
    ]
        coclass PenInputPanel_Internal {
        [default] interface IUnknown;
    };










//rtscom.h

interface IRealTimeStylus;
interface IRealTimeStylus2;
interface IRealTimeStylus3;
interface IRealTimeStylusSynchronization;
interface IStrokeBuilder;
interface IStylusPlugin;
interface IStylusSyncPlugin;
interface IStylusAsyncPlugin;
interface IDynamicRenderer;
interface IGestureRecognizer;










typedef
enum RealTimeStylusDataInterest
{
    RTSDI_AllData = 0xffffffff,
    RTSDI_None = 0,
    RTSDI_Error = 0x1,
    RTSDI_RealTimeStylusEnabled = 0x2,
    RTSDI_RealTimeStylusDisabled = 0x4,
    RTSDI_StylusNew = 0x8,
    RTSDI_StylusInRange = 0x10,
    RTSDI_InAirPackets = 0x20,
    RTSDI_StylusOutOfRange = 0x40,
    RTSDI_StylusDown = 0x80,
    RTSDI_Packets = 0x100,
    RTSDI_StylusUp = 0x200,
    RTSDI_StylusButtonUp = 0x400,
    RTSDI_StylusButtonDown = 0x800,
    RTSDI_SystemEvents = 0x1000,
    RTSDI_TabletAdded = 0x2000,
    RTSDI_TabletRemoved = 0x4000,
    RTSDI_CustomStylusDataAdded = 0x8000,
    RTSDI_UpdateMapping = 0x10000,
    RTSDI_DefaultEvents = 0x9386 // ((((((RTSDI_RealTimeStylusEnabled | RTSDI_RealTimeStylusDisabled) | RTSDI_StylusDown) | RTSDI_Packets) | RTSDI_StylusUp) | RTSDI_SystemEvents) | RTSDI_CustomStylusDataAdded)
}     RealTimeStylusDataInterest;

typedef CURSOR_ID STYLUS_ID;

typedef struct RTS_StylusInfo
{
    TABLET_CONTEXT_ID tcid;
    STYLUS_ID cid;
    BOOL bIsInvertedCursor;
}     RTS_StylusInfo;

typedef
enum RTS_StylusQueue
{
    SyncStylusQueue = 0x1,
    AsyncStylusQueueImmediate = 0x2,
    AsyncStylusQueue = 0x3
}     RTS_StylusQueue;

typedef
enum RealTimeStylusLockType
{
    RTSLT_ObjLock = 0x1,
    RTSLT_SyncEventLock = 0x2,
    RTSLT_AsyncEventLock = 0x4,
    RTSLT_ExcludeCallback = 0x8,
    RTSLT_SyncObjLock = 0xb,
    RTSLT_AsyncObjLock = 0xd
}     RealTimeStylusLockType;

typedef struct RTS_GESTURE_DATA
{
    int gestureId;
    int recoConfidence;
    int strokeCount;
}     RTS_GESTURE_DATA;

typedef struct DYNAMIC_RENDERER_CACHED_DATA
{
    LONG strokeId;
    IDynamicRenderer* dynamicRenderer;
}     DYNAMIC_RENDERER_CACHED_DATA;

//#if defined(__cplusplus)
//const GUID GUID_GESTURE_DATA = { 0x41E4EC0F-26AA-455A-9AA5-2CD36CF63FB9} };
//const GUID GUID_DYNAMIC_RENDERER_CACHED_DATA = { 0xBF531B92-25BF-4A95-89AD-0E476B34B4F5} };
//#endif // of if defined(__cplusplus)

[
    odl,
        uuid(A8BB5D22-3144-4a7b-93CD-F34A16BE513A)
]
interface IRealTimeStylus : stdole.IUnknown
{
public:
    [propget] HRESULT Enabled(
        [out, retval] BOOL * pfEnable);

    [propput] HRESULT Enabled(
        [in] BOOL fEnable);

    [propget] HRESULT HWND(
        [out, retval] LongPtr* phwnd);

    [propput] HRESULT HWND(
        [in] LongPtr hwnd);

    [propget] HRESULT WindowInputRectangle(
        [out, retval] RECT* prcWndInputRect);

    [propput] HRESULT WindowInputRectangle(
        [in] RECT* prcWndInputRect);

    HRESULT AddStylusSyncPlugin(
        [in] ULONG iIndex,
        [in] IStylusSyncPlugin* piPlugin);

    HRESULT RemoveStylusSyncPlugin(
        [in] ULONG iIndex,
        [in, out] IStylusSyncPlugin** ppiPlugin);

    HRESULT RemoveAllStylusSyncPlugins(void);

    HRESULT GetStylusSyncPlugin(
        [in] ULONG iIndex,
        [in, out] IStylusSyncPlugin** ppiPlugin);

    HRESULT GetStylusSyncPluginCount(
        [in, out] ULONG* pcPlugins);

    HRESULT AddStylusAsyncPlugin(
        [in] ULONG iIndex,
        [in] IStylusAsyncPlugin* piPlugin);

    HRESULT RemoveStylusAsyncPlugin(
        [in] ULONG iIndex,
        [in, out] IStylusAsyncPlugin** ppiPlugin);

    HRESULT RemoveAllStylusAsyncPlugins(void);

    HRESULT GetStylusAsyncPlugin(
        [in] ULONG iIndex,
        [in, out] IStylusAsyncPlugin** ppiPlugin);

    HRESULT GetStylusAsyncPluginCount(
        [in, out] ULONG* pcPlugins);

    [propget] HRESULT ChildRealTimeStylusPlugin(
        [out, retval] IRealTimeStylus** ppiRTS);

    [propputref] HRESULT ChildRealTimeStylusPlugin(
       [in] IRealTimeStylus* piRTS);

    HRESULT AddCustomStylusDataToQueue(
        [in] RTS_StylusQueue sq,
        [in] UUID* pGuidId,
        [in] ULONG cbData,
        [in] void* pbData);

    HRESULT ClearStylusQueues(void);

    HRESULT SetAllTabletsMode(
        [in] BOOL fUseMouseForInput);

    HRESULT SetSingleTabletMode(
        [in] IInkTablet* piTablet);

    HRESULT GetTablet(
        [out, retval] IInkTablet** ppiSingleTablet);

    HRESULT GetTabletContextIdFromTablet(
        [in] IInkTablet* piTablet,
        [out, retval] TABLET_CONTEXT_ID* ptcid);

    HRESULT GetTabletFromTabletContextId(
        [in] TABLET_CONTEXT_ID tcid,
        [out, retval] IInkTablet** ppiTablet);

    HRESULT GetAllTabletContextIds(
        [in, out] ULONG* pcTcidCount,
        [in, out] LongPtr* ppTcids);
        /* [size_is][size_is][out]  __RPC__deref_out_ecount_full_opt(*pcTcidCount) TABLET_CONTEXT_ID** ppTcids);*/

    HRESULT GetStyluses(
        [out, retval] IInkCursors** ppiInkCursors);

    HRESULT GetStylusForId(
        [in] STYLUS_ID sid,
        [out, retval] IInkCursor** ppiInkCursor);

    HRESULT SetDesiredPacketDescription(
        [in] ULONG cProperties,
        [in] UUID* pPropertyGuids);

    HRESULT GetDesiredPacketDescription(
        [in, out] ULONG* pcProperties,
        [in, out] LongPtr* ppPropertyGuids);
        /* [size_is][size_is][out] __RPC__deref_out_ecount_full_opt(*pcProperties) GUID** ppPropertyGuids); */

    HRESULT GetPacketDescriptionData(
        [in] TABLET_CONTEXT_ID tcid,
        [in, out] FLOAT* pfInkToDeviceScaleX,
        [in, out] FLOAT* pfInkToDeviceScaleY,
        [in, out] ULONG* pcPacketProperties,
        [in, out] LongPtr* ppPacketProperties);
        /* [size_is][size_is][out]__RPC__deref_out_ecount_full_opt(*pcPacketProperties) PACKET_PROPERTY** ppPacketProperties); */ 

};

[
    odl,
        uuid(B5F2A6CD-3179-4a3e-B9C4-BB5865962BE2)
]
interface IRealTimeStylus2 : stdole.IUnknown
{
    [propget] HRESULT FlicksEnabled(
        [out, retval] BOOL * pfEnable);

    [propput] HRESULT FlicksEnabled(
        [in] BOOL fEnable);

};

[
    odl,
        uuid(D70230A3-6986-4051-B57A-1CF69F4D9DB5)
]
interface IRealTimeStylus3 : stdole.IUnknown
{
    [propget] HRESULT MultiTouchEnabled(
        [out, retval] BOOL * pfEnable);

    [propput] HRESULT MultiTouchEnabled(
        [in] BOOL fEnable);

};

[
    odl,
        uuid(AA87EAB8-AB4A-4cea-B5CB-46D84C6A2509)
]
interface IRealTimeStylusSynchronization : stdole.IUnknown
{
    HRESULT AcquireLock(
        [in] RealTimeStylusLockType lock);

    HRESULT ReleaseLock(
        [in] RealTimeStylusLockType lock);




};

[
    odl,
        uuid(A5FD4E2D-C44B-4092-9177-260905EB672B)
]
interface IStrokeBuilder : stdole.IUnknown
{
    HRESULT CreateStroke(
        [in] ULONG cPktBuffLength,
        [in] LONG * pPackets,
        [in] ULONG cPacketProperties,
        [in] PACKET_PROPERTY * pPacketProperties,
        [in] FLOAT fInkToDeviceScaleX,
        [in] FLOAT fInkToDeviceScaleY,
        [in, out] IInkStrokeDisp * *ppIInkStroke);

    HRESULT BeginStroke(
        [in] TABLET_CONTEXT_ID tcid,
        [in] STYLUS_ID sid,
        [in] LONG* pPacket,
        [in] ULONG cPacketProperties,
        [in] PACKET_PROPERTY* pPacketProperties,
        [in] FLOAT fInkToDeviceScaleX,
        [in] FLOAT fInkToDeviceScaleY,
        [in, out] IInkStrokeDisp** ppIInkStroke);

    HRESULT AppendPackets(
        [in] TABLET_CONTEXT_ID tcid,
        [in] STYLUS_ID sid,
        [in] ULONG cPktBuffLength,
        [in] LONG* pPackets);

    HRESULT EndStroke(
        [in] TABLET_CONTEXT_ID tcid,
        [in] STYLUS_ID sid,
        [in, out] IInkStrokeDisp** ppIInkStroke,
        [in, out] RECT* pDirtyRect);

    [propget] HRESULT Ink(
        [out, retval] IInkDisp** ppiInkObj);

    [propputref] HRESULT Ink(
        [in] IInkDisp* piInkObj);

};

[
    odl,
        uuid(A81436D8-4757-4fd1-A185-133F97C6C545)
]
interface IStylusPlugin : stdole.IUnknown
{
    HRESULT RealTimeStylusEnabled(
        [in] IRealTimeStylus * piRtsSrc,
        [in] ULONG cTcidCount,
        [in] TABLET_CONTEXT_ID * pTcids);

    HRESULT RealTimeStylusDisabled(
        [in] IRealTimeStylus* piRtsSrc,
        [in] ULONG cTcidCount,
        [in] TABLET_CONTEXT_ID* pTcids);

    HRESULT StylusInRange(
        [in] IRealTimeStylus* piRtsSrc,
        [in] TABLET_CONTEXT_ID tcid,
        [in] STYLUS_ID sid);

    HRESULT StylusOutOfRange(
        [in] IRealTimeStylus* piRtsSrc,
        [in] TABLET_CONTEXT_ID tcid,
        [in] STYLUS_ID sid);

    HRESULT StylusDown(
        [in] IRealTimeStylus* piRtsSrc,
        [in] RTS_StylusInfo* pStylusInfo,
        [in] ULONG cPropCountPerPkt,
        [in] LONG* pPacket,
        [in, out] LongPtr* ppInOutPkt);
        /* [out][in] __RPC__deref_inout_opt LONG** ppInOutPkt); */

    HRESULT StylusUp(
        [in] IRealTimeStylus* piRtsSrc,
        [in] RTS_StylusInfo* pStylusInfo,
        [in] ULONG cPropCountPerPkt,
        [in] LONG* pPacket,
        [in, out] LongPtr* ppInOutPkt);
    /* [out][in] __RPC__deref_inout_opt LONG** ppInOutPkt); */

    HRESULT StylusButtonDown(
        [in] IRealTimeStylus* piRtsSrc,
        [in] STYLUS_ID sid,
        [in] UUID* pGuidStylusButton,
        [in, out] POINT* pStylusPos);

    HRESULT StylusButtonUp(
        [in] IRealTimeStylus* piRtsSrc,
        [in] STYLUS_ID sid,
        [in] UUID* pGuidStylusButton,
        [in, out] POINT* pStylusPos);

    HRESULT InAirPackets(
        [in] IRealTimeStylus* piRtsSrc,
        [in] RTS_StylusInfo* pStylusInfo,
        [in] ULONG cPktCount,
        [in] ULONG cPktBuffLength,
        [in] LONG* pPackets,
        [in, out] ULONG* pcInOutPkts,
        [in, out] LongPtr* ppInOutPkt);
    /* [out][in] __RPC__deref_inout_opt LONG** ppInOutPkt); */

    HRESULT Packets(
        [in] IRealTimeStylus* piRtsSrc,
        [in] RTS_StylusInfo* pStylusInfo,
        [in] ULONG cPktCount,
        [in] ULONG cPktBuffLength,
        [in] LONG* pPackets,
        [in, out] ULONG* pcInOutPkts,
        [in, out] LongPtr* ppInOutPkt);
    /* [out][in] __RPC__deref_inout_opt LONG** ppInOutPkt); */

    HRESULT CustomStylusDataAdded(
        [in] IRealTimeStylus* piRtsSrc,
        [in] UUID* pGuidId,
        [in] ULONG cbData,
        [in] void* pbData);

    HRESULT SystemEvent(
        [in] IRealTimeStylus* piRtsSrc,
        [in] TABLET_CONTEXT_ID tcid,
        [in] STYLUS_ID sid,
        [in] SYSTEM_EVENT event,
        [in] SYSTEM_EVENT_DATA eventdata);

    HRESULT TabletAdded(
        [in] IRealTimeStylus* piRtsSrc,
        [in] IInkTablet* piTablet);

    HRESULT TabletRemoved(
        [in] IRealTimeStylus* piRtsSrc,
        [in] LONG iTabletIndex);

    HRESULT Error(
        [in] IRealTimeStylus* piRtsSrc,
        [in] IStylusPlugin* piPlugin,
        [in] RealTimeStylusDataInterest dataInterest,
        [in] HRESULT hrErrorCode,
        [in, out] LongPtr* lptrKey);

    HRESULT UpdateMapping(
        [in] IRealTimeStylus* piRtsSrc);

    HRESULT DataInterest(
        [out, retval] RealTimeStylusDataInterest* pDataInterest);

};

[
    odl,
        uuid(A157B174-482F-4d71-A3F6-3A41DDD11BE9)
]
interface IStylusSyncPlugin : IStylusPlugin
{
};

[
    odl,
        uuid(A7CCA85A-31BC-4cd2-AADC-3289A3AF11C8)
]
interface IStylusAsyncPlugin : IStylusPlugin
{
};

[
    odl,
        uuid(A079468E-7165-46f9-B7AF-98AD01A93009)
]
interface IDynamicRenderer : stdole.IUnknown
{
    [propget] HRESULT Enabled(
        [out, retval] BOOL * bEnabled);

    [propput] HRESULT Enabled(
        [in] BOOL bEnabled);

    [propget] HRESULT HWND(
        [out, retval] LongPtr* hwnd);

    [propput] HRESULT HWND(
        [in] LongPtr hwnd);

    [propget] HRESULT ClipRectangle(
        [out, retval] RECT* prcClipRect);

    [propput] HRESULT ClipRectangle(
        [in] RECT* prcClipRect);

    [propget] HRESULT ClipRegion(
        [out, retval] LongPtr* phClipRgn);

    [propput] HRESULT ClipRegion(
        [in] LongPtr hClipRgn);

    [propget] HRESULT DrawingAttributes(
        [out, retval] IInkDrawingAttributes** ppiDA);

    [propputref] HRESULT DrawingAttributes(
        [in] IInkDrawingAttributes* piDA);

    [propget] HRESULT DataCacheEnabled(
        [out, retval] BOOL* pfCacheData);

    [propput] HRESULT DataCacheEnabled(
        [in] BOOL fCacheData);

    HRESULT ReleaseCachedData(
        [in] ULONG strokeId);

    HRESULT Refresh(void);

    HRESULT Draw(
        [in] LongPtr hDC);

};

[
    odl,
        uuid(AE9EF86B-7054-45e3-AE22-3174DC8811B7)
]
interface IGestureRecognizer : stdole.IUnknown
{
    [propget] HRESULT Enabled(
        [out, retval] BOOL * pfEnabled);

    [propput] HRESULT Enabled(
        [in] BOOL fEnabled);

    [propget] HRESULT MaxStrokeCount(
        [out, retval] long* pcStrokes);

    [propput] HRESULT MaxStrokeCount(
        [in] long cStrokes);

    HRESULT EnableGestures(
        [in] ULONG cGestures,
        [in] int* pGestures);

    HRESULT Reset(void);

};




//CLSID_RealTimeStylus;

[
    uuid(E26B366D-F998-43ce-836F-CB6D904432B0)
]
coclass RealTimeStylus
{
    [default] interface IRealTimeStylus;
};

//CLSID_DynamicRenderer;

[
    uuid(ECD32AEA-746F-4dcb-BF68-082757FAFF18)
]
coclass DynamicRenderer
{
    [default] interface IDynamicRenderer;
};

//CLSID_GestureRecognizer;

[
    uuid(EA30C654-C62C-441f-AC00-95F9A196782C)
]
coclass GestureRecognizer
{
    [default] interface IGestureRecognizer;
};

//CLSID_StrokeBuilder;

[
    uuid(E810CEE7-6E51-4cb0-AA3A-0B985B70DAF7)
]
coclass StrokeBuilder
{
    [default] interface IStrokeBuilder;
};








