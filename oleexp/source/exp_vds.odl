


// ***************************************************************
//
// vdscmmn.idl
//
// ***************************************************************

//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2000
//
//    File: vdscmmn.idl
//
//    Abstract:
//        declarations of interfaces and types common to the common layer,
//        software providers, and hardware providers.
//
//----------------------------------------------------------------------------

//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")
//
//import "vdserr.h";
//
//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(push)")
//cpp_quote("#pragma warning(disable:4820) /* padding added after data member */")
//cpp_quote("#endif")

interface IEnumVdsObject;
interface IVdsAsync;
interface IVdsAdviseSink;
interface IVdsProvider;
interface IVdsProviderSupport;

//
// All possible object status
//
//tB Added
typedef enum VdsObjectStatus 
{
     STATUS_UNKNOWN = 0,
     STATUS_ONLINE = 1,
     STATUS_NOT_READY = 2,
     STATUS_NO_MEDIA = 3,
     STATUS_OFFLINE = 4,
     STATUS_FAILED = 5,
     STATUS_MISSING = 6,
     STATUS_STANDBY = 7,
     STATUS_REMOVED = 8,
     STATUS_PARTIALLY_MANAGED =  9
} VdsObjectStatus;
//
// Object IDs
//
//typedef GUID        VDS_OBJECT_ID;

//
// Object types
//
typedef enum VDS_OBJECT_TYPE
{
    // values >=0 and <10 are exposed to the service, client, and provider.
    // values >=10 and <30 are reserved for software providers.
    // values >=30 and <60 are reserved for hardware providers.
    // values >=90 are reserved by the VDS service and not exposed to providers.
    // values >=100 are used internally by the VDS service and not exposed to
    //  clients and providers.
    // values >=200 are reserved for virtual disk storage providers.

    VDS_OT_UNKNOWN = 0,
    VDS_OT_PROVIDER = 1,

    VDS_OT_PACK = 10,
    VDS_OT_VOLUME = 11,
    VDS_OT_VOLUME_PLEX = 12,
    VDS_OT_DISK = 13,

    VDS_OT_SUB_SYSTEM = 30,
    VDS_OT_CONTROLLER = 31,
    VDS_OT_DRIVE = 32,
    VDS_OT_LUN = 33,
    VDS_OT_LUN_PLEX = 34,
    VDS_OT_PORT = 35,
    VDS_OT_PORTAL = 36,
    VDS_OT_TARGET = 37,
    VDS_OT_PORTAL_GROUP = 38,
    VDS_OT_STORAGE_POOL = 39,

    VDS_OT_HBAPORT = 90,
    VDS_OT_INIT_ADAPTER = 91,
    VDS_OT_INIT_PORTAL = 92,

    VDS_OT_ASYNC = 100,
    VDS_OT_ENUM = 101,

    VDS_OT_VDISK = 200,
    VDS_OT_OPEN_VDISK = 201,
} VDS_OBJECT_TYPE;
// Partitions and extents are not COM objects.

//
// Provider Types
//
typedef enum VDS_PROVIDER_TYPE
{
    VDS_PT_UNKNOWN = 0,
    VDS_PT_SOFTWARE = 1,
    VDS_PT_HARDWARE = 2,
    VDS_PT_VIRTUALDISK = 3,
    VDS_PT_MAX = 4
} VDS_PROVIDER_TYPE;

//
// Provider Flags
//
typedef enum VDS_PROVIDER_FLAG
{
    //
    // This flag is set by dynamic providers. Applications can tell from
    // this flag if a disk is dynamic or not.
    //

    VDS_PF_DYNAMIC = 0x00000001,

    //
    // The hardware provider manages an in-box hardware controller,
    // instead of a external RAID cabinet.
    //

    VDS_PF_INTERNAL_HARDWARE_PROVIDER = 0x00000002,

    //
    // This flag is for basic provider which does not really have the
    // concept of pack. We fake a pack for each basic disk. The pack
    // contains only one disk.
    //

    VDS_PF_ONE_DISK_ONLY_PER_PACK = 0x00000004,

    //
    // This flag is for downrev provider. On a downrev machine, multiple
    // disk groups(pack) are not supported. Only one pack can be online
    // at a time.
    //

    VDS_PF_ONE_PACK_ONLINE_ONLY = 0x00000008,

    //
    // All volumes managed by this provider must have contiguous space.
    // This flag currently applies to basic provider only. We may remove
    // it if we think it's enough to have VDS_PF_DYNAMIC flag.
    //

    VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS = 0x00000010,

    //
    // These three are internal flags that will be translated to
    // VDS_SVF_SUPPORT_DYNAMIC, VDS_SVF_SUPPORT_FAULT_TOLERANT
    // VDS_SVF_SUPPORT_DYNAMIC_1394 by the service.
    //

    VDS_PF_SUPPORT_DYNAMIC = 0x80000000,
    VDS_PF_SUPPORT_FAULT_TOLERANT = 0x40000000,   // Indicates that both mirrors and RAID5 are supported.
    VDS_PF_SUPPORT_DYNAMIC_1394 = 0x20000000,


    //
    // Added for Windows 7. Client SKUs support mirrors but not RAID5.
    // No change to server SKUs, both mirrors and RAID5 are supported.
    // These are for the dynamic provider only.
    //

    VDS_PF_SUPPORT_MIRROR = 0x00000020,
    VDS_PF_SUPPORT_RAID5 = 0x00000040

} VDS_PROVIDER_FLAG;

//
// Recover Actions
//
typedef enum VDS_RECOVER_ACTION
{
    VDS_RA_UNKNOWN = 0,
    VDS_RA_REFRESH = 1,
    VDS_RA_RESTART = 2

} VDS_RECOVER_ACTION;

//
// Notification Target Types
//
typedef enum VDS_NOTIFICATION_TARGET_TYPE
{
    VDS_NTT_UNKNOWN = 0,

    VDS_NTT_PACK = 10, //VDS_OT_PACK,
    VDS_NTT_VOLUME = 11, //VDS_OT_VOLUME,
    VDS_NTT_DISK = 13, //VDS_OT_DISK,
    VDS_NTT_PARTITION = 60,

    VDS_NTT_DRIVE_LETTER = 61,
    VDS_NTT_FILE_SYSTEM = 62,
    VDS_NTT_MOUNT_POINT = 63,

    VDS_NTT_SUB_SYSTEM = 30, //VDS_OT_SUB_SYSTEM,
    VDS_NTT_CONTROLLER = 31, //VDS_OT_CONTROLLER,
    VDS_NTT_DRIVE = 32, //VDS_OT_DRIVE,
    VDS_NTT_LUN = 33, //VDS_OT_LUN,
    VDS_NTT_PORT = 35, //VDS_OT_PORT,
    VDS_NTT_PORTAL = 36, //VDS_OT_PORTAL,
    VDS_NTT_TARGET = 37, //VDS_OT_TARGET,
    VDS_NTT_PORTAL_GROUP = 38, //VDS_OT_PORTAL_GROUP,

    VDS_NTT_SERVICE = 200

} VDS_NOTIFICATION_TARGET_TYPE;

//
// Event types
//     software providers notifications range from 1 to 100.
//     hardware provider notifications range from 101 to 200.
//     service notifications range from 201 to 300.
//     common notifications range from 301 to 400.
//

////
//// pack notifications
////
//const ULONG VDS_NF_PACK_ARRIVE = 1;
//// When a pack is created
//const ULONG VDS_NF_PACK_DEPART = 2;
//// When a pack is deleted
//const ULONG VDS_NF_PACK_MODIFY = 3;
//// When a pack is modified(including online, offline)
//
////
//// volume notifications
////
//const ULONG VDS_NF_VOLUME_ARRIVE = 4;
//// When a volume is created or discovered.
//const ULONG VDS_NF_VOLUME_DEPART = 5;
//// When a volume is deleted or disappears.
//const ULONG VDS_NF_VOLUME_MODIFY = 6;
//// When something changed in the volume's VDS_VOLUME_PROP structure.
//const ULONG VDS_NF_VOLUME_REBUILDING_PROGRESS = 7;
//// When a volume is in rebuilding process.
//
//
////
//// disk notifications
////
//const ULONG VDS_NF_DISK_ARRIVE = 8;
//// When a spindle is plugged in, or a RAID controller surfaced a LUN
//// that is local to the host.
//const ULONG VDS_NF_DISK_DEPART = 9;
//// When a spindle is unplugged, or a RAID controller unbound a LUN
//// that was local to the host.
//const ULONG VDS_NF_DISK_MODIFY = 10;
//// When something changed in the disk's VDS_DISK_PROP structure.
//
////
//// partition notifications
////
//const ULONG VDS_NF_PARTITION_ARRIVE = 11;
//// When a partition is created. If the partition is also a volume,
//// a volume arrival notification will also be sent.
//const ULONG VDS_NF_PARTITION_DEPART = 12;
//// When a partition is deleted. If the partition is also a volume,
//// a volume removal notification will also be sent.
//const ULONG VDS_NF_PARTITION_MODIFY = 13;
//// When a partition is changed. If the partition is also a volume,
//// and if the partition attributes change, a volume change notification
//// will also be sent.
//
////
//// subsystem notifications
////
//
//const ULONG     VDS_NF_SUB_SYSTEM_ARRIVE = 101;
//// When a new subsystem is discovered.
//const ULONG     VDS_NF_SUB_SYSTEM_DEPART = 102;
//// When a subsystem is disconnected.
//// NOTE: more subystem notifications continue below starting at 151
//
////
//// controller notifications
////
//const ULONG     VDS_NF_CONTROLLER_ARRIVE = 103;  // ONLINE
//// When a controller goes online.
//const ULONG     VDS_NF_CONTROLLER_DEPART = 104;  // OFFLINE
//// When a controller goes offline.
//
////
//// drive notifications
////
//const ULONG     VDS_NF_DRIVE_ARRIVE = 105;
//// When a spindle is plugged in behind a RAID controller.
//const ULONG     VDS_NF_DRIVE_DEPART = 106;
//// When a spindle is unplugged behind a RAID controller.
//const ULONG     VDS_NF_DRIVE_MODIFY = 107;
//// When something changed in the spindle's VDS_DRIVE_PROP structure.
//
////
//// LUN notifications
////     The three LUN notifications will be sent only when the LUN is not
////     local to the machine. Otherwise, disk notifications will be sent.
////
//const ULONG     VDS_NF_LUN_ARRIVE = 108;
//// When a LUN is created.
//const ULONG     VDS_NF_LUN_DEPART = 109;
//// When a LUN is deleted.
//const ULONG     VDS_NF_LUN_MODIFY = 110;
//// When something changed in the LUN's VDS_LUN_PROP structure.
//// TODO: add VDS_NF_LUN_REBUILDING_PROGRESS?
//
////
//// controller port notifications
////
//const ULONG     VDS_NF_PORT_ARRIVE = 121;  // ONLINE
//// When a controller port goes online.
//const ULONG     VDS_NF_PORT_DEPART = 122;  // OFFLINE
//// When a controller port goes offline.
//
////
//// portal notifications
////
//const ULONG     VDS_NF_PORTAL_ARRIVE = 123;
//// When an iSCSI portal is created.
//const ULONG     VDS_NF_PORTAL_DEPART = 124;
//// When an iSCSI portal is removed.
//const ULONG     VDS_NF_PORTAL_MODIFY = 125;
//// When something changed in the iSCSI portal's VDS_ISCSI_PORTAL_PROP structure.
//
////
//// target notifications
////
//const ULONG     VDS_NF_TARGET_ARRIVE = 126;
//// When an iSCSI target is created.
//const ULONG     VDS_NF_TARGET_DEPART = 127;
//// When an iSCSI target is deleted.
//const ULONG     VDS_NF_TARGET_MODIFY = 128;
//// When something changed in the iSCSI portal's VDS_ISCSI_TARGET_PROP structure.
//
////
//// portal group notifications
////
//const ULONG     VDS_NF_PORTAL_GROUP_ARRIVE = 129;
//// When an iSCSI portal group is created.
//const ULONG     VDS_NF_PORTAL_GROUP_DEPART = 130;
//// When an iSCSI portal group is deleted.
//const ULONG     VDS_NF_PORTAL_GROUP_MODIFY = 131;
//// When something changed in the iSCSI portal group's VDS_ISCSI_PORTALGROUP_PROP structure.
//
////
//// more subsystem notifications
////
//const ULONG     VDS_NF_SUB_SYSTEM_MODIFY = 151;
//// When something changed in the subsystem's VDS_SUB_SYSTEM_PROP structure.
//
////
//// drive letter notifications
////
//const ULONG       VDS_NF_DRIVE_LETTER_FREE = 201;
//// When a drive letter is freed.
//const ULONG       VDS_NF_DRIVE_LETTER_ASSIGN = 202;
//// When a drive letter is assigned.
//
////
//// file system notifications
////
//const ULONG       VDS_NF_FILE_SYSTEM_MODIFY = 203;
//// When a volume gets a new label, or file system is extended or shrunk.
//// Note, this does not include change of file system comression flags.
//const ULONG       VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS = 204;
//// When a file system is being formated.
//// NOTE: more file system notifications continue below starting at 206
//
////
//// mount point notification
////
//const ULONG       VDS_NF_MOUNT_POINTS_CHANGE = 205;
//
////
//// more file system notifications
////
//const ULONG       VDS_NF_FILE_SYSTEM_SHRINKING_PROGRESS = 206;
//// When a file system is in the process of shrinking
//
////
//// common notifications
////
//const ULONG     VDS_NF_SERVICE_OUT_OF_SYNC = 301;
//
////
//// Windows 7 notifications
////
//
////
//// controller notifications
////
//const ULONG     VDS_NF_CONTROLLER_MODIFY = 350;
//// When something changed in controller's properties.
//const ULONG     VDS_NF_CONTROLLER_REMOVED = 351;
//// When a controller is removed.
//
////
//// controller port notifications
////
//const ULONG     VDS_NF_PORT_MODIFY = 352;
//// When something changed in controller port's properties.
//const ULONG     VDS_NF_PORT_REMOVED = 353;
//// When a controller port is removed.
//
//
////
//// drive notifications
////
//const ULONG     VDS_NF_DRIVE_REMOVED = 354;
//// When a drive is removed.

//
// Notification Structs
//

typedef struct VDS_PACK_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       packId;

} VDS_PACK_NOTIFICATION;

typedef struct VDS_DISK_NOTIFICATION
{
    ULONG               ulEvent;  // arrival, departure, modified.
    UUID       diskId;

} VDS_DISK_NOTIFICATION;

typedef struct VDS_VOLUME_NOTIFICATION
{
    ULONG               ulEvent;
    // created, deleted, modified, resyncing progress
    UUID       volumeId;
    UUID       plexId;
    // This is for resyncing and rebuilding only.
    // resyncing can happen on more than one plex at
    // different pace.
    ULONG               ulPercentCompleted;

} VDS_VOLUME_NOTIFICATION;

typedef struct VDS_PARTITION_NOTIFICATION
{
    ULONG               ulEvent;
    // created, deleted, modified, resyncing progress
    UUID       diskId;
    ULONGLONG           ullOffset;

} VDS_PARTITION_NOTIFICATION;

typedef struct VDS_SERVICE_NOTIFICATION
{
    ULONG               ulEvent;
    VDS_RECOVER_ACTION  action;

} VDS_SERVICE_NOTIFICATION;

typedef struct VDS_DRIVE_LETTER_NOTIFICATION
{
    ULONG               ulEvent;  // freed, used
    WCHAR               wcLetter;
    UUID       volumeId;

} VDS_DRIVE_LETTER_NOTIFICATION;

typedef struct VDS_FILE_SYSTEM_NOTIFICATION
{
    ULONG               ulEvent;  // created, format progress
    UUID       volumeId;
    DWORD               dwPercentCompleted;

} VDS_FILE_SYSTEM_NOTIFICATION;

typedef struct VDS_MOUNT_POINT_NOTIFICATION
{
    ULONG               ulEvent;  // mount points changed
    UUID       volumeId;

} VDS_MOUNT_POINT_NOTIFICATION;

typedef struct VDS_SUB_SYSTEM_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       subSystemId;

} VDS_SUB_SYSTEM_NOTIFICATION;

typedef struct VDS_CONTROLLER_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       controllerId;

} VDS_CONTROLLER_NOTIFICATION;

typedef struct VDS_DRIVE_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       driveId;

} VDS_DRIVE_NOTIFICATION;

typedef struct VDS_LUN_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       LunId;

} VDS_LUN_NOTIFICATION;

typedef struct VDS_PORT_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       portId;

} VDS_PORT_NOTIFICATION;

typedef struct VDS_PORTAL_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       portalId;

} VDS_PORTAL_NOTIFICATION;

typedef struct VDS_TARGET_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       targetId;

} VDS_TARGET_NOTIFICATION;

typedef struct VDS_PORTAL_GROUP_NOTIFICATION
{
    ULONG               ulEvent;
    UUID       portalGroupId;

} VDS_PORTAL_GROUP_NOTIFICATION;

typedef struct VDS_NOTIFICATION
{
    VDS_NOTIFICATION_TARGET_TYPE    objectType;
    //[switch_is(objectType)] union
    //{
    //    [case(VDS_NTT_PACK)]
    //        VDS_PACK_NOTIFICATION           Pack;
    //    [case(VDS_NTT_DISK)]
    //        VDS_DISK_NOTIFICATION           Disk;
    //    [case(VDS_NTT_VOLUME)]
    //        VDS_VOLUME_NOTIFICATION         Volume;
    //    [case(VDS_NTT_PARTITION)]
    //        VDS_PARTITION_NOTIFICATION      Partition;

    //    [case(VDS_NTT_DRIVE_LETTER)]
    //        VDS_DRIVE_LETTER_NOTIFICATION   Letter;
    //    [case(VDS_NTT_FILE_SYSTEM)]
    //        VDS_FILE_SYSTEM_NOTIFICATION    FileSystem;
    //    [case(VDS_NTT_MOUNT_POINT)]
    //        VDS_MOUNT_POINT_NOTIFICATION    MountPoint;

    //    [case(VDS_NTT_SUB_SYSTEM)]
    //        VDS_SUB_SYSTEM_NOTIFICATION     SubSystem;
    //    [case(VDS_NTT_CONTROLLER)]
    //        VDS_CONTROLLER_NOTIFICATION     Controller;
    //    [case(VDS_NTT_DRIVE)]
    //        VDS_DRIVE_NOTIFICATION          Drive;
    //    [case(VDS_NTT_LUN)]
    //        VDS_LUN_NOTIFICATION            Lun;
    //    [case(VDS_NTT_PORT)]
    //        VDS_PORT_NOTIFICATION           Port;
    //    [case(VDS_NTT_PORTAL)]
    //        VDS_PORTAL_NOTIFICATION         Portal;
    //    [case(VDS_NTT_TARGET)]
    //        VDS_TARGET_NOTIFICATION         Target;
    //    [case(VDS_NTT_PORTAL_GROUP)]
    //        VDS_PORTAL_GROUP_NOTIFICATION   PortalGroup;

    //    [case(VDS_NTT_SERVICE)]
    //        VDS_SERVICE_NOTIFICATION        Service;

    //    [default] ;
    //};
    int pad;
    BYTE u[40];
} VDS_NOTIFICATION;

//
// Async Output Type
//
typedef enum VDS_ASYNC_OUTPUT_TYPE
{
    VDS_ASYNCOUT_UNKNOWN = 0,
    VDS_ASYNCOUT_CREATEVOLUME = 1,
    VDS_ASYNCOUT_EXTENDVOLUME = 2,
    VDS_ASYNCOUT_SHRINKVOLUME = 3,
    VDS_ASYNCOUT_ADDVOLUMEPLEX = 4,
    VDS_ASYNCOUT_BREAKVOLUMEPLEX = 5,
    VDS_ASYNCOUT_REMOVEVOLUMEPLEX = 6,
    VDS_ASYNCOUT_REPAIRVOLUMEPLEX = 7,
    VDS_ASYNCOUT_RECOVERPACK = 8,
    VDS_ASYNCOUT_REPLACEDISK = 9,
    VDS_ASYNCOUT_CREATEPARTITION = 10,
    VDS_ASYNCOUT_CLEAN = 11,
    VDS_ASYNCOUT_CREATELUN = 50,
    //    VDS_ASYNCOUT_BREAKLUNPLEX       = 51, // ** DEPRECATED **
    VDS_ASYNCOUT_ADDLUNPLEX = 52,
    VDS_ASYNCOUT_REMOVELUNPLEX = 53,
    VDS_ASYNCOUT_EXTENDLUN = 54,
    VDS_ASYNCOUT_SHRINKLUN = 55,
    VDS_ASYNCOUT_RECOVERLUN = 56,

    // iSCSI related asyncs
    VDS_ASYNCOUT_LOGINTOTARGET = 60,
    VDS_ASYNCOUT_LOGOUTFROMTARGET = 61,
    VDS_ASYNCOUT_CREATETARGET = 62,
    VDS_ASYNCOUT_CREATEPORTALGROUP = 63,
    VDS_ASYNCOUT_DELETETARGET = 64,
    VDS_ASYNCOUT_ADDPORTAL = 65,
    VDS_ASYNCOUT_REMOVEPORTAL = 66,
    VDS_ASYNCOUT_DELETEPORTALGROUP = 67,

    VDS_ASYNCOUT_FORMAT = 101,

    //
    // Virtual disk related output.
    //
    VDS_ASYNCOUT_CREATE_VDISK = 200,
    VDS_ASYNCOUT_ATTACH_VDISK = 201,
    VDS_ASYNCOUT_COMPACT_VDISK = 202,
    VDS_ASYNCOUT_MERGE_VDISK = 203,
    VDS_ASYNCOUT_EXPAND_VDISK = 204
} VDS_ASYNC_OUTPUT_TYPE;

typedef struct VDS_ASYNC_OUTPUT
{
    VDS_ASYNC_OUTPUT_TYPE type;

    //[switch_is(type)] union
    //{
    //    // CreatePartition() or CreatePartitionEx() return value.
    //    [case(VDS_ASYNCOUT_CREATEPARTITION)]
    //        struct _cp
    //    {
    //        ULONGLONG ullOffset;    // acual offset of the create partition
    //        UUID volumeId; // ID of the associated volume if the
    //        // partition is a volume.
    //    } cp;

    //    // CreateVolume() return value
    //    [case(VDS_ASYNCOUT_CREATEVOLUME)]
    //        struct _cv
    //    {
    //        IUnknown* pVolumeUnk;

    //    } cv;

    //    // BreakPlex() return value
    //    [case(VDS_ASYNCOUT_BREAKVOLUMEPLEX)]
    //        struct _bvp
    //    {
    //        IUnknown* pVolumeUnk;

    //    } bvp;

    //    // Shrink() return value
    //    [case(VDS_ASYNCOUT_SHRINKVOLUME)]
    //        struct _sv
    //    {
    //        ULONGLONG    ullReclaimedBytes;    // actual number of reclaimed bytes
    //    } sv;


    //    [case(VDS_ASYNCOUT_CREATELUN)]
    //        struct _cl
    //    {
    //        IUnknown* pLunUnk;

    //    } cl;

    //    /** DEPRECATED **
    //    *        [case(VDS_ASYNCOUT_BREAKLUNPLEX)]
    //    *        struct _blp
    //    *        {
    //    *            IUnknown *pLunUnk;
    //    *
    //    *        } blp;
    //    */

    //    // CreateTarget() return value
    //    [case(VDS_ASYNCOUT_CREATETARGET)]
    //        struct _ct
    //    {
    //        IUnknown* pTargetUnk;

    //    } ct;

    //    // CreatePortalGroup() return value
    //    [case(VDS_ASYNCOUT_CREATEPORTALGROUP)]
    //        struct _cpg
    //    {
    //        IUnknown* pPortalGroupUnk;

    //    } cpg;

    //    [case(VDS_ASYNCOUT_CREATE_VDISK)]
    //        struct _cvd
    //    {
    //        IUnknown* pVDiskUnk;

    //    } cvd;

    //    [default] ;
    //};
    int pad;
    BYTE u[24];
} VDS_ASYNC_OUTPUT;


//
// iSCSI Portal Group Tags
//
//typedef USHORT  VDS_ISCSI_PORTALGROUP_TAG;


//
// IP address type
//
typedef enum VDS_IPADDRESS_TYPE
{
    VDS_IPT_TEXT = 0,
    VDS_IPT_IPV4 = 1,
    VDS_IPT_IPV6 = 2,
    VDS_IPT_EMPTY = 3
} VDS_IPADDRESS_TYPE;


//
// Object Health
//
//tB Added
typedef enum VDS_HEALTH
{
    VDS_H_UNKNOWN = 0,
    VDS_H_HEALTHY = 1,
    VDS_H_REBUILDING = 2,
    VDS_H_STALE = 3,
    VDS_H_FAILING = 4,
    VDS_H_FAILING_REDUNDANCY = 5,
    VDS_H_FAILED_REDUNDANCY = 6,
    VDS_H_FAILED_REDUNDANCY_FAILING = 7,
    VDS_H_FAILED = 8,
    VDS_H_REPLACED = 9,
    VDS_H_PENDING_FAILURE = 10,
    VDS_H_DEGRADED = 11

} VDS_HEALTH;

//
// Object TransitionState (configuration stability)
//
//tB Added
typedef enum VDS_TRANSITION_STATE
{
    VDS_TS_UNKNOWN = 0,
    VDS_TS_STABLE = 1,
    VDS_TS_EXTENDING = 2,
    VDS_TS_SHRINKING = 3,
    VDS_TS_RECONFIGING = 4,    // Volume is changing location on disk.
    VDS_TS_RESTRIPING = 5

} VDS_TRANSITION_STATE;

//
// File System Types
// NOTE: IVdsAdvancedDisk::FormatPartition() method in the software provider
//       interface references this type, although this method is implemented
//       only by the service.
//
//tB Added
typedef enum VDS_FILE_SYSTEM_TYPE
{
    VDS_FST_UNKNOWN = 0,
    VDS_FST_RAW,
    VDS_FST_FAT,
    VDS_FST_FAT32,
    VDS_FST_NTFS,
    VDS_FST_CDFS,
    VDS_FST_UDF,
    VDS_FST_EXFAT,
    VDS_FST_CSVFS,
    VDS_FST_REFS

} VDS_FILE_SYSTEM_TYPE;

//
// --- HBA port related enums ---
//

//
// Types
//
typedef enum VDS_HBAPORT_TYPE
{
    // These types correspond to the definitions in the HBA API
    VDS_HPT_UNKNOWN = 1,    // Unknown
    VDS_HPT_OTHER = 2,    // Other
    VDS_HPT_NOTPRESENT = 3,    // Not present
    VDS_HPT_NPORT = 5,    // Fabric
    VDS_HPT_NLPORT = 6,    // Public Loop
    VDS_HPT_FLPORT = 7,    // Fabric on a Loop
    VDS_HPT_FPORT = 8,    // Fabric Port
    VDS_HPT_EPORT = 9,    // Fabric Expansion Port
    VDS_HPT_GPORT = 10,   // Generic Fabric Port
    VDS_HPT_LPORT = 20,   // Private Loop
    VDS_HPT_PTP = 21    // Point to Point

} VDS_HBAPORT_TYPE;

//
// Status
//
typedef enum VDS_HBAPORT_STATUS
{
    // These states correspond to the definitions in the HBA API
    VDS_HPS_UNKNOWN = 1,    // Unknown
    VDS_HPS_ONLINE = 2,    // Operational
    VDS_HPS_OFFLINE = 3,    // User Offline
    VDS_HPS_BYPASSED = 4,    // Bypassed
    VDS_HPS_DIAGNOSTICS = 5,    // In Diagnostics Mode
    VDS_HPS_LINKDOWN = 6,    // Link Down
    VDS_HPS_ERROR = 7,    // Port Error
    VDS_HPS_LOOPBACK = 8     // Loopback

} VDS_HBAPORT_STATUS;

//
// Flags
//
typedef enum VDS_HBAPORT_SPEED_FLAG
{
    // These flags correspond to the definitions in the HBA API
    VDS_HSF_UNKNOWN = 0x0,      // Unknown - transceiver incapable of reporting
    VDS_HSF_1GBIT = 0x1,      // 1 GBit/sec
    VDS_HSF_2GBIT = 0x2,      // 2 GBit/sec
    VDS_HSF_10GBIT = 0x4,      // 10 GBit/sec
    VDS_HSF_4GBIT = 0x8,      // 4 GBit/sec
    VDS_HSF_NOT_NEGOTIATED = 0x8000 //(1 << 15) // Speed not established

} VDS_HBAPORT_SPEED_FLAG;


//
// --- MPIO related enums ---
//

//
// Path Status
//
typedef enum VDS_PATH_STATUS
{
    VDS_MPS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_MPS_ONLINE = 1, //STATUS_ONLINE,
    VDS_MPS_FAILED = 5, //STATUS_FAILED,
    VDS_MPS_STANDBY = 7 //STATUS_STANDBY

} VDS_PATH_STATUS;


//
// Load balance policy
//
typedef enum VDS_LOADBALANCE_POLICY_ENUM
{
    VDS_LBP_UNKNOWN = 0,
    VDS_LBP_FAILOVER = 1,
    VDS_LBP_ROUND_ROBIN = 2,
    VDS_LBP_ROUND_ROBIN_WITH_SUBSET = 3,
    VDS_LBP_DYN_LEAST_QUEUE_DEPTH = 4,
    VDS_LBP_WEIGHTED_PATHS = 5,
    VDS_LBP_LEAST_BLOCKS = 6,
    VDS_LBP_VENDOR_SPECIFIC = 7

} VDS_LOADBALANCE_POLICY_ENUM;


//
// Load Balance Policy Support Flags
//
typedef enum VDS_PROVIDER_LBSUPPORT_FLAG
{
    VDS_LBF_FAILOVER = 0x01,
    VDS_LBF_ROUND_ROBIN = 0x02,
    VDS_LBF_ROUND_ROBIN_WITH_SUBSET = 0x04,
    VDS_LBF_DYN_LEAST_QUEUE_DEPTH = 0x08,
    VDS_LBF_WEIGHTED_PATHS = 0x10,
    VDS_LBF_LEAST_BLOCKS = 0x20,
    VDS_LBF_VENDOR_SPECIFIC = 0x40

} VDS_PROVIDER_LBSUPPORT_FLAG;


//
// --- Provider related enums ---
//

//
// Version Support Flags
//
typedef enum VDS_VERSION_SUPPORT_FLAG
{
    VDS_VSF_1_0 = 0x01,
    VDS_VSF_1_1 = 0x02,
    VDS_VSF_2_0 = 0x04,
    VDS_VSF_2_1 = 0x08,
    VDS_VSF_3_0 = 0x10

} VDS_VERSION_SUPPORT_FLAG;


//
// --- HwProvider related enums ---
//

//
// Types
//
typedef enum VDS_HWPROVIDER_TYPE
{
    VDS_HWT_UNKNOWN = 0,
    VDS_HWT_PCI_RAID = 1,
    VDS_HWT_FIBRE_CHANNEL = 2,
    VDS_HWT_ISCSI = 3,
    VDS_HWT_SAS = 4,
    VDS_HWT_HYBRID = 5
} VDS_HWPROVIDER_TYPE;


//
// --- iSCSI related enums ---
//

//
// Login Types
//
typedef enum VDS_ISCSI_LOGIN_TYPE
{
    VDS_ILT_MANUAL = 0,
    VDS_ILT_PERSISTENT = 1,
    VDS_ILT_BOOT = 2
} VDS_ISCSI_LOGIN_TYPE;


//
// Authorization Types
//
typedef enum VDS_ISCSI_AUTH_TYPE
{
    VDS_IAT_NONE = 0,
    VDS_IAT_CHAP = 1,
    VDS_IAT_MUTUAL_CHAP = 2
} VDS_ISCSI_AUTH_TYPE;


//
// IPSEC Flags
//
typedef enum VDS_ISCSI_IPSEC_FLAG
{
    // These flags correspond to the definitions in the iSNS portal security bitmap
    VDS_IIF_VALID = 0x01,
    VDS_IIF_IKE = 0x02,
    VDS_IIF_MAIN_MODE = 0x04,
    VDS_IIF_AGGRESSIVE_MODE = 0x08,
    VDS_IIF_PFS_ENABLE = 0x10,
    VDS_IIF_TRANSPORT_MODE_PREFERRED = 0x20,
    VDS_IIF_TUNNEL_MODE_PREFERRED = 0x40
} VDS_ISCSI_IPSEC_FLAG;


//
// Login Flags
//
typedef enum VDS_ISCSI_LOGIN_FLAG
{
    VDS_ILF_REQUIRE_IPSEC = 0x1,
    VDS_ILF_MULTIPATH_ENABLED = 0x2
} VDS_ISCSI_LOGIN_FLAG;


//
// --- Miscellaneous Structures ---
//

//
// Path IDs
//
typedef struct VDS_PATH_ID
{
    ULONGLONG ullSourceId;
    ULONGLONG ullPathId;
} VDS_PATH_ID;


//
// World Wide Name
//
typedef struct VDS_WWN
{
    // This structure corresponds to the HBA_WWN structure in the HBA API
    UCHAR rguchWwn[8];
} VDS_WWN;


//
// IP Address
//
typedef struct VDS_IPADDRESS
{
    VDS_IPADDRESS_TYPE  type;
    ULONG               ipv4Address;
    UCHAR               ipv6Address[16];
    ULONG               ulIpv6FlowInfo;
    ULONG               ulIpv6ScopeId;
    WCHAR               wszTextAddress[256+1];
    ULONG               ulPort;
} VDS_IPADDRESS;

//
// IPSEC Key
//
typedef struct VDS_ISCSI_IPSEC_KEY
{
    //[size_is(ulKeySize)] UCHAR* pKey;
    LongPtr pKey;
    ULONG                       ulKeySize;
} VDS_ISCSI_IPSEC_KEY;


//
// CHAP Shared Secret
//
typedef struct VDS_ISCSI_SHARED_SECRET
{
    //[size_is(ulSharedSecretSize)] UCHAR* pSharedSecret;
    LongPtr pSharedSecret;
    ULONG                                   ulSharedSecretSize;
} VDS_ISCSI_SHARED_SECRET;


//
// --- VDS Object Properties ---
//

//
// HBA port properties
//
typedef struct VDS_HBAPORT_PROP
{
    UUID           id;
    VDS_WWN                 wwnNode;
    VDS_WWN                 wwnPort;

    VDS_HBAPORT_TYPE        type;
    VDS_HBAPORT_STATUS      status;
    ULONG                   ulPortSpeed;
    ULONG                   ulSupportedPortSpeed;

} VDS_HBAPORT_PROP;


//
// Initiator adapter properties
//
typedef struct VDS_ISCSI_INITIATOR_ADAPTER_PROP
{
    UUID   id;
    LongPtr pwszName;
} VDS_ISCSI_INITIATOR_ADAPTER_PROP;


//
// Initiator portal properties
//
typedef struct VDS_ISCSI_INITIATOR_PORTAL_PROP
{
    UUID   id;
    VDS_IPADDRESS   address;
    ULONG           ulPortIndex;
} VDS_ISCSI_INITIATOR_PORTAL_PROP;


//
// Provider properties
//
typedef struct VDS_PROVIDER_PROP
{
    UUID       id;
    LongPtr     pwszName;
    UUID                guidVersionId;
    LongPtr     pwszVersion;
    VDS_PROVIDER_TYPE   type;
    VDS_PROVIDER_FLAG               ulFlags;
    ULONG               ulStripeSizeFlags;
    // This is for software provider only.
    // The Microsoft dynamic provider supports only 64k as a stripe size.
    // The Microsoft basic provider should set this to 0 - it does not support stripes.
    SHORT               sRebuildPriority;
    // This field is not used by microsoft providers.

} VDS_PROVIDER_PROP;

//
// --- MPIO related Structures ---
//

//
// Path Information
//
typedef struct VDS_PATH_INFO
{
    VDS_PATH_ID             pathId;
    VDS_HWPROVIDER_TYPE     type;
    VDS_PATH_STATUS         status;

    //// subsystem-side endpoint of the path
    //[switch_is(type)] union
    //{
    //    [case(VDS_HWT_FIBRE_CHANNEL, VDS_HWT_SAS)]
    //        UUID       controllerPortId;
    //    [case(VDS_HWT_ISCSI)]
    //        UUID       targetPortalId;
    //    [default] ;
    //};
    UUID u1;
    //// local server-side endpoint of the path
    //[switch_is(type)] union
    //{
    //    [case(VDS_HWT_FIBRE_CHANNEL, VDS_HWT_SAS)]
    //        UUID       hbaPortId;
    //    [case(VDS_HWT_ISCSI)]
    //        UUID       initiatorAdapterId;
    //    [default] ;
    //};
    UUID u2;
    //// additional information about the local server-side endpoint of the path
    //[switch_is(type)] union
    //{
    //    [case(VDS_HWT_FIBRE_CHANNEL, VDS_HWT_SAS)]
    //        VDS_HBAPORT_PROP* pHbaPortProp;
    //    [case(VDS_HWT_ISCSI)]
    //        VDS_IPADDRESS* pInitiatorPortalIpAddr;
    //    [default] ;
    //};
    LongPtr u3;
} VDS_PATH_INFO;


//
// Path Policy
//
typedef struct VDS_PATH_POLICY
{
    VDS_PATH_ID     pathId;
    BOOL            bPrimaryPath;
    ULONG           ulWeight;   // only relevant for VDS_LBP_WEIGHTED_PATHS

} VDS_PATH_POLICY;


//
// LUN info data
//

//import "vdslun.idl";

// ***************************************************************
//
// vdslun.idl
//
// ***************************************************************

//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2000
//
//    File: vdslun.idl
//
//    Abstract:
//        Declaration of VDS_LUN_INFORMATION and related structures.
//
//----------------------------------------------------------------------------



///////////////////////////////////////////////////////////////////////////////
//  Imports
//

//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")
//
//import "oaidl.idl";
//import "ocidl.idl";
//
//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(push)")
//cpp_quote("#pragma warning(disable:4820) /* padding added after data member */")
//cpp_quote("#endif")

// Mode page 83 data types corresponding to STORAGE_IDENTIFIER_CODE_SET in ntddstor.h
typedef enum VDS_STORAGE_IDENTIFIER_CODE_SET
{
    VDSStorageIdCodeSetReserved = 0,
    VDSStorageIdCodeSetBinary = 1,
    VDSStorageIdCodeSetAscii = 2,
    VDSStorageIdCodeSetUtf8 = 3
} VDS_STORAGE_IDENTIFIER_CODE_SET;


// Mode page 83 identifier types corresponding to STORAGE_IDENTIFIER_TYPE in ntddstor.h
typedef enum VDS_STORAGE_IDENTIFIER_TYPE
{
    VDSStorageIdTypeVendorSpecific = 0,
    VDSStorageIdTypeVendorId = 1,
    VDSStorageIdTypeEUI64 = 2,
    VDSStorageIdTypeFCPHName = 3,
    VDSStorageIdTypePortRelative = 4,
    VDSStorageIdTypeTargetPortGroup = 5,
    VDSStorageIdTypeLogicalUnitGroup = 6,
    VDSStorageIdTypeMD5LogicalUnitIdentifier = 7,
    VDSStorageIdTypeScsiNameString = 8
} VDS_STORAGE_IDENTIFIER_TYPE;


// Bus types corresponding to STORAGE_BUS_TYPE in ntddstor.h
typedef enum VDS_STORAGE_BUS_TYPE
{
    VDSBusTypeUnknown = 0x00,
    VDSBusTypeScsi = 0x01,
    VDSBusTypeAtapi = 0x02,
    VDSBusTypeAta = 0x03,
    VDSBusType1394 = 0x04,
    VDSBusTypeSsa = 0x05,
    VDSBusTypeFibre = 0x06,
    VDSBusTypeUsb = 0x07,
    VDSBusTypeRAID = 0x08,
    VDSBusTypeiScsi = 0x09,
    VDSBusTypeSas = 0x0A,
    VDSBusTypeSata = 0x0B,
    VDSBusTypeSd = 0x0C,
    VDSBusTypeMmc = 0x0D,
    VDSBusTypeMax = 0x0E,   // Keeping it for Legacy. Applications should migrate to assuming BusTypeVirtual is 0x0E
    VDSBusTypeVirtual = 0x0E,
    VDSBusTypeFileBackedVirtual = 0x0F,
    VDSBusTypeSpaces = 0x10,
    VDSBusTypeNVMe = 0x11,
    VDSBusTypeScm = 0x12,
    VDSBusTypeUfs = 0x13,

    VDSBusTypeMaxReserved = 0x7F
} VDS_STORAGE_BUS_TYPE;


// Storage identifier corresponding to STORAGE_IDENTIFIER in ntddstor.h
typedef struct VDS_STORAGE_IDENTIFIER
{
    // whether ascii or binary data
    VDS_STORAGE_IDENTIFIER_CODE_SET m_CodeSet;

    // type of identifier
    VDS_STORAGE_IDENTIFIER_TYPE     m_Type;

    // length of identifier in bytes
    ULONG                           m_cbIdentifier;

    // actual identintifier
    //[size_is(m_cbIdentifier)] BYTE* m_rgbIdentifier;
    LongPtr m_rgbIdentifier;
} VDS_STORAGE_IDENTIFIER;

// Mode page 83 is mandatory, returns a list of identifiers.
// Device ID descriptor corresponding to STORAGE_DEVICE_ID_DESCRIPTOR in ntddstor.h
typedef struct VDS_STORAGE_DEVICE_ID_DESCRIPTOR
{
    // version of structure
    ULONG                                               m_version;

    // number of identifiers
    ULONG                                               m_cIdentifiers;

    //[size_is(m_cIdentifiers)] VDS_STORAGE_IDENTIFIER* m_rgIdentifiers;
    LongPtr m_rgIdentifiers;
} VDS_STORAGE_DEVICE_ID_DESCRIPTOR;

// Interconnect address types
typedef enum VDS_INTERCONNECT_ADDRESS_TYPE
{
    VDS_IA_UNKNOWN = 0,
    VDS_IA_FCFS = 1,
    VDS_IA_FCPH = 2,
    VDS_IA_FCPH3 = 3,
    VDS_IA_MAC = 4,
    VDS_IA_SCSI = 5
} VDS_INTERCONNECT_ADDRESS_TYPE;

// Physical interconnect
//
// This part of VDS was initially defined in the context of
// VSS hardware transportable snapshots. From the VSS hardware
// provider documentation:
// VDS_INTERCONNECT_ADDRESS_TYPE is an enumeration of
// recognized interconnect addressing schemes and includes, but
// is not limited to, FCFS, FCPH, FCP3, MAC (iSCSI), and SCSI.
// By default, it is empty, and it is recommended that this is
// left empty.
//
// The original thinking was that we might need a field to tell
// other (wave your hands here) software how to interpret and/or
// display in a nice way the other fields in VDS_INTERCONNECT.
//
// However, our current clients (Storage Manager for SANs and
// DiskRAID) don’t use it anyway.
// We recommend that you leave this field blank, as it is not
// likely to be used by clients.
//
typedef struct VDS_INTERCONNECT
{
    // address type
    VDS_INTERCONNECT_ADDRESS_TYPE   m_addressType;

    // port that address refers to
    ULONG                           m_cbPort;

    // actual address of port
    LongPtr m_pbPort; //[size_is(m_cbPort)] BYTE*

    // size of address
    ULONG                           m_cbAddress;

    // address relative to the port
    LongPtr m_pbAddress; //[size_is(m_cbAddress)] BYTE* 
} VDS_INTERCONNECT;



// Information about a lun.  Includes STORAGE_DEVICE_DESCRIPTOR
// (from ntddstor.h) STORAGE_DEVICE_ID_DESCRIPTOR, interconnect address type,
// and interconnect address.
typedef struct VDS_LUN_INFORMATION
{
    // version of structure
    ULONG                                           m_version;

    // The SCSI-2 device type
    BYTE                                            m_DeviceType;

    // The SCSI-2 device type modifier (if any) - this may be zero
    BYTE                                            m_DeviceTypeModifier;

    // Flag indicating whether the device can support mulitple outstanding
    // commands.  The actual synchronization in this case is the responsibility
    // of the port driver.
    BOOL                                            m_bCommandQueueing;

    // Contains the bus type (as defined above) of the device.  It should be
    // used to interpret the raw device properties at the end of this structure
    // (if any).
    // The bus type for mode page 0x83 is currently determined by looking at the
    // registry, which is set by the inf.
    // This results in the bus type being bogus if the driver writer did not set
    // this property correctly.
    VDS_STORAGE_BUS_TYPE                            m_BusType;


    // vendor id string.  For devices with no such ID this will be zero
    //[string] char* m_szVendorId;
    LongPtr m_szVendorId; //[string] char*
    // device's product id string.  For devices with no such ID this will be zero
    LongPtr m_szProductId; //[string] char*

    // zero-terminated ascii string containing the device's
    // product revision string.  For devices with no such string this will be
    // zero
    LongPtr m_szProductRevision; //[string] char*

    // zero-terminated ascii string containing the device's
    // serial number.  For devices with no serial number this will be zero.
    // Mode page 0x80, optional
    LongPtr m_szSerialNumber; //[string] char*

    // disk signature
    UUID                                            m_diskSignature;

    // device id descriptor
    VDS_STORAGE_DEVICE_ID_DESCRIPTOR                m_deviceIdDescriptor;

    // number of interconnects
    ULONG                                           m_cInterconnects;

    // array of interconnects
    LongPtr m_rgInterconnects; // [size_is(m_cInterconnects)] VDS_INTERCONNECT*
} VDS_LUN_INFORMATION;

//const ULONG VER_VDS_LUN_INFORMATION = 1;

//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(pop)")
//cpp_quote("#endif")
//
//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion


//
// --- Interface definitions ---
//

//
// IEnumVdsObject:
//   This is an interface pointer to a generic VDS objects collection. Object
//   can be providers, packs, volumes, disks, SubSystems, Controllers and
//   spindles. But different types of objects do not mix in a collection.
// Implemented by: enum object
//
[
    odl,
        uuid(118610b7-8d94-4030-b5b8-500889788e4e)
]
interface IEnumVdsObject : stdole.IUnknown
{
    [helpstring("method Next")]
        long Next(
            [in]  ULONG celt,
            [out]
            IUnknown** ppObjectArray,
            [out] ULONG* pcFetched
        );

    [helpstring("method Skip")]
        HRESULT Skip(
            [in] ULONG celt
        );

    [helpstring("method Reset")]
        HRESULT Reset(
            void
        );

    [helpstring("method Clone")]
        HRESULT Clone(
            [out] IEnumVdsObject** ppEnum
        );
}

//
// IVdsAsync:
// Implemented by: async object
//
[
    odl,
        uuid(d5d23b6d-5a55-4492-9889-397a3c2d2dbc)
]
interface IVdsAsync : stdole.IUnknown
{
    [helpstring("method Cancel")]
        HRESULT Cancel(
            void
        );

    // Wait:
    //   If the asynchronous operation needs to return a result, it is
    //   returned through VDS_ASYNC_OUTPUT. Otherwise, the second argument
    //   is ignored.
    [helpstring("method Wait")]
        HRESULT Wait(
            [in, out] HRESULT* pHrResult,
            [in, out] VDS_ASYNC_OUTPUT* pAsyncOut
        );

    //QueryStatus:
    //  The argument reflects the progress of the operation Format.
    //  For CreateVolume, CreateLun, etc. the value is set to -1 to
    //  mean nothing. We want it so that simple programs/scripts that
    //  do not want to handle notification can still get progress info.
    [helpstring("method QueryStatus")]
        HRESULT QueryStatus(
            [in, out] HRESULT* pHrResult,
            [in, out] ULONG* pulPercentCompleted
        );
}

//
// IVdsAdviseSink:
//   Applications register this interface with the service in order to receive
//   notifications from it. The service registers this interface with the
//   providers in order to receive notifications from them, which it can also
//   pass to the applications.
// Implemented by: callback object
// Implemented where: application, common layer
//
[
    odl,
        uuid(8326cd1d-cf59-4936-b786-5efc08798e25)
]
interface IVdsAdviseSink : stdole.IUnknown
{
    [helpstring("method OnNotify")]
        HRESULT OnNotify(
            [in] LONG lNumberOfNotifications,
            [in] VDS_NOTIFICATION* pNotificationArray
        );
}

//
// IVdsProvider:
// Implemented by: provider object
// Implemented where: providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(10c5e575-7984-4e81-a56b-431f5f92ae42)
]
interface IVdsProvider : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_PROVIDER_PROP* pProviderProp
        );
}

//
// IVdsProviderSupport:
// Implemented by: provider object
// Implemented where: providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(1732be13-e8f9-4a03-bfbc-5f616aa66ce1)
]
interface IVdsProviderSupport : stdole.IUnknown
{
    [helpstring("method GetVersionSupport")]
        HRESULT GetVersionSupport(
            [out] ULONG* ulVersionSupport
        );

}

//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(pop)")
//cpp_quote("#endif")
//
//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion
















// ***************************************************************
//
// vdssp.idl
//
// ***************************************************************

//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2000
//
//    File: vdssp.idl
//
//    Abstract:
//        declarations of interfaces and types implemented by software provider
//        and also exposed by the service.
//
//----------------------------------------------------------------------------

//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")
//
//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(push)")
//cpp_quote("#pragma warning(disable:4820) /* padding added after data member */")
//cpp_quote("#endif")

interface IVdsSwProvider;
interface IVdsPack;
interface IVdsPack2;
interface IVdsDisk;
interface IVdsDisk2;
interface IVdsDisk3;
interface IVdsDiskOnline;
interface IVdsAdvancedDisk;
interface IVdsAdvancedDisk2;
interface IVdsAdvancedDisk3;
interface IVdsCreatePartitionEx;
interface IVdsRemovable;
interface IVdsVolume;
interface IVdsVolume2;
interface IVdsVolumeOnline;
interface IVdsVolumePlex;

//
// Pack Status
//
typedef enum VDS_PACK_STATUS
{
    VDS_PS_UNKNOWN = 0, // STATUS_UNKNOWN,
    VDS_PS_ONLINE = 1, //STATUS_ONLINE,
    VDS_PS_OFFLINE = 4 //STATUS_OFFLINE

} VDS_PACK_STATUS;

//
// Pack Flags
//
typedef enum VDS_PACK_FLAG
{
    VDS_PKF_FOREIGN = 0x1,
    // Set on all packs that are not the primary\online pack.
    VDS_PKF_NOQUORUM = 0x2,
    // This flag was not used on W2K3 and will not be used on LH either.
    VDS_PKF_POLICY = 0x4,
    // Will be set on personal SKU for the dynamic provider - pack is offline
    // because dyanmic disks are not supported on the OS SKU.
    VDS_PKF_CORRUPTED = 0x8,
    // This flag indicates the disk contained in the pack has a corrupted
    // database.
    VDS_PKF_ONLINE_ERROR = 0x10
    // This flag indicates the pack is offline because error happened when
    // trying to online it. The config will be offline if 1) we do not have quorum,
    // or, 2) there were online errors. For both of these cases, we will set the
    // VDS_PKF_ONLINE_ERROR flag on the pack.

} VDS_PACK_FLAG;

//
// Disk Status
//
//tB added
typedef enum VDS_DISK_STATUS
{
    VDS_DS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_DS_ONLINE = 1, //STATUS_ONLINE,
    VDS_DS_NOT_READY = 2, //STATUS_NOT_READY, // One example is with ACPI Power Management. You can ask a disk to
    // hibernate (spin down).
    VDS_DS_NO_MEDIA = 3, //STATUS_NO_MEDIA,  // This flag is for removable media, CDROM.
    VDS_DS_FAILED = 5, //STATUS_FAILED,
    VDS_DS_MISSING = 6, //STATUS_MISSING,
    VDS_DS_OFFLINE = 4 //STATUS_OFFLINE    // Added to W2K8

} VDS_DISK_STATUS;

//
// Partition Styles
//
//tB added
typedef enum VDS_PARTITION_STYLE
{
    VDS_PST_UNKNOWN = 0,
    VDS_PST_MBR = 1,
    VDS_PST_GPT = 2

} VDS_PARTITION_STYLE;

//
// Disk Flags
//
typedef enum VDS_DISK_FLAG
{
    VDS_DF_AUDIO_CD = 0x1,
    VDS_DF_HOTSPARE = 0x2,
    VDS_DF_RESERVE_CAPABLE = 0x4,
    VDS_DF_MASKED = 0x8,
    VDS_DF_STYLE_CONVERTIBLE = 0x10,
    VDS_DF_CLUSTERED = 0x20,
    VDS_DF_READ_ONLY = 0x40,     // Added to Vista SP1, Windows Server 2008
    VDS_DF_SYSTEM_DISK = 0x80,     // Added to Vista SP1, Windows Server 2008
    VDS_DF_BOOT_DISK = 0x100,    // Added to Vista SP1, Windows Server 2008
    VDS_DF_PAGEFILE_DISK = 0x200,    // Added to Vista SP1, Windows Server 2008
    VDS_DF_HIBERNATIONFILE_DISK = 0x400,    // Added to Vista SP1, Windows Server 2008
    VDS_DF_CRASHDUMP_DISK = 0x800,    // Added to Vista SP1, Windows Server 2008
    VDS_DF_HAS_ARC_PATH = 0x1000,   // Added to Vista SP1, Windows Server 2008
    VDS_DF_DYNAMIC = 0x2000,   // Added to Vista SP1, Windows Server 2008
    VDS_DF_BOOT_FROM_DISK = 0x4000,   // Added to Windows7, indicates the disk from
    // which the machine will boot.
    // Note that this is BIOS disk 0 on MBR, not
    // the CURRENT system volume disk.
    // for example if you are booted to WinPE,
    // this flag is set on BIOS disk 0. For EFI
    // machines, this flag is set on disk containing
    // the ESP used to boot the machine.
    VDS_DF_CURRENT_READ_ONLY = 0x8000,   // Added to Windows7, indicates that the
    // current read-only state of the disk.

    VDS_DF_REFS_NOT_SUPPORTED = 0x10000   // Added to WindowsBLUE. 
} VDS_DISK_FLAG;

//
// Partition Flags
//
typedef enum VDS_PARTITION_FLAG
{
    VDS_PTF_SYSTEM = 0x1   // whether this partition is a system
    // partition. We need this flag because
    // we don't return ESP partitions as
    // volumes.
} VDS_PARTITION_FLAG;

//
// Lun Reserve Modes
//
//tB Added
typedef enum VDS_LUN_RESERVE_MODE
{
    VDS_LRM_NONE = 0,
    VDS_LRM_EXCLUSIVE_RW = 1,
    VDS_LRM_EXCLUSIVE_RO = 2,
    VDS_LRM_SHARED_RO = 3,
    VDS_LRM_SHARED_RW = 4

} VDS_LUN_RESERVE_MODE;

//
// Volume Status
//
//tB Added 
typedef enum VDS_VOLUME_STATUS
{
    VDS_VS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_VS_ONLINE = 1, //STATUS_ONLINE,
    VDS_VS_NO_MEDIA = 3, //STATUS_NO_MEDIA,
    VDS_VS_FAILED = 5, //STATUS_FAILED,
    VDS_VS_OFFLINE = 4 //STATUS_OFFLINE        // Added for Win7

} VDS_VOLUME_STATUS;

//
// Volume Types
//
//tB Added 
typedef enum VDS_VOLUME_TYPE
{
    VDS_VT_UNKNOWN = 0,
    VDS_VT_SIMPLE = 10,
    VDS_VT_SPAN = 11,
    VDS_VT_STRIPE = 12,
    VDS_VT_MIRROR = 13,
    VDS_VT_PARITY = 14
    //   Each volume has one or more plexes.
    //   Each plex has one or more members.
    //      e.g. a simple volume has one VDS_VPT_SIMPLE plex,
    //                  which in turn has one member,
    //                  with one or more extents on the same disk.
    //           a spanned volume has one VDS_VPT_SPAN plex,
    //                  which in turn has one member,
    //                  with one or more extents on more than one disk.
    //           a stripped volume has one VDS_VPT_STRIPE plex,
    //                  which in turn has two or more members,
    //                  with each member having one or more extents on
    //                  the same disk. (allowing on different disks?)
    //           a RAID5 volume has one VDS_VPT_PARITY plex,
    //                  which in turn has three or more members,
    //                  with each member having one or more extents on
    //                  the same disk. (allowing on different disks?)
    //           a mirrorred volume has two or more plexes of any type.
    //

} VDS_VOLUME_TYPE;

//
// Volume Flags
//
//tB Added
typedef enum VDS_VOLUME_FLAG
{
    VDS_VF_SYSTEM_VOLUME = 0x1,
    VDS_VF_BOOT_VOLUME = 0x2,
    VDS_VF_ACTIVE = 0x4,
    VDS_VF_READONLY = 0x8,
    VDS_VF_HIDDEN = 0x10,
    VDS_VF_CAN_EXTEND = 0x20,
    VDS_VF_CAN_SHRINK = 0x40,
    VDS_VF_PAGEFILE = 0x80,
    VDS_VF_HIBERNATION = 0x100,
    VDS_VF_CRASHDUMP = 0x200,
    VDS_VF_INSTALLABLE = 0x400,
    VDS_VF_LBN_REMAP_ENABLED = 0x800,

    VDS_VF_FORMATTING = 0x1000,
    VDS_VF_NOT_FORMATTABLE = 0x2000,
    VDS_VF_NTFS_NOT_SUPPORTED = 0x4000,
    VDS_VF_FAT32_NOT_SUPPORTED = 0x8000,
    VDS_VF_FAT_NOT_SUPPORTED = 0x10000,

    VDS_VF_NO_DEFAULT_DRIVE_LETTER = 0x20000,
    // This flag behaves similarly to VDS_VF_HIDDEN and VDS_VF_READONLY
    // flags. On a MBR basic disk, these flags apply to all partitions.
    // But setting VDS_VF_NO_DEFAULT_DRIVE_LETTER flag does not delete
    // drive letters on other partitions on the same disk that already
    // have them. Yet setting VDS_VF_HIDDEN or VDS_VF_READONLY flag makes
    // other partitions HIDDEN or READONLY immediately at the same time.
    VDS_VF_PERMANENTLY_DISMOUNTED = 0x40000,
    // This flag means the volume is offlined by IOCTL_VOLUME_OFFLINE.
    // It can be made mountable by IOCTL_VOLUME_ONLINE, or assigning
    // a mount point explicitely. A volume will have this flag
    // after IVdsVolumeMF::Dismount( bForce, bPermanent=TRUE ) is called.
    VDS_VF_PERMANENT_DISMOUNT_SUPPORTED = 0x80000,
    // Whether this volume supports the bPermanent flag in IVdsVolumeMF::
    // Dismount() method.
    VDS_VF_SHADOW_COPY = 0x100000,
    // Whether this volume is a shadow copy of another volume.

    VDS_VF_FVE_ENABLED = 0x200000,
    // Whether this volume has full volume encryption enabled.
    VDS_VF_DIRTY = 0x400000,
    // Whether this volume has dirty flag set
    VDS_VF_REFS_NOT_SUPPORTED = 0x800000,
    // Whether this volume backs a boot volume.
    VDS_VF_BACKS_BOOT_VOLUME = 0x1000000,
    // Whether this volume is backed by a wimboot image
    VDS_VF_BACKED_BY_WIM_IMAGE = 0x2000000

} VDS_VOLUME_FLAG;

//
// Volume Plex Types
//
typedef enum VDS_VOLUME_PLEX_TYPE
{
    VDS_VPT_UNKNOWN = 0,
    VDS_VPT_SIMPLE = 10, //VDS_VT_SIMPLE,
    VDS_VPT_SPAN = 11, //VDS_VT_SPAN,
    VDS_VPT_STRIPE = 12, //VDS_VT_STRIPE,
    VDS_VPT_PARITY = 14 //VDS_VT_PARITY

} VDS_VOLUME_PLEX_TYPE;

//
// Volume Plex Status
//
typedef enum VDS_VOLUME_PLEX_STATUS
{
    VDS_VPS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_VPS_ONLINE = 1, //STATUS_ONLINE,
    VDS_VPS_NO_MEDIA = 3, //STATUS_NO_MEDIA,
    VDS_VPS_FAILED = 5 //STATUS_FAILED

} VDS_VOLUME_PLEX_STATUS;

//
// Disk Extent Types
//
typedef enum VDS_DISK_EXTENT_TYPE
{
    VDS_DET_UNKNOWN = 0,
    // extent of any unknown partition.
    VDS_DET_FREE = 1,
    // extent of free space, including free space inside extended partition.
    VDS_DET_DATA = 2,
    // extent of any volume (other than OEM partition, unknown partition and
    // ESP partition)
    VDS_DET_OEM = 3,
    // extent of OEM partition.
    VDS_DET_ESP = 4,
    // extent of ESP partition.
    VDS_DET_MSR = 5,
    // extent of MSR partition.
    VDS_DET_LDM = 6,
    // extent of LDM meta data partition.
    VDS_DET_CLUSTER = 7,
    // extent of Cluster meta data partition.
    VDS_DET_UNUSABLE = 0x7FFF
    // extent of unusable space on a disk. (e.g. space outside 4 primary
    // primary partitions on a basic MBR disk)

} VDS_DISK_EXTENT_TYPE;

//
// Pack properties
//
typedef struct VDS_PACK_PROP
{
    UUID       id;
    LongPtr     pwszName;
    // leave blank for basic pack.
    VDS_PACK_STATUS     status;
    VDS_PACK_FLAG               ulFlags;

} VDS_PACK_PROP;

//
// Disk Properties
//
typedef struct VDS_DISK_PROP
{
    UUID       id;
    VDS_DISK_STATUS     status;
    VDS_LUN_RESERVE_MODE ReserveMode;    // to be filled by the VDS service.
    VDS_HEALTH          health;
    DWORD               dwDeviceType;   // Values: (defined in winioctl.h)
    //         FILE_DEVICE_DISK
    //         FILE_DEVICE_CDROM
    //         FILE_DEVICE_DVD
    //         etc.
    DWORD               dwMediaType;    // Values: (STORAGE_MEDIA_TYPE values)
    //         RemovableMedia
    //         FixedMedia
    //         CD_ROM
    //         etc.
    int padVBOnly;
    ULONGLONG           ullSize;
    ULONG               ulBytesPerSector;
    ULONG               ulSectorsPerTrack;
    ULONG               ulTracksPerCylinder;
    VDS_DISK_FLAG               ulFlags;

    VDS_STORAGE_BUS_TYPE    BusType;

    VDS_PARTITION_STYLE     PartitionStyle;
    //[switch_is(PartitionStyle)] union
    //{
    //    [case(VDS_PST_MBR)]
    //        DWORD           dwSignature;    // not guaranteed to be unique.
    //    [case(VDS_PST_GPT)]
    //        GUID            DiskGuid;
    //    [default] ;
    //};
    BYTE GuidOrSig[16];
    LongPtr     pwszDiskAddress;
    // The address is for displaying purpose. It's only meaningful if
    // the disk has a SCSI-like address, which contains some configuration
    // information (port number, target id, etc):
    //     SCSI, IDE: Port#Path#Target#Lun#.
    //     1394, USB: None
    //     Fibre Channel: ?
    LongPtr     pwszName;
    // This is the name that can be used to open a handle to the object
    // by CreateFile(). Examples:
    //      Cdrom:  \\?\CdRom1
    //      Disk:   \\?\PhysicalDrive3
    LongPtr     pwszFriendlyName;
    // This is a name returned from PnP. This name is maintained in
    // registry by PnP. Example:
    //      SEAGATE ST34573N SCSI Disk Device
    LongPtr     pwszAdaptorName;
    // This is the name of the adaptor on which this disk is attached.
    // It is returned from PnP, and maintained in registry.
    //      Adaptec AHA-2940U2W - Ultra2 SCSI.
    LongPtr     pwszDevicePath;
    // This is returned by PnP. This id can be used to uniquely identify
    // a device on a machine by PnP. To bring up the disk property page
    // using an internal routine exported by device manager, we need to
    // pass in device instance id.
    int padVBOnly2;
} VDS_DISK_PROP;


//
// Disk Properties, version 2 added for Win7.
//
//
// Disk offline reason
//

//tB added
typedef enum VDS_DISK_OFFLINE_REASON
{
    VDSDiskOfflineReasonNone = 0,
    VDSDiskOfflineReasonPolicy = 1,
    VDSDiskOfflineReasonRedundantPath = 2,
    VDSDiskOfflineReasonSnapshot = 3,
    VDSDiskOfflineReasonCollision = 4,
    VDSDiskOfflineReasonResourceExhaustion = 5,
    VDSDiskOfflineReasonWriteFailure = 6,
    VDSDiskOfflineReasonDIScan = 7,
    VDSDiskOfflineReasonLostDataPersistence = 8
} VDS_DISK_OFFLINE_REASON;

//tB added
typedef struct VDS_DISK_PROP2
{
    UUID           id;
    VDS_DISK_STATUS         status;
    VDS_DISK_OFFLINE_REASON OfflineReason;
    VDS_LUN_RESERVE_MODE    ReserveMode;    // to be filled by the VDS service.
    VDS_HEALTH              health;
    DWORD                   dwDeviceType;   // Values: (defined in winioctl.h)
    //         FILE_DEVICE_DISK
    //         FILE_DEVICE_CDROM
    //         FILE_DEVICE_DVD
    //         etc.
    DWORD                   dwMediaType;    // Values: (STORAGE_MEDIA_TYPE values)
    //         RemovableMedia
    //         FixedMedia
    //         CD_ROM
    //         etc.
    ULONGLONG               ullSize;
    ULONG                   ulBytesPerSector;
    ULONG                   ulSectorsPerTrack;
    ULONG                   ulTracksPerCylinder;
    ULONG                   ulFlags; // audio CD, hotspare,

    VDS_STORAGE_BUS_TYPE    BusType;

    VDS_PARTITION_STYLE     PartitionStyle;
    //[switch_is(PartitionStyle)] union
    //{
    //    [case(VDS_PST_MBR)]
    //        DWORD               dwSignature;    // not guaranteed to be unique.
    //    [case(VDS_PST_GPT)]
    //        GUID                DiskGuid;
    //    [default] ;
    //};
    BYTE SigOrGuid[16];
    LongPtr         pwszDiskAddress;
    // The address is for displaying purpose. It's only meaningful if
    // the disk has a SCSI-like address, which contains some configuration
    // information (port number, target id, etc):
    //     SCSI, IDE: Port#Path#Target#Lun#.
    //     1394, USB: None
    //     Fibre Channel: ?
    LongPtr         pwszName;
    // This is the name that can be used to open a handle to the object
    // by CreateFile(). Examples:
    //      Cdrom:  \\?\CdRom1
    //      Disk:   \\?\PhysicalDrive3
    LongPtr         pwszFriendlyName;
    // This is a name returned from PnP. This name is maintained in
    // registry by PnP. Example:
    //      SEAGATE ST34573N SCSI Disk Device
    LongPtr         pwszAdaptorName;
    // This is the name of the adaptor on which this disk is attached.
    // It is returned from PnP, and maintained in registry.
    //      Adaptec AHA-2940U2W - Ultra2 SCSI.
    LongPtr         pwszDevicePath;
    // This is returned by PnP. This id can be used to uniquely identify
    // a device on a machine by PnP. To bring up the disk property page
    // using an internal routine exported by device manager, we need to
    // pass in device instance id.
    LongPtr         pwszLocationPath;
    // This string is built from a combination of the SCSI address and
    // the DEVPKEY_Device_LocationPaths value for the disk's adapter.

} VDS_DISK_PROP2;

//tB added
typedef struct VDS_ADVANCEDDISK_PROP
{
    LongPtr     pwszId;

    LongPtr     pwszPathname;
    LongPtr     pwszLocation;
    LongPtr     pwszFriendlyName;
    LongPtr     pswzIdentifier;
    USHORT              usIdentifierFormat;
    ULONG               ulNumber;

    LongPtr     pwszSerialNumber;
    LongPtr     pwszFirmwareVersion;
    LongPtr     pwszManufacturer;
    LongPtr     pwszModel;
    int padVBOnly;
    ULONGLONG           ullTotalSize;
    ULONGLONG           ullAllocatedSize;
    ULONG               ulLogicalSectorSize;
    ULONG               ulPhysicalSectorSize;

    ULONG               ulPartitionCount;

    VDS_DISK_STATUS     status;
    VDS_HEALTH          health;

    VDS_STORAGE_BUS_TYPE BusType;

    VDS_PARTITION_STYLE     PartitionStyle;
    //[switch_is(PartitionStyle)] union
    //{
    //    [case(VDS_PST_MBR)]
    //        DWORD               dwSignature;    // not guaranteed to be unique.
    //    [case(VDS_PST_GPT)]
    //        GUID                DiskGuid;
    //    [default] ;
    //};
    BYTE SigOrGuid[16];
    ULONG               ulFlags;
    DWORD               dwDeviceType;
    int padVBOnly2;
} VDS_ADVANCEDDISK_PROP;

//
// Volume Properties
//
//tB Added 
typedef struct VDS_VOLUME_PROP
{
    UUID       id;
    VDS_VOLUME_TYPE     type;
    VDS_VOLUME_STATUS   status;
    VDS_HEALTH          health;
    VDS_TRANSITION_STATE TransitionState;

    ULONGLONG           ullSize;
    ULONG               ulFlags; // VDS_VOLUME_FLAG
    VDS_FILE_SYSTEM_TYPE  RecommendedFileSystemType;
    LongPtr     pwszName;
    // This is the name that can be used to open a handle to the object
    // by CreateFile(). Example:
    //     \\?\GLOBALROOT\Device\HarddiskVolume#
    int padVBOnly;
} VDS_VOLUME_PROP;

//
// Volume Properties - adding uniqueid
//
typedef struct VDS_VOLUME_PROP2
{
    UUID       id;
    VDS_VOLUME_TYPE     type;
    VDS_VOLUME_STATUS   status;
    VDS_HEALTH          health;
    VDS_TRANSITION_STATE TransitionState;

    ULONGLONG           ullSize;
    ULONG               ulFlags; // VDS_VOLUME_FLAG
    VDS_FILE_SYSTEM_TYPE  RecommendedFileSystemType;
    ULONG               cbUniqueId;
    LongPtr     pwszName;
    // This is the name that can be used to open a handle to the object
    // by CreateFile(). Example:
    //     \\?\GLOBALROOT\Device\HarddiskVolume#
    LongPtr pUniqueId; //[size_is(cbUniqueId)]  BYTE* 
    int padVBOnly;
} VDS_VOLUME_PROP2;

//
// Volume plex properties
//
typedef struct VDS_VOLUME_PLEX_PROP
{
    UUID              id;
    VDS_VOLUME_PLEX_TYPE       type;
    VDS_VOLUME_PLEX_STATUS     status;
    VDS_HEALTH                 health;
    VDS_TRANSITION_STATE       TransitionState;

    ULONGLONG                  ullSize;
    ULONG                      ulStripeSize;
    ULONG                      ulNumberOfMembers;

    // No flags.

} VDS_VOLUME_PLEX_PROP;

//
// Disk extent struct
//
typedef struct VDS_DISK_EXTENT
{
    UUID           diskId;
    VDS_DISK_EXTENT_TYPE    type;
    int padVBOnly;
    ULONGLONG               ullOffset;
    ULONGLONG               ullSize;

    UUID           volumeId;
    // the volume the extent belongs to.
    UUID           plexId;
    // if the extent belongs to a volume, it's the id of the plex
    // it belongs to. An extent can belong to a partition (e.g.
    // MSR, LDM Meta Data), but not a volume.
    ULONG                   memberIdx;
    // if the extent belongs to a plex of a volume, it's the index
    // of the member it belongs to. Member index is 0 based.
    int padVBOnly2;
} VDS_DISK_EXTENT;

//
// Disk free extent
//
typedef struct VDS_DISK_FREE_EXTENT
{
    UUID       diskId;
    ULONGLONG           ullOffset;
    ULONGLONG           ullSize;
} VDS_DISK_FREE_EXTENT;

//
// Input struct for IVdsPack::CreateVolume and IVdsVolume::Extend method.
//
//tB Added
typedef struct VDS_INPUT_DISK
{
    UUID       diskId;     // This field is required.
    ULONGLONG           ullSize;    // This field is required.
    UUID       plexId;
    // When extending a volume, specify which plex the disk belongs to.
    // It is ignored when creating a volume and repair a RAID-5 volume.
    ULONG               memberIdx;
    // This field specifies which member the extent should belong to.
    // either all disks' memberIdx are specified, or none is specified.
    // It must not be specified when repairing a RAID-5 volume.
    int padVBOnly;
} VDS_INPUT_DISK;

//#define INVALID_MEMBER_IDX      (0xFFFFFFFF)

//
// Partition Properties
//
//cpp_quote("#define GPT_PARTITION_NAME_LENGTH    36")
//#define GPT_PARTITION_NAME_LENGTH    36
//tB Added
typedef struct VDS_PARTITION_INFO_GPT
{
    UUID                partitionType;
    UUID                partitionId;
    ULONGLONG            attributes;
    WCHAR                name[36]; //GPT_PARTITION_NAME_LENGTH

} VDS_PARTITION_INFO_GPT;

typedef struct VDS_PARTITION_INFO_MBR
{                                    // equivalent to PARTITION_INFORMATION_MBR
                                    // and convertible to each other
    BYTE                partitionType;
    BOOLEAN                bootIndicator;
    BOOLEAN                recognizedPartition;
    DWORD                 hiddenSectors;

} VDS_PARTITION_INFO_MBR;

typedef struct VDS_PARTITION_PROP
{
    VDS_PARTITION_STYLE PartitionStyle;
    ULONG               ulFlags;
    ULONG                ulPartitionNumber;
    int padVBOnly;
    ULONGLONG            ullOffset;
    ULONGLONG            ullSize;
    //[switch_is(PartitionStyle)] union
    //{
    //    [case(VDS_PST_MBR)]
    //        VDS_PARTITION_INFO_MBR Mbr;  // For MBR disk
    //    [case(VDS_PST_GPT)]
    //        VDS_PARTITION_INFO_GPT Gpt; // For GPT disk
    //    [default] ;
    //};
    BYTE PartitionUnion[112];
} VDS_PARTITION_PROP;

//
// MIDLize'd PARTITION_INFORMATION_EX
//   The midlized types have identical representation with the original
//   NT types.
//

typedef enum VDS_PARTITION_STYLE2
{
    VDS_PARTITION_STYLE_MBR,
    VDS_PARTITION_STYLE_GPT,
    VDS_PARTITION_STYLE_RAW

} VDS_PARTITION_STYLE2; // VDS_PARTITION_STYLE is already defined.

typedef struct VDS_PARTITION_INFORMATION_EX
{
    VDS_PARTITION_STYLE2   dwPartitionStyle;
    int padVBOnly;
    ULONGLONG           ullStartingOffset;      // LARGE_INTEGER
    ULONGLONG           ullPartitionLength;     // LARGE_INTEGER
    DWORD               dwPartitionNumber;
    BOOLEAN             bRewritePartition;
    //[switch_is(dwPartitionStyle)] union
    //{
    //    [case (VDS_PARTITION_STYLE_MBR)]
    //        VDS_PARTITION_INFO_MBR Mbr;
    //    [case (VDS_PARTITION_STYLE_GPT)]
    //        VDS_PARTITION_INFO_GPT Gpt;
    //};
    BYTE PartitionUnion[112];
} VDS_PARTITION_INFORMATION_EX;

typedef struct CREATE_PARTITION_PARAMETERS
{
    VDS_PARTITION_STYLE style;   // legal values: MBR or GPT
    //[switch_is(style)] union
    //{
    //    [case(VDS_PST_MBR)]
    //        struct
    //    {
    //        BYTE        partitionType;
    //        BOOLEAN     bootIndicator;
    //    } MbrPartInfo;
    //    [case(VDS_PST_GPT)]
    //        struct
    //    {
    //        GUID        partitionType;
    //        GUID        partitionId;    // Pass zero to generate, ASR needs to set this.
    //        ULONGLONG   attributes;
    //        WCHAR       name[GPT_PARTITION_NAME_LENGTH];
    //    } GptPartInfo;
    //    [default] ;
    //};
    int pad;
    BYTE PartitionUnion[112];
    // These two union structs are based on PARTITION_INFORMATION_MBR,
    // PARTITION_INFORMATION_GPT, which are used in IOCTL_DISK_SET_
    // DRIVE_LAYOUT_EX.

} CREATE_PARTITION_PARAMETERS;

typedef struct CHANGE_ATTRIBUTES_PARAMETERS
{
    VDS_PARTITION_STYLE style;   // legal values: MBR or GPT
    //[switch_is(style)] union
    //{
    //    [case(VDS_PST_MBR)]
    //        struct
    //    {
    //        BOOLEAN     bootIndicator;
    //    } MbrPartInfo;
    //    [case(VDS_PST_GPT)]
    //        struct
    //    {
    //        ULONGLONG   attributes; // Includes a boot indicator flag
    //    } GptPartInfo;
    //    [default] ;
    //};
    int padVBOnly;
    ULONGLONG PartInfoUnion;
} CHANGE_ATTRIBUTES_PARAMETERS;

typedef struct CHANGE_PARTITION_TYPE_PARAMETERS
{
    VDS_PARTITION_STYLE style;   // legal values: MBR or GPT
    //[switch_is(style)] union
    //{
    //    [case(VDS_PST_MBR)]
    //        struct
    //    {
    //        BYTE        partitionType;
    //    } MbrPartInfo;
    //    [case(VDS_PST_GPT)]
    //        struct
    //    {
    //        GUID        partitionType;
    //    } GptPartInfo;
    //    [default] ;
    //};
    UUID PartitionType;
} CHANGE_PARTITION_TYPE_PARAMETERS;

//
// IVdsSwProvider:
//   This interface exposes software provider specific functions.
// Implemented by: provider object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(9aa58360-ce33-4f92-b658-ed24b14425b8)
]
interface IVdsSwProvider : stdole.IUnknown
{
    // QueryPacks:
    [helpstring("method QueryPacks")]
        HRESULT QueryPacks(
            [out] IEnumVdsObject** ppEnum
        );

    // CreatePack:
    [helpstring("method CreatePack")]
        HRESULT CreatePack(
            [out] IVdsPack** ppPack
        );
    // NOTE: For basic provider, each pack can have only one disk.
}

//
// IVdsPack:
// Implemented by: pack object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(3b69d7f5-9d94-4648-91ca-79939ba263bf)
]
interface IVdsPack : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_PACK_PROP* pPackProp
        );

    [helpstring("method GetProvider")]
        HRESULT GetProvider(
            [out] IVdsProvider** ppProvider
        );

    [helpstring("method QueryVolumes")]
        HRESULT QueryVolumes(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method QueryDisks")]
        HRESULT QueryDisks(
            [out] IEnumVdsObject** ppEnum
        );

    // CreateVolume:
    //   The types of volumes that can be created include simple, spanned,
    //   striped, mirrored, RAID-5. Basic provider can create volume from only
    //   one extent.
    [helpstring("method CreateVolume")]
        HRESULT CreateVolume(
            [in] VDS_VOLUME_TYPE type,
            [in] VDS_INPUT_DISK* pInputDiskArray,
            [in] LONG lNumberOfDisks,
            [in] ULONG ulStripeSize,
            [out] IVdsAsync** ppAsync
        );

    // AddDisk:
    //   Providers don't implement this method. Instead, they implement
    //   AddDisk() on IVdsMigrateDisks interface.
    [helpstring("method AddDisk")]
        HRESULT AddDisk(
            //[in] UUID DiskId,
            [in] int DiskId1, [in] int DiskId2, [in] int DiskId3, [in] int DiskId4,
            [in] VDS_PARTITION_STYLE PartitionStyle,
            [in] BOOL bAsHotSpare
        );

    // MigrateDisks:
    //   Providers don't implement this method. Instead, they implement
    //   IVdsMigrateDisks interface.
    [helpstring("method MigrateDisks")]
        HRESULT MigrateDisks(
            [in] UUID* pDiskArray,
            [in] LONG lNumberOfDisks,
            //[in] UUID TargetPack,
            [in] int TargetPack1, [in] int TargetPack2, [in] int TargetPack3, [in] int TargetPackd4,
            [in] BOOL bForce,
            // In some cases the migration may cause data loss.
            // if this flag is set to FALSE, the operation will
            // not proceed. One example is when a transitive
            // closure is missing a disk, the rest disks need to
            // be moved to another pack. This would normally be
            // vetoed. With bForce set to TRUE, the operation
            // will proceed.
            [in] BOOL bQueryOnly,
            // If this is set to TRUE, migration will not be really
            // carried out. The return results through pHresults
            // indicate whether a disk can be migrated or not.
            [out] HRESULT* pResults,
            // If a disk can be migrated, or is migrated successfully,
            // the corresponding HRESULT will be S_OK, otherwise,
            // a warning code, or an error code..
            [out] BOOL* pbRebootNeeded
        );

    // ReplaceDisk:
    //   Basic pack does not support this operation.
    [helpstring("method ReplaceDisk")]
        HRESULT ReplaceDisk(
            //[in] UUID OldDiskId,
            [in] int OldDiskId1, [in] int OldDiskId2, [in] int OldDiskId3, [in] int OldDiskId4,
            //[in] UUID NewDiskId,
            [in] int NewDiskId1, [in] int NewDiskId2, [in] int NewDiskId3, [in] int NewDiskId4,
            [out] IVdsAsync** ppAsync
        );

    // RemoveMissingDisk:
    [helpstring("method RemoveMissingDisk")]
        HRESULT RemoveMissingDisk(
            //[in] UUID DiskId,
            [in] int DiskId1, [in] int DiskId2, [in] int DiskId3, [in] int DiskId4
        );

    // Recover:
    //   This method tries to bring a failing or failed pack back to healthy
    //   state. It also tries to recover all unhealthy disks and volumes in
    //   the pack.
    [helpstring("method Recover")]
        HRESULT Recover(
            [out] IVdsAsync** ppAsync
        );
}


//
// IVdsPack2:
// Implemented by: pack object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(13B50BFF-290A-47DD-8558-B7C58DB1A71A)
]
interface IVdsPack2 : stdole.IUnknown
{
    // CreateVolume2:
    //   Adding an ullAlign param to CreateVolume.
    [helpstring("method CreateVolume2")]
        HRESULT CreateVolume2(
            [in] VDS_VOLUME_TYPE    type,
            [in] VDS_INPUT_DISK* pInputDiskArray,
            [in] LONG               lNumberOfDisks,
            [in] ULONG              ulStripeSize,
            [in] ULONG              ulAlign,
            [out] IVdsAsync** ppAsync
        );
}


//
// IVdsDisk:
// Implemented by: disk object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(07e5c822-f00c-47a1-8fce-b244da56fd06) 
]
interface IVdsDisk : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_DISK_PROP* pDiskProperties
        );

    [helpstring("method GetPack")]
        HRESULT GetPack(
            [out] IVdsPack** ppPack
        );
    // NOTE: for disks that are managed by the service (unallocated
    //       & masked), this method returns NULL.

    [helpstring("method GetIdentificationData")]
        HRESULT GetIdentificationData(
            [out] VDS_LUN_INFORMATION* pLunInfo
        );

    // QueryExtents:
    //   Return all extents on a disk. Extents include:
    //     dynamic volume extent, dynamic free extent,
    //     primary partition extent, logical drive extent, extended
    //       free extent,
    //     ESP extent, OEM extent, foreign partition extent,
    //     MSR extent, LDM Metadata extent
    //   Extent has a link to the volume on top of it, and an
    //   attribute to identify it as foreign partition.(unknown)
    [helpstring("method QueryExtents")]
        HRESULT QueryExtents(
            //[out] VDS_DISK_EXTENT** ppExtentArray,
            [out] LongPtr *ppExtentArray,
            [out] LONG* plNumberOfExtents
        );

    // ConvertStyle:
    //     To convert the style of a disk, the disk must be empty, meaning
    //   no user data, no OEM partition, no ESP partition, no unknown
    //   partition. It's OK to have LDM Metadata partition, or MSR partition.
    [helpstring("method ConvertStyle")]
        HRESULT ConvertStyle(
            [in] VDS_PARTITION_STYLE NewStyle
        );

    // SetFlags:
    //   Only VDS_DF_HOTSPARE can be set.
    [helpstring("method SetFlags")]
        HRESULT SetFlags(
            [in] VDS_DISK_FLAG   ulFlags
        );

    // ClearFlags:
    //   Only VDS_DF_HOTSPARE can be cleared.
    [helpstring("method ClearFlags")]
        HRESULT ClearFlags(
            [in] VDS_DISK_FLAG  ulFlags
        );
}



//
// IVdsDisk2:
// Implemented by: disk object
// Implemented where: The service, common layer
// Accessed by: applications
//
[
    odl,
        uuid(40F73C8B-687D-4a13-8D96-3D7F2E683936)
]
interface IVdsDisk2 : stdole.IUnknown
{
    [helpstring("method SetSANMode")]
        HRESULT SetSANMode(
            [in] BOOL bEnable
        );
}


//
// IVdsDiskOnline:
// Implemented by: disk object
// Implemented where: The service, common layer
// Accessed by: applications
//
[
    odl,
        uuid(90681B1D-6A7F-48e8-9061-31B7AA125322)
]
interface IVdsDiskOnline : stdole.IUnknown
{
    [helpstring("method Online")]
        HRESULT Online(void);

    [helpstring("method Offline")]
        HRESULT Offline(void);
}

//
// IVdsAdvancedDisk:
//   This interface is for configuring and managing partitions.
// Implemented by: disk object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(6e6f6b40-977c-4069-bddd-ac710059f8c0)
]
interface IVdsAdvancedDisk : stdole.IUnknown
{
    [helpstring("method GetPartitionProperties")]
        HRESULT GetPartitionProperties(
            [in] ULONGLONG ullOffset,
            [out] VDS_PARTITION_PROP* pPartitionProp
        );

    [helpstring("method QueryPartitions")]
        HRESULT QueryPartitions(
            //[out] VDS_PARTITION_PROP** ppPartitionPropArray,
            [out] LongPtr *ppPartitionPropArray,
            [out] LONG* plNumberOfPartitions
        );
    // Remark: Partitions include:
    //         primary partition, extended partition, logical drive,
    //         OEM partition, ESP partition, MSR partition, LDM Metadata
    //         partition, LDM data partition, Unknown partition.

    [helpstring("method CreatePartition")]
        HRESULT CreatePartition(
            [in] ULONGLONG ullOffset,
            [in] ULONGLONG ullSize,
            [in] CREATE_PARTITION_PARAMETERS* para,
            [out] IVdsAsync** ppAsync
        );
    // Remark: CreatePartition will fail on dynamic disks.

    [helpstring("method DeletePartition")]
        HRESULT DeletePartition(
            [in] ULONGLONG ullOffset,
            [in] BOOL bForce,       // forcefully delete a normal partition
            // that is in use
            [in] BOOL bForceProtected
            // forcefully delete a protected partition.
           // Protected partitions include OEM, ESP and
           // MSR partitions
        );
    // Remark: DeletePartition always fails on dynamic disk.

    [helpstring("method ChangeAttributes")]
        HRESULT ChangeAttributes(
            [in] ULONGLONG ullOffset,
            [in] CHANGE_ATTRIBUTES_PARAMETERS* para
        );

    // Providers don't implement this method.
    [helpstring("method AssignDriveLetter")]
        HRESULT AssignDriveLetter(
            [in] ULONGLONG ullOffset,           // partition offset
            [in] WCHAR wcLetter                 // drive letter to assign
        );

    [helpstring("method DeleteDriveLetter")]
        HRESULT DeleteDriveLetter(
            [in] ULONGLONG ullOffset,           // partition offset
            [in] WCHAR wcLetter
        );

    [helpstring("method GetDriveLetter")]
        HRESULT GetDriveLetter(
            [in] ULONGLONG ullOffset,
            [out] WCHAR* pwcLetter
        );

    [helpstring("method FormtPartition")]
        HRESULT FormatPartition(
            [in] ULONGLONG ullOffset,
            [in] VDS_FILE_SYSTEM_TYPE type,
            [in] LongPtr pwszLabel,
            [in] DWORD dwUnitAllocationSize,
            [in] BOOL bForce,
            [in] BOOL bQuickFormat,
            [in] BOOL bEnableCompression,    // NTFS only.
            [out] IVdsAsync** ppAsync
        );

    // Providers don't implement bFullClean option. Providers should return
    // as soon as possible after delete drive layout. The service will claim
    // the disk and finish the full clean part. The service blocks all calls
    // when the provider is cleaning a disk.
    HRESULT Clean(
        [in] BOOL bForce,
        [in] BOOL bForceOEM,
        [in] BOOL bFullClean,
        [out] IVdsAsync** ppAsync
    );
}

//
// IVdsAdvancedDisk2:
//   This interface is the next version of IVdsAdvancedDisk.
//   It contains additional methods to configure and manage
//   partitions.
// Implemented by: disk object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(9723f420-9355-42de-ab66-e31bb15beeac)
]
interface IVdsAdvancedDisk2 : stdole.IUnknown
{
    //
    // The following methods are new to LH.
    //

    [helpstring("method ChangePartitionType")]
        HRESULT ChangePartitionType(
            [in] ULONGLONG ullOffset,
            [in] BOOL bForce,
            [in] CHANGE_PARTITION_TYPE_PARAMETERS* para
        );

}


//
// IVdsAdvancedDisk3:
//   This interface is the next version of IVdsAdvancedDisk.
//   It contains additional methods to configure and manage
//   partitions.
// Implemented by: disk object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(3858C0D5-0F35-4BF5-9714-69874963BC36)
]
interface IVdsAdvancedDisk3 : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_ADVANCEDDISK_PROP* pAdvDiskProp
        );

    [helpstring("method GetUniqueId")]
        HRESULT GetUniqueId(
            [out] LongPtr* ppwszId
        );
}


//
// IVdsCreatePartitionEx:
//   This interface is to add alignment feature to CreatePartition
//   method on IVdsAdvancedDisk interface. It contains only one
//   method CreatePartitionEx.
// Implemented by: disk object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(9882f547-cfc3-420b-9750-00dfbec50662)
]
interface IVdsCreatePartitionEx : stdole.IUnknown
{
    [helpstring("method CreatePartitionEx")]
        HRESULT CreatePartitionEx(
            [in] ULONGLONG ullOffset,
            [in] ULONGLONG ullSize,
            [in] ULONG     ulAlign,
            [in] CREATE_PARTITION_PARAMETERS* para,
            [out] IVdsAsync** ppAsync
        );
    // Remark: CreatePartitionEx will fail on dynamic disks.
}

//
// IVdsRemovable:
//   Only removable disks implement this interface.
// Implemented by: disk object
// Implemented where: basic software provider, common layer
// Accessed by: applications
//
[
    odl,
        uuid(0316560b-5db4-4ed9-bbb5-213436ddc0d9)
]
interface IVdsRemovable : stdole.IUnknown
{
    [helpstring("method QueryMedia")]
        HRESULT QueryMedia(
        );

    [helpstring("method Eject")]
        HRESULT Eject(
            void
        );
}

//
// IVdsVolume:
// Implemented by: volume object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(88306bb2-e71f-478c-86a2-79da200a0f11)
]
interface IVdsVolume : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_VOLUME_PROP* pVolumeProperties
        );

    [helpstring("method GetPack")]
        HRESULT GetPack(
            [out] IVdsPack** ppPack
        );

    // QueryPlexes:
    //   Retrieve all the plexes of the volume.
    //   The most common case is that one volume has one plex (except mirror).
    [helpstring("method QueryPlexes")]
        HRESULT QueryPlexes(
            [out] IEnumVdsObject** ppEnum
        );

    // Extend:
    //   This method extends a volume by adding extents to each member of each
    //   plex of the volume. If a plex already has enough extra space (e.g.
    //   adding a bigger volume as a plex to a small volume), no disk extent
    //   is needed for that plex. If the disk extents have more space than
    //   needed, the extra space is not used.
    //
    //   Notes:
    //   1) A basic volume can also be extended, but the extent must be
    //      contiguous with the volume.
    //   2) When no extent is supplied, the method will extend the volume
    //      using any usable extra space on its plexes.
    //      (E.g. Adding two bigger plexes and then break off the original
    //            smaller plex, we end up having extra space on each of the
    //            plexes.)
    //
    [helpstring("method Extend")]
        HRESULT Extend(
            [in] VDS_INPUT_DISK* pInputDiskArray,
            [in] LONG lNumberOfDisks,
            [out] IVdsAsync** ppAsync
        );

    // Shrink:
    //   This method shrinks the volume and all plexes and return the
    //   released extents.
    //
    //   The file system will be shrunk first. In order to shrink a volume,
    //   the file system must support shrink.
    //
    //   Notes:
    //   1) when uNumberOfBytesToRemove is 0, this method shrink any plex
    //      whose size is greater than the volume and free up its extra space.
    [helpstring("method Shrink")]
        HRESULT Shrink(
            [in] ULONGLONG ullNumberOfBytesToRemove,
            [out] IVdsAsync** ppAsync
        );

    // AddPlex:
    //    Once a volume is added as a plex to another volume, it is no
    //    longer a volume itself. It loses its volume device object.
    //    Its COM object should allow an application to know the volume
    //    is gone, as if it's deleted.
    //    The target volume inherits flags from the base volume. The added
    //    plex loses it's original flags. E.g. VDS_VF_LBN_REMAP_ENABLED.
    //
    //    Note:
    //    1) A mirrored volume can be added as a plex to another volume too.
    //       The new volume will have a total number of plexes of the sum
    //       of the two separate volumes.
    [helpstring("method AddPlex")]
        HRESULT AddPlex(
            //[in] UUID VolumeId,
            [in] int VolumeId1, [in] int VolumeId2, [in] int VolumeId3, [in] int VolumeId4,
            [out] IVdsAsync** ppAsync
        );

    // BreakPlex:
    //    Break a specified plex of the volume. The broken-away plex becomes
    //    a hidden, readonly volume on its own.
    [helpstring("BreakPlex")]
        HRESULT BreakPlex(
            //[in] UUID plexId,
            [in] int plexId1, [in] int plexId2, [in] int plexId3, [in] int plexId4,
            [out] IVdsAsync** ppAsync
        );

    // RemovePlex:
    //    Remove a specified plex of the volume. The last plex of a volume
    //    cannot be removed.
    [helpstring("RemovePlex")]
        HRESULT RemovePlex(
            //[in] UUID plexId,
            [in] int plexId1, [in] int plexId2, [in] int plexId3, [in] int plexId4,
            [out] IVdsAsync** ppAsync
        );

    // Delete:
    //   All plexes are deleted.
    [helpstring("method Delete")]
        HRESULT Delete(
            [in] BOOL bForce
            // This flag is reserved for the service. Providers should
            // ignore it. It means if the volume is in use, whether or
            // not to forcefully delete.
        );

    // SetFlags:
    //   The flags can be VDS_VF_LBN_REMAP_ENABLED, VDS_VF_HIDDEN, VDS_VF_READONLY.
    //   Added flag: VDS_VF_INSTALLABLE to make a dynamic volume installable.
    [helpstring("method SetFlags")]
        HRESULT SetFlags(
            [in] ULONG ulFlags,
            [in] BOOL bRevertOnClose
        );

    // ClearFlags:
    //   The flags can be VDS_VF_LBN_REMAP_ENABLED, VDS_VF_HIDDEN.
    //   Added flag: VDS_VF_INSTALLABLE to remove hard partition under
    //   a dynamic volume.
    [helpstring("method ClearFlags")]
        HRESULT ClearFlags(
            [in] ULONG ulFlags
        );
}

//
// IVdsVolume2:
// Implemented by: volume object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(72AE6713-DCBB-4a03-B36B-371F6AC6B53D)
]
interface IVdsVolume2 : stdole.IUnknown
{
    [helpstring("method GetProperties2")]
        HRESULT GetProperties2(
            [out] VDS_VOLUME_PROP2* pVolumeProperties
        );
}


//
// IVdsVolumeOnline:
// Implemented by: volume object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(1BE2275A-B315-4f70-9E44-879B3A2A53F2)
]
interface IVdsVolumeOnline : stdole.IUnknown
{
    [helpstring("method Online")]
        HRESULT Online(void);
}



//
// IVdsVolumePlex:
// Implemented by: volume plex object
// Implemented where: software providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(4daa0135-e1d1-40f1-aaa5-3cc1e53221c3)
]
interface IVdsVolumePlex : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_VOLUME_PLEX_PROP* pPlexProperties
        );

    [helpstring("method GetVolume")]
        HRESULT GetVolume(
            [out] IVdsVolume** ppVolume
        );

    [helpstring("method QueryExtents")]
        HRESULT QueryExtents(
            //[out] VDS_DISK_EXTENT** ppExtentArray,
            [out] LongPtr * ppExtentArray,
            [out] LONG* plNumberOfExtents
        );

    // Repair:
    //   This method repairs a fault tolerant volume plex by moving bad
    //   member to good disks. Only disk id and size should be specified
    //   for VDS_INPUT_DISK.
    [helpstring("method Repair")]
        HRESULT Repair(
            [in] VDS_INPUT_DISK* pInputDiskArray,
            [in] LONG lNumberOfDisks,
            [out] IVdsAsync** ppAsync
        );
}



//
// IVdsDisk3:
// Implemented by: disk object
// Implemented where: The service, common layer
// Accessed by: applications
//
[
    odl,
        uuid(8F4B2F5D-EC15-4357-992F-473EF10975B9)
]
interface IVdsDisk3 : stdole.IUnknown
{
    [helpstring("method GetProperties2")]
        HRESULT GetProperties2(
            [out] VDS_DISK_PROP2* pDiskProperties
        );

    [helpstring("method QueryFreeExtents")]
        HRESULT QueryFreeExtents(
            [in]  ULONG ulAlign,
            //[out] VDS_DISK_FREE_EXTENT** ppFreeExtentArray,
            [out] LongPtr *ppFreeExtentArray,
            [out] LONG* plNumberOfFreeExtents
        );
}

//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(pop)")
//cpp_quote("#endif")
//
//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion















// ***************************************************************
//
// vdshp.idl
//
// ***************************************************************


//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2000
//
//    File: vdshp.idl
//
//    Abstract:
//        declarations of interfaces and types implemented by hardware provider
//        and also exposed by the common layer.
//
//----------------------------------------------------------------------------

//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")
//
//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(push)")
//cpp_quote("#pragma warning(disable:4820) /* padding added after data member */")
//cpp_quote("#endif")

interface IVdsHwProvider;
interface IVdsHwProviderType;
interface IVdsHwProviderType2;
interface IVdsHwProviderStoragePools;
interface IVdsLun;
interface IVdsLun2;
interface IVdsLunNaming;
interface IVdsLunNumber;
interface IVdsLunControllerPorts;
interface IVdsLunMpio;
interface IVdsSubSystem;
interface IVdsSubSystemNaming;
interface IVdsSubSystemIscsi;
interface IVdsSubSystem2;
interface IVdsSubSystemInterconnect;
interface IVdsControllerPort;
interface IVdsController;
interface IVdsControllerControllerPort;
interface IVdsDrive;
interface IVdsDrive2;
interface IVdsLunPlex;
interface IVdsIscsiPortal;
interface IVdsIscsiTarget;
interface IVdsIscsiPortalGroup;
interface IVdsStoragePool;
interface IVdsMaintenance;



//
// --- SubSystem related enums ---
//

//
// Status
//
typedef enum VDS_SUB_SYSTEM_STATUS
{
    VDS_SSS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_SSS_ONLINE = 1, //STATUS_ONLINE,
    VDS_SSS_NOT_READY = 2, //STATUS_NOT_READY,
    VDS_SSS_OFFLINE = 4, //STATUS_OFFLINE,
    VDS_SSS_FAILED = 5, //STATUS_FAILED,
    VDS_SSS_PARTIALLY_MANAGED = 9, //STATUS_PARTIALLY_MANAGED

} VDS_SUB_SYSTEM_STATUS;


//
// Flags
//
typedef enum VDS_SUB_SYSTEM_FLAG
{
    VDS_SF_LUN_MASKING_CAPABLE = 0x00001,
    VDS_SF_LUN_PLEXING_CAPABLE = 0x00002,
    VDS_SF_LUN_REMAPPING_CAPABLE = 0x00004,
    VDS_SF_DRIVE_EXTENT_CAPABLE = 0x00008,
    VDS_SF_HARDWARE_CHECKSUM_CAPABLE = 0x00010,

    // VDS 1.1 specific flags
    VDS_SF_RADIUS_CAPABLE = 0x00020,
    VDS_SF_READ_BACK_VERIFY_CAPABLE = 0x00040,
    VDS_SF_WRITE_THROUGH_CACHING_CAPABLE = 0x00080,

    VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS = 0x00200,
    VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS = 0x00400,
    VDS_SF_SUPPORTS_SIMPLE_LUNS = 0x00800,
    VDS_SF_SUPPORTS_SPAN_LUNS = 0x01000,
    VDS_SF_SUPPORTS_STRIPE_LUNS = 0x02000,
    VDS_SF_SUPPORTS_MIRROR_LUNS = 0x04000,
    VDS_SF_SUPPORTS_PARITY_LUNS = 0x08000,

    // iSCSI specific flags
    VDS_SF_SUPPORTS_AUTH_CHAP = 0x10000,
    VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP = 0x20000,
    VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG = 0x40000,

    // Win7 flags
    VDS_SF_SUPPORTS_LUN_NUMBER = 0x80000,
    VDS_SF_SUPPORTS_MIRRORED_CACHE = 0x100000,
    VDS_SF_READ_CACHING_CAPABLE = 0x200000,
    VDS_SF_WRITE_CACHING_CAPABLE = 0x400000,
    VDS_SF_MEDIA_SCAN_CAPABLE = 0x800000,
    VDS_SF_CONSISTENCY_CHECK_CAPABLE = 0x1000000

} VDS_SUB_SYSTEM_FLAG;


//
// Supported raid type flag
//
typedef enum VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG
{
    VDS_SF_SUPPORTS_RAID2_LUNS = 0x00001,
    VDS_SF_SUPPORTS_RAID3_LUNS = 0x00002,
    VDS_SF_SUPPORTS_RAID4_LUNS = 0x00004,
    VDS_SF_SUPPORTS_RAID5_LUNS = 0x00008,
    VDS_SF_SUPPORTS_RAID6_LUNS = 0x00010,
    VDS_SF_SUPPORTS_RAID01_LUNS = 0x00020,
    VDS_SF_SUPPORTS_RAID03_LUNS = 0x00040,
    VDS_SF_SUPPORTS_RAID05_LUNS = 0x00080,
    VDS_SF_SUPPORTS_RAID10_LUNS = 0x00100,
    VDS_SF_SUPPORTS_RAID15_LUNS = 0x00200,
    VDS_SF_SUPPORTS_RAID30_LUNS = 0x00400,
    VDS_SF_SUPPORTS_RAID50_LUNS = 0x00800,
    VDS_SF_SUPPORTS_RAID51_LUNS = 0x01000,
    VDS_SF_SUPPORTS_RAID53_LUNS = 0x02000,
    VDS_SF_SUPPORTS_RAID60_LUNS = 0x04000,
    VDS_SF_SUPPORTS_RAID61_LUNS = 0x08000,

} VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG;


//
// Supported interconnects flag
//
typedef enum VDS_INTERCONNECT_FLAG
{
    VDS_ITF_PCI_RAID = 0x01,
    VDS_ITF_FIBRE_CHANNEL = 0x02,
    VDS_ITF_ISCSI = 0x04,
    VDS_ITF_SAS = 0x08

} VDS_INTERCONNECT_FLAG;


//
// --- Controller related enums ---
//

//
// Status
//
typedef enum VDS_CONTROLLER_STATUS
{
    VDS_CS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_CS_ONLINE = 1, //STATUS_ONLINE,
    VDS_CS_NOT_READY = 2, //STATUS_NOT_READY,
    VDS_CS_OFFLINE = 4, //STATUS_OFFLINE,
    VDS_CS_FAILED = 5, //STATUS_FAILED,
    VDS_CS_REMOVED = 8, //STATUS_REMOVED

} VDS_CONTROLLER_STATUS;



//
// --- Controller Port related enums ---
//

//
// Status
//
typedef enum VDS_PORT_STATUS
{
    VDS_PRS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_PRS_ONLINE = 1, //STATUS_ONLINE,
    VDS_PRS_NOT_READY = 2, //STATUS_NOT_READY,
    VDS_PRS_OFFLINE = 4, //STATUS_OFFLINE,
    VDS_PRS_FAILED = 5, //STATUS_FAILED,
    VDS_PRS_REMOVED = 8, //STATUS_REMOVED

} VDS_PORT_STATUS;



//
// --- Drive related enums ---
//

//
// Status
//
//tB Added
typedef enum VDS_DRIVE_STATUS
{
    VDS_DRS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_DRS_ONLINE = 1, //STATUS_ONLINE,
    VDS_DRS_NOT_READY = 2, //STATUS_NOT_READY,
    VDS_DRS_OFFLINE = 4, //STATUS_OFFLINE,
    VDS_DRS_FAILED = 5, //STATUS_FAILED,
    VDS_DRS_REMOVED = 8, //STATUS_REMOVED

} VDS_DRIVE_STATUS;


//
// Flags
//
typedef enum VDS_DRIVE_FLAG
{
    VDS_DRF_HOTSPARE = 0x01,
    VDS_DRF_ASSIGNED = 0x02,
    VDS_DRF_UNASSIGNED = 0x04,
    VDS_DRF_HOTSPARE_IN_USE = 0x08,
    VDS_DRF_HOTSPARE_STANDBY = 0x10

} VDS_DRIVE_FLAG;



//
// --- LUN related enums ---
//

//
// Types
//
//tB Added
typedef enum VDS_LUN_TYPE
{
    VDS_LT_UNKNOWN = 0,

    // automagic types (used as input parameters only)
    VDS_LT_DEFAULT = 1,
    VDS_LT_FAULT_TOLERANT = 2,
    VDS_LT_NON_FAULT_TOLERANT = 3,

    // actual types (used as input and query return)
    VDS_LT_SIMPLE = 10,
    VDS_LT_SPAN = 11,
    VDS_LT_STRIPE = 12,
    VDS_LT_MIRROR = 13,
    VDS_LT_PARITY = 14,

    VDS_LT_RAID2 = 15,
    VDS_LT_RAID3 = 16,
    VDS_LT_RAID4 = 17,
    VDS_LT_RAID5 = 18,
    VDS_LT_RAID6 = 19,
    VDS_LT_RAID01 = 20,
    VDS_LT_RAID03 = 21,
    VDS_LT_RAID05 = 22,
    VDS_LT_RAID10 = 23,
    VDS_LT_RAID15 = 24,
    VDS_LT_RAID30 = 25,
    VDS_LT_RAID50 = 26,
    VDS_LT_RAID51 = 27,
    VDS_LT_RAID53 = 28,
    VDS_LT_RAID60 = 29,
    VDS_LT_RAID61 = 30,

} VDS_LUN_TYPE;


//
// Status
//
//tB Added
typedef enum VDS_LUN_STATUS
{
    VDS_LS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_LS_ONLINE = 1, //STATUS_ONLINE,
    VDS_LS_NOT_READY = 2, //STATUS_NOT_READY,
    VDS_LS_OFFLINE = 4 ,//STATUS_OFFLINE,
    VDS_LS_FAILED = 5, //STATUS_FAILED

} VDS_LUN_STATUS;


//
// Flags
//
typedef enum VDS_LUN_FLAG
{
    VDS_LF_LBN_REMAP_ENABLED = 0x01,
    VDS_LF_READ_BACK_VERIFY_ENABLED = 0x02,
    VDS_LF_WRITE_THROUGH_CACHING_ENABLED = 0x04,
    VDS_LF_HARDWARE_CHECKSUM_ENABLED = 0x08,
    VDS_LF_READ_CACHE_ENABLED = 0x10,
    VDS_LF_WRITE_CACHE_ENABLED = 0x20,
    VDS_LF_MEDIA_SCAN_ENABLED = 0x40,
    VDS_LF_CONSISTENCY_CHECK_ENABLED = 0x80,
    VDS_LF_SNAPSHOT = 0x100

} VDS_LUN_FLAG;

//
// --- LUN plex related enums ---
//

//
// Types
//
//tB Added
typedef enum VDS_LUN_PLEX_TYPE
{
    VDS_LPT_UNKNOWN = 0,
    VDS_LPT_SIMPLE = 10, //VDS_LT_SIMPLE,
    VDS_LPT_SPAN = 11, //VDS_LT_SPAN,
    VDS_LPT_STRIPE = 12, //VDS_LT_STRIPE,
    VDS_LPT_PARITY = 14, //VDS_LT_PARITY,

    VDS_LPT_RAID2 = 15, //VDS_LT_RAID2,
    VDS_LPT_RAID3 = 16, //VDS_LT_RAID3,
    VDS_LPT_RAID4 = 17, //VDS_LT_RAID4,
    VDS_LPT_RAID5 = 18, //VDS_LT_RAID5,
    VDS_LPT_RAID6 = 19, //VDS_LT_RAID6,
    VDS_LPT_RAID03 = 21, //VDS_LT_RAID03,
    VDS_LPT_RAID05 = 22, //VDS_LT_RAID05,
    VDS_LPT_RAID10 = 23, //VDS_LT_RAID10,
    VDS_LPT_RAID15 = 24, //VDS_LT_RAID15,
    VDS_LPT_RAID30 = 25, //VDS_LT_RAID30,
    VDS_LPT_RAID50 = 26, //VDS_LT_RAID50,
    VDS_LPT_RAID53 = 28, //VDS_LT_RAID53,
    VDS_LPT_RAID60 = 29, //VDS_LT_RAID60,


} VDS_LUN_PLEX_TYPE;

//
// Status
//
//tB Added
typedef enum VDS_LUN_PLEX_STATUS
{
    VDS_LPS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_LPS_ONLINE = 1, //STATUS_ONLINE,
    VDS_LPS_NOT_READY = 2, //STATUS_NOT_READY,
    VDS_LPS_OFFLINE = 4, //STATUS_OFFLINE,
    VDS_LPS_FAILED = 5, //STATUS_FAILED

} VDS_LUN_PLEX_STATUS;


typedef enum VDS_LUN_PLEX_FLAG
{
    VDS_LPF_LBN_REMAP_ENABLED = 0x1 //VDS_LF_LBN_REMAP_ENABLED

} VDS_LUN_PLEX_FLAG;


//
// --- iSCSI portal related enums ---
//

//
// Status
//
typedef enum VDS_ISCSI_PORTAL_STATUS
{
    VDS_IPS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_IPS_ONLINE = 1, //STATUS_ONLINE,
    VDS_IPS_NOT_READY = 2, //STATUS_NOT_READY,
    VDS_IPS_OFFLINE = 4, //STATUS_OFFLINE,
    VDS_IPS_FAILED = 5, //STATUS_FAILED
} VDS_ISCSI_PORTAL_STATUS;


//
// --- Storage Pool related enums ---
//

//
// Status
//
typedef enum VDS_STORAGE_POOL_STATUS
{
    VDS_SPS_UNKNOWN = 0, //STATUS_UNKNOWN,
    VDS_SPS_ONLINE = 1, //STATUS_ONLINE,
    VDS_SPS_NOT_READY = 2, //STATUS_NOT_READY,
    VDS_SPS_OFFLINE = 4, //STATUS_OFFLINE
} VDS_STORAGE_POOL_STATUS;

//
// Pool type
// Note: The values are used as flags
// So, if a new type is added, its
// value should be 0x04.
//
typedef enum VDS_STORAGE_POOL_TYPE
{
    VDS_SPT_UNKNOWN = 0x00,
    VDS_SPT_PRIMORDIAL = 0x01,
    VDS_SPT_CONCRETE = 0x02
} VDS_STORAGE_POOL_TYPE;


//
// --- Miscellaneous enums ---
//

//
// Maintenance Operations
//
typedef enum VDS_MAINTENANCE_OPERATION
{
    BlinkLight = 1,
    BeepAlarm = 2,
    SpinDown = 3,
    SpinUp = 4,
    Ping = 5

} VDS_MAINTENANCE_OPERATION;


//
// Hints for creating a LUN
//
typedef struct VDS_HINTS
{
    ULONGLONG   ullHintMask;
    ULONGLONG   ullExpectedMaximumSize;

    ULONG       ulOptimalReadSize;           // 0 indicates no optimal size
    ULONG       ulOptimalReadAlignment;      // 0 indicates no optimal alignment
    ULONG       ulOptimalWriteSize;          // 0 indicates no optimal size
    ULONG       ulOptimalWriteAlignment;     // 0 indicates no optimal alignment
    ULONG       ulMaximumDriveCount;         // 0 indicates no maximum
    ULONG       ulStripeSize;                // 0 indicates unspecified stripe size

    BOOL        bFastCrashRecoveryRequired;
    BOOL        bMostlyReads;
    BOOL        bOptimizeForSequentialReads;
    BOOL        bOptimizeForSequentialWrites;
    BOOL        bRemapEnabled;
    BOOL        bReadBackVerifyEnabled;
    BOOL        bWriteThroughCachingEnabled;
    BOOL        bHardwareChecksumEnabled;
    BOOL        bIsYankable;                 // No migration prior to media

    SHORT       sRebuildPriority;

} VDS_HINTS;

//const ULONGLONG         VDS_HINT_FASTCRASHRECOVERYREQUIRED = 0x0000000000000001L;
//const ULONGLONG         VDS_HINT_MOSTLYREADS = 0x0000000000000002L;
//const ULONGLONG         VDS_HINT_OPTIMIZEFORSEQUENTIALREADS = 0x0000000000000004L;
//const ULONGLONG         VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES = 0x0000000000000008L;
//
//const ULONGLONG         VDS_HINT_READBACKVERIFYENABLED = 0x0000000000000010L;
//const ULONGLONG         VDS_HINT_REMAPENABLED = 0x0000000000000020L;
//const ULONGLONG         VDS_HINT_WRITETHROUGHCACHINGENABLED = 0x0000000000000040L;
//const ULONGLONG         VDS_HINT_HARDWARECHECKSUMENABLED = 0x0000000000000080L;
//
//const ULONGLONG         VDS_HINT_ISYANKABLE = 0x0000000000000100L;


//
// New hints structure for creating a LUN
//
//tB Added
typedef struct VDS_HINTS2
{
    ULONGLONG               ullHintMask;
    ULONGLONG               ullExpectedMaximumSize;

    ULONG                   ulOptimalReadSize;           // 0 indicates no optimal size
    ULONG                   ulOptimalReadAlignment;      // 0 indicates no optimal alignment
    ULONG                   ulOptimalWriteSize;          // 0 indicates no optimal size
    ULONG                   ulOptimalWriteAlignment;     // 0 indicates no optimal alignment
    ULONG                   ulMaximumDriveCount;         // 0 indicates no maximum
    ULONG                   ulStripeSize;                // 0 indicates unspecified stripe size

    // reserved for future use
    ULONG                   ulReserved1;
    ULONG                   ulReserved2;
    ULONG                   ulReserved3;

    BOOL                    bFastCrashRecoveryRequired;
    BOOL                    bMostlyReads;
    BOOL                    bOptimizeForSequentialReads;
    BOOL                    bOptimizeForSequentialWrites;
    BOOL                    bRemapEnabled;
    BOOL                    bReadBackVerifyEnabled;
    BOOL                    bWriteThroughCachingEnabled;
    BOOL                    bHardwareChecksumEnabled;
    BOOL                    bIsYankable;                 // No migration prior to media

    // new additions
    BOOL                    bAllocateHotSpare;
    BOOL                    bUseMirroredCache;
    BOOL                    bReadCachingEnabled;
    BOOL                    bWriteCachingEnabled;
    BOOL                    bMediaScanEnabled;
    BOOL                    bConsistencyCheckEnabled;

    VDS_STORAGE_BUS_TYPE    BusType;

    // reserved for future use
    BOOL                    bReserved1;
    BOOL                    bReserved2;
    BOOL                    bReserved3;

    SHORT                   sRebuildPriority;

    BYTE padVBOnly[6];
} VDS_HINTS2;

//const ULONGLONG	        VDS_HINT_ALLOCATEHOTSPARE = 0x0000000000000200L;
//const ULONGLONG	        VDS_HINT_BUSTYPE = 0x0000000000000400L;
//const ULONGLONG	        VDS_HINT_USEMIRROREDCACHE = 0x0000000000000800L;
//const ULONGLONG	        VDS_HINT_READCACHINGENABLED = 0x0000000000001000L;
//const ULONGLONG	        VDS_HINT_WRITECACHINGENABLED = 0x0000000000002000L;
//const ULONGLONG	        VDS_HINT_MEDIASCANENABLED = 0x0000000000004000L;
//const ULONGLONG	        VDS_HINT_CONSISTENCYCHECKENABLED = 0x0000000000008000L;



//
// --- VDS Object Properties ---
//

//
// Subsytem Properties
//
typedef struct VDS_SUB_SYSTEM_PROP
{
    UUID           id;

    LongPtr         pwszFriendlyName;

    LongPtr         pwszIdentification; // The disk array's serial number, the subsystem's identifier.

    VDS_SUB_SYSTEM_FLAG                   ulFlags;
    ULONG                   ulStripeSizeFlags;

    VDS_SUB_SYSTEM_STATUS   status;
    VDS_HEALTH              health; // Healthy, Failed

    SHORT                   sNumberOfInternalBuses;
    SHORT                   sMaxNumberOfSlotsEachBus;
    SHORT                   sMaxNumberOfControllers;
    SHORT                   sRebuildPriority;

} VDS_SUB_SYSTEM_PROP;


typedef struct VDS_SUB_SYSTEM_PROP2
{
    UUID           id;

    LongPtr         pwszFriendlyName;

    LongPtr         pwszIdentification; // The disk array's serial number, the subsystem's identifier.

    VDS_SUB_SYSTEM_FLAG                   ulFlags;
    ULONG                   ulStripeSizeFlags;
    VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG                   ulSupportedRaidTypeFlags;

    VDS_SUB_SYSTEM_STATUS   status;
    VDS_HEALTH              health; // Healthy, Failed

    SHORT                   sNumberOfInternalBuses;
    SHORT                   sMaxNumberOfSlotsEachBus;
    SHORT                   sMaxNumberOfControllers;
    SHORT                   sRebuildPriority;

    ULONG                   ulNumberOfEnclosures;

} VDS_SUB_SYSTEM_PROP2;



//
// Controller Properties
//
typedef struct VDS_CONTROLLER_PROP
{
    UUID           id;

    LongPtr         pwszFriendlyName;

    LongPtr         pwszIdentification;

    VDS_CONTROLLER_STATUS   status;
    VDS_HEALTH              health;  // HEALTHY, FAILED

    SHORT                   sNumberOfPorts; // always >= 1.
    // ports are numbered starting from 0.

} VDS_CONTROLLER_PROP;


//
// Drive Properties
//
//tB Added
typedef struct VDS_DRIVE_PROP
{
    UUID           id;

    ULONGLONG               ullSize;

    LongPtr         pwszFriendlyName;

    LongPtr         pwszIdentification;

    VDS_DRIVE_FLAG                   ulFlags;

    VDS_DRIVE_STATUS        status;
    VDS_HEALTH              health;

    SHORT                   sInternalBusNumber;
    SHORT                   sSlotNumber;

} VDS_DRIVE_PROP;


//
// Drive Properties 2
//
typedef struct VDS_DRIVE_PROP2
{
    UUID           id;

    ULONGLONG               ullSize;

    LongPtr         pwszFriendlyName;

    LongPtr         pwszIdentification;

    VDS_DRIVE_FLAG                   ulFlags;

    VDS_DRIVE_STATUS        status;
    VDS_HEALTH              health;

    SHORT                   sInternalBusNumber;
    SHORT                   sSlotNumber;

    ULONG                   ulEnclosureNumber;
    VDS_STORAGE_BUS_TYPE    busType;
    ULONG                   ulSpindleSpeed;
    int padVBOnly;
} VDS_DRIVE_PROP2;


//
// Drive Extent
//
typedef struct VDS_DRIVE_EXTENT
{
    UUID       id;

    UUID       LunId;

    ULONGLONG           ullSize;

    BOOL                bUsed;

    int padVBOnly;
} VDS_DRIVE_EXTENT;




//
// LUN properties
//
 //#define VDS_REBUILD_PRIORITY_MIN        0 
 //#define VDS_REBUILD_PRIORITY_MAX        16 

//tB Added
typedef struct VDS_LUN_PROP
{
    UUID           id;

    ULONGLONG               ullSize;

    LongPtr         pwszFriendlyName;

    LongPtr         pwszIdentification;

    // This is a list of masks (or one mask) of the LUN. It specifies
    // which node(s) (designated by a string meaningful to the provider)
    // can access the LUN. If the LUN is not masked, pwszUnmaskingList
    // should be NULL.
    LongPtr         pwszUnmaskingList;

    VDS_LUN_FLAG                   ulFlags;

    VDS_LUN_TYPE            type;
    VDS_LUN_STATUS          status;
    VDS_HEALTH              health;
    VDS_TRANSITION_STATE    TransitionState;

    SHORT                   sRebuildPriority;

    BYTE padVBOnly[6];
} VDS_LUN_PROP;

//
// LUN plex properties
//
//tB Added
typedef struct VDS_LUN_PLEX_PROP
{
    UUID           id;
    ULONGLONG               ullSize;

    VDS_LUN_PLEX_TYPE       type;
    VDS_LUN_PLEX_STATUS     status;
    VDS_HEALTH              health;
    VDS_TRANSITION_STATE    TransitionState;

    VDS_LUN_PLEX_FLAG                   ulFlags;

    // These properties are returned by the provider.  They are
    // set using VDS_HINTS as part of CreateLun or ApplyHints.
    ULONG                   ulStripeSize;

    SHORT                   sRebuildPriority;

    BYTE padVBOnly[6];
} VDS_LUN_PLEX_PROP;



//
// Port properties
//
typedef struct VDS_PORT_PROP
{
    UUID           id;

    LongPtr         pwszFriendlyName;

    LongPtr         pwszIdentification;

    VDS_PORT_STATUS         status;

} VDS_PORT_PROP;



//
// iSCSI portal properties
//
typedef struct VDS_ISCSI_PORTAL_PROP
{
    UUID           id;

    VDS_IPADDRESS           address;

    VDS_ISCSI_PORTAL_STATUS status;

} VDS_ISCSI_PORTAL_PROP;



//
// iSCSI target properties
//
typedef struct VDS_ISCSI_TARGET_PROP
{
    UUID   id;

    LongPtr pwszIscsiName;
    LongPtr pwszFriendlyName;

    BOOL            bChapEnabled;

} VDS_ISCSI_TARGET_PROP;



//
// iSCSI portal group properties
//
typedef struct VDS_ISCSI_PORTALGROUP_PROP
{
    UUID               id;

    USHORT   tag;

} VDS_ISCSI_PORTALGROUP_PROP;


//
// Storage Pool attributes
//
//tB Added
typedef enum VDS_RAID_TYPE
{
    VDS_RT_UNKNOWN = 0,

    VDS_RT_RAID0 = 10,
    VDS_RT_RAID1 = 11,
    VDS_RT_RAID2 = 12,
    VDS_RT_RAID3 = 13,
    VDS_RT_RAID4 = 14,
    VDS_RT_RAID5 = 15,
    VDS_RT_RAID6 = 16,
    VDS_RT_RAID01 = 17,
    VDS_RT_RAID03 = 18,
    VDS_RT_RAID05 = 19,
    VDS_RT_RAID10 = 20,
    VDS_RT_RAID15 = 21,
    VDS_RT_RAID30 = 22,
    VDS_RT_RAID50 = 23,
    VDS_RT_RAID51 = 24,
    VDS_RT_RAID53 = 25,
    VDS_RT_RAID60 = 26,
    VDS_RT_RAID61 = 27,

} VDS_RAID_TYPE;

//tB Added
typedef struct VDS_POOL_CUSTOM_ATTRIBUTES
{
    LongPtr	pwszName;
    LongPtr	pwszValue;
} VDS_POOL_CUSTOM_ATTRIBUTES;

//tB Added
typedef struct VDS_POOL_ATTRIBUTES
{
    ULONGLONG			    ullAttributeMask;

    VDS_RAID_TYPE			raidType;
    VDS_STORAGE_BUS_TYPE	busType;
    LongPtr				    pwszIntendedUsage;
    BOOL				    bSpinDown;
    BOOL				    bIsThinProvisioned;
    int padVBOnly;
    ULONGLONG			    ullProvisionedSpace;

    BOOL				    bNoSinglePointOfFailure;
    ULONG				    ulDataRedundancyMax;
    ULONG				    ulDataRedundancyMin;
    ULONG				    ulDataRedundancyDefault;
    ULONG				    ulPackageRedundancyMax;
    ULONG				    ulPackageRedundancyMin;
    ULONG				    ulPackageRedundancyDefault;

    ULONG				    ulStripeSize;
    ULONG				    ulStripeSizeMax;
    ULONG				    ulStripeSizeMin;
    ULONG				    ulDefaultStripeSize;
    ULONG				    ulNumberOfColumns;
    ULONG				    ulNumberOfColumnsMax;
    ULONG				    ulNumberOfColumnsMin;
    ULONG				    ulDefaultNumberofColumns;

    ULONG				    ulDataAvailabilityHint;
    ULONG				    ulAccessRandomnessHint;
    ULONG				    ulAccessDirectionHint;
    ULONG				    ulAccessSizeHint;
    ULONG				    ulAccessLatencyHint;
    ULONG				    ulAccessBandwidthWeightHint;
    ULONG				    ulStorageCostHint;
    ULONG				    ulStorageEfficiencyHint;

    // Custom attributes array
    ULONG				    ulNumOfCustomAttributes;
    //[size_is(ulNumOfCustomAttributes)] VDS_POOL_CUSTOM_ATTRIBUTES* pPoolCustomAttributes;
    LongPtr pPoolCustomAttributes;

    // Reserved for future use
    BOOL				    bReserved1;
    BOOL				    bReserved2;

    ULONG				    ulReserved1;
    ULONG				    ulReserved2;

    int padVBOnly2;

    ULONGLONG			    ullReserved1;
    ULONGLONG			    ullReserved2;

} VDS_POOL_ATTRIBUTES;

//const ULONGLONG VDS_POOL_ATTRIB_RAIDTYPE = 0x0000000000000001L;
//const ULONGLONG VDS_POOL_ATTRIB_BUSTYPE = 0x0000000000000002L;
//const ULONGLONG VDS_POOL_ATTRIB_ALLOW_SPINDOWN = 0x0000000000000004L;
//const ULONGLONG VDS_POOL_ATTRIB_THIN_PROVISION = 0x0000000000000008L;
//
//const ULONGLONG VDS_POOL_ATTRIB_NO_SINGLE_POF = 0x0000000000000010L;
//const ULONGLONG VDS_POOL_ATTRIB_DATA_RDNCY_MAX = 0x0000000000000020L;
//const ULONGLONG VDS_POOL_ATTRIB_DATA_RDNCY_MIN = 0x0000000000000040L;
//const ULONGLONG VDS_POOL_ATTRIB_DATA_RDNCY_DEF = 0x0000000000000080L;
//const ULONGLONG VDS_POOL_ATTRIB_PKG_RDNCY_MAX = 0x0000000000000100L;
//const ULONGLONG VDS_POOL_ATTRIB_PKG_RDNCY_MIN = 0x0000000000000200L;
//const ULONGLONG VDS_POOL_ATTRIB_PKG_RDNCY_DEF = 0x0000000000000400L;
//const ULONGLONG VDS_POOL_ATTRIB_STRIPE_SIZE = 0x0000000000000800L;
//const ULONGLONG VDS_POOL_ATTRIB_STRIPE_SIZE_MAX = 0x0000000000001000L;
//const ULONGLONG VDS_POOL_ATTRIB_STRIPE_SIZE_MIN = 0x0000000000002000L;
//const ULONGLONG VDS_POOL_ATTRIB_STRIPE_SIZE_DEF = 0x0000000000004000L;
//const ULONGLONG VDS_POOL_ATTRIB_NUM_CLMNS = 0x0000000000008000L;
//const ULONGLONG VDS_POOL_ATTRIB_NUM_CLMNS_MAX = 0x0000000000010000L;
//const ULONGLONG VDS_POOL_ATTRIB_NUM_CLMNS_MIN = 0x0000000000020000L;
//const ULONGLONG VDS_POOL_ATTRIB_NUM_CLMNS_DEF = 0x0000000000040000L;
//
//const ULONGLONG VDS_POOL_ATTRIB_DATA_AVL_HINT = 0x0000000000080000L;
//const ULONGLONG VDS_POOL_ATTRIB_ACCS_RNDM_HINT = 0x0000000000100000L;
//const ULONGLONG VDS_POOL_ATTRIB_ACCS_DIR_HINT = 0x0000000000200000L;
//const ULONGLONG VDS_POOL_ATTRIB_ACCS_SIZE_HINT = 0x0000000000400000L;
//const ULONGLONG VDS_POOL_ATTRIB_ACCS_LTNCY_HINT = 0x0000000000800000L;
//const ULONGLONG VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT = 0x0000000001000000L;
//const ULONGLONG VDS_POOL_ATTRIB_STOR_COST_HINT = 0x0000000002000000L;
//const ULONGLONG VDS_POOL_ATTRIB_STOR_EFFCY_HINT = 0x0000000004000000L;
//
//const ULONGLONG VDS_POOL_ATTRIB_CUSTOM_ATTRIB = 0x0000000008000000L;


//
// Storage Pool properties
//
typedef struct VDS_STORAGE_POOL_PROP
{
    UUID           id;
    VDS_STORAGE_POOL_STATUS status;
    VDS_HEALTH              health;

    VDS_STORAGE_POOL_TYPE   type;
    LongPtr         pwszName;
    LongPtr         pwszDescription;
    ULONGLONG               ullTotalConsumedSpace;
    ULONGLONG               ullTotalManagedSpace;
    ULONGLONG               ullRemainingFreeSpace;

} VDS_STORAGE_POOL_PROP;

//
// Storage pool drive extent
//
typedef struct VDS_STORAGE_POOL_DRIVE_EXTENT
{
    UUID       id;
    ULONGLONG           ullSize;
    BOOL                bUsed;
    int padVBOnly;
} VDS_STORAGE_POOL_DRIVE_EXTENT;



//
// --- Interface definitions ---
//


//
// IVdsHwProvider:
//   This interface exposes hardware provider specific functions.
// Implemented by: provider object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(d99bdaae-b13a-4178-9fdb-e27f16b4603e)
]
interface IVdsHwProvider : stdole.IUnknown
{
    // QuerySubSystems:
    //   A subsystem is a hardware array or software implementation of
    //   hardware array functionality. Hardware arrays can have more
    //   than one controller (failover). PCI-RAID controllers can be
    //   connected to the host server directly. In this case, each
    //   PCI-RAID controller is a storage system.
    [helpstring("method QuerySubSystems")]
        HRESULT QuerySubSystems(
            [out] IEnumVdsObject** ppEnum
        );


    // Reenumerate:
    //   For providers that cannot automatically detect new subsystems,
    //   this method needs to be called to find new subsystems.
    [helpstring("method Reenumerate")]
        HRESULT Reenumerate(
            void
        );

    // Refresh
    [helpstring("method Refresh")]
        HRESULT Refresh(
            void
        );

}

//
// IVdsHwProviderType:
//
// Implemented by: provider object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(3e0f5166-542d-4fc6-947a-012174240b7e)
]
interface IVdsHwProviderType : stdole.IUnknown
{
    [helpstring("method GetProviderType")]
        HRESULT GetProviderType(
            [out] VDS_HWPROVIDER_TYPE* pType
        );
}

//
// IVdsHwProviderType2:
//
// Implemented by: provider object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(8190236f-c4d0-4e81-8011-d69512fcc984)
]
interface IVdsHwProviderType2 : stdole.IUnknown
{
    [helpstring("method GetProviderType2")]
        HRESULT GetProviderType2(
            [out] VDS_HWPROVIDER_TYPE* pType
        );

}

//
// IVdsHwProviderStoragePools:
//
// Implemented by: provider object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(d5b5937a-f188-4c79-b86c-11c920ad11b8)
]
interface IVdsHwProviderStoragePools : stdole.IUnknown
{
    [helpstring("method QueryStoragePools")]
        HRESULT QueryStoragePools(
            [in] VDS_STORAGE_POOL_TYPE ulFlags,
            [in] ULONGLONG ullRemainingFreeSpace,
            [in] VDS_POOL_ATTRIBUTES* pPoolAttributes,
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method CreateLunInStoragePool")]
        HRESULT CreateLunInStoragePool(
            [in] VDS_LUN_TYPE type,
            [in] ULONGLONG ullSizeInBytes,
            //[in] UUID StoragePoolId,
            [in] int StoragePoolId1, [in] int StoragePoolId2, [in] int StoragePoolId3, [in] int StoragePoolId4,
            [in] LongPtr pwszUnmaskingList,
            [in] VDS_HINTS2* pHints2,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method QueryMaxLunCreateSizeInStoragePool")]
        HRESULT QueryMaxLunCreateSizeInStoragePool(
            [in] VDS_LUN_TYPE type,
            //[in] UUID StoragePoolId,
            [in] int StoragePoolId1, [in] int StoragePoolId2, [in] int StoragePoolId3, [in] int StoragePoolId4,
            [in] VDS_HINTS2* pHints2,
            [out] ULONGLONG* pullMaxLunSize
        );
}


//
// IVdsSubSystem:
//
// Implemented by: subsystem object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(6fcee2d3-6d90-4f91-80e2-a5c7caaca9d8)
]
interface IVdsSubSystem : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_SUB_SYSTEM_PROP* pSubSystemProp
        );

    [helpstring("method GetProvider")]
        HRESULT GetProvider(
            [out] IVdsProvider** ppProvider
        );

    [helpstring("method QueryControllers")]
        HRESULT QueryControllers(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method QueryLuns")]
        HRESULT QueryLuns(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method QueryDrives")]
        HRESULT QueryDrives(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method GetDrive")]
        HRESULT GetDrive(
            [in] SHORT sBusNumber,
            [in] SHORT sSlotNumber,
            [out] IVdsDrive** ppDrive
        );

    // Reenumerate:
    //   For subsystems that cannot automatically detect new spindle arrival,
    //   departure, this method needs to be called to find new spindle.
    [helpstring("method Reenumerate")]
        HRESULT Reenumerate(
            void
        );

    //
    // Sets the controller states to be either "online" or "offline."
    // Note that all the controllers of the current subsystem
    // must be on one and only one of the two arrays.
    //
    [helpstring("method SetControllerStatus")]
        HRESULT SetControllerStatus(
            [in] UUID* pOnlineControllerIdArray,
            [in] LONG lNumberOfOnlineControllers,
            [in] UUID* pOfflineControllerIdArray,
            [in] LONG lNumberOfOfflineControllers
        );


    [helpstring("method CreateLun")]
        HRESULT CreateLun(
            [in] VDS_LUN_TYPE type,
            [in] ULONGLONG ullSizeInBytes,
            [in] UUID* pDriveIdArray,
            [in] LONG lNumberOfDrives,
            [in] LongPtr pwszUnmaskingList,
            // for enclosures that support hardware lun masking,
            // this is a list of computer names that should be
            // able to see the LUN; otherwise, it's ignored.
            //   "*": everybody can see it;
            //   "": nobody can see it.
            [in] VDS_HINTS* pHints,
            [out] IVdsAsync** ppAsync
        );


    [helpstring("method ReplaceDrive")]
        HRESULT ReplaceDrive(
            //[in] UUID DriveToBeReplaced,
            [in] int DriveToBeReplaced1, [in] int DriveToBeReplaced2, [in] int DriveToBeReplaced3, [in] int DriveToBeReplaced4,
            //[in] UUID ReplacementDrive
            [in] int ReplacementDrive1, [in] int ReplacementDrive2, [in] int ReplacementDrive3, [in] int ReplacementDrive4
        );

    [helpstring("method SetStatus")]
        HRESULT SetStatus(
            [in] VDS_SUB_SYSTEM_STATUS status
        );

    [helpstring("method QueryMaxLunCreateSize")]
        HRESULT QueryMaxLunCreateSize(
            [in] VDS_LUN_TYPE type,
            [in] UUID* pDriveIdArray,
            [in] LONG lNumberOfDrives,
            [in] VDS_HINTS* pHints,
            [out] ULONGLONG* pullMaxLunSize
        );

}

//
// IVdsSubSystem2:
//
// Implemented by: subsystem object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(be666735-7800-4a77-9d9c-40f85b87e292)
]
interface IVdsSubSystem2 : stdole.IUnknown
{
    [helpstring("method GetProperties2")]
        HRESULT GetProperties2(
            [out] VDS_SUB_SYSTEM_PROP2* pSubSystemProp2
        );

    [helpstring("method GetDrive2")]
        HRESULT GetDrive2(
            [in] SHORT sBusNumber,
            [in] SHORT sSlotNumber,
            [in] ULONG ulEnclosureNumber,
            [out] IVdsDrive** ppDrive
        );

    [helpstring("method CreateLun2")]
        HRESULT CreateLun2(
            [in] VDS_LUN_TYPE type,
            [in] ULONGLONG ullSizeInBytes,
            [in] UUID* pDriveIdArray,
            [in] LONG lNumberOfDrives,
            [in] LongPtr pwszUnmaskingList,
            // for enclosures that support hardware lun masking,
            // this is a list of computer names that should be
            // able to see the LUN; otherwise, it's ignored.
            //   "*": everybody can see it;
            //   "": nobody can see it.
            [in] VDS_HINTS2* pHints2,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method QueryMaxLunCreateSize2")]
        HRESULT QueryMaxLunCreateSize2(
            [in] VDS_LUN_TYPE type,
            [in] UUID* pDriveIdArray,
            [in] LONG lNumberOfDrives,
            [in] VDS_HINTS2* pHints2,
            [out] ULONGLONG* pullMaxLunSize
        );

}

//
// IVdsSubSystemNaming:
//   This interface is for adding the ability to set a friendly name for
//   subsystems.
// Implemented by: subsystem object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(0d70faa3-9cd4-4900-aa20-6981b6aafc75)
]
interface IVdsSubSystemNaming : stdole.IUnknown
{
    HRESULT SetFriendlyName(
        [in] LongPtr pwszFriendlyName
    );
}

//
// IVdsSubSystemIscsi:
//
// Implemented by: subsystem object
// Implemented where: iSCSI hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(0027346f-40d0-4b45-8cec-5906dc0380c8)
]
interface IVdsSubSystemIscsi : stdole.IUnknown
{
    [helpstring("method QueryTargets")]
        HRESULT QueryTargets(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method QueryPortals")]
        HRESULT QueryPortals(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method CreateTarget")]
        HRESULT CreateTarget(
            [in] LongPtr pwszIscsiName,
            [in] LongPtr pwszFriendlyName,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method SetIpsecGroupPresharedKey")]
        HRESULT SetIpsecGroupPresharedKey(
            [in] VDS_ISCSI_IPSEC_KEY* pIpsecKey
        );

}

//
// IVdsSubSystemInterconnect:
//
// Implemented by: subsystem object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(9e6fa560-c141-477b-83ba-0b6c38f7febf)
]
interface IVdsSubSystemInterconnect : stdole.IUnknown
{
    HRESULT GetSupportedInterconnects(
        [out] VDS_INTERCONNECT_FLAG* pulSupportedInterconnectsFlag
    );
}

//
// IVdsControllerPort:
//
// Implemented by: controllerport object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(18691d0d-4e7f-43e8-92e4-cf44beeed11c)
]
interface IVdsControllerPort : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_PORT_PROP* pPortProp
        );

    [helpstring("method GetController")]
        HRESULT GetController(
            [out] IVdsController** ppController
        );

    [helpstring("method QueryAssociatedLuns")]
        HRESULT QueryAssociatedLuns(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method Reset")]
        HRESULT Reset(
            void
        );

    [helpstring("method SetStatus")]
        HRESULT SetStatus(
            [in] VDS_PORT_STATUS status
        );

}


//
// IVdsController:
//
// Implemented by: controller object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(cb53d96e-dffb-474a-a078-790d1e2bc082)
]
interface IVdsController : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_CONTROLLER_PROP* pControllerProp
        );

    [helpstring("method GetSubSystem")]
        HRESULT GetSubSystem(
            [out] IVdsSubSystem** ppSubSystem
        );

    // GetPortProperties:
    //   If a port on a controller failed, all paths using this port fail.
    // Deprecated by IVdsControllerPort::GetProperties()
    [helpstring("method GetPortProperties")]
        HRESULT GetPortProperties(
            [in] SHORT sPortNumber,
            [out] VDS_PORT_PROP* pPortProp
        );

    [helpstring("method FlushCache")]
        HRESULT FlushCache(
            void
        );

    [helpstring("method InvalidateCache")]
        HRESULT InvalidateCache(
            void
        );

    [helpstring("method Reset")]
        HRESULT Reset(
            void
        );

    // Deprecated by IVdsControllerPort::QueryAssociatedLuns()
    [helpstring("method QueryAssociatedLuns")]
        HRESULT QueryAssociatedLuns(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method SetStatus")]
        HRESULT SetStatus(
            [in] VDS_CONTROLLER_STATUS status
        );

}

//
// IVdsControllerControllerPort:
//   This interface is to add the ability to enumerate Controller ports for a
//   class implementing the IVdsController interface.
// Implemented by: controller object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(ca5d735f-6bae-42c0-b30e-f2666045ce71)
]
interface IVdsControllerControllerPort : stdole.IUnknown
{
    [helpstring("method QueryControllerPorts")]
        HRESULT QueryControllerPorts(
            [out] IEnumVdsObject** ppEnum
        );
}

//
// IVdsDrive:
//
// Implemented by: drive object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(ff24efa4-aade-4b6b-898b-eaa6a20887c7)
]
interface IVdsDrive : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_DRIVE_PROP* pDriveProp
        );

    [helpstring("method GetSubSystem")]
        HRESULT GetSubSystem(
            [out] IVdsSubSystem** ppSubSystem
        );

    // QueryExtents:
    //   A spindle can contribute to more than one LUNs, which could be surfaced
    //   to different computers. All LUNs are returned.
    [helpstring("method QueryExtents")]
        HRESULT QueryExtents(
            [out] VDS_DRIVE_EXTENT** ppExtentArray,
            [out] LONG* plNumberOfExtents
        );

    [helpstring("method SetFlags")]
        HRESULT SetFlags(
            [in] VDS_DRIVE_FLAG ulFlags
        );

    [helpstring("method ClearFlags")]
        HRESULT ClearFlags(
            [in] VDS_DRIVE_FLAG ulFlags
        );

    [helpstring("method SetStatus")]
        HRESULT SetStatus(
            [in] VDS_DRIVE_STATUS status
        );

}


//
// IVdsDrive2:
//
// Implemented by: drive object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(60b5a730-addf-4436-8ca7-5769e2d1ffa4)
]
interface IVdsDrive2 : stdole.IUnknown
{
    [helpstring("method GetProperties2")]
        HRESULT GetProperties2(
            [out] VDS_DRIVE_PROP2* pDriveProp2
        );
}


//
// IVdsLun
//   Only LUNs exposed by RAID controllers implement this interface.
// Implemented by: disk(LUN) object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(3540a9c7-e60f-4111-a840-8bba6c2c83d8)
]
interface IVdsLun : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_LUN_PROP* pLunProp
        );

    [helpstring("method GetSubSystem")]
        HRESULT GetSubSystem(
            [out] IVdsSubSystem** ppSubSystem
        );

    [helpstring("method GetIdentificationData")]
        HRESULT GetIdentificationData(
            [out] VDS_LUN_INFORMATION* pLunInfo
        );

    // QueryActiveControllers:
    //   The model is that all controllers can control a LUN. One or more of
    //   them are active, and the rest are inactive.
    // Deprecated by IVdsLunControllerPorts::QueryActiveControllerPorts()
    [helpstring("method QueryActiveControllers")]
        HRESULT QueryActiveControllers(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method Extend")]
        HRESULT Extend(
            [in] ULONGLONG ullNumberOfBytesToAdd,
            [in] UUID* pDriveIdArray,
            [in] LONG lNumberOfDrives,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method Shrink")]
        HRESULT Shrink(
            [in] ULONGLONG ullNumberOfBytesToRemove,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method QueryPlexes")]
        HRESULT QueryPlexes(
            [out] IEnumVdsObject** ppEnum
        );

    // AddPlex:
    //   Add a LUN as a plex to this LUN. The added LUN is no longer a LUN
    //   (cannot be accessed from outside).
    //
    //   If a mirrored LUN is added, each plex of it is added.
    //
    [helpstring("method AddPlex")]
        HRESULT AddPlex(
            //[in] UUID lunId,
            [in] int lunId1, [in] int lunId2, [in] int lunId3, [in] int lunId4,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method RemovePlex")]
        HRESULT RemovePlex(
            //[in] UUID plexId,
            [in] int plexId1, [in] int plexId2, [in] int plexId3, [in] int plexId4,
            [out] IVdsAsync** ppAsync
        );

    // Recover:
    //   This method is used to trigger a recover process. High-end RAID
    //   subsystems may be able to do this automatically, but low-end
    //   ones (like storport) may need this method to explicitly start
    //   the process.
    [helpstring("method Recover")]
        HRESULT Recover(
            [out] IVdsAsync** ppAsync
        );

    // SetMask: (hardware lun masking)
    //   Mask/Unmask the LUN. pwszUnmaskingList is a list of nodes separated by
    //   ";". These nodes should be granted access to the LUN.
    //
    //   If the value is "*", all computers on the network are to be
    //   granted access to the LUN. If the value is "", no computers are to
    //   be granted access to the LUN.
    //
    //   For Fibre Channel networks, each entry is a World-Wide Name
    //   (WWN) of each port to which the LUN is unmasked, formatted as
    //   a 64-bit uppercased hexadecimal string (16 characters long),
    //   most significant bit first.
    //
    //   For iSCSI networks, each entry is an iSCSI name of each target
    //   to which the LUN is unmasked. A LUN unmasked to a particular target
    //   is considered to be associated with that target.
    //
    // Notes to Implementers
    //
    //   The unmasking list can contain the same WWN or iSCSI name
    //   twice. The caller is neither expected to remove duplicates from
    //   the list nor to validate the format of the WWN or iSCSI name.
    //   If the hardware is unable to handle the duplicates correctly,
    //   the provider should perform all validations and remove duplicate
    //   WWNs and iSCSI names from the list before processing.
    //
    //   It used to be the case that any format could be specified, but
    //   we decided that was a bad thing because an application could
    //   never figure out what a provider would understand.  So, we
    //   mandated that all providers must accept a WWN formatted as
    //   specified (or an iSCSI name in the case of iSCSI).
    //
    //   However, we don’t require that providers should only accept
    //   this format.  If a provider is able to translate or interpret
    //   another type of name, then it’s still fine.  For instance,
    //   if a provider understands WWN formatted using lowercase
    //   characters instead of uppercase, then it is free to accept
    //   them and return success (it’s also free to return failure
    //   as well).  The only stipulation is that the provider must
    //   understand the WWN when it’s formatted as specified above.
    //
    //   This method works only if the LUN's enclosure supports hardware
    //   lun masking.
    //
    [helpstring("method SetMask")]
        HRESULT SetMask(
            [in] LongPtr pwszUnmaskingList
        );

    // Delete:
    //   Delete the LUN.
    [helpstring("method Delete")]
        HRESULT Delete(
            void
        );

    //
    // Sets the list of controllers "Active" and "Inactive" for this
    // LUN.  Note that all the controllers of the current subsystem
    // must be on one and only one of the two arrays.
    //
    // Deprecated by IVdsLunControllerPorts::AssociateControllerPorts()
    [helpstring("method AssociateControllers")]
        HRESULT AssociateControllers(
            [in] UUID* pActiveControllerIdArray,
            [in] LONG lNumberOfActiveControllers,
            [in] UUID* pInactiveControllerIdArray,
            [in] LONG lNumberOfInactiveControllers
        );


    [helpstring("method QueryHints")]
        HRESULT QueryHints(
            [out] VDS_HINTS* pHints
        );

    [helpstring("method ApplyHints")]
        HRESULT ApplyHints(
            [in] VDS_HINTS* pHints
        );

    [helpstring("method SetStatus")]
        HRESULT SetStatus(
            [in] VDS_LUN_STATUS status
        );

    [helpstring("method QueryMaxLunExtendSize")]
        HRESULT QueryMaxLunExtendSize(
            [in] UUID* pDriveIdArray,
            [in] LONG lNumberOfDrives,
            [out] ULONGLONG* pullMaxBytesToBeAdded
        );

}

//
// IVdsLun2
//   Only LUNs exposed by RAID controllers implement this interface.
// Implemented by: disk(LUN) object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(e5b3a735-9efb-499a-8071-4394d9ee6fcb)
]
interface IVdsLun2 : stdole.IUnknown
{
    [helpstring("method QueryHints2")]
        HRESULT QueryHints2(
            [out] VDS_HINTS2* pHints2
        );

    [helpstring("method ApplyHints2")]
        HRESULT ApplyHints2(
            [in] VDS_HINTS2* pHints2
        );
}

//
// IVdsLunNaming:
//   This interface is for adding the ability to set a friendly name for LUNs.
// Implemented by: disk(LUN) object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(907504cb-6b4e-4d88-a34d-17ba661fbb06)
]
interface IVdsLunNaming : stdole.IUnknown
{
    HRESULT SetFriendlyName(
        [in] LongPtr pwszFriendlyName
    );
}

//
// IVdsLunNumber:
//  This interface is for adding the ability to retrieve the LUN number of a LUN.
// Implemented by: disk(LUN) object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(d3f95e46-54b3-41f9-b678-0f1871443a08)
]
interface IVdsLunNumber : stdole.IUnknown
{
    HRESULT GetLunNumber(
        [out] ULONG* pulLunNumber
    );
}

//
// IVdsLunControllerPorts:
//   This interface is for adding the ability to work with controller ports.
// Implemented by: disk(LUN) object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(451fe266-da6d-406a-bb60-82e534f85aeb)
]
interface IVdsLunControllerPorts : stdole.IUnknown
{
    //
    // Sets the list of controller ports "Active" and "Inactive" for this LUN.
    // Note that all the controller ports of the current subsystem must be on
    // one and only one of the two arrays.
    //
    [helpstring("method AssociateControllerPorts")]
        HRESULT AssociateControllerPorts(
            [in] UUID * pActiveControllerPortIdArray,
            [in] LONG lNumberOfActiveControllerPorts,
            [in] UUID* pInactiveControllerPortIdArray,
            [in] LONG lNumberOfInactiveControllerPorts
        );

    [helpstring("method QueryActiveControllerPorts")]
        HRESULT QueryActiveControllerPorts(
            [out] IEnumVdsObject** ppEnum
        );

}

//
// IVdsLunMpio:
//   This interface is for adding the ability to work with MPIO paths for a
//   class implementing the IVdsLun interface.  This is needed to support MPIO.
// Implemented by: disk(LUN) object
// Implemented where: non-iSCSI hardware providers supporting MPIO, common layer
// Accessed by: applications
//
[
    odl,
        uuid(7c5fbae3-333a-48a1-a982-33c15788cde3)
]
interface IVdsLunMpio : stdole.IUnknown
{
    //
    // Returns information about the paths to the LUN.  The VDS_PATH_INFO
    // structure identifies that path in terms of the endpoints and the status
    // of the path.
    // If a provider is an iSCSI provider or if a provider does not support
    // MPIO, this interface should not be implemented at all.  In the case
    // of iSCSI, VDS will completely ignore it since it will use the
    // service's own routines to handle MPIO for iSCSI.
    //
    [helpstring("method GetPathInfo")]
        HRESULT GetPathInfo(
            //[out, size_is(, *plNumberOfPaths)] VDS_PATH_INFO** ppPaths,
            [out] LongPtr* ppPaths,
            [out] LONG* plNumberOfPaths
        );

    [helpstring("method GetLoadBalancePolicy")]
        HRESULT GetLoadBalancePolicy(
            [out] VDS_LOADBALANCE_POLICY_ENUM* pPolicy,
            //[out, size_is(, *plNumberOfPaths)] VDS_PATH_POLICY** ppPaths,
            [out] LongPtr* ppPaths,
            [out] LONG* plNumberOfPaths
        );

    [helpstring("method SetLoadBalancePolicy")]
        HRESULT SetLoadBalancePolicy(
            [in] VDS_LOADBALANCE_POLICY_ENUM policy,
            [in] VDS_PATH_POLICY* pPaths,
            [in] LONG lNumberOfPaths
        );

    [helpstring("method GetSupportedLbPolicies")]
        HRESULT GetSupportedLbPolicies(
            [out] VDS_PROVIDER_LBSUPPORT_FLAG* pulLbFlags
        );

}

//
// IVdsLunIscsi:
//   This interface is for adding the ability to associate LUNs with iSCSI
//   targets.
// Implemented by: disk(LUN) object
// Implemented where: iSCSI hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(0d7c1e64-b59b-45ae-b86a-2c2cc6a42067)
]
interface IVdsLunIscsi : stdole.IUnknown
{
    [helpstring("method AssociateTargets")]
        HRESULT AssociateTargets(
            [in] UUID* pTargetIdArray,
            [in] LONG lNumberOfTargets
        );

    [helpstring("method QueryAssociatedTargets")]
        HRESULT QueryAssociatedTargets(
            [out] IEnumVdsObject** ppEnum
        );

}

// IVdsLunPlex:
//
// Implemented by: LUN plex object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(0ee1a790-5d2e-4abb-8c99-c481e8be2138)
]
interface IVdsLunPlex : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_LUN_PLEX_PROP* pPlexProp
        );

    [helpstring("method GetLun")]
        HRESULT GetLun(
            [out] IVdsLun** ppLun
        );

    [helpstring("method QueryExtents")]
        HRESULT QueryExtents(
            //[out, size_is(, *plNumberOfExtents)]
            //VDS_DRIVE_EXTENT** ppExtentArray,
            [out] LongPtr* ppExtentArray,
            [out] LONG* plNumberOfExtents
        );

    [helpstring("method QueryHints")]
        HRESULT QueryHints(
            [out] VDS_HINTS* pHints
        );

    [helpstring("method ApplyHints")]
        HRESULT ApplyHints(
            [in] VDS_HINTS* pHints
        );

}

//
// IVdsIscsiPortal:
//
// Implemented by: iSCSI target portal object
// Implemented where: iSCSI hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(7fa1499d-ec85-4a8a-a47b-ff69201fcd34)
]
interface IVdsIscsiPortal : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_ISCSI_PORTAL_PROP* pPortalProp
        );

    [helpstring("method GetSubSystem")]
        HRESULT GetSubSystem(
            [out] IVdsSubSystem** ppSubSystem
        );

    [helpstring("method QueryAssociatedPortalGroups")]
        HRESULT QueryAssociatedPortalGroups(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method SetStatus")]
        HRESULT SetStatus(
            [in] VDS_ISCSI_PORTAL_STATUS status
        );

    [helpstring("method SetIpsecTunnelAddress")]
        HRESULT SetIpsecTunnelAddress(
            [in] VDS_IPADDRESS* pTunnelAddress,
            [in] VDS_IPADDRESS* pDestinationAddress
        );

    [helpstring("method GetIpsecSecurity")]
        HRESULT GetIpsecSecurity(
            [in] VDS_IPADDRESS* pInitiatorPortalAddress,
            [out] ULONGLONG* pullSecurityFlags
        );

    [helpstring("method SetIpsecSecurity")]
        HRESULT SetIpsecSecurity(
            [in] VDS_IPADDRESS* pInitiatorPortalAddress,
            [in] ULONGLONG ullSecurityFlags,
            [in] VDS_ISCSI_IPSEC_KEY* pIpsecKey
        );

}

//
// IVdsIscsiTarget:
//
// Implemented by: iSCSI target object
// Implemented where: iSCSI hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(aa8f5055-83e5-4bcc-aa73-19851a36a849)
]
interface IVdsIscsiTarget : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_ISCSI_TARGET_PROP* pTargetProp
        );

    [helpstring("method GetSubSystem")]
        HRESULT GetSubSystem(
            [out] IVdsSubSystem** ppSubSystem
        );

    [helpstring("method QueryPortalGroups")]
        HRESULT QueryPortalGroups(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method QueryAssociatedLuns")]
        HRESULT QueryAssociatedLuns(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method CreatePortalGroup")]
        HRESULT CreatePortalGroup(
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method Delete")]
        HRESULT Delete(
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method SetFriendlyName")]
        HRESULT SetFriendlyName(
            [in] LongPtr pwszFriendlyName
        );

    [helpstring("method SetSharedSecret")]
        HRESULT SetSharedSecret(
            [in] VDS_ISCSI_SHARED_SECRET* pTargetSharedSecret,
            [in] LongPtr pwszInitiatorName
        );

    [helpstring("method RememberInitiatorSharedSecret")]
        HRESULT RememberInitiatorSharedSecret(
            [in] LongPtr pwszInitiatorName,
            [in] VDS_ISCSI_SHARED_SECRET* pInitiatorSharedSecret
        );

    [helpstring("method GetConnectedInitiators")]
        HRESULT GetConnectedInitiators(
            //[out, string, size_is(, *plNumberOfInitiators)]
            //LPWSTR** pppwszInitiatorList,
            [out] LongPtr* pppwszInitiatorList,
            [out] LONG* plNumberOfInitiators
        );

}

//
// IVdsIscsiPortalGroup:
//
// Implemented by: iSCSI portal group object
// Implemented where: iSCSI hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(fef5f89d-a3dd-4b36-bf28-e7dde045c593)
]
interface IVdsIscsiPortalGroup : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_ISCSI_PORTALGROUP_PROP* pPortalGroupProp
        );

    [helpstring("method GetTarget")]
        HRESULT GetTarget(
            [out] IVdsIscsiTarget** ppTarget
        );

    [helpstring("method QueryAssociatedPortals")]
        HRESULT QueryAssociatedPortals(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method AddPortal")]
        HRESULT AddPortal(
            //[in] UUID portalId,
            [in] int portalId1, [in] int portalId2, [in] int portalId3, [in] int portalId4,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method RemovePortal")]
        HRESULT RemovePortal(
            //[in] UUID portalId,
            [in] int portalId1, [in] int portalId2, [in] int portalId3, [in] int portalId4,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method Delete")]
        HRESULT Delete(
            [out] IVdsAsync** ppAsync
        );

}

//
// IVdsStoragePool:
//
// Implemented by: storage pool object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(932ca8cf-0eb3-4ba8-9620-22665d7f8450)
]
interface IVdsStoragePool : stdole.IUnknown
{
    [helpstring("method GetProvider")]
        HRESULT GetProvider(
            [out] IVdsProvider** ppProvider
        );

    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_STORAGE_POOL_PROP* pStoragePoolProp
        );

    [helpstring("method GetAttributes")]
        HRESULT GetAttributes(
            [out] VDS_POOL_ATTRIBUTES* pStoragePoolAttributes
        );

    [helpstring("method QueryDriveExtents")]
        HRESULT QueryDriveExtents(
            //[out, size_is(, *plNumberOfExtents)]
            //VDS_STORAGE_POOL_DRIVE_EXTENT** ppExtentArray,
            [out] LongPtr* ppExtentArray,
            [out] LONG* plNumberOfExtents
        );

    [helpstring("method QueryAllocatedLuns")]
        HRESULT QueryAllocatedLuns(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method QueryAllocatedStoragePools")]
        HRESULT QueryAllocatedStoragePools(
            [out] IEnumVdsObject** ppEnum
        );
}

//
// IVdsMaintenance:
// Implemented by: drive object, controller object, subsystem object
// Implemented where: hardware providers, common layer
// Accessed by: applications
//
[
    odl,
        uuid(daebeef3-8523-47ed-a2b9-05cecce2a1ae)
]

interface IVdsMaintenance : stdole.IUnknown
{
    [helpstring("method StartMaintenance")]
        HRESULT StartMaintenance(
            [in] VDS_MAINTENANCE_OPERATION operation
        );

    [helpstring("method StopMaintenance")]
        HRESULT StopMaintenance(
            [in] VDS_MAINTENANCE_OPERATION operation
        );

    [helpstring("method PulseMaintenance")]
        HRESULT PulseMaintenance(
            [in] VDS_MAINTENANCE_OPERATION operation,
            [in] ULONG ulCount
        );
}

//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(pop)")
//cpp_quote("#endif")
//
//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion


// ***************************************************************
//
// vdsvd.idl
//
// ***************************************************************

//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2008
//
//    Abstract:
//        Declarations of interfaces and types implemented by virtual disk
//        provider.
//
//----------------------------------------------------------------------------

//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")
//
//cpp_quote("#if (WINVER >= _WIN32_WINNT_WIN7)")
//
//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(push)")
//cpp_quote("#pragma warning(disable:4820) /* padding added after data member */")
//cpp_quote("#endif")

//tB ADDED
typedef struct VIRTUAL_STORAGE_TYPE
{
    DWORD DeviceId;
    GUID  VendorId;
} VIRTUAL_STORAGE_TYPE;
typedef enum CREATE_VIRTUAL_DISK_FLAG
{
    CREATE_VIRTUAL_DISK_FLAG_NONE = 0x0,

    // Pre-allocate all physical space necessary for the virtual
    // size of the disk (e.g. a fixed VHD).
    CREATE_VIRTUAL_DISK_FLAG_FULL_PHYSICAL_ALLOCATION = 0x1,

    // Take ownership of the source disk during create from source disk, to
    // insure the source disk does not change during the create operation.  The
    // source disk must also already be offline or read-only (or both).
    // Ownership is released when create is done.  This also has a side-effect
    // of disallowing concurrent create from same source disk.  Create will fail
    // if ownership cannot be obtained or if the source disk is not already
    // offline or read-only.  This flag is optional, but highly recommended for
    // creates from source disk.  No effect for other types of create (no effect
    // for create from source VHD; no effect for create without SourcePath).
    CREATE_VIRTUAL_DISK_FLAG_PREVENT_WRITES_TO_SOURCE_DISK = 0x2,

    // Do not copy initial virtual disk metadata or block states from the
    // parent VHD; this is useful if the parent VHD is a stand-in file and the
    // real parent will be explicitly set later.
    CREATE_VIRTUAL_DISK_FLAG_DO_NOT_COPY_METADATA_FROM_PARENT = 0x4,

    // Create the backing storage disk.
    CREATE_VIRTUAL_DISK_FLAG_CREATE_BACKING_STORAGE = 0x8,

    // If set, the SourceLimitPath is an change tracking ID, and all data that has changed
    // since that change tracking ID will be copied from the source. If clear, the
    // SourceLimitPath is a VHD file path in the source VHD's chain, and
    // all data that is present in the children of that VHD in the chain
    // will be copied from the source.
    CREATE_VIRTUAL_DISK_FLAG_USE_CHANGE_TRACKING_SOURCE_LIMIT = 0x10,

    // If set and the parent VHD has change tracking enabled, the child will
    // have change tracking enabled and will recognize all change tracking
    // IDs that currently exist in the parent. If clear or if the parent VHD
    // does not have change tracking available, then change tracking will
    // not be enabled in the new VHD.
    CREATE_VIRTUAL_DISK_FLAG_PRESERVE_PARENT_CHANGE_TRACKING_STATE = 0x20,

    // When creating a VHD Set from source, don't copy the data in the original
    // backing store, but intsead use the file as is. If this flag is not specified
    // and a source file is passed to CreateVirtualDisk for a VHDSet file, the data
    // in the source file is copied. If this flag is set the data is moved. The
    // name of the file may change.
    CREATE_VIRTUAL_DISK_FLAG_VHD_SET_USE_ORIGINAL_BACKING_STORAGE = 0x40,

    //
    // When creating a fixed virtual disk, take advantage of an underlying sparse file.
    // Only supported on file systems that support sparse VDLs.
    //
    CREATE_VIRTUAL_DISK_FLAG_SPARSE_FILE = 0x80,

    //
    // Creates a VHD suitable as the backing store for a virtual persistent memory device.
    //
    CREATE_VIRTUAL_DISK_FLAG_PMEM_COMPATIBLE = 0x100,

    //
    // Allow a VHD to be created on a compressed volume.
    //
    CREATE_VIRTUAL_DISK_FLAG_SUPPORT_COMPRESSED_VOLUMES = 0x200,

    //
    // Allow a VHD to be created when it may be marked as a sparse file. This flag is a companion
    // to CREATE_VIRTUAL_DISK_FLAG_SPARSE_FILE, and overrides the behavior that only
    // allows sparse files on file systems that support sparse VDLs.
    //
    CREATE_VIRTUAL_DISK_FLAG_SUPPORT_SPARSE_FILES_ANY_FS = 0x400,

} CREATE_VIRTUAL_DISK_FLAG;
typedef enum DEPENDENT_DISK_FLAG
{
    DEPENDENT_DISK_FLAG_NONE = 0x00000000,

    //
    // Multiple files backing the virtual storage device
    //
    DEPENDENT_DISK_FLAG_MULT_BACKING_FILES = 0x00000001,

    DEPENDENT_DISK_FLAG_FULLY_ALLOCATED = 0x00000002,

    DEPENDENT_DISK_FLAG_READ_ONLY = 0x00000004,

    //
    // Backing file of the virtual storage device is not local to the machine
    //
    DEPENDENT_DISK_FLAG_REMOTE = 0x00000008,

    //
    // Volume is the system volume
    //
    DEPENDENT_DISK_FLAG_SYSTEM_VOLUME = 0x00000010,

    //
    // Volume backing the virtual storage device file is the system volume
    //
    DEPENDENT_DISK_FLAG_SYSTEM_VOLUME_PARENT = 0x00000020,

    DEPENDENT_DISK_FLAG_REMOVABLE = 0x00000040,

    //
    // Drive letters are not assigned to the volumes
    // on the virtual disk automatically.
    //
    DEPENDENT_DISK_FLAG_NO_DRIVE_LETTER = 0x00000080,

    DEPENDENT_DISK_FLAG_PARENT = 0x00000100,

    //
    // Virtual disk is not attached on the local host
    // (instead attached on a guest VM for instance)
    //
    DEPENDENT_DISK_FLAG_NO_HOST_DISK = 0x00000200,

    //
    // Indicates the lifetime of the disk is not tied
    // to any system handles
    //
    DEPENDENT_DISK_FLAG_PERMANENT_LIFETIME = 0x00000400,

    //
    // Volume backing the virtual storage device file
    // can be a compressed volume.
    //
    DEPENDENT_DISK_FLAG_SUPPORT_COMPRESSED_VOLUMES = 0x00000800,

    //
    // Allow the file to be mounted, even if it is sparse and the
    // volume on which it sits does not support a sparse VDL.
    //
    DEPENDENT_DISK_FLAG_ALWAYS_ALLOW_SPARSE = 0x00001000,

    //
    // Allow the file to be mounted, even if it is encrypted.
    //
    DEPENDENT_DISK_FLAG_SUPPORT_ENCRYPTED_FILES = 0x00002000,

} DEPENDENT_DISK_FLAG;
typedef enum VIRTUAL_DISK_ACCESS_MASK {
    VIRTUAL_DISK_ACCESS_NONE = 0x00000000,
    VIRTUAL_DISK_ACCESS_ATTACH_RO = 0x00010000,
    VIRTUAL_DISK_ACCESS_ATTACH_RW = 0x00020000,
    VIRTUAL_DISK_ACCESS_DETACH = 0x00040000,
    VIRTUAL_DISK_ACCESS_GET_INFO = 0x00080000,
    VIRTUAL_DISK_ACCESS_CREATE = 0x00100000,
    VIRTUAL_DISK_ACCESS_METAOPS = 0x00200000,
    VIRTUAL_DISK_ACCESS_READ = 0x000d0000,
    VIRTUAL_DISK_ACCESS_ALL = 0x003f0000,

    //
    // A special flag to be used to test if the virtual disk needs to be
    // opened for write.
    //

    VIRTUAL_DISK_ACCESS_WRITABLE = 0x00320000

} VIRTUAL_DISK_ACCESS_MASK;



interface IVdsVdProvider;
interface IVdsVDisk;
interface IVdsOpenVDisk;

typedef struct VDS_CREATE_VDISK_PARAMETERS
{
    UUID UniqueId;
    ULONGLONG MaximumSize;
    ULONG BlockSizeInBytes;
    ULONG SectorSizeInBytes;
    LongPtr pParentPath;
    LongPtr pSourcePath;
} VDS_CREATE_VDISK_PARAMETERS;

[
    odl,
        uuid(b481498c-8354-45f9-84a0-0bdd2832a91f)
]
interface IVdsVdProvider : stdole.IUnknown
{
    [helpstring("method QueryVDisks")]
        HRESULT QueryVDisks(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method CreateVDisk")]
        HRESULT CreateVDisk(
            [in] VIRTUAL_STORAGE_TYPE* VirtualDeviceType,
            [in] LongPtr pPath,
            [in] LongPtr pStringSecurityDescriptor,
            [in] CREATE_VIRTUAL_DISK_FLAG Flags,
            [in] ULONG ProviderSpecificFlags,
            [in] ULONG Reserved,
            [in] VDS_CREATE_VDISK_PARAMETERS* pCreateDiskParameters,
            [in, out] IVdsAsync** ppAsync
        );

    [helpstring("method AddVDisk")]
        HRESULT AddVDisk(
            [in] VIRTUAL_STORAGE_TYPE* VirtualDeviceType,
            [in] LongPtr pPath,
            [in, out] IVdsVDisk** ppVDisk
        );

    HRESULT GetDiskFromVDisk(
        [in] IVdsVDisk* pVDisk,
        [out] IVdsDisk** ppDisk
    );

    HRESULT GetVDiskFromDisk(
        [in] IVdsDisk* pDisk,
        [out] IVdsVDisk** ppVDisk
    );
}


typedef enum VDS_VDISK_STATE {
    VDS_VST_UNKNOWN = 0,
    VDS_VST_ADDED,
    VDS_VST_OPEN,
    VDS_VST_ATTACH_PENDING,
    VDS_VST_ATTACHED_NOT_OPEN,
    VDS_VST_ATTACHED,
    VDS_VST_DETACH_PENDING,
    VDS_VST_COMPACTING,
    VDS_VST_MERGING,
    VDS_VST_EXPANDING,
    VDS_VST_DELETED,
    VDS_VST_MAX
} VDS_VDISK_STATE;


typedef struct VDS_VDISK_PROPERTIES
{
    UUID Id;
    VDS_VDISK_STATE State;
    VIRTUAL_STORAGE_TYPE  VirtualDeviceType;
    ULONGLONG VirtualSize;
    ULONGLONG PhysicalSize;
    LongPtr pPath;
    LongPtr pDeviceName;
    DEPENDENT_DISK_FLAG DiskFlag;
    BOOL bIsChild;
    LongPtr pParentPath;
    int padVBOnly;
} VDS_VDISK_PROPERTIES;



//tB ADDED
typedef enum OPEN_VIRTUAL_DISK_FLAG
{
    OPEN_VIRTUAL_DISK_FLAG_NONE = 0x00000000,

    // Open the backing store without opening any differencing chain parents.
    // This allows one to fixup broken parent links.
    OPEN_VIRTUAL_DISK_FLAG_NO_PARENTS = 0x00000001,

    // The backing store being opened is an empty file. Do not perform virtual
    // disk verification.
    OPEN_VIRTUAL_DISK_FLAG_BLANK_FILE = 0x00000002,

    // This flag is only specified at boot time to load the system disk
    // during virtual disk boot.  Must be kernel mode to specify this flag.
    OPEN_VIRTUAL_DISK_FLAG_BOOT_DRIVE = 0x00000004,

    // This flag causes the backing file to be opened in cached mode.
    OPEN_VIRTUAL_DISK_FLAG_CACHED_IO = 0x00000008,

    // Open the backing store without opening any differencing chain parents.
    // This allows one to fixup broken parent links temporarily without updating
    // the parent locator.
    OPEN_VIRTUAL_DISK_FLAG_CUSTOM_DIFF_CHAIN = 0x00000010,

    // This flag causes all backing stores except the leaf backing store to
    // be opened in cached mode.
    OPEN_VIRTUAL_DISK_FLAG_PARENT_CACHED_IO = 0x00000020,

    // This flag causes a Vhd Set file to be opened without any virtual disk.
    OPEN_VIRTUAL_DISK_FLAG_VHDSET_FILE_ONLY = 0x00000040,

    // For differencing disks, relative parent locators are not used when
    // determining the path of a parent VHD.
    OPEN_VIRTUAL_DISK_FLAG_IGNORE_RELATIVE_PARENT_LOCATOR = 0x00000080,

    // Disable flushing and FUA (both for payload data and for metadata)
    // for backing files associated with this virtual disk.
    OPEN_VIRTUAL_DISK_FLAG_NO_WRITE_HARDENING = 0x00000100,

    // Open the backing store even if it is a compressed file.
    OPEN_VIRTUAL_DISK_FLAG_SUPPORT_COMPRESSED_VOLUMES = 0x00000200,

    // Open the backing store even if it is a sparse file, on any file system.
    OPEN_VIRTUAL_DISK_FLAG_SUPPORT_SPARSE_FILES_ANY_FS = 0x00000400,

    // Open the backing store even if it is an encrypted file.
    OPEN_VIRTUAL_DISK_FLAG_SUPPORT_ENCRYPTED_FILES = 0x00000800,

} OPEN_VIRTUAL_DISK_FLAG;
typedef enum ATTACH_VIRTUAL_DISK_FLAG
{
    ATTACH_VIRTUAL_DISK_FLAG_NONE = 0x00000000,

    // Attach the disk as read only
    ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY = 0x00000001,

    // Will cause all volumes on the disk to be mounted
    // without drive letters.
    ATTACH_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER = 0x00000002,

    // Will decouple the disk lifetime from that of the VirtualDiskHandle.
    // The disk will be attached until an explicit call is made to
    // DetachVirtualDisk, even if all handles are closed.
    ATTACH_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME = 0x00000004,

    // Indicates that the drive will not be attached to
    // the local system (but rather to a VM).
    ATTACH_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST = 0x00000008,

    // Do not assign a custom security descriptor to the disk; use the
    // system default.
    ATTACH_VIRTUAL_DISK_FLAG_NO_SECURITY_DESCRIPTOR = 0x00000010,

    // Default volume encryption policies should not be applied to the
    // disk when attached to the local system.
    ATTACH_VIRTUAL_DISK_FLAG_BYPASS_DEFAULT_ENCRYPTION_POLICY = 0x00000020,

    // Attach the disk as a non-PnP device.
    ATTACH_VIRTUAL_DISK_FLAG_NON_PNP = 0x00000040,

    // Restrict the disk's view to the specified offset and length.
    ATTACH_VIRTUAL_DISK_FLAG_RESTRICTED_RANGE = 0x00000080,

    // Restrict the disk's view to the unique data partition.
    ATTACH_VIRTUAL_DISK_FLAG_SINGLE_PARTITION = 0x00000100,

    // Register the non-PnP disk as a volume with mount manager.
    ATTACH_VIRTUAL_DISK_FLAG_REGISTER_VOLUME = 0x00000200,

} ATTACH_VIRTUAL_DISK_FLAG;
typedef enum DETACH_VIRTUAL_DISK_FLAG
{
    DETACH_VIRTUAL_DISK_FLAG_NONE = 0x00000000,

} DETACH_VIRTUAL_DISK_FLAG;
typedef enum COMPACT_VIRTUAL_DISK_FLAG
{
    COMPACT_VIRTUAL_DISK_FLAG_NONE = 0x00000000,
    COMPACT_VIRTUAL_DISK_FLAG_NO_ZERO_SCAN = 0x00000001,
    COMPACT_VIRTUAL_DISK_FLAG_NO_BLOCK_MOVES = 0x00000002,

} COMPACT_VIRTUAL_DISK_FLAG;
typedef enum MERGE_VIRTUAL_DISK_FLAG
{
    MERGE_VIRTUAL_DISK_FLAG_NONE = 0x00000000,

} MERGE_VIRTUAL_DISK_FLAG;
typedef enum _EXPAND_VIRTUAL_DISK_FLAG
{
    EXPAND_VIRTUAL_DISK_FLAG_NONE = 0x00000000,
    EXPAND_VIRTUAL_DISK_FLAG_NOTIFY_CHANGE = 0x00000001,

} EXPAND_VIRTUAL_DISK_FLAG;


[
    odl,
        uuid(1e062b84-e5e6-4b4b-8a25-67b81e8f13e8)
]
interface IVdsVDisk : stdole.IUnknown
{
    HRESULT Open(
        [in] VIRTUAL_DISK_ACCESS_MASK AccessMask,
        [in] OPEN_VIRTUAL_DISK_FLAG Flags,
        [in] ULONG ReadWriteDepth,
        [out] IVdsOpenVDisk** ppOpenVDisk
    );

    HRESULT GetProperties(
        [out] VDS_VDISK_PROPERTIES* pDiskProperties
    );

    HRESULT GetHostVolume(
        [out] IVdsVolume** ppVolume
    );

    HRESULT GetDeviceName(
        [out] LongPtr* ppDeviceName);

}


[
    odl,
        uuid(75c8f324-f715-4fe3-a28e-f9011b61a4a1)
]
interface IVdsOpenVDisk : stdole.IUnknown
{
    HRESULT Attach(
        [in] LongPtr pStringSecurityDescriptor,
        [in] ATTACH_VIRTUAL_DISK_FLAG Flags,
        [in] ULONG ProviderSpecificFlags,
        [in] ULONG TimeoutInMs,
        [out] IVdsAsync** ppAsync
    );

    HRESULT Detach(
        [in] DETACH_VIRTUAL_DISK_FLAG Flags,
        [in] ULONG ProviderSpecificFlags
    );

    HRESULT DetachAndDelete(
        [in] DETACH_VIRTUAL_DISK_FLAG Flags,
        [in] ULONG ProviderSpecificFlags
    );

    HRESULT Compact(
        [in] COMPACT_VIRTUAL_DISK_FLAG Flags,
        [in] ULONG Reserved,
        [out] IVdsAsync** ppAsync
    );

    HRESULT Merge(
        [in] MERGE_VIRTUAL_DISK_FLAG Flags,
        [in] ULONG MergeDepth,
        [out] IVdsAsync** ppAsync
    );

    HRESULT Expand(
        [in] EXPAND_VIRTUAL_DISK_FLAG Flags,
        [in] ULONGLONG NewSize,
        [out] IVdsAsync** ppAsync
    );
}

//const ULONG VDS_ATTACH_VIRTUAL_DISK_FLAG_USE_FILE_ACL = 0x00000001;

//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(pop)")
//cpp_quote("#endif")
//
//cpp_quote("#endif // _WIN32_WINNT_WIN7")
//
//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion










// ***************************************************************
//
// vds.idl
//
// ***************************************************************

//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2000
//
//    File: vds.idl
//
//    Abstract:
//        declarations of interfaces and types of Virtual Disk Service.
//
//    Note:
//        if a type is an aggregation of types defined by software provider,
//        hardware provider, or the common layer, they are listed in this
//        order: common to all, software provider specific, hardware provider
//        specific, common layer specific.
//
//----------------------------------------------------------------------------

//cpp_quote("//+--------------------------------------------------------------")
//cpp_quote("//")
//cpp_quote("//  Microsoft Windows")
//cpp_quote("//  Copyright (c) 2008 Microsoft Corporation.")
//cpp_quote("//")
//cpp_quote("//---------------------------------------------------------------")
//
//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")
//
//import "oaidl.idl";
//import "vdssys.idl";
//
////
//// Includes
////
//#include "vdscmmn.idl"
//#include "vdssp.idl"
//#include "vdshp.idl"
//#include "vdsvd.idl"
//
//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(push)")
//cpp_quote("#pragma warning(disable:4820) /* padding added after data member */")
//cpp_quote("#endif")

//#define DRIVE_LETTER_PROP
//#define MAX_PATH                260

interface IVdsServiceLoader;
interface IVdsService;
interface IVdsServiceUninstallDisk;
interface IVdsServiceHba;
interface IVdsServiceIscsi;
interface IVdsServiceInitialization;
interface IVdsHbaPort;
interface IVdsIscsiInitiatorAdapter;
interface IVdsIscsiInitiatorPortal;
interface IVdsDiskPartitionMF;
interface IVdsDiskPartitionMF2;
interface IVdsVolumeMF;
interface IVdsVolumeMF2;
interface IVdsVolumeMF3;
interface IVdsVolumeShrink;
interface IVdsSubSystemImportTarget;
interface IVdsIscsiPortalLocal;
interface IVdsServiceSAN;
interface IVdsServiceSw;

//cpp_quote("// {9C38ED61-D565-4728-AEEE-C80952F0ECDE}")
//// DEFINE_GUID(CLSID_VdsLoader,   0X9C38ED61,0xD565,0x4728,0xAE,0xEE,0xC8,0x09,0x52,0xF0,0xEC,0xDE); 
////cpp_quote("")
////cpp_quote("// {7D1933CB-86F6-4A98-8628-01BE94C9A575}")
//// DEFINE_GUID(CLSID_VdsService, 0x7D1933CB,0x86F6,0x4A98,0x86,0x28,0x01,0xBE,0x94,0xC9,0xA5,0x75); 
//cpp_quote("")
//
//const LONG MAX_FS_NAME_SIZE = 8;   // size of file system type as used in VDS_FILE_SYSTEM_TYPE_PROP: NTFS, FAT32...
//const LONG MAX_FS_FORMAT_SUPPORT_NAME_SIZE = 32;   // size of file system type as used in VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP: NTFS, FAT32...
//const LONG MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE = 32;

//
// Service Flags
//
typedef enum VDS_SERVICE_FLAG
{
    VDS_SVF_SUPPORT_DYNAMIC = 0x00000001,   // Dynamic is not supported on all SKUs. Laptops did not support dynamic until Vista.
    VDS_SVF_SUPPORT_FAULT_TOLERANT = 0x00000002,   // SKU supports both mirrors and RAID5 (server SKUs).
    VDS_SVF_SUPPORT_GPT = 0x00000004,   // GPT disks are supported.
    VDS_SVF_SUPPORT_DYNAMIC_1394 = 0x00000008,   // 1394 dynamic disks are supported.
    VDS_SVF_CLUSTER_SERVICE_CONFIGURED = 0x00000010,   // Server is part of a cluster configuration.
    VDS_SVF_AUTO_MOUNT_OFF = 0x00000020,   // NoAutoMount is enabled.
    VDS_SVF_OS_UNINSTALL_VALID = 0x00000040,
    VDS_SVF_EFI = 0x00000080,   // Server boots EFI (from GPT disk).
    VDS_SVF_SUPPORT_MIRROR = 0x00000100,  // Added for Windows7 - SKU supports mirrors (Windows7 client and server SKUs).
    VDS_SVF_SUPPORT_RAID5 = 0x00000200,  // Added for Windows7 - SKU supports RAID5 (server SKUs).
    VDS_SVF_SUPPORT_REFS = 0x00000400   // Added for Windows8 - SKU supports ReFS (server SKUs).

} VDS_SERVICE_FLAG;

//
// Service Properties
//
typedef struct VDS_SERVICE_PROP
{
    LongPtr     pwszVersion;
    VDS_SERVICE_FLAG               ulFlags;

} VDS_SERVICE_PROP;

//
// SAN Policy flags
//

typedef enum VDS_SAN_POLICY
{
    VDS_SP_UNKNOWN = 0x0,  //
    VDS_SP_ONLINE = 0x1,  // All newly discovered disks are brought ONLINE and made WRITABLE
    VDS_SP_OFFLINE_SHARED = 0x2,  // All newly discovered disks not residing on a shared bus are
    // brought ONLINE and made WRITABLE.
    VDS_SP_OFFLINE = 0x3,  // All newly discovered disks remain OFFLINE and READ-ONLY.
    VDS_SP_OFFLINE_INTERNAL = 0x4,  // All newly discovered internal disks remain OFFLINE and READ-ONLY.
    VDS_SP_MAX = 0x5,

} VDS_SAN_POLICY;

//
// Reparse Point Properties
//
typedef struct VDS_REPARSE_POINT_PROP
{
    UUID       SourceVolumeId;
    LongPtr     pwszPath;

} VDS_REPARSE_POINT_PROP;

//
// Drive Letter Flags
//
typedef enum VDS_DRIVE_LETTER_FLAG
{
    VDS_DLF_NON_PERSISTENT = 0x1

} VDS_DRIVE_LETTER_FLAG;

//
// Drive Letter Properties
//
typedef struct VDS_DRIVE_LETTER_PROP
{
    WCHAR               wcLetter;
    UUID       volumeId;
    VDS_DRIVE_LETTER_FLAG               ulFlags;     // pending removal
    BOOL                bUsed;

} VDS_DRIVE_LETTER_PROP;


//
// File System Type Flags
//
typedef enum VDS_FILE_SYSTEM_FLAG
{
    VDS_FSF_SUPPORT_FORMAT = 0x1,
    // A UI's drop down list should only have
    // those file systems that support format.
    VDS_FSF_SUPPORT_QUICK_FORMAT = 0x2,
    VDS_FSF_SUPPORT_COMPRESS = 0x4,
    VDS_FSF_SUPPORT_SPECIFY_LABEL = 0x8,
    VDS_FSF_SUPPORT_MOUNT_POINT = 0x10,
    VDS_FSF_SUPPORT_REMOVABLE_MEDIA = 0x20,
    VDS_FSF_SUPPORT_EXTEND = 0x40,

    VDS_FSF_ALLOCATION_UNIT_512 = 0x10000,
    VDS_FSF_ALLOCATION_UNIT_1K = 0x20000,
    VDS_FSF_ALLOCATION_UNIT_2K = 0x40000,
    VDS_FSF_ALLOCATION_UNIT_4K = 0x80000,
    VDS_FSF_ALLOCATION_UNIT_8K = 0x100000,
    VDS_FSF_ALLOCATION_UNIT_16K = 0x200000,
    VDS_FSF_ALLOCATION_UNIT_32K = 0x400000,
    VDS_FSF_ALLOCATION_UNIT_64K = 0x800000,
    VDS_FSF_ALLOCATION_UNIT_128K = 0x1000000,
    VDS_FSF_ALLOCATION_UNIT_256K = 0x2000000

} VDS_FILE_SYSTEM_FLAG;

//
// File System Type Properties
//
typedef struct VDS_FILE_SYSTEM_TYPE_PROP
{
    VDS_FILE_SYSTEM_TYPE type;   // FAT, FAT32, NTFS, ...
    WCHAR               wszName[8]; //MAX_FS_NAME_SIZE
    VDS_FILE_SYSTEM_FLAG               ulFlags;
    ULONG               ulCompressionFlags;
    // legal alloc unit sizes valid for compression
    ULONG               ulMaxLableLength;
    LongPtr     pwszIllegalLabelCharSet;

} VDS_FILE_SYSTEM_TYPE_PROP;

//
// File System Format Support Flags
//
typedef enum VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG
{
    VDS_FSS_DEFAULT = 0x1,
    VDS_FSS_PREVIOUS_REVISION = 0x2,
    VDS_FSS_RECOMMENDED = 0x4

} VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG;

//
// File System Format Support Properties
//
typedef struct VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP
{
    VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG               ulFlags;
    USHORT              usRevision;
    ULONG               ulDefaultUnitAllocationSize;
    ULONG               rgulAllowedUnitAllocationSizes[32]; //MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE
    WCHAR               wszName[32]; //MAX_FS_FORMAT_SUPPORT_NAME_SIZE

} VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP;

//
// File System Flags
//
typedef enum VDS_FILE_SYSTEM_PROP_FLAG
{
    VDS_FPF_COMPRESSED = 0x1

} VDS_FILE_SYSTEM_PROP_FLAG;


//
// File System Option Flags
//
typedef enum VDS_FORMAT_OPTION_FLAGS
{
    VDS_FSOF_NONE = 0x00000000,
    VDS_FSOF_FORCE = 0x00000001,
    VDS_FSOF_QUICK = 0x00000002,
    VDS_FSOF_COMPRESSION = 0x00000004,
    VDS_FSOF_DUPLICATE_METADATA = 0x00000008

} VDS_FORMAT_OPTION_FLAGS;

//
// File System Properties
//
typedef struct VDS_FILE_SYSTEM_PROP
{
    VDS_FILE_SYSTEM_TYPE type;
    // It is recommended that GetFileSystemTypeName be used instead of this
    // type field so that unknown file systems types can be retrieved too.
    UUID       volumeId;
    ULONG               ulFlags;
    // When this flag is set/cleared, there is no notification sent.
    // This is indeed a flag for the root directory of the volume.
    // There is no notification sent on the volume by PnP if it changed.
    ULONGLONG           ullTotalAllocationUnits;
    ULONGLONG           ullAvailableAllocationUnits;
    ULONG               ulAllocationUnitSize;
    LongPtr     pwszLabel;

} VDS_FILE_SYSTEM_PROP;

//
// Types for Provider queries
//
typedef enum VDS_QUERY_PROVIDER_FLAG
{
    VDS_QUERY_SOFTWARE_PROVIDERS = 0x1,
    VDS_QUERY_HARDWARE_PROVIDERS = 0x2,
    VDS_QUERY_VIRTUALDISK_PROVIDERS = 0x4
} VDS_QUERY_PROVIDER_FLAG;

//
// IVdsServiceLoader:
// Implemented by: service loader object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(e0393303-90d4-4a97-ab71-e9b671ee2729)
]
interface IVdsServiceLoader : stdole.IUnknown
{
    [helpstring("method LoadService")]
        HRESULT LoadService(
            [in] LongPtr       pwszMachineName,
            [out] IVdsService** ppService
        );
}

//
// IVdsService:
// Implemented by: service object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(0818a8ef-9ba9-40d8-a6f9-e22833cc771e)
]
interface IVdsService : stdole.IUnknown
{
    // IsServiceReady:
    //   This method returns S_OK when it is fully initialized. Otherwise,
    //   it returns S_FALSE. Before the service initialization completes,
    //   an application should not call any other method other than
    //   GetProperties(). If the service failed to initialize, it returns
    //   VDS_E_INITIALIZATION_FAILED.
    [helpstring("method IsServiceReady")]
        HRESULT IsServiceReady(
        );

    // WaitForServiceReady:
    //   Before the service is ready, call to any method except If this
    //   method returns S_OK, the service
    //   successfully initialized; it returns VDS_E_INITIALIZED_FAILED if the
    //   service failed to initialize successfully.
    [helpstring("method WaitForServiceReady")]
        HRESULT WaitForServiceReady(
        );

    // GetProperties:
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_SERVICE_PROP* pServiceProp
        );

    [helpstring("method QueryProviders")]
        HRESULT QueryProviders(
            [in] VDS_QUERY_PROVIDER_FLAG masks,
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method QueryMaskedDisks")]
        HRESULT QueryMaskedDisks(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method QueryUnallocatedDisks")]
        HRESULT QueryUnallocatedDisks(
            [out] IEnumVdsObject** ppEnum
        );

    // GetObject:
    //   This method provides a way to go from id to object pointer. Object
    //   type can be provider, pack, volume, disk, storage system, controller.
    //   Although there seems to be no need for a controller or storage system
    //   object to have a persistent ID, it is good to have a transient ID
    //   which lasts a VDS session.
    //   Notifications will contain object id instead of object pointer.
    //   An application needs to convert from id to pointer.
    [helpstring("method GetObject")]
        HRESULT GetObject(
            //[in] UUID ObjectId,
            [in] int ObjectId1, [in] int ObjectId2, [in] int ObjectId3, [in] int ObjectId4,
            [in] VDS_OBJECT_TYPE type,
            [out] IUnknown** ppObjectUnk
        );

    [helpstring("method QueryDriveLetters")]
        HRESULT QueryDriveLetters(
            [in] WCHAR wcFirstLetter,
            [in] DWORD count,
            [out] VDS_DRIVE_LETTER_PROP* pDriveLetterPropArray
        );

    // It is recommended that IVdsVolumeMF2::QueryFileSystemFormatSupport() be
    // called to retrieve the supported file systems for particular volumes
    // rather than calling QueryFileSystemTypes(), which may not apply to all
    // volumes.
    [helpstring("method QueryFileSystemTypes")]
        HRESULT QueryFileSystemTypes(
            //[out, size_is(, *plNumberOfFileSystems)]
            //VDS_FILE_SYSTEM_TYPE_PROP** ppFileSystemTypeProps,
            [out] LongPtr* ppFileSystemTypeProps,
            [out] LONG* plNumberOfFileSystems
        );

    // Reenumerate
    //   Discover new disks, removed disks. It returns immediately
    //   After the request is sent. To rescan disks inside a RAID
    //   box, use Reinventory on IVdsSubSystem.
    [helpstring("method Reenumerate")]
        HRESULT Reenumerate(
            void
        );

    // Refresh
    //   Refresh disk ownership and disk layout.
    // NOTE: Sync disk layout to whatever the disk driver has. Does not
    //   force the driver to read layout from disk.
    [helpstring("method Refresh")]
        HRESULT Refresh(
            void
        );

    // CleanupObsoleteMountPoints:
    //   This method scrubs the registry with IOCTL_MOUNTMGR_SCRUB_REGISTRY,
    //   and remove any mount points pointing to volumes that no longer exist.
    //
    [helpstring("method CleanupObsoleteMountPoints")]
        HRESULT CleanupObsoleteMountPoints(
            void
        );

    // Advise:
    //   Applications register for notifications with the service object. The
    //   service receives notifications from software providers and hardware
    //   providers and forwards notifications to applications.
    [helpstring("method Advise")]
        HRESULT Advise(
            [in] IVdsAdviseSink* pSink,
            [out] DWORD* pdwCookie
        );

    [helpstring("method Unadvise")]
        HRESULT Unadvise(
            [in] DWORD dwCookie
        );

    [helpstring("method Reboot")]
        HRESULT Reboot(
        );

    [helpstring("method SetFlags")]
        HRESULT SetFlags(
            [in] VDS_SERVICE_FLAG ulFlags
        );

    [helpstring("method ClearFlags")]
        HRESULT ClearFlags(
            [in] VDS_SERVICE_FLAG ulFlags
        );
}

//
// IVdsServiceUninstallDisk:
// Implemented by: service object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(B6B22DA8-F903-4be7-B492-C09D875AC9DA)
]
interface IVdsServiceUninstallDisk : stdole.IUnknown
{
    [helpstring("method GetDiskIdFromLunInfo")]
        HRESULT GetDiskIdFromLunInfo(
            [in] VDS_LUN_INFORMATION* pLunInfo,
            [out] UUID* pDiskId
        );

    [helpstring("method UninstallDisks")]
        HRESULT UninstallDisks(
            [in] UUID* pDiskIdArray,
            [in] ULONG          ulCount,
            [in] BOOLEAN        bForce,
            [out] BOOLEAN* pbReboot,
            [out] HRESULT* pResults
        );
}

//
// IVdsServiceHba:
//   This interface is to add the ability to enumerate HBA ports for a class
//   implementing the IVdsService interface.
// Implemented by: service object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(0ac13689-3134-47c6-a17c-4669216801be)
]
interface IVdsServiceHba : stdole.IUnknown
{
    [helpstring("method QueryHbaPorts")]
        HRESULT QueryHbaPorts(
            [out] IEnumVdsObject** ppEnum
        );
}

//
// IVdsServiceIscsi:
//   This interface is to add the ability to interface with the local iSCSI
//   initiator service for a class implementing the IVdsService interface.
// Implemented by: service object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(14fbe036-3ed7-4e10-90e9-a5ff991aff01)
]
interface IVdsServiceIscsi : stdole.IUnknown
{
    [helpstring("method GetInitiatorName")]
        HRESULT GetInitiatorName(
            [out] LongPtr* ppwszIscsiName
        );

    [helpstring("method QueryInitiatorAdapters")]
        HRESULT QueryInitiatorAdapters(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method SetIpsecGroupPresharedKey")]
        HRESULT SetIpsecGroupPresharedKey(
            [in] VDS_ISCSI_IPSEC_KEY* pIpsecKey
        );

    [helpstring("method SetAllIpsecTunnelAddresses")]
        HRESULT SetAllIpsecTunnelAddresses(
            [in] VDS_IPADDRESS* pTunnelAddress,
            [in] VDS_IPADDRESS* pDestinationAddress
        );

    [helpstring("method SetAllIpsecSecurity")]
        HRESULT SetAllIpsecSecurity(
            //[in] UUID targetPortalId,
            [in] int targetPortalId1, [in] int targetPortalId2, [in] int targetPortalId3, [in] int targetPortalId4,
            [in] ULONGLONG ullSecurityFlags,
            [in] VDS_ISCSI_IPSEC_KEY* pIpsecKey
        );

    [helpstring("method SetInitiatorSharedSecret")]
        HRESULT SetInitiatorSharedSecret(
            [in] VDS_ISCSI_SHARED_SECRET* pInitiatorSharedSecret,
            //[in] UUID targetId
            [in] int targetId1, [in] int targetId2, [in] int targetId3, [in] int targetId4
        );

    [helpstring("method RememberTargetSharedSecret")]
        HRESULT RememberTargetSharedSecret(
            //[in] UUID targetId,
            [in] int targetId1, [in] int targetId2, [in] int targetId3, [in] int targetId4,
            [in] VDS_ISCSI_SHARED_SECRET* pTargetSharedSecret
        );
}

//
// IVdsServiceInitialization:
//   This interface is used by service loader object to start initialization
//   of a service object. It is not to be used by any application.

[
    odl,
        uuid(4afc3636-db01-4052-80c3-03bbcb8d3c69)
]
interface IVdsServiceInitialization : stdole.IUnknown
{
    // Initialize:
    //   If the name passed in is NULL, the service should launch regular
    //   providers; otherwise, it launches downrev providers and ask them
    //   to connect to a remote downrev machine.
    [helpstring("method Initialize")]
        HRESULT Initialize(
            [in] LongPtr      pwszMachineName
        );
}

//
// IVdsHbaPort:
// Implemented by: hbaport object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(2abd757f-2851-4997-9a13-47d2a885d6ca)
]
interface IVdsHbaPort : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_HBAPORT_PROP* pHbaPortProp
        );

    [helpstring("method SetAllPathStatuses")]
        HRESULT SetAllPathStatuses(
            [in] VDS_PATH_STATUS status
        );

}

//
// IVdsIscsiInitiatorAdapter:
// Implemented by: iSCSI initiator adapter object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(b07fedd4-1682-4440-9189-a39b55194dc5)
]
interface IVdsIscsiInitiatorAdapter : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_ISCSI_INITIATOR_ADAPTER_PROP* pInitiatorAdapterProp
        );

    [helpstring("method QueryInitiatorPortals")]
        HRESULT QueryInitiatorPortals(
            [out] IEnumVdsObject** ppEnum
        );

    [helpstring("method LoginToTarget")]
        HRESULT LoginToTarget(
            [in] VDS_ISCSI_LOGIN_TYPE loginType,
            //[in] UUID targetId,
            [in] int targetId1, [in] int targetId2, [in] int targetId3, [in] int targetId4,
            //[in] UUID targetPortalId,
            [in] int targetPortalId1, [in] int targetPortalId2, [in] int targetPortalId3, [in] int targetPortalId4,
            //[in] UUID initiatorPortalId,
            [in] int initiatorPortalId1, [in] int initiatorPortalId2, [in] int initiatorPortalId3, [in] int initiatorPortalId4,
            [in] VDS_ISCSI_LOGIN_FLAG ulLoginFlags,
            [in] BOOL bHeaderDigest,
            [in] BOOL bDataDigest,
            [in] VDS_ISCSI_AUTH_TYPE authType,
            [out] IVdsAsync** ppAsync
        );

    [helpstring("method LogoutFromTarget")]
        HRESULT LogoutFromTarget(
            //[in] UUID targetId,
            [in] int targetId1, [in] int targetId2, [in] int targetId3, [in] int targetId4,
            [out] IVdsAsync** ppAsync
        );
}

//
// IVdsIscsiInitiatorPortal:
// Implemented by: iSCSI initiator portal object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(38a0a9ab-7cc8-4693-ac07-1f28bd03c3da)
]
interface IVdsIscsiInitiatorPortal : stdole.IUnknown
{
    [helpstring("method GetProperties")]
        HRESULT GetProperties(
            [out] VDS_ISCSI_INITIATOR_PORTAL_PROP* pInitiatorPortalProp
        );

    [helpstring("method GetInitiatorAdapter")]
        HRESULT GetInitiatorAdapter(
            [out] IVdsIscsiInitiatorAdapter** ppInitiatorAdapter
        );

    [helpstring("method SetIpsecTunnelAddress")]
        HRESULT SetIpsecTunnelAddress(
            [in] VDS_IPADDRESS* pTunnelAddress,
            [in] VDS_IPADDRESS* pDestinationAddress
        );

    [helpstring("method GetIpsecSecurity")]
        HRESULT GetIpsecSecurity(
            //[in] UUID targetPortalId,
            [in] int targetPortalId1, [in] int targetPortalId2, [in] int targetPortalId3, [in] int targetPortalId4,
            [out] ULONGLONG* pullSecurityFlags
        );

    [helpstring("method SetIpsecSecurity")]
        HRESULT SetIpsecSecurity(
            //[in] UUID targetPortalId,
            [in] int targetPortalId1, [in] int targetPortalId2, [in] int targetPortalId3, [in] int targetPortalId4,
            [in] ULONGLONG ullSecurityFlags,
            [in] VDS_ISCSI_IPSEC_KEY* pIpsecKey
        );
}

// IVdsDiskPartitionMF:
//   The common layer adds this interface for each disk object. It provides
//   additional partition file system management functions.
// Implemented by: disk object
// Implemented where: common layer
// Accessed by: applications
[
    odl,
        uuid(538684e0-ba3d-4bc0-aca9-164aff85c2a9)
]
interface IVdsDiskPartitionMF : stdole.IUnknown
{
    // GetPartitionFileSystemLabel:
    //   Retrieve information for the file system on the partition.
    [helpstring("method GetPartitionFileSystemProperties")]
        HRESULT GetPartitionFileSystemProperties(
            [in] ULONGLONG ullOffset,
            [out] VDS_FILE_SYSTEM_PROP* pFileSystemProp
        );

    // GetPartitionFileSystemTypeName:
    //   Retrieve the name of the file system type returned by the partition
    //   file system attibutes.
    [helpstring("method GetPartitionFileSystemTypeName")]
        HRESULT GetPartitionFileSystemTypeName(
            [in] ULONGLONG ullOffset,
            [out] LongPtr* ppwszFileSystemTypeName
        );

    // QueryPartitionFileSystemFormatSupport:
    //   Retrieve the file systems that are supported for formatting the
    //   partition.
    [helpstring("method QueryPartitionFileSystemFormatSupport")]
        HRESULT QueryPartitionFileSystemFormatSupport(
            [in] ULONGLONG ullOffset,
            //[out, size_is(, *plNumberOfFileSystems)]
            //VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP** ppFileSystemSupportProps,
            [out] LongPtr* ppFileSystemSupportProps,
            [out] LONG* plNumberOfFileSystems
        );

    // FormatPartitionEx:
    //   Format the partition using the desired settings.  Defaults are used
    //   for file system type and allocation unit size if NULL and 0 are used,
    //   respectively.
    [helpstring("method FormatPartitionEx")]
        HRESULT FormatPartitionEx(
            [in] ULONGLONG ullOffset,
            [in] LongPtr pwszFileSystemTypeName,
            [in] USHORT usFileSystemRevision,
            [in] ULONG ulDesiredUnitAllocationSize,
            [in] LongPtr pwszLabel,
            [in] BOOL bForce,
            [in] BOOL bQuickFormat,
            [in] BOOL bEnableCompression,
            [out] IVdsAsync** ppAsync
        );

}

// IVdsVolumeMF:
//   The common layer adds this interface for each volume object. It provides
//   access path and file system management functions.
// Implemented by: volume object
// Implemented where: common layer
// Accessed by: applications
[
    odl,
        uuid(ee2d5ded-6236-4169-931d-b9778ce03dc6)
]
interface IVdsVolumeMF : stdole.IUnknown
{
    // GetFileSystemProperties:
    //   Retrieve information for the file system on the volume.
    [helpstring("method queryFileSystemProperties")]
        HRESULT GetFileSystemProperties(
            [out] VDS_FILE_SYSTEM_PROP* pFileSystemProp
        );

    [helpstring("method Format")]
        HRESULT Format(
            [in] VDS_FILE_SYSTEM_TYPE type,
            [in] LongPtr pwszLabel,
            [in] DWORD dwUnitAllocationSize,
            [in] BOOL bForce,
            [in] BOOL bQuickFormat,
            [in] BOOL bEnableCompression,
            [out] IVdsAsync** ppAsync
        );

    // AddAccessPath:
    //   Add both drive letter and mount paths. Drive letter must be in the
    //   form of "D:\", "C:\". Trailing backslash is required.
    [helpstring("method AddAccessPath")]
        HRESULT AddAccessPath(
            [in] LongPtr pwszPath
        );

    // QueryAccessPaths:
    //   Retrieves all access paths, including drive letter. The drive letter
    //   is returned as the first access path in pwszPathArray.
    [helpstring("method QueryAccessPaths")]
        HRESULT QueryAccessPaths(
            //[out, string, size_is(, *plNumberOfAccessPaths)]
            //LPWSTR** pwszPathArray,
            [out] LongPtr * pwszPathArray,
            [out] LONG* plNumberOfAccessPaths
        );

    // QueryReparsePoints:
    //   Retrieves reparse points to a volume. Each reparse point is
    //   represented as a tuple of source volume id and path on the volume.
    //   Unlike QueryAccessPaths(), this method does not return redundant
    //   access paths.
    [helpstring("method QueryReparsePoints")]
        HRESULT QueryReparsePoints(
            //[out, size_is(, *plNumberOfReparsePointProps)]
            //VDS_REPARSE_POINT_PROP** ppReparsePointProps,
            [out] LongPtr* ppReparsePointProps,
            [out] LONG* plNumberOfReparsePointProps
        );

    [helpstring("method DeleteAccessPath")]
        HRESULT DeleteAccessPath(
            [in] LongPtr pwszPath,
            [in] BOOL bForce
        );

    [helpstring("method Mount")]
        HRESULT Mount(
            void
        );

    [helpstring("method Dismount")]
        HRESULT Dismount(
            [in] BOOL bForce,
            [in] BOOL bPermanent
        );

    // SetFlags:
    //   Only VDS_FPF_COMPRESSED can be set.
    [helpstring("method SetFileSystemFlags")]
        HRESULT SetFileSystemFlags(
            [in] VDS_FILE_SYSTEM_FLAG  ulFlags
        );

    // ClearFlags:
    //   Only VDS_FPF_COMPRESSED can be cleared.
    [helpstring("method ClearFileSystemFlags")]
        HRESULT ClearFileSystemFlags(
            [in] VDS_FILE_SYSTEM_FLAG ulFlags
        );

}

// IVdsVolumeMF2:
//   The common layer adds this interface for each volume object. It provides
//   additional file system management functions.
// Implemented by: volume object
// Implemented where: common layer
// Accessed by: applications
[
    odl,
        uuid(4dbcee9a-6343-4651-b85f-5e75d74d983c)
]
interface IVdsVolumeMF2 : stdole.IUnknown
{
    // GetFileSystemTypeName:
    //   Retrieve the name of the file system type returned by the volume file
    //   system attibutes.
    [helpstring("method GetFileSystemTypeName")]
        HRESULT GetFileSystemTypeName(
            [out] LongPtr* ppwszFileSystemTypeName
        );

    // QueryFileSystemFormatSupport:
    //   Retrieve the file systems that are supported for formatting the
    //   volume.
    [helpstring("method QueryFileSystemFormatSupport")]
        HRESULT QueryFileSystemFormatSupport(
            //[out, size_is(, *plNumberOfFileSystems)]
            //VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP** ppFileSystemSupportProps,
            [out] LongPtr* ppFileSystemSupportProps,
            [out] LONG* plNumberOfFileSystems
        );

    // FormatEx:
    //   Format the volume using the desired settings.  Defaults are used for
    //   file system type and allocation unit size if NULL and 0 are used,
    //   respectively.
    [helpstring("method FormatEx")]
        HRESULT FormatEx(
            [in] LongPtr pwszFileSystemTypeName,
            [in] USHORT usFileSystemRevision,
            [in] ULONG ulDesiredUnitAllocationSize,
            [in] LongPtr pwszLabel,
            [in] BOOL bForce,
            [in] BOOL bQuickFormat,
            [in] BOOL bEnableCompression,
            [out] IVdsAsync** ppAsync
        );

}

// IVdsVolumeShrink:
//   The common layer adds this interface for each volume object. It provides
//   volume shrink functionality.
// Implemented by: volume object
// Implemented where: common layer
// Accessed by: applications
[
    odl,
        uuid(d68168c9-82a2-4f85-b6e9-74707c49a58f)
]
interface IVdsVolumeShrink : stdole.IUnknown
{
    //
    // QueryMaxReclaimableBytes
    //   This method will return the maximum number of bytes which can be
    //   salvaged from the current volume.
    //
    [helpstring("method QueryMaxReclaimableBytes")]
        HRESULT QueryMaxReclaimableBytes(
            [out]   ULONGLONG* pullMaxNumberOfReclaimableBytes
        );

    // Shrink:
    //   This method shrinks the volume and all plexes and return the
    //   released extents.
    //
    //   The file system will be shrunk first. In order to shrink a volume,
    //   the file system must support shrink.
    //
    [helpstring("method Shrink")]
        HRESULT Shrink(
            [in]    ULONGLONG   ullDesiredNumberOfReclaimableBytes,
            [in]    ULONGLONG   ullMinNumberOfReclaimableBytes,
            [out]   IVdsAsync** ppAsync
        );
}

//
// IVdsSubSystemImportTarget:
//
// Implemented by: subsystem object
// Implemented where: common layer
// Accessed by: applications
//
[
    odl,
        uuid(83bfb87f-43fb-4903-baa6-127f01029eec)
]
interface IVdsSubSystemImportTarget : stdole.IUnknown
{
    [helpstring("method GetImportTarget")]
        HRESULT GetImportTarget(
            [out] LongPtr* ppwszIscsiName
        );

    [helpstring("method SetImportTarget")]
        HRESULT SetImportTarget(
            [in] LongPtr pwszIscsiName
        );

}

//
// IVdsIscsiPortalLocal:
//
// Implemented by: iSCSI target portal object
// Implemented where: common layer
// Accessed by: applications
[
    odl,
        uuid(ad837c28-52c1-421d-bf04-fae7da665396)
]
interface IVdsIscsiPortalLocal : stdole.IUnknown
{
    [helpstring("method SetIpsecSecurityLocal")]
        HRESULT SetIpsecSecurityLocal(
            [in] ULONGLONG ullSecurityFlags,
            [in] VDS_ISCSI_IPSEC_KEY* pIpsecKey
        );

}

//
// IVdsServiceSAN:
//
//  Provides disk online/offline management functions.
//  Implemented by: Service object
//  Implemented where: common layer
//  Accessed by: applications
[
    odl,
        uuid(FC5D23E8-A88B-41a5-8DE0-2D2F73C5A630)
]
interface IVdsServiceSAN : stdole.IUnknown
{
    [helpstring("method GetSANPolicy")]
        HRESULT GetSANPolicy(
            [out] VDS_SAN_POLICY* pSanPolicy
        );

    [helpstring("method SetSANPolicy")]
        HRESULT SetSANPolicy(
            [in] VDS_SAN_POLICY SanPolicy
        );

}


// IVdsVolumeMF3:
//   The common layer adds this interface for each volume object. I
// Implemented by: volume object
// Implemented where: common layer
// Accessed by: applications
[
    odl,
        uuid(6788FAF9-214E-4b85-BA59-266953616E09)
]
interface IVdsVolumeMF3 : stdole.IUnknown
{
    //
    // QueryVolumeGuidPathnames:
    //   Retrieve the list of volume GUID pathnames.
    //

    [helpstring("method QueryVolumeGuidPathnames")]
        HRESULT QueryVolumeGuidPathnames(
            //[out, string, size_is(, *pulNumberOfPaths)] LPWSTR** pwszPathArray,
            [out] LongPtr* pwszPathArray,
            [out] ULONG* pulNumberOfPaths
        );


    //
    // FormatEx2:
    //   Format the volume using the desired settings.  Defaults are used for
    //   file system type and allocation unit size if NULL and 0 are used,
    //   respectively. Added a flag for duplicating UDF meta data. Changed flags
    //   to a bitmap.
    //

    [helpstring("method FormatEx2")]
        HRESULT FormatEx2(
            [in] LongPtr pwszFileSystemTypeName,
            [in] USHORT usFileSystemRevision,
            [in] ULONG ulDesiredUnitAllocationSize,
            [in] LongPtr pwszLabel,
            [in] VDS_FORMAT_OPTION_FLAGS Options,
            [out] IVdsAsync** ppAsync
        );

    //
    // OfflineVolume:
    //   Offline the volume by calling IOCTL_VOLUME_OFFLINE control code.
    //   If the volume is already offline it does not do anything, simply
    //   returns S_OK.

    [helpstring("method OfflineVolume")]
        HRESULT OfflineVolume(
            void
        );

}
// IVdsDiskPartitionMF2:
//   The common layer adds this interface for each disk object. It provides
//   additional partition file system management functions.
// Implemented by: disk object
// Implemented where: common layer
// Accessed by: applications
[
    odl,
        uuid(9CBE50CA-F2D2-4bf4-ACE1-96896B729625)
]
interface IVdsDiskPartitionMF2 : stdole.IUnknown
{
    //
    // FormatPartitionEx2:
    //   Format the partition using the desired settings.  Defaults are used
    //   for file system type and allocation unit size if NULL and 0 are used,
    //   respectively. Added a flag for duplicating UDF meta data. Changed flags
    //   to a bitmap.
    //

    [helpstring("method FormatPartitionEx2")]
        HRESULT FormatPartitionEx2(
            [in] ULONGLONG ullOffset,
            [in] LongPtr pwszFileSystemTypeName,
            [in] USHORT usFileSystemRevision,
            [in] ULONG ulDesiredUnitAllocationSize,
            [in] LongPtr pwszLabel,
            [in] VDS_FORMAT_OPTION_FLAGS Options,
            [out] IVdsAsync** ppAsync
        );

}


// IVdsServiceSw:
//   Provides a means to lookup disks by the unique PNPDeviceID string
// Implemented by: service object
// Implemented where: common layer
// Accessed by: applications
[
    odl,
        uuid(15fc031c-0652-4306-b2c3-f558b8f837e2)
]
interface IVdsServiceSw : stdole.IUnknown
{
    [helpstring("method GetDiskObject")]
        HRESULT GetDiskObject(
            [in] LongPtr pwszDeviceID,
            [out] IUnknown** ppDiskUnk
        );
}

//cpp_quote("#if _MSC_VER >= 1200")
//cpp_quote("#pragma warning(pop)")
//cpp_quote("#endif")
//
//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion








// ***************************************************************
//
// vdsprvcm.idl
//
// ***


//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2000
//
//    File: vdsprvcm.idl
//
//    Abstract:
//        declarations of interfaces and types that are exposed by providers
//        to the service, but not exposed through the service.
//
//----------------------------------------------------------------------------

//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

interface IVdsProviderPrivate;

//
// IVdsProviderPrivate:
// Implemented by: provider object
// Implemented where: providers
// Accessed by: common layer
//
[
    odl,
        uuid(11f3cd41-b7e8-48ff-9472-9dff018aa292)
]
interface IVdsProviderPrivate : stdole.IUnknown
{
    // GetObject:
    //   The service queries each provider using this method to find
    //   the object and create a wrapper object for it.
    [helpstring("method GetObject")]
        HRESULT GetObject(
            //[in] UUID ObjectId,
            [in] int ObjectId1, [in] int ObjectId2, [in] int ObjectId3, [in] int ObjectId4,
            [in] VDS_OBJECT_TYPE type,
            [out] IUnknown** ppObjectUnk
        );

    // OnLoad:
    //   The service call OnLoad() method after loading
    //   a provider. The provider should intialize itself in
    //   this call.
    [helpstring("method OnLoad")]
        HRESULT OnLoad(
            [in] LongPtr pwszMachineName,
            [in] IUnknown* pCallbackObject
        );
    // A provider should call QueryInterface() on pCallbackObject to
    // get any interface pointer needed. At this time, there are only
    // two such interface: IVdsOwnershipChangeQuery(for software provider
    // only) and IVdsAdviseSink.

// OnUnload:
//   The service call OnUnload() method before unloading
//   a provider. The provider should unintialize itself in
//   this call. It returns S_FALSE to let the service know
//   it's not ready to unload yet.
    [helpstring("method OnUnload")]
        HRESULT OnUnload(
            [in] BOOL bForceUnload
        );
}

//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion
//
//










// ***************************************************************
//
// vdshpcm.idl
//
// ***************************************************************


//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2000
//
//    File: vdshpcm.idl
//
//    Abstract:
//        declarations of interfaces that are exposed by hardware providers to
//        the common layer, but not exposed through the common layer.
//
//        IVdsOwnershipChangeQuery is also implemented by service and exposed
//        to software providers.
//
//----------------------------------------------------------------------------

//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

interface IVdsHwProviderPrivate;
interface IVdsHwProviderPrivateMpio;

//
// IVdsHwProviderPrivate:
// Implemented by: provider object
// Implemented where: hardware providers
// Accessed by: common layer
//
[
    odl,
        uuid(98f17bf3-9f33-4f12-8714-8b4075092c2e)
]
interface IVdsHwProviderPrivate : stdole.IUnknown
{
    // QueryIfOwnLun:
    //   This method tells the service if the provider owns the disk. The
    //   service passes in the disk's device interface. If the method
    //   returns S_OK, the provider owns this disk; otherwise, it returns
    //   S_FALSE. The provider pass back the disk id to the service.
    [helpstring("method QueryIfOwnLun")]
        HRESULT QueryIfCreatedLun(
            [in] LongPtr pwszDevicePath,
            [in] VDS_LUN_INFORMATION* pVdsLunInformation,
            [out] UUID* pLunId
        );

}


//
// IVdsHwProviderPrivateMpio:
//   This interface is to add the ability to set HBA port status in a provider
//   for a class implementing the IVdsHwProviderPrivate interface.  This is
//   needed to support MPIO.
// Implemented by: provider object
// Implemented where: non-iSCSI hardware providers supporting MPIO
// Accessed by: common layer
//
[
    odl,
        uuid(310a7715-ac2b-4c6f-9827-3d742f351676)
]
interface IVdsHwProviderPrivateMpio : stdole.IUnknown
{
    [helpstring("method SetAllPathStatusesFromHbaPort")]
        HRESULT SetAllPathStatusesFromHbaPort(
            //[in] VDS_HBAPORT_PROP hbaPortProp,
            [in] int hbaPortProp1, [in] int hbaPortProp2, [in] int hbaPortProp3, [in] int hbaPortProp4, [in] int hbaPortProp5, [in] int hbaPortProp6, [in] int hbaPortProp7, [in] int hbaPortProp8, [in] int hbaPortProp9, [in] int hbaPortProp10, [in] int hbaPortProp11, [in] int hbaPortProp12,
            [in] VDS_PATH_STATUS status
        );
}

//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion
//



















// ***************************************************************
//
// vdscmprv.idl
//
// ***************************************************************
//+---------------------------------------------------------------------------
//
//    Microsoft Windows
//    Copyright (C) Microsoft Corporation, 2000
//
//    File: vdscmprv.idl
//
//    Abstract:
//        declarations of interfaces that are exposed by the common layer to
//        providers.
//
//----------------------------------------------------------------------------

//cpp_quote("#include <winapifamily.h>")
//
//#pragma region Desktop Family
//cpp_quote("#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)")

interface IVdsAdmin;

//#define MAX_COMPUTERNAME_LENGTH         15
//#define MAX_PROVIDERNAME_LENGTH         200
//#define MAX_VERSIONSTRING_LENGTH        16


//
// IVdsAdmin:
//   This interface is used by providers to register themselves. Provider
//   information is stored in registry under
//   \HKEY_LOCAL_MACHINE\SYSTEM\CurrentContrlSet\Services\VDS\SoftwareProviders
//   or
//   \HKEY_LOCAL_MACHINE\SYSTEM\CurrentContrlSet\Services\VDS\HardwareProviders
//   When VDS service starts up, it looks through the registry and launch
//   registered providers.
// Implemented by: service object
// Implemented where: common layer
// Accessed by: provider setup
//
[
    odl,
        uuid(d188e97d-85aa-4d33-abc6-26299a10ffc1)
]
interface IVdsAdmin : stdole.IUnknown
{
    // RegisterProvider:
    [helpstring("method RegisterProvider")]
        HRESULT RegisterProvider(
            //[in] UUID      providerId,
            [in] int providerId1 ,[in] int providerId2, [in] int providerId3, [in] int providerId4,
            //[in] CLSID              providerClsid,
            [in] int providerClsid1, [in] int providerClsid2, [in] int providerClsid3, [in] int providerClsid4,
            [in] LongPtr             pwszName,
            [in] VDS_PROVIDER_TYPE  type,
            [in] LongPtr             pwszMachineName,
            [in] LongPtr             pwszVersion,
            //[in] GUID               guidVersionId
            [in] int guidVersionId1, [in] int guidVersionId2, [in] int guidVersionId3, [in] int guidVersionId4
        );


    // UnregisterProvider:
    //   Removes provider information from registry.
    [helpstring("method UnregisterProvider")]
        HRESULT UnregisterProvider(
            //[in] UUID      providerId,
            [in] int providerId1, [in] int providerId2, [in] int providerId3, [in] int providerId4
        );
}

//cpp_quote("#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */")
//#pragma endregion

