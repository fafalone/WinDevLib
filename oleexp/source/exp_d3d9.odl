


// d3d9types.h


typedef struct D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;


typedef struct D3DVIEWPORT9 {
    DWORD       X;
    DWORD       Y;            /* Viewport Top left */
    DWORD       Width;
    DWORD       Height;       /* Viewport Dimensions */
    float       MinZ;         /* Min/max of clip Volume */
    float       MaxZ;
} D3DVIEWPORT9;

/*
 * Values for clip fields.
 */

 // Max number of user clipping planes, supported in D3D.
//#define D3DMAXUSERCLIPPLANES 32

// These bits could be ORed together to use with D3DRS_CLIPPLANEENABLE
//
typedef enum D3D9ClipPlanes
{
     D3DCLIPPLANE0 = 1, //(1 << 0),
     D3DCLIPPLANE1 = 2, //(1 << 1),
     D3DCLIPPLANE2 = 4, //(1 << 2),
     D3DCLIPPLANE3 = 8, // (1 << 3),
     D3DCLIPPLANE4 = 16, //(1 << 4),
     D3DCLIPPLANE5 = 32 //(1 << 5)
} D3D9ClipPlanes;
// The following bits are used in the ClipUnion and ClipIntersection
// members of the D3DCLIPSTATUS9
//

typedef enum D3D9ClipStatus
{
D3DCS_LEFT        = 0x00000001,
D3DCS_RIGHT       = 0x00000002,
D3DCS_TOP         = 0x00000004,
D3DCS_BOTTOM      = 0x00000008,
D3DCS_FRONT       = 0x00000010,
D3DCS_BACK        = 0x00000020,
D3DCS_PLANE0      = 0x00000040,
D3DCS_PLANE1      = 0x00000080,
D3DCS_PLANE2      = 0x00000100,
D3DCS_PLANE3      = 0x00000200,
D3DCS_PLANE4      = 0x00000400,
D3DCS_PLANE5      = 0x00000800,

D3DCS_ALL = 0x00000FFF //(D3DCS_LEFT   | D3DCS_RIGHT |  D3DCS_TOP |  D3DCS_BOTTOM |  D3DCS_FRONT |  D3DCS_BACK |  D3DCS_PLANE0 |  D3DCS_PLANE1 |  D3DCS_PLANE2 |  D3DCS_PLANE3 |  D3DCS_PLANE4 |  D3DCS_PLANE5)
} D3D9ClipStatus;


typedef struct D3DCLIPSTATUS9 {
    D3D9ClipStatus ClipUnion;
    D3D9ClipStatus ClipIntersection;
} D3DCLIPSTATUS9;

typedef struct D3DMATERIAL9 {
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    float           Power;          /* Sharpness if specular highlight */
} D3DMATERIAL9;

typedef enum D3DLIGHTTYPE {
    D3DLIGHT_POINT = 1,
    D3DLIGHT_SPOT = 2,
    D3DLIGHT_DIRECTIONAL = 3,
    D3DLIGHT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

typedef struct D3DLIGHT9 {
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    float           Range;            /* Cutoff range */
    float           Falloff;          /* Falloff */
    float           Attenuation0;     /* Constant attenuation */
    float           Attenuation1;     /* Linear attenuation */
    float           Attenuation2;     /* Quadratic attenuation */
    float           Theta;            /* Inner angle of spotlight cone */
    float           Phi;              /* Outer angle of spotlight cone */
} D3DLIGHT9;

/*
 * Options for clearing
 */
typedef enum D3DCLEAR
{
     D3DCLEAR_TARGET = 0x00000001,  /* Clear target surface */
     D3DCLEAR_ZBUFFER = 0x00000002,  /* Clear target z buffer */
     D3DCLEAR_STENCIL = 0x00000004   /* Clear stencil planes */
} D3DCLEAR;
 /*
  * The following defines the rendering states
  */

typedef enum D3DSHADEMODE {
    D3DSHADE_FLAT = 1,
    D3DSHADE_GOURAUD = 2,
    D3DSHADE_PHONG = 3,
    D3DSHADE_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;

typedef enum D3DFILLMODE {
    D3DFILL_POINT = 1,
    D3DFILL_WIREFRAME = 2,
    D3DFILL_SOLID = 3,
    D3DFILL_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef enum D3DBLEND {
    D3DBLEND_ZERO = 1,
    D3DBLEND_ONE = 2,
    D3DBLEND_SRCCOLOR = 3,
    D3DBLEND_INVSRCCOLOR = 4,
    D3DBLEND_SRCALPHA = 5,
    D3DBLEND_INVSRCALPHA = 6,
    D3DBLEND_DESTALPHA = 7,
    D3DBLEND_INVDESTALPHA = 8,
    D3DBLEND_DESTCOLOR = 9,
    D3DBLEND_INVDESTCOLOR = 10,
    D3DBLEND_SRCALPHASAT = 11,
    D3DBLEND_BOTHSRCALPHA = 12,
    D3DBLEND_BOTHINVSRCALPHA = 13,
    D3DBLEND_BLENDFACTOR = 14, /* Only supported if D3DPBLENDCAPS_BLENDFACTOR is on */
    D3DBLEND_INVBLENDFACTOR = 15, /* Only supported if D3DPBLENDCAPS_BLENDFACTOR is on */
    /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DBLEND_SRCCOLOR2 = 16,
    D3DBLEND_INVSRCCOLOR2 = 17,

//#endif // !D3D_DISABLE_9EX
    /* -- D3D9Ex only */
    D3DBLEND_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum D3DBLENDOP {
    D3DBLENDOP_ADD = 1,
    D3DBLENDOP_SUBTRACT = 2,
    D3DBLENDOP_REVSUBTRACT = 3,
    D3DBLENDOP_MIN = 4,
    D3DBLENDOP_MAX = 5,
    D3DBLENDOP_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DBLENDOP;

typedef enum D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP = 1,
    D3DTADDRESS_MIRROR = 2,
    D3DTADDRESS_CLAMP = 3,
    D3DTADDRESS_BORDER = 4,
    D3DTADDRESS_MIRRORONCE = 5,
    D3DTADDRESS_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum D3DCULL {
    D3DCULL_NONE = 1,
    D3DCULL_CW = 2,
    D3DCULL_CCW = 3,
    D3DCULL_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum D3DCMPFUNC {
    D3DCMP_NEVER = 1,
    D3DCMP_LESS = 2,
    D3DCMP_EQUAL = 3,
    D3DCMP_LESSEQUAL = 4,
    D3DCMP_GREATER = 5,
    D3DCMP_NOTEQUAL = 6,
    D3DCMP_GREATEREQUAL = 7,
    D3DCMP_ALWAYS = 8,
    D3DCMP_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum D3DSTENCILOP {
    D3DSTENCILOP_KEEP = 1,
    D3DSTENCILOP_ZERO = 2,
    D3DSTENCILOP_REPLACE = 3,
    D3DSTENCILOP_INCRSAT = 4,
    D3DSTENCILOP_DECRSAT = 5,
    D3DSTENCILOP_INVERT = 6,
    D3DSTENCILOP_INCR = 7,
    D3DSTENCILOP_DECR = 8,
    D3DSTENCILOP_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum D3DFOGMODE {
    D3DFOG_NONE = 0,
    D3DFOG_EXP = 1,
    D3DFOG_EXP2 = 2,
    D3DFOG_LINEAR = 3,
    D3DFOG_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum D3DZBUFFERTYPE {
    D3DZB_FALSE = 0,
    D3DZB_TRUE = 1, // Z buffering
    D3DZB_USEW = 2, // W buffering
    D3DZB_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

// Primitives supported by draw-primitive API
typedef enum D3DPRIMITIVETYPE {
    D3DPT_POINTLIST = 1,
    D3DPT_LINELIST = 2,
    D3DPT_LINESTRIP = 3,
    D3DPT_TRIANGLELIST = 4,
    D3DPT_TRIANGLESTRIP = 5,
    D3DPT_TRIANGLEFAN = 6,
    D3DPT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

typedef enum D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW = 2,
    D3DTS_PROJECTION = 3,
    D3DTS_TEXTURE0 = 16,
    D3DTS_TEXTURE1 = 17,
    D3DTS_TEXTURE2 = 18,
    D3DTS_TEXTURE3 = 19,
    D3DTS_TEXTURE4 = 20,
    D3DTS_TEXTURE5 = 21,
    D3DTS_TEXTURE6 = 22,
    D3DTS_TEXTURE7 = 23,
    D3DTS_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

//#define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + 256)
//#define D3DTS_WORLD  D3DTS_WORLDMATRIX(0)
//#define D3DTS_WORLD1 D3DTS_WORLDMATRIX(1)
//#define D3DTS_WORLD2 D3DTS_WORLDMATRIX(2)
//#define D3DTS_WORLD3 D3DTS_WORLDMATRIX(3)

typedef enum D3DRENDERSTATETYPE {
    D3DRS_ZENABLE = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
    D3DRS_FILLMODE = 8,    /* D3DFILLMODE */
    D3DRS_SHADEMODE = 9,    /* D3DSHADEMODE */
    D3DRS_ZWRITEENABLE = 14,   /* TRUE to enable z writes */
    D3DRS_ALPHATESTENABLE = 15,   /* TRUE to enable alpha tests */
    D3DRS_LASTPIXEL = 16,   /* TRUE for last-pixel on lines */
    D3DRS_SRCBLEND = 19,   /* D3DBLEND */
    D3DRS_DESTBLEND = 20,   /* D3DBLEND */
    D3DRS_CULLMODE = 22,   /* D3DCULL */
    D3DRS_ZFUNC = 23,   /* D3DCMPFUNC */
    D3DRS_ALPHAREF = 24,   /* D3DFIXED */
    D3DRS_ALPHAFUNC = 25,   /* D3DCMPFUNC */
    D3DRS_DITHERENABLE = 26,   /* TRUE to enable dithering */
    D3DRS_ALPHABLENDENABLE = 27,   /* TRUE to enable alpha blending */
    D3DRS_FOGENABLE = 28,   /* TRUE to enable fog blending */
    D3DRS_SPECULARENABLE = 29,   /* TRUE to enable specular */
    D3DRS_FOGCOLOR = 34,   /* D3DCOLOR */
    D3DRS_FOGTABLEMODE = 35,   /* D3DFOGMODE */
    D3DRS_FOGSTART = 36,   /* Fog start (for both vertex and pixel fog) */
    D3DRS_FOGEND = 37,   /* Fog end      */
    D3DRS_FOGDENSITY = 38,   /* Fog density  */
    D3DRS_RANGEFOGENABLE = 48,   /* Enables range-based fog */
    D3DRS_STENCILENABLE = 52,   /* BOOL enable/disable stenciling */
    D3DRS_STENCILFAIL = 53,   /* D3DSTENCILOP to do if stencil test fails */
    D3DRS_STENCILZFAIL = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    D3DRS_STENCILPASS = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    D3DRS_STENCILFUNC = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRS_STENCILREF = 57,   /* Reference value used in stencil test */
    D3DRS_STENCILMASK = 58,   /* Mask value used in stencil test */
    D3DRS_STENCILWRITEMASK = 59,   /* Write mask applied to values written to stencil buffer */
    D3DRS_TEXTUREFACTOR = 60,   /* D3DCOLOR used for multi-texture blend */
    D3DRS_WRAP0 = 128,  /* wrap for 1st texture coord. set */
    D3DRS_WRAP1 = 129,  /* wrap for 2nd texture coord. set */
    D3DRS_WRAP2 = 130,  /* wrap for 3rd texture coord. set */
    D3DRS_WRAP3 = 131,  /* wrap for 4th texture coord. set */
    D3DRS_WRAP4 = 132,  /* wrap for 5th texture coord. set */
    D3DRS_WRAP5 = 133,  /* wrap for 6th texture coord. set */
    D3DRS_WRAP6 = 134,  /* wrap for 7th texture coord. set */
    D3DRS_WRAP7 = 135,  /* wrap for 8th texture coord. set */
    D3DRS_CLIPPING = 136,
    D3DRS_LIGHTING = 137,
    D3DRS_AMBIENT = 139,
    D3DRS_FOGVERTEXMODE = 140,
    D3DRS_COLORVERTEX = 141,
    D3DRS_LOCALVIEWER = 142,
    D3DRS_NORMALIZENORMALS = 143,
    D3DRS_DIFFUSEMATERIALSOURCE = 145,
    D3DRS_SPECULARMATERIALSOURCE = 146,
    D3DRS_AMBIENTMATERIALSOURCE = 147,
    D3DRS_EMISSIVEMATERIALSOURCE = 148,
    D3DRS_VERTEXBLEND = 151,
    D3DRS_CLIPPLANEENABLE = 152,
    D3DRS_POINTSIZE = 154,   /* float point size */
    D3DRS_POINTSIZE_MIN = 155,   /* float point size min threshold */
    D3DRS_POINTSPRITEENABLE = 156,   /* BOOL point texture coord control */
    D3DRS_POINTSCALEENABLE = 157,   /* BOOL point size scale enable */
    D3DRS_POINTSCALE_A = 158,   /* float point attenuation A value */
    D3DRS_POINTSCALE_B = 159,   /* float point attenuation B value */
    D3DRS_POINTSCALE_C = 160,   /* float point attenuation C value */
    D3DRS_MULTISAMPLEANTIALIAS = 161,  // BOOL - set to do FSAA with multisample buffer
    D3DRS_MULTISAMPLEMASK = 162,  // DWORD - per-sample enable/disable
    D3DRS_PATCHEDGESTYLE = 163,  // Sets whether patch edges will use float style tessellation
    D3DRS_DEBUGMONITORTOKEN = 165,  // DEBUG ONLY - token to debug monitor
    D3DRS_POINTSIZE_MAX = 166,   /* float point size max threshold */
    D3DRS_INDEXEDVERTEXBLENDENABLE = 167,
    D3DRS_COLORWRITEENABLE = 168,  // per-channel write enable
    D3DRS_TWEENFACTOR = 170,   // float tween factor
    D3DRS_BLENDOP = 171,   // D3DBLENDOP setting
    D3DRS_POSITIONDEGREE = 172,   // NPatch position interpolation degree. D3DDEGREE_LINEAR or D3DDEGREE_CUBIC (default)
    D3DRS_NORMALDEGREE = 173,   // NPatch normal interpolation degree. D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC
    D3DRS_SCISSORTESTENABLE = 174,
    D3DRS_SLOPESCALEDEPTHBIAS = 175,
    D3DRS_ANTIALIASEDLINEENABLE = 176,
    D3DRS_MINTESSELLATIONLEVEL = 178,
    D3DRS_MAXTESSELLATIONLEVEL = 179,
    D3DRS_ADAPTIVETESS_X = 180,
    D3DRS_ADAPTIVETESS_Y = 181,
    D3DRS_ADAPTIVETESS_Z = 182,
    D3DRS_ADAPTIVETESS_W = 183,
    D3DRS_ENABLEADAPTIVETESSELLATION = 184,
    D3DRS_TWOSIDEDSTENCILMODE = 185,   /* BOOL enable/disable 2 sided stenciling */
    D3DRS_CCW_STENCILFAIL = 186,   /* D3DSTENCILOP to do if ccw stencil test fails */
    D3DRS_CCW_STENCILZFAIL = 187,   /* D3DSTENCILOP to do if ccw stencil test passes and Z test fails */
    D3DRS_CCW_STENCILPASS = 188,   /* D3DSTENCILOP to do if both ccw stencil and Z tests pass */
    D3DRS_CCW_STENCILFUNC = 189,   /* D3DCMPFUNC fn.  ccw Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRS_COLORWRITEENABLE1 = 190,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DRS_COLORWRITEENABLE2 = 191,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DRS_COLORWRITEENABLE3 = 192,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
    D3DRS_BLENDFACTOR = 193,   /* D3DCOLOR used for a constant blend factor during alpha blending for devices that support D3DPBLENDCAPS_BLENDFACTOR */
    D3DRS_SRGBWRITEENABLE = 194,   /* Enable rendertarget writes to be DE-linearized to SRGB (for formats that expose D3DUSAGE_QUERY_SRGBWRITE) */
    D3DRS_DEPTHBIAS = 195,
    D3DRS_WRAP8 = 198,   /* Additional wrap states for vs_3_0+ attributes with D3DDECLUSAGE_TEXCOORD */
    D3DRS_WRAP9 = 199,
    D3DRS_WRAP10 = 200,
    D3DRS_WRAP11 = 201,
    D3DRS_WRAP12 = 202,
    D3DRS_WRAP13 = 203,
    D3DRS_WRAP14 = 204,
    D3DRS_WRAP15 = 205,
    D3DRS_SEPARATEALPHABLENDENABLE = 206,  /* TRUE to enable a separate blending function for the alpha channel */
    D3DRS_SRCBLENDALPHA = 207,  /* SRC blend factor for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
    D3DRS_DESTBLENDALPHA = 208,  /* DST blend factor for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
    D3DRS_BLENDOPALPHA = 209,  /* Blending operation for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */


    D3DRS_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// Maximum number of simultaneous render targets D3D supports
//#define D3D_MAX_SIMULTANEOUS_RENDERTARGETS 4

// Values for material source
typedef enum D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL = 0,            // Color from material is used
    D3DMCS_COLOR1 = 1,            // Diffuse vertex color is used
    D3DMCS_COLOR2 = 2,            // Specular vertex color is used
    D3DMCS_FORCE_DWORD = 0x7fffffff,   // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;

// Bias to apply to the texture coordinate set to apply a wrap to.
//#define D3DRENDERSTATE_WRAPBIAS                 128UL

/* Flags to construct the WRAP render states */
typedef enum D3D9WrapRenderStates
{
     D3DWRAP_U  = 0x00000001,
     D3DWRAP_V  = 0x00000002,
     D3DWRAP_W  = 0x00000004 
} D3D9WrapRenderStates;

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
typedef enum D3D9WrapCoords
{
     D3DWRAPCOORD_0 = 0x00000001,    // same as D3DWRAP_U
     D3DWRAPCOORD_1 = 0x00000002,    // same as D3DWRAP_V
     D3DWRAPCOORD_2 = 0x00000004,    // same as D3DWRAP_W
     D3DWRAPCOORD_3 = 0x00000008 
} D3D9WrapCoords;

/* Flags to construct D3DRS_COLORWRITEENABLE */
typedef enum D3D9ColorWriteColors
{
     D3DCOLORWRITEENABLE_RED = 1, //(1L<<0),
     D3DCOLORWRITEENABLE_GREEN = 2, //(1L<<1),
     D3DCOLORWRITEENABLE_BLUE = 4, //(1L<<2),
     D3DCOLORWRITEENABLE_ALPHA = 8 //(1L<<3)
} D3D9ColorWriteColors;
/*
 * State enumerants for per-stage processing of fixed function pixel processing
 * Two of these affect fixed function vertex processing as well: TEXTURETRANSFORMFLAGS and TEXCOORDINDEX.
 */
typedef enum D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP = 1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
    D3DTSS_COLORARG1 = 2, /* D3DTA_* (texture arg) */
    D3DTSS_COLORARG2 = 3, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAOP = 4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
    D3DTSS_ALPHAARG1 = 5, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAARG2 = 6, /* D3DTA_* (texture arg) */
    D3DTSS_BUMPENVMAT00 = 7, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT01 = 8, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT10 = 9, /* float (bump mapping matrix) */
    D3DTSS_BUMPENVMAT11 = 10, /* float (bump mapping matrix) */
    D3DTSS_TEXCOORDINDEX = 11, /* identifies which set of texture coordinates index this texture */
    D3DTSS_BUMPENVLSCALE = 22, /* float scale for bump map luminance */
    D3DTSS_BUMPENVLOFFSET = 23, /* float offset for bump map luminance */
    D3DTSS_TEXTURETRANSFORMFLAGS = 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */
    D3DTSS_COLORARG0 = 26, /* D3DTA_* third arg for triadic ops */
    D3DTSS_ALPHAARG0 = 27, /* D3DTA_* third arg for triadic ops */
    D3DTSS_RESULTARG = 28, /* D3DTA_* arg for result (CURRENT or TEMP) */
    D3DTSS_CONSTANT = 32, /* Per-stage constant D3DTA_CONSTANT */


    D3DTSS_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURESTAGESTATETYPE;

/*
 * State enumerants for per-sampler texture processing.
 */
typedef enum D3DSAMPLERSTATETYPE
{
    D3DSAMP_ADDRESSU = 1,  /* D3DTEXTUREADDRESS for U coordinate */
    D3DSAMP_ADDRESSV = 2,  /* D3DTEXTUREADDRESS for V coordinate */
    D3DSAMP_ADDRESSW = 3,  /* D3DTEXTUREADDRESS for W coordinate */
    D3DSAMP_BORDERCOLOR = 4,  /* D3DCOLOR */
    D3DSAMP_MAGFILTER = 5,  /* D3DTEXTUREFILTER filter to use for magnification */
    D3DSAMP_MINFILTER = 6,  /* D3DTEXTUREFILTER filter to use for minification */
    D3DSAMP_MIPFILTER = 7,  /* D3DTEXTUREFILTER filter to use between mipmaps during minification */
    D3DSAMP_MIPMAPLODBIAS = 8,  /* float Mipmap LOD bias */
    D3DSAMP_MAXMIPLEVEL = 9,  /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
    D3DSAMP_MAXANISOTROPY = 10, /* DWORD maximum anisotropy */
    D3DSAMP_SRGBTEXTURE = 11, /* Default = 0 (which means Gamma 1.0,
                                   no correction required.) else correct for
                                   Gamma = 2.2 */
    D3DSAMP_ELEMENTINDEX = 12, /* When multi-element texture is assigned to sampler, this
                                    indicates which element index to use.  Default = 0.  */
    D3DSAMP_DMAPOFFSET = 13, /* Offset in vertices in the pre-sampled displacement map.
                                    Only valid for D3DDMAPSAMPLER sampler  */
    D3DSAMP_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DSAMPLERSTATETYPE;

/* Special sampler which is used in the tesselator */
//#define D3DDMAPSAMPLER 256

// Samplers used in vertex shaders
//#define D3DVERTEXTEXTURESAMPLER0 (D3DDMAPSAMPLER+1)
//#define D3DVERTEXTEXTURESAMPLER1 (D3DDMAPSAMPLER+2)
//#define D3DVERTEXTEXTURESAMPLER2 (D3DDMAPSAMPLER+3)
//#define D3DVERTEXTEXTURESAMPLER3 (D3DDMAPSAMPLER+4)

// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
typedef enum D3D9TextCoordIndexFlags
{
     D3DTSS_TCI_PASSTHRU = 0x00000000,
     D3DTSS_TCI_CAMERASPACENORMAL = 0x00010000,
     D3DTSS_TCI_CAMERASPACEPOSITION = 0x00020000,
     D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR = 0x00030000,
     D3DTSS_TCI_SPHEREMAP = 0x00040000
} D3D9TextCoordIndexFlags;
/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DTSS.
 */
typedef enum D3DTEXTUREOP
{
    // Control
    D3DTOP_DISABLE = 1,      // disables stage
    D3DTOP_SELECTARG1 = 2,      // the default
    D3DTOP_SELECTARG2 = 3,

    // Modulate
    D3DTOP_MODULATE = 4,      // multiply args together
    D3DTOP_MODULATE2X = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X = 6,      // multiply and  2 bits

    // Add
    D3DTOP_ADD = 7,   // add arguments together
    D3DTOP_ADDSIGNED = 8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X = 9,   // as above but left  1 bit
    D3DTOP_SUBTRACT = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH = 11,   // add 2 args, subtract product
    // Arg1 + Arg2 - Arg1*Arg2
    // = Arg1 + (1-Arg1)*Arg2

// Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
D3DTOP_BLENDDIFFUSEALPHA = 12, // iterated alpha
D3DTOP_BLENDTEXTUREALPHA = 13, // texture alpha
D3DTOP_BLENDFACTORALPHA = 14, // alpha from D3DRS_TEXTUREFACTOR

// Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
D3DTOP_BLENDTEXTUREALPHAPM = 15, // texture alpha
D3DTOP_BLENDCURRENTALPHA = 16, // by alpha of current color

// Specular mapping
D3DTOP_PREMODULATE = 17,     // modulate with next texture before use
D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
// COLOROP only
D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
// COLOROP only
D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
// COLOROP only
D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
// COLOROP only

// Bump mapping
D3DTOP_BUMPENVMAP = 22, // per pixel env map perturbation
D3DTOP_BUMPENVMAPLUMINANCE = 23, // with luminance channel

// This can do either diffuse or specular bump mapping with correct input.
// Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
// where each component has been scaled and offset to make it signed.
// The result is replicated into all four (including alpha) channels.
// This is a valid COLOROP only.
D3DTOP_DOTPRODUCT3 = 24,

// Triadic ops
D3DTOP_MULTIPLYADD = 25, // Arg0 + Arg1*Arg2
D3DTOP_LERP = 26, // (Arg0)*Arg1 + (1-Arg0)*Arg2

D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
 * operations set in texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum D3D9TextureBlendOpFlags
{
     D3DTA_SELECTMASK = 0x0000000f,  // mask for arg selector
     D3DTA_DIFFUSE = 0x00000000,  // select diffuse color (read only)
     D3DTA_CURRENT = 0x00000001, // select stage destination register (read/write)
     D3DTA_TEXTURE = 0x00000002,  // select texture color (read only)
     D3DTA_TFACTOR = 0x00000003,  // select D3DRS_TEXTUREFACTOR (read only)
     D3DTA_SPECULAR = 0x00000004,  // select specular color (read only)
     D3DTA_TEMP = 0x00000005,  // select temporary register color (read/write)
     D3DTA_CONSTANT = 0x00000006,  // select texture stage constant
     D3DTA_COMPLEMENT = 0x00000010,  // take 1.0 - x (read modifier)
     D3DTA_ALPHAREPLICATE = 0x00000020  // replicate alpha to color components (read modifier)
} D3D9TextureBlendOpFlags;
 //
 // Values for D3DSAMP_***FILTER texture stage states
 //
typedef enum D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE = 0,    // filtering disabled (valid for mip filter only)
    D3DTEXF_POINT = 1,    // nearest
    D3DTEXF_LINEAR = 2,    // linear interpolation
    D3DTEXF_ANISOTROPIC = 3,    // anisotropic
    D3DTEXF_PYRAMIDALQUAD = 6,    // 4-sample tent
    D3DTEXF_GAUSSIANQUAD = 7,    // 4-sample gaussian
    /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DTEXF_CONVOLUTIONMONO = 8,    // Convolution filter for monochrome textures

//#endif // !D3D_DISABLE_9EX
    /* -- D3D9Ex only */
    D3DTEXF_FORCE_DWORD = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREFILTERTYPE;

/* Bits for Flags in ProcessVertices call */

typedef enum D3D9ProcessVerticiesFlags
{
  D3DPV_DONOTCOPYDATA = 1 //(1 << 0)
} D3D9ProcessVerticiesFlags;
//-------------------------------------------------------------------

// Flexible vertex format bits
//
typedef enum D3D9VertexFormatBits
{
    D3DFVF_RESERVED0        = 0x001,
    D3DFVF_POSITION_MASK    = 0x400E,
    D3DFVF_XYZ              = 0x002,
    D3DFVF_XYZRHW           = 0x004,
    D3DFVF_XYZB1            = 0x006,
    D3DFVF_XYZB2            = 0x008,
    D3DFVF_XYZB3            = 0x00a,
    D3DFVF_XYZB4            = 0x00c,
    D3DFVF_XYZB5            = 0x00e,
    D3DFVF_XYZW             = 0x4002,

    D3DFVF_NORMAL           = 0x010,
    D3DFVF_PSIZE            = 0x020,
    D3DFVF_DIFFUSE          = 0x040,
    D3DFVF_SPECULAR         = 0x080,

    D3DFVF_TEXCOUNT_MASK    = 0xf00,
    D3DFVF_TEXCOUNT_SHIFT   = 8,
    D3DFVF_TEX0             = 0x000,
    D3DFVF_TEX1             = 0x100,
    D3DFVF_TEX2             = 0x200,
    D3DFVF_TEX3             = 0x300,
    D3DFVF_TEX4             = 0x400,
    D3DFVF_TEX5             = 0x500,
    D3DFVF_TEX6             = 0x600,
    D3DFVF_TEX7             = 0x700,
    D3DFVF_TEX8             = 0x800,

    D3DFVF_LASTBETA_UBYTE4   = 0x1000,
    D3DFVF_LASTBETA_D3DCOLOR = 0x8000,

    D3DFVF_RESERVED2         = 0x6000  // 2 reserved bits
} D3D9VertexFormatBits;
//---------------------------------------------------------------------
// Vertex Shaders
//

// Vertex shader declaration

// Vertex element semantics
//
typedef enum D3DDECLUSAGE
{
    D3DDECLUSAGE_POSITION = 0,
    D3DDECLUSAGE_BLENDWEIGHT,   // 1
    D3DDECLUSAGE_BLENDINDICES,  // 2
    D3DDECLUSAGE_NORMAL,        // 3
    D3DDECLUSAGE_PSIZE,         // 4
    D3DDECLUSAGE_TEXCOORD,      // 5
    D3DDECLUSAGE_TANGENT,       // 6
    D3DDECLUSAGE_BINORMAL,      // 7
    D3DDECLUSAGE_TESSFACTOR,    // 8
    D3DDECLUSAGE_POSITIONT,     // 9
    D3DDECLUSAGE_COLOR,         // 10
    D3DDECLUSAGE_FOG,           // 11
    D3DDECLUSAGE_DEPTH,         // 12
    D3DDECLUSAGE_SAMPLE,        // 13
} D3DDECLUSAGE;

//#define MAXD3DDECLUSAGE         D3DDECLUSAGE_SAMPLE
//#define MAXD3DDECLUSAGEINDEX    15
//#define MAXD3DDECLLENGTH        64 // does not include "end" marker vertex element

typedef enum D3DDECLMETHOD
{
    D3DDECLMETHOD_DEFAULT = 0,
    D3DDECLMETHOD_PARTIALU,
    D3DDECLMETHOD_PARTIALV,
    D3DDECLMETHOD_CROSSUV,    // Normal
    D3DDECLMETHOD_UV,
    D3DDECLMETHOD_LOOKUP,               // Lookup a displacement map
    D3DDECLMETHOD_LOOKUPPRESAMPLED,     // Lookup a pre-sampled displacement map
} D3DDECLMETHOD;

//#define MAXD3DDECLMETHOD D3DDECLMETHOD_LOOKUPPRESAMPLED

// Declarations for _Type fields
//
typedef enum D3DDECLTYPE
{
    D3DDECLTYPE_FLOAT1 = 0,  // 1D float expanded to (value, 0., 0., 1.)
    D3DDECLTYPE_FLOAT2 = 1,  // 2D float expanded to (value, value, 0., 1.)
    D3DDECLTYPE_FLOAT3 = 2,  // 3D float expanded to (value, value, value, 1.)
    D3DDECLTYPE_FLOAT4 = 3,  // 4D float
    D3DDECLTYPE_D3DCOLOR = 4,  // 4D packed unsigned bytes mapped to 0. to 1. range
    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
    D3DDECLTYPE_UBYTE4 = 5,  // 4D unsigned byte
    D3DDECLTYPE_SHORT2 = 6,  // 2D signed short expanded to (value, value, 0., 1.)
    D3DDECLTYPE_SHORT4 = 7,  // 4D signed short

    // The following types are valid only with vertex shaders >= 2.0


    D3DDECLTYPE_UBYTE4N = 8,  // Each of 4 bytes is normalized by dividing to 255.0
    D3DDECLTYPE_SHORT2N = 9,  // 2D signed short normalized (v[0]/32767.0,v[1]/32767.0,0,1)
    D3DDECLTYPE_SHORT4N = 10,  // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
    D3DDECLTYPE_USHORT2N = 11,  // 2D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,0,1)
    D3DDECLTYPE_USHORT4N = 12,  // 4D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,v[2]/65535.0,v[3]/65535.0)
    D3DDECLTYPE_UDEC3 = 13,  // 3D unsigned 10 10 10 format expanded to (value, value, value, 1)
    D3DDECLTYPE_DEC3N = 14,  // 3D signed 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1)
    D3DDECLTYPE_FLOAT16_2 = 15,  // Two 16-bit floating point values, expanded to (value, value, 0, 1)
    D3DDECLTYPE_FLOAT16_4 = 16,  // Four 16-bit floating point values
    D3DDECLTYPE_UNUSED = 17,  // When the type field in a decl is unused.
} D3DDECLTYPE;

//#define MAXD3DDECLTYPE      D3DDECLTYPE_UNUSED

typedef struct D3DVERTEXELEMENT9
{
    WORD    Stream;     // Stream index
    WORD    Offset;     // Offset in the stream in bytes
    BYTE    Type;       // Data type
    BYTE    Method;     // Processing method
    BYTE    Usage;      // Semantics
    BYTE    UsageIndex; // Semantic index
} D3DVERTEXELEMENT9;

// This is used to initialize the last vertex element in a vertex declaration
// array
//
//#define D3DDECL_END() {0xFF,0,D3DDECLTYPE_UNUSED,0,0,0}
//
//// Maximum supported number of texture coordinate sets
//#define D3DDP_MAXTEXCOORD   8

//---------------------------------------------------------------------
// Values for IDirect3DDevice9::SetStreamSourceFreq's Setting parameter
//---------------------------------------------------------------------
typedef enum D3D9StreamSrcFrqSettings
{
     D3DSTREAMSOURCE_INDEXEDDATA  = 0x40000000, //(1<<30)
     D3DSTREAMSOURCE_INSTANCEDATA = 0x80000000, //(2<<30)
} D3D9StreamSrcFrqSettings;


//---------------------------------------------------------------------
//
// The internal format of Pixel Shader (PS) & Vertex Shader (VS)
// Instruction Tokens is defined in the Direct3D Device Driver Kit
//
//---------------------------------------------------------------------

//
// Instruction Token Bit Definitions
//
//#define D3DSI_OPCODE_MASK       0x0000FFFF
//
//#define D3DSI_INSTLENGTH_MASK   0x0F000000
//#define D3DSI_INSTLENGTH_SHIFT  24

typedef enum D3DSHADER_INSTRUCTION_OPCODE_TYPE
{
    D3DSIO_NOP = 0,
    D3DSIO_MOV,
    D3DSIO_ADD,
    D3DSIO_SUB,
    D3DSIO_MAD,
    D3DSIO_MUL,
    D3DSIO_RCP,
    D3DSIO_RSQ,
    D3DSIO_DP3,
    D3DSIO_DP4,
    D3DSIO_MIN,
    D3DSIO_MAX,
    D3DSIO_SLT,
    D3DSIO_SGE,
    D3DSIO_EXP,
    D3DSIO_LOG,
    D3DSIO_LIT,
    D3DSIO_DST,
    D3DSIO_LRP,
    D3DSIO_FRC,
    D3DSIO_M4x4,
    D3DSIO_M4x3,
    D3DSIO_M3x4,
    D3DSIO_M3x3,
    D3DSIO_M3x2,
    D3DSIO_CALL,
    D3DSIO_CALLNZ,
    D3DSIO_LOOP,
    D3DSIO_RET,
    D3DSIO_ENDLOOP,
    D3DSIO_LABEL,
    D3DSIO_DCL,
    D3DSIO_POW,
    D3DSIO_CRS,
    D3DSIO_SGN,
    D3DSIO_ABS,
    D3DSIO_NRM,
    D3DSIO_SINCOS,
    D3DSIO_REP,
    D3DSIO_ENDREP,
    D3DSIO_IF,
    D3DSIO_IFC,
    D3DSIO_ELSE,
    D3DSIO_ENDIF,
    D3DSIO_BREAK,
    D3DSIO_BREAKC,
    D3DSIO_MOVA,
    D3DSIO_DEFB,
    D3DSIO_DEFI,

    D3DSIO_TEXCOORD = 64,
    D3DSIO_TEXKILL,
    D3DSIO_TEX,
    D3DSIO_TEXBEM,
    D3DSIO_TEXBEML,
    D3DSIO_TEXREG2AR,
    D3DSIO_TEXREG2GB,
    D3DSIO_TEXM3x2PAD,
    D3DSIO_TEXM3x2TEX,
    D3DSIO_TEXM3x3PAD,
    D3DSIO_TEXM3x3TEX,
    D3DSIO_RESERVED0,
    D3DSIO_TEXM3x3SPEC,
    D3DSIO_TEXM3x3VSPEC,
    D3DSIO_EXPP,
    D3DSIO_LOGP,
    D3DSIO_CND,
    D3DSIO_DEF,
    D3DSIO_TEXREG2RGB,
    D3DSIO_TEXDP3TEX,
    D3DSIO_TEXM3x2DEPTH,
    D3DSIO_TEXDP3,
    D3DSIO_TEXM3x3,
    D3DSIO_TEXDEPTH,
    D3DSIO_CMP,
    D3DSIO_BEM,
    D3DSIO_DP2ADD,
    D3DSIO_DSX,
    D3DSIO_DSY,
    D3DSIO_TEXLDD,
    D3DSIO_SETP,
    D3DSIO_TEXLDL,
    D3DSIO_BREAKP,

    D3DSIO_PHASE = 0xFFFD,
    D3DSIO_COMMENT = 0xFFFE,
    D3DSIO_END = 0xFFFF,

    D3DSIO_FORCE_DWORD = 0x7fffffff,   // force 32-bit size enum
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;

//---------------------------------------------------------------------
// Use these constants with D3DSIO_SINCOS macro as SRC2, SRC3
//
//#define D3DSINCOSCONST1 -1.5500992e-006f, -2.1701389e-005f,  0.0026041667f, 0.00026041668f
//#define D3DSINCOSCONST2 -0.020833334f, -0.12500000f, 1.0f, 0.50000000f
//
////---------------------------------------------------------------------
//// Co-Issue Instruction Modifier - if set then this instruction is to be
//// issued in parallel with the previous instruction(s) for which this bit
//// is not set.
////
//#define D3DSI_COISSUE           0x40000000
//
////---------------------------------------------------------------------
//// Opcode specific controls
//
//#define D3DSP_OPCODESPECIFICCONTROL_MASK  0x00ff0000
//#define D3DSP_OPCODESPECIFICCONTROL_SHIFT 16
//
//// ps_2_0 texld controls
//#define D3DSI_TEXLD_PROJECT (0x01 << D3DSP_OPCODESPECIFICCONTROL_SHIFT)
//#define D3DSI_TEXLD_BIAS    (0x02 << D3DSP_OPCODESPECIFICCONTROL_SHIFT)

// Comparison for dynamic conditional instruction opcodes (i.e. if, breakc)
typedef enum D3DSHADER_COMPARISON
{
    // < = >
    D3DSPC_RESERVED0 = 0, // 0 0 0
    D3DSPC_GT = 1, // 0 0 1
    D3DSPC_EQ = 2, // 0 1 0
    D3DSPC_GE = 3, // 0 1 1
    D3DSPC_LT = 4, // 1 0 0
    D3DSPC_NE = 5, // 1 0 1
    D3DSPC_LE = 6, // 1 1 0
    D3DSPC_RESERVED1 = 7  // 1 1 1
} D3DSHADER_COMPARISON;

//// Comparison is part of instruction opcode token:
//#define D3DSHADER_COMPARISON_SHIFT D3DSP_OPCODESPECIFICCONTROL_SHIFT
//#define D3DSHADER_COMPARISON_MASK  (0x7<<D3DSHADER_COMPARISON_SHIFT)
//
////---------------------------------------------------------------------
//// Predication flags on instruction token
//#define D3DSHADER_INSTRUCTION_PREDICATED    (0x1 << 28)

//---------------------------------------------------------------------
// DCL Info Token Controls

// For dcl info tokens requiring a semantic (usage + index)
//#define D3DSP_DCL_USAGE_SHIFT 0
//#define D3DSP_DCL_USAGE_MASK  0x0000000f
//
//#define D3DSP_DCL_USAGEINDEX_SHIFT 16
//#define D3DSP_DCL_USAGEINDEX_MASK  0x000f0000
//
//// DCL pixel shader sampler info token.
//#define D3DSP_TEXTURETYPE_SHIFT 27
//#define D3DSP_TEXTURETYPE_MASK  0x78000000

typedef enum D3DSAMPLER_TEXTURE_TYPE
{
    D3DSTT_UNKNOWN = 0, // 0 << D3DSP_TEXTURETYPE_SHIFT, // uninitialized value
    D3DSTT_2D = 0x10000000, //2 << D3DSP_TEXTURETYPE_SHIFT, // dcl_2d s# (for declaring a 2-D texture)
    D3DSTT_CUBE = 0x18000000, // 3 << D3DSP_TEXTURETYPE_SHIFT, // dcl_cube s# (for declaring a cube texture)
    D3DSTT_VOLUME = 0x20000000, //4 << D3DSP_TEXTURETYPE_SHIFT, // dcl_volume s# (for declaring a volume texture)
    D3DSTT_FORCE_DWORD = 0x7fffffff,      // force 32-bit size enum
} D3DSAMPLER_TEXTURE_TYPE;

//---------------------------------------------------------------------
// Parameter Token Bit Definitions
//
//#define D3DSP_REGNUM_MASK       0x000007FF

// destination parameter write mask
typedef enum D3D9ParamWriteMask
{
    D3DSP_WRITEMASK_0       = 0x00010000,  // Component 0 (X;Red)
    D3DSP_WRITEMASK_1       = 0x00020000,  // Component 1 (Y;Green)
    D3DSP_WRITEMASK_2       = 0x00040000,  // Component 2 (Z;Blue)
    D3DSP_WRITEMASK_3       = 0x00080000,  // Component 3 (W;Alpha)
    D3DSP_WRITEMASK_ALL     = 0x000F0000,  // All Components
} D3D9ParamWriteMask;

typedef enum D3D9ParamModifiers
{
    // destination parameter modifiers
    D3DSP_DSTMOD_SHIFT = 20,
    D3DSP_DSTMOD_MASK       = 0x00F00000,

// Bit masks for destination parameter modifiers
       D3DSPDM_NONE               = 0, // (0<<D3DSP_DSTMOD_SHIFT), // nop
       D3DSPDM_SATURATE           = 1048576, // (1<<D3DSP_DSTMOD_SHIFT), // clamp to 0. to 1. range
       D3DSPDM_PARTIALPRECISION   = 2097152, // (2<<D3DSP_DSTMOD_SHIFT), // Partial precision hint
       D3DSPDM_MSAMPCENTROID      = 4194304 // (4<<D3DSP_DSTMOD_SHIFT) // Relevant to multisampling only:
                                                                //      When the pixel center is not covered, sample
                                                                //      attribute or compute gradients/LOD
                                                                //      using multisample "centroid" location.
                                                                //      "Centroid" is some location within the covered
                                                                //      region of the pixel.
} D3D9ParamModifiers;

typedef enum D3D9DestinationParam
{
// destination parameter 
    D3DSP_DSTSHIFT_SHIFT = 24,
    D3DSP_DSTSHIFT_MASK     = 0x0F000000
} D3D9DestinationParam;
// destination/source parameter register type

typedef enum D3D9DSourceParam
{
    D3DSP_REGTYPE_SHIFT = 28,
    D3DSP_REGTYPE_SHIFT2 = 8,
    D3DSP_REGTYPE_MASK      = 0x70000000,
    D3DSP_REGTYPE_MASK2     = 0x00001800
} D3D9DSourceParam;


typedef enum D3DSHADER_PARAM_REGISTER_TYPE
{
    D3DSPR_TEMP = 0, // Temporary Register File
    D3DSPR_INPUT = 1, // Input Register File
    D3DSPR_CONST = 2, // Constant Register File
    D3DSPR_ADDR = 3, // Address Register (VS)
    D3DSPR_TEXTURE = 3, // Texture Register File (PS)
    D3DSPR_RASTOUT = 4, // Rasterizer Register File
    D3DSPR_ATTROUT = 5, // Attribute Output Register File
    D3DSPR_TEXCRDOUT = 6, // Texture Coordinate Output Register File
    D3DSPR_OUTPUT = 6, // Output register file for VS3.0+
    D3DSPR_CONSTINT = 7, // Constant Integer Vector Register File
    D3DSPR_COLOROUT = 8, // Color Output Register File
    D3DSPR_DEPTHOUT = 9, // Depth Output Register File
    D3DSPR_SAMPLER = 10, // Sampler State Register File
    D3DSPR_CONST2 = 11, // Constant Register File  2048 - 4095
    D3DSPR_CONST3 = 12, // Constant Register File  4096 - 6143
    D3DSPR_CONST4 = 13, // Constant Register File  6144 - 8191
    D3DSPR_CONSTBOOL = 14, // Constant Boolean register file
    D3DSPR_LOOP = 15, // Loop counter register file
    D3DSPR_TEMPFLOAT16 = 16, // 16-bit float temp register file
    D3DSPR_MISCTYPE = 17, // Miscellaneous (single) registers.
    D3DSPR_LABEL = 18, // Label
    D3DSPR_PREDICATE = 19, // Predicate register
    D3DSPR_FORCE_DWORD = 0x7fffffff,         // force 32-bit size enum
} D3DSHADER_PARAM_REGISTER_TYPE;

// The miscellaneous register file (D3DSPR_MISCTYPES)
// contains register types for which there is only ever one
// register (i.e. the register # is not needed).
// Rather than use up additional register types for such
// registers, they are defined
// as particular offsets into the misc. register file:
typedef enum D3DSHADER_MISCTYPE_OFFSETS
{
    D3DSMO_POSITION = 0, // Input position x,y,z,rhw (PS)
    D3DSMO_FACE = 1, // Floating point primitive area (PS)
} D3DSHADER_MISCTYPE_OFFSETS;

// Register offsets in the Rasterizer Register File
//
typedef enum D3DVS_RASTOUT_OFFSETS
{
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD = 0x7fffffff,         // force 32-bit size enum
} D3DVS_RASTOUT_OFFSETS;

// Source operand addressing modes

//#define D3DVS_ADDRESSMODE_SHIFT 13
//#define D3DVS_ADDRESSMODE_MASK  (1 << D3DVS_ADDRESSMODE_SHIFT)

typedef enum D3DVS_ADDRESSMODE_TYPE
{
    D3DVS_ADDRMODE_ABSOLUTE = 0, //(0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE = 8192, //(1 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVS_ADDRESSMODE_TYPE;

//#define D3DSHADER_ADDRESSMODE_SHIFT 13
//#define D3DSHADER_ADDRESSMODE_MASK  (1 << D3DSHADER_ADDRESSMODE_SHIFT)

typedef enum D3DSHADER_ADDRESSMODE_TYPE
{
    D3DSHADER_ADDRMODE_ABSOLUTE = 0, //(0 << D3DSHADER_ADDRESSMODE_SHIFT),
    D3DSHADER_ADDRMODE_RELATIVE = 8192, //(1 << D3DSHADER_ADDRESSMODE_SHIFT),
    D3DSHADER_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DSHADER_ADDRESSMODE_TYPE;

//typedef enum D3D9SwizzleShift
//{
//// Source operand swizzle definitions
////
//    D3DVS_SWIZZLE_SHIFT = 16
//    D3DVS_SWIZZLE_MASK = 0x00FF0000
//
//// The following bits define where to take component X from:
//
//    D3DVS_X_X = (0 << D3DVS_SWIZZLE_SHIFT)
//    D3DVS_X_Y = (1 << D3DVS_SWIZZLE_SHIFT)
//    D3DVS_X_Z = (2 << D3DVS_SWIZZLE_SHIFT)
//    D3DVS_X_W = (3 << D3DVS_SWIZZLE_SHIFT)
//
//// The following bits define where to take component Y from:
//
//    D3DVS_Y_X = (0 << (D3DVS_SWIZZLE_SHIFT + 2))
//    D3DVS_Y_Y = (1 << (D3DVS_SWIZZLE_SHIFT + 2))
//    D3DVS_Y_Z = (2 << (D3DVS_SWIZZLE_SHIFT + 2))
//    D3DVS_Y_W = (3 << (D3DVS_SWIZZLE_SHIFT + 2))
//
//// The following bits define where to take component Z from:
//
//    D3DVS_Z_X = (0 << (D3DVS_SWIZZLE_SHIFT + 4))
//    D3DVS_Z_Y = (1 << (D3DVS_SWIZZLE_SHIFT + 4))
//    D3DVS_Z_Z = (2 << (D3DVS_SWIZZLE_SHIFT + 4))
//    D3DVS_Z_W = (3 << (D3DVS_SWIZZLE_SHIFT + 4))
//
//// The following bits define where to take component W from:
//
//    D3DVS_W_X = (0 << (D3DVS_SWIZZLE_SHIFT + 6))
//    D3DVS_W_Y = (1 << (D3DVS_SWIZZLE_SHIFT + 6))
//    D3DVS_W_Z = (2 << (D3DVS_SWIZZLE_SHIFT + 6))
//    D3DVS_W_W = (3 << (D3DVS_SWIZZLE_SHIFT + 6))
//
//// Value when there is no swizzle (X is taken from X, Y is taken from Y,
//// Z is taken from Z, W is taken from W
////
//    D3DVS_NOSWIZZLE = (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)
//
//// source parameter swizzle
//    D3DSP_SWIZZLE_SHIFT = 16
//    D3DSP_SWIZZLE_MASK = 0x00FF0000
//
//    D3DSP_NOSWIZZLE = ((0 << (D3DSP_SWIZZLE_SHIFT + 0)) |   (1 << (D3DSP_SWIZZLE_SHIFT + 2)) |  (2 << (D3DSP_SWIZZLE_SHIFT + 4)) |   (3 << (D3DSP_SWIZZLE_SHIFT + 6)))
//
//    // pixel-shader swizzle ops
//    D3DSP_REPLICATERED = ((0 << (D3DSP_SWIZZLE_SHIFT + 0)) |   (0 << (D3DSP_SWIZZLE_SHIFT + 2)) |  (0 << (D3DSP_SWIZZLE_SHIFT + 4)) |  (0 << (D3DSP_SWIZZLE_SHIFT + 6)))
//
//    D3DSP_REPLICATEGREEN = ((1 << (D3DSP_SWIZZLE_SHIFT + 0)) |   (1 << (D3DSP_SWIZZLE_SHIFT + 2)) |   (1 << (D3DSP_SWIZZLE_SHIFT + 4)) |   (1 << (D3DSP_SWIZZLE_SHIFT + 6)))
//
//    D3DSP_REPLICATEBLUE = ((2 << (D3DSP_SWIZZLE_SHIFT + 0)) |  (2 << (D3DSP_SWIZZLE_SHIFT + 2)) |  (2 << (D3DSP_SWIZZLE_SHIFT + 4)) |  (2 << (D3DSP_SWIZZLE_SHIFT + 6)))
//
//    D3DSP_REPLICATEALPHA = ((3 << (D3DSP_SWIZZLE_SHIFT + 0)) |  (3 << (D3DSP_SWIZZLE_SHIFT + 2)) |  (3 << (D3DSP_SWIZZLE_SHIFT + 4)) |  (3 << (D3DSP_SWIZZLE_SHIFT + 6)))
//} D3D9SwizzleShift;
    // source parameter modifiers

    typedef enum D3DSHADER_PARAM_SRCMOD_TYPE
{
     D3DSP_SRCMOD_SHIFT    =  24,
     D3DSP_SRCMOD_MASK      = 0x0F000000,
    D3DSPSM_NONE = 0, //0 << D3DSP_SRCMOD_SHIFT, // nop
    D3DSPSM_NEG = 0x1000000, //1 << D3DSP_SRCMOD_SHIFT, // negate
    D3DSPSM_BIAS = 0x2000000, //2 << D3DSP_SRCMOD_SHIFT, // bias
    D3DSPSM_BIASNEG = 0x3000000, //3 << D3DSP_SRCMOD_SHIFT, // bias and negate
    D3DSPSM_SIGN = 0x4000000, //4 << D3DSP_SRCMOD_SHIFT, // sign
    D3DSPSM_SIGNNEG = 0x5000000, //5 << D3DSP_SRCMOD_SHIFT, // sign and negate
    D3DSPSM_COMP = 0x6000000, //6 << D3DSP_SRCMOD_SHIFT, // complement
    D3DSPSM_X2 = 0x7000000, //7 << D3DSP_SRCMOD_SHIFT, // *2
    D3DSPSM_X2NEG = 0x8000000, //8 << D3DSP_SRCMOD_SHIFT, // *2 and negate
    D3DSPSM_DZ = 0x9000000, //9 << D3DSP_SRCMOD_SHIFT, // divide through by z component
    D3DSPSM_DW = 0xA000000, //10 << D3DSP_SRCMOD_SHIFT, // divide through by w component
    D3DSPSM_ABS = 0xB000000, //11 << D3DSP_SRCMOD_SHIFT, // abs()
    D3DSPSM_ABSNEG = 0xC000000, //12 << D3DSP_SRCMOD_SHIFT, // -abs()
    D3DSPSM_NOT = 0xD000000, //13 << D3DSP_SRCMOD_SHIFT, // for predicate register: "!p0"
    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
} D3DSHADER_PARAM_SRCMOD_TYPE;

// Source or dest token bits [15:14]:
// destination parameter modifiers

typedef enum D3DSHADER_MIN_PRECISION
{
     D3DSP_MIN_PRECISION_SHIFT = 14,
     D3DSP_MIN_PRECISION_MASK = 0x0000C000,
   D3DMP_DEFAULT = 0, // Default precision for the shader model
    D3DMP_16 = 1, // 16 bit per component
    D3DMP_2_8 = 2, // 10 bits (2.8) per component
} D3DSHADER_MIN_PRECISION;
// If the older D3DSPDM_PARTIALPRECISION is set,
// that is equivalent to the whole operation specifying
// D3DMP_16 (on all operands).  The two encodings are not 
// used together however.



//// pixel shader version token
//#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))
//
//// vertex shader version token
//#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))
//
//// extract major/minor from version cap
//#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
//#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)
//
//// destination/source parameter register type
//#define D3DSI_COMMENTSIZE_SHIFT     16
//#define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
//#define D3DSHADER_COMMENT(_DWordSize) \
//((((_DWordSize) << D3DSI_COMMENTSIZE_SHIFT)& D3DSI_COMMENTSIZE_MASK) | D3DSIO_COMMENT)
//
//// pixel/vertex shader end token
//#define D3DPS_END()  0x0000FFFF
//#define D3DVS_END()  0x0000FFFF


//---------------------------------------------------------------------

// High order surfaces
//
typedef enum D3DBASISTYPE
{
    D3DBASIS_BEZIER = 0,
    D3DBASIS_BSPLINE = 1,
    D3DBASIS_CATMULL_ROM = 2, /* In D3D8 this used to be D3DBASIS_INTERPOLATE */
    D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;

typedef enum D3DDEGREETYPE
{
    D3DDEGREE_LINEAR = 1,
    D3DDEGREE_QUADRATIC = 2,
    D3DDEGREE_CUBIC = 3,
    D3DDEGREE_QUINTIC = 5,
    D3DDEGREE_FORCE_DWORD = 0x7fffffff,
} D3DDEGREETYPE;

typedef enum D3DPATCHEDGESTYLE
{
    D3DPATCHEDGE_DISCRETE = 0,
    D3DPATCHEDGE_CONTINUOUS = 1,
    D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;

typedef enum D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL = 1, // capture all state
    D3DSBT_PIXELSTATE = 2, // capture pixel state
    D3DSBT_VERTEXSTATE = 3, // capture vertex state
    D3DSBT_FORCE_DWORD = 0x7fffffff,
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
//
typedef enum D3DVERTEXBLENDFLAGS
{
    D3DVBF_DISABLE = 0,     // Disable vertex blending
    D3DVBF_1WEIGHTS = 1,     // 2 matrix blending
    D3DVBF_2WEIGHTS = 2,     // 3 matrix blending
    D3DVBF_3WEIGHTS = 3,     // 4 matrix blending
    D3DVBF_TWEENING = 255,   // blending using D3DRS_TWEENFACTOR
    D3DVBF_0WEIGHTS = 256,   // one matrix is used with weight 1.0
    D3DVBF_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
} D3DVERTEXBLENDFLAGS;

typedef enum D3DTEXTURETRANSFORMFLAGS {
    D3DTTFF_DISABLE = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1 = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2 = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3 = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4 = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

//#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
//#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
//#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
//#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values
//
//#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
//#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
//#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
//#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


//---------------------------------------------------------------------

/* Direct3D9 Device types */
typedef enum D3DDEVTYPE
{
    D3DDEVTYPE_HAL = 1,
    D3DDEVTYPE_REF = 2,
    D3DDEVTYPE_SW = 3,

    D3DDEVTYPE_NULLREF = 4,

    D3DDEVTYPE_FORCE_DWORD = 0x7fffffff
} D3DDEVTYPE;

/* Multi-Sample buffer types */
typedef enum D3DMULTISAMPLE_TYPE
{
    D3DMULTISAMPLE_NONE = 0,
    D3DMULTISAMPLE_NONMASKABLE = 1,
    D3DMULTISAMPLE_2_SAMPLES = 2,
    D3DMULTISAMPLE_3_SAMPLES = 3,
    D3DMULTISAMPLE_4_SAMPLES = 4,
    D3DMULTISAMPLE_5_SAMPLES = 5,
    D3DMULTISAMPLE_6_SAMPLES = 6,
    D3DMULTISAMPLE_7_SAMPLES = 7,
    D3DMULTISAMPLE_8_SAMPLES = 8,
    D3DMULTISAMPLE_9_SAMPLES = 9,
    D3DMULTISAMPLE_10_SAMPLES = 10,
    D3DMULTISAMPLE_11_SAMPLES = 11,
    D3DMULTISAMPLE_12_SAMPLES = 12,
    D3DMULTISAMPLE_13_SAMPLES = 13,
    D3DMULTISAMPLE_14_SAMPLES = 14,
    D3DMULTISAMPLE_15_SAMPLES = 15,
    D3DMULTISAMPLE_16_SAMPLES = 16,

    D3DMULTISAMPLE_FORCE_DWORD = 0x7fffffff
} D3DMULTISAMPLE_TYPE;

/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *      C = Computed from other channels (typically on certain read operations)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D3DFMT_D16_LOCKABLE indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      D3DFMT_D32F_LOCKABLE indicates:
 *           - An IEEE 754 floating-point value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE and D3DFMT_D32F_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */
//#ifndef MAKEFOURCC
//#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
//((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) | \
//    ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24))
//#endif /* defined(MAKEFOURCC) */
//
//
//    typedef enum D3DFORMAT
//{
//    D3DFMT_UNKNOWN = 0,
//
//    D3DFMT_R8G8B8 = 20,
//    D3DFMT_A8R8G8B8 = 21,
//    D3DFMT_X8R8G8B8 = 22,
//    D3DFMT_R5G6B5 = 23,
//    D3DFMT_X1R5G5B5 = 24,
//    D3DFMT_A1R5G5B5 = 25,
//    D3DFMT_A4R4G4B4 = 26,
//    D3DFMT_R3G3B2 = 27,
//    D3DFMT_A8 = 28,
//    D3DFMT_A8R3G3B2 = 29,
//    D3DFMT_X4R4G4B4 = 30,
//    D3DFMT_A2B10G10R10 = 31,
//    D3DFMT_A8B8G8R8 = 32,
//    D3DFMT_X8B8G8R8 = 33,
//    D3DFMT_G16R16 = 34,
//    D3DFMT_A2R10G10B10 = 35,
//    D3DFMT_A16B16G16R16 = 36,
//
//    D3DFMT_A8P8 = 40,
//    D3DFMT_P8 = 41,
//
//    D3DFMT_L8 = 50,
//    D3DFMT_A8L8 = 51,
//    D3DFMT_A4L4 = 52,
//
//    D3DFMT_V8U8 = 60,
//    D3DFMT_L6V5U5 = 61,
//    D3DFMT_X8L8V8U8 = 62,
//    D3DFMT_Q8W8V8U8 = 63,
//    D3DFMT_V16U16 = 64,
//    D3DFMT_A2W10V10U10 = 67,
//
//    D3DFMT_UYVY = MAKEFOURCC('U', 'Y', 'V', 'Y'),
//    D3DFMT_R8G8_B8G8 = MAKEFOURCC('R', 'G', 'B', 'G'),
//    D3DFMT_YUY2 = MAKEFOURCC('Y', 'U', 'Y', '2'),
//    D3DFMT_G8R8_G8B8 = MAKEFOURCC('G', 'R', 'G', 'B'),
//    D3DFMT_DXT1 = MAKEFOURCC('D', 'X', 'T', '1'),
//    D3DFMT_DXT2 = MAKEFOURCC('D', 'X', 'T', '2'),
//    D3DFMT_DXT3 = MAKEFOURCC('D', 'X', 'T', '3'),
//    D3DFMT_DXT4 = MAKEFOURCC('D', 'X', 'T', '4'),
//    D3DFMT_DXT5 = MAKEFOURCC('D', 'X', 'T', '5'),
//
//    D3DFMT_D16_LOCKABLE = 70,
//    D3DFMT_D32 = 71,
//    D3DFMT_D15S1 = 73,
//    D3DFMT_D24S8 = 75,
//    D3DFMT_D24X8 = 77,
//    D3DFMT_D24X4S4 = 79,
//    D3DFMT_D16 = 80,
//
//    D3DFMT_D32F_LOCKABLE = 82,
//    D3DFMT_D24FS8 = 83,
//
//    /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)
//
//    /* Z-Stencil formats valid for CPU access */
//    D3DFMT_D32_LOCKABLE = 84,
//    D3DFMT_S8_LOCKABLE = 85,
//
//#endif // !D3D_DISABLE_9EX
//    /* -- D3D9Ex only */
//
//
//    D3DFMT_L16 = 81,
//
//    D3DFMT_VERTEXDATA = 100,
//    D3DFMT_INDEX16 = 101,
//    D3DFMT_INDEX32 = 102,
//
//    D3DFMT_Q16W16V16U16 = 110,
//
//    D3DFMT_MULTI2_ARGB8 = MAKEFOURCC('M', 'E', 'T', '1'),
//
//    // Floating point surface formats
//
//    // s10e5 formats (16-bits per channel)
//    D3DFMT_R16F = 111,
//    D3DFMT_G16R16F = 112,
//    D3DFMT_A16B16G16R16F = 113,
//
//    // IEEE s23e8 formats (32-bits per channel)
//    D3DFMT_R32F = 114,
//    D3DFMT_G32R32F = 115,
//    D3DFMT_A32B32G32R32F = 116,
//
//    D3DFMT_CxV8U8 = 117,
//
//    /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)
//
//    // Monochrome 1 bit per pixel format
//    D3DFMT_A1 = 118,
//
//    // 2.8 biased fixed point
//    D3DFMT_A2B10G10R10_XR_BIAS = 119,
//
//
//    // Binary format indicating that the data has no inherent type
//    D3DFMT_BINARYBUFFER = 199,
//
//#endif // !D3D_DISABLE_9EX
//    /* -- D3D9Ex only */
//
//
//    D3DFMT_FORCE_DWORD = 0x7fffffff
//} D3DFORMAT;

/* Display Modes */
typedef struct D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    D3DFORMAT       Format;
} D3DDISPLAYMODE;

/* Creation Parameters */
typedef struct D3DDEVICE_CREATION_PARAMETERS
{
    UINT            AdapterOrdinal;
    D3DDEVTYPE      DeviceType;
    LongPtr            hFocusWindow;
    DWORD           BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;


/* SwapEffects */
typedef enum D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD = 1,
    D3DSWAPEFFECT_FLIP = 2,
    D3DSWAPEFFECT_COPY = 3,

    /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)
    D3DSWAPEFFECT_OVERLAY = 4,
    D3DSWAPEFFECT_FLIPEX = 5,
//#endif // !D3D_DISABLE_9EX
    /* -- D3D9Ex only */

    D3DSWAPEFFECT_FORCE_DWORD = 0x7fffffff
} D3DSWAPEFFECT;

/* Pool types */
typedef enum D3DPOOL {
    D3DPOOL_DEFAULT = 0,
    D3DPOOL_MANAGED = 1,
    D3DPOOL_SYSTEMMEM = 2,
    D3DPOOL_SCRATCH = 3,

    D3DPOOL_FORCE_DWORD = 0x7fffffff
} D3DPOOL;


/* RefreshRate pre-defines */
//#define D3DPRESENT_RATE_DEFAULT         0x00000000


/* Resize Optional Parameters */
typedef struct D3DPRESENT_PARAMETERS
{
    UINT                BackBufferWidth;
    UINT                BackBufferHeight;
    D3DFORMAT           BackBufferFormat;
    UINT                BackBufferCount;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    DWORD               MultiSampleQuality;

    D3DSWAPEFFECT       SwapEffect;
    LongPtr                hDeviceWindow;
    BOOL                Windowed;
    BOOL                EnableAutoDepthStencil;
    D3DFORMAT           AutoDepthStencilFormat;
    DWORD               Flags;

    /* FullScreen_RefreshRateInHz must be zero for Windowed mode */
    UINT                FullScreen_RefreshRateInHz;
    UINT                PresentationInterval;
} D3DPRESENT_PARAMETERS;

// Values for D3DPRESENT_PARAMETERS.Flags
typedef enum D3DPRESENTFLAG
{
    D3DPRESENTFLAG_LOCKABLE_BACKBUFFER      = 0x00000001,
    D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL     = 0x00000002,
    D3DPRESENTFLAG_DEVICECLIP               = 0x00000004,
    D3DPRESENTFLAG_VIDEO                    = 0x00000010,

/* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DPRESENTFLAG_NOAUTOROTATE                    = 0x00000020,
    D3DPRESENTFLAG_UNPRUNEDMODE                    = 0x00000040,
    D3DPRESENTFLAG_OVERLAY_LIMITEDRGB              = 0x00000080,
    D3DPRESENTFLAG_OVERLAY_YCbCr_BT709             = 0x00000100,
    D3DPRESENTFLAG_OVERLAY_YCbCr_xvYCC             = 0x00000200,
    D3DPRESENTFLAG_RESTRICTED_CONTENT              = 0x00000400,
    D3DPRESENTFLAG_RESTRICT_SHARED_RESOURCE_DRIVER = 0x00000800
} D3DPRESENTFLAG;
//#endif // !D3D_DISABLE_9EX
/* -- D3D9Ex only */

/* Gamma Ramp: Same as DX7 */

typedef struct D3DGAMMARAMP
{
    WORD                red[256];
    WORD                green[256];
    WORD                blue[256];
} D3DGAMMARAMP;

/* Back buffer types */
typedef enum D3DBACKBUFFER_TYPE
{
    D3DBACKBUFFER_TYPE_MONO = 0,
    D3DBACKBUFFER_TYPE_LEFT = 1,
    D3DBACKBUFFER_TYPE_RIGHT = 2,

    D3DBACKBUFFER_TYPE_FORCE_DWORD = 0x7fffffff
} D3DBACKBUFFER_TYPE;


/* Types */
typedef enum D3DRESOURCETYPE {
    D3DRTYPE_SURFACE = 1,
    D3DRTYPE_VOLUME = 2,
    D3DRTYPE_TEXTURE = 3,
    D3DRTYPE_VOLUMETEXTURE = 4,
    D3DRTYPE_CUBETEXTURE = 5,
    D3DRTYPE_VERTEXBUFFER = 6,
    D3DRTYPE_INDEXBUFFER = 7,           //if this changes, change _D3DDEVINFO_RESOURCEMANAGER definition


    D3DRTYPE_FORCE_DWORD = 0x7fffffff
} D3DRESOURCETYPE;

/* Usages */
typedef enum D3DUSAGE
{
    D3DUSAGE_RENDERTARGET       = (0x00000001),
    D3DUSAGE_DEPTHSTENCIL       = (0x00000002),
    D3DUSAGE_DYNAMIC            = (0x00000200),

// /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DUSAGE_NONSECURE          = (0x00800000),

//#endif // !D3D_DISABLE_9EX
// /* -- D3D9Ex only */

// When passed to CheckDeviceFormat, D3DUSAGE_AUTOGENMIPMAP may return
// D3DOK_NOAUTOGEN if the device doesn't support autogeneration for that format.
// D3DOK_NOAUTOGEN is a success code, not a failure code... the SUCCEEDED and FAILED macros
// will return true and false respectively for this code.
    D3DUSAGE_AUTOGENMIPMAP      = (0x00000400),
    D3DUSAGE_DMAP               = (0x00004000),

// The following usages are valid only for querying CheckDeviceFormat
    D3DUSAGE_QUERY_LEGACYBUMPMAP            = (0x00008000),
    D3DUSAGE_QUERY_SRGBREAD                 = (0x00010000),
    D3DUSAGE_QUERY_FILTER                   = (0x00020000),
    D3DUSAGE_QUERY_SRGBWRITE                = (0x00040000),
    D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING = (0x00080000),
    D3DUSAGE_QUERY_VERTEXTEXTURE            = (0x00100000),
    D3DUSAGE_QUERY_WRAPANDMIP	            = (0x00200000),

// /* Usages for Vertex/Index buffers */
    D3DUSAGE_WRITEONLY          = (0x00000008),
    D3DUSAGE_SOFTWAREPROCESSING = (0x00000010),
    D3DUSAGE_DONOTCLIP          = (0x00000020),
    D3DUSAGE_POINTS             = (0x00000040),
    D3DUSAGE_RTPATCHES          = (0x00000080),
    D3DUSAGE_NPATCHES           = (0x00000100),

// /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DUSAGE_TEXTAPI                         = (0x10000000),
    D3DUSAGE_RESTRICTED_CONTENT              = (0x00000800),
    D3DUSAGE_RESTRICT_SHARED_RESOURCE        = (0x00002000),
    D3DUSAGE_RESTRICT_SHARED_RESOURCE_DRIVER = (0x00001000), 

//#endif // !D3D_DISABLE_9EX
// /* -- D3D9Ex only */

} D3DUSAGE;
















/* CubeMap Face identifiers */
typedef enum D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z = 5,

    D3DCUBEMAP_FACE_FORCE_DWORD = 0x7fffffff
} D3DCUBEMAP_FACES;


/* Lock flags */
typedef enum D3DLOCK
{
     D3DLOCK_READONLY = 0x00000010,
     D3DLOCK_DISCARD = 0x00002000,
     D3DLOCK_NOOVERWRITE = 0x00001000,
     D3DLOCK_NOSYSLOCK = 0x00000800,
     D3DLOCK_DONOTWAIT = 0x00004000,

     D3DLOCK_NO_DIRTY_UPDATE = 0x00008000 
} D3DLOCK;






/* Vertex Buffer Description */
typedef struct D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;

    DWORD               FVF;

} D3DVERTEXBUFFER_DESC;

/* Index Buffer Description */
typedef struct D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;
    UINT                Size;
} D3DINDEXBUFFER_DESC;


/* Surface Description */
typedef struct D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    DWORD               MultiSampleQuality;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC;

typedef struct D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    D3DPOOL             Pool;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC;

/* Structure for LockRect */
typedef struct D3DLOCKED_RECT
{
    INT                 Pitch;
    LongPtr pBits;
} D3DLOCKED_RECT;

/* Structures for LockBox */
typedef struct D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX;

typedef struct D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    LongPtr pBits;
} D3DLOCKED_BOX;

/* Structures for LockRange */
typedef struct D3DRANGE
{
    UINT                Offset;
    UINT                Size;
} D3DRANGE;

/* Structures for high order primitives */
typedef struct D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DDEGREETYPE       Degree;
} D3DRECTPATCH_INFO;

typedef struct D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DDEGREETYPE       Degree;
} D3DTRIPATCH_INFO;

/* Adapter Identifier */

//#define MAX_DEVICE_IDENTIFIER_STRING        512
typedef struct D3DADAPTER_IDENTIFIER9
{
    UCHAR            Driver[512];
    UCHAR            Description[512];
    UCHAR            DeviceName[32];         /* Device name for GDI (ex. \\.\DISPLAY1) */

//#ifdef _WIN32
    LARGE_INTEGER   DriverVersion;          /* Defined for 32 bit components */
//#else
//    DWORD           DriverVersionLowPart;   /* Defined for 16 bit driver components */
//    DWORD           DriverVersionHighPart;
//#endif

    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;

    UUID            DeviceIdentifier;

    DWORD           WHQLLevel;

} D3DADAPTER_IDENTIFIER9;


/* Raster Status structure returned by GetRasterStatus */
typedef struct D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS;



/* Debug monitor tokens (DEBUG only)

   Note that if D3DRS_DEBUGMONITORTOKEN is set, the call is treated as
   passing a token to the debug monitor.  For example, if, after passing
   D3DDMT_ENABLE/DISABLE to D3DRS_DEBUGMONITORTOKEN other token values
   are passed in, the enabled/disabled state of the debug
   monitor will still persist.

   The debug monitor defaults to enabled.

   Calling GetRenderState on D3DRS_DEBUGMONITORTOKEN is not of any use.
*/
typedef enum D3DDEBUGMONITORTOKENS {
    D3DDMT_ENABLE = 0,    // enable debug monitor
    D3DDMT_DISABLE = 1,    // disable debug monitor
    D3DDMT_FORCE_DWORD = 0x7fffffff,
} D3DDEBUGMONITORTOKENS;

// Async feedback

typedef enum D3DQUERYTYPE {
    D3DQUERYTYPE_VCACHE = 4, // /* D3DISSUE_END */
    D3DQUERYTYPE_RESOURCEMANAGER = 5, // /* D3DISSUE_END */
    D3DQUERYTYPE_VERTEXSTATS = 6, // /* D3DISSUE_END */
    D3DQUERYTYPE_EVENT = 8, // /* D3DISSUE_END */
    D3DQUERYTYPE_OCCLUSION = 9, // /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_TIMESTAMP = 10, // /* D3DISSUE_END */
    D3DQUERYTYPE_TIMESTAMPDISJOINT = 11, // /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_TIMESTAMPFREQ = 12, // /* D3DISSUE_END */
    D3DQUERYTYPE_PIPELINETIMINGS = 13, // /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_INTERFACETIMINGS = 14, // /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_VERTEXTIMINGS = 15, // /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_PIXELTIMINGS = 16, // /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_BANDWIDTHTIMINGS = 17, // /* D3DISSUE_BEGIN, D3DISSUE_END */
    D3DQUERYTYPE_CACHEUTILIZATION = 18, // /* D3DISSUE_BEGIN, D3DISSUE_END */
    // /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)
    D3DQUERYTYPE_MEMORYPRESSURE = 19, // /* D3DISSUE_BEGIN, D3DISSUE_END */
//#endif // !D3D_DISABLE_9EX
} D3DQUERYTYPE;

// Flags field for Issue
typedef enum D3DISSUE
{
     D3DISSUE_END = 1, //(1 << 0) // Tells the runtime to issue the end of a query, changing it's state to "non-signaled".
     D3DISSUE_BEGIN = 2 //(1 << 1) // Tells the runtime to issue the beginng of a query.
} D3DISSUE;

// Flags field for GetData
typedef enum D3D9GetDataFlags
{
     D3DGETDATA_FLUSH = 1 // (1 << 0) // Tells the runtime to flush if the query is outstanding.
} D3D9GetDataFlags;

typedef struct D3DRESOURCESTATS
{
    // Data collected since last Present()
    BOOL    bThrashing;             // /* indicates if thrashing */
    DWORD   ApproxBytesDownloaded;  // /* Approximate number of bytes downloaded by resource manager */
    DWORD   NumEvicts;              // /* number of objects evicted */
    DWORD   NumVidCreates;          // /* number of objects created in video memory */
    DWORD   LastPri;                // /* priority of last object evicted */
    DWORD   NumUsed;                // /* number of objects set to the device */
    DWORD   NumUsedInVidMem;        // /* number of objects set to the device, which are already in video memory */
    // Persistent data
    DWORD   WorkingSet;             // /* number of objects in video memory */
    DWORD   WorkingSetBytes;        // /* number of bytes in video memory */
    DWORD   TotalManaged;           // /* total number of managed objects */
    DWORD   TotalBytes;             // /* total number of bytes of managed objects */
} D3DRESOURCESTATS;

//#define D3DRTYPECOUNT (D3DRTYPE_INDEXBUFFER+1)

typedef struct D3DDEVINFO_RESOURCEMANAGER
{
//#ifndef WOW64_ENUM_WORKAROUND
//    D3DRESOURCESTATS    stats[D3DRTYPECOUNT];
//#else
    D3DRESOURCESTATS    stats[8];
//#endif
} D3DDEVINFO_RESOURCEMANAGER;

typedef struct D3DDEVINFO_D3DVERTEXSTATS
{
    DWORD   NumRenderedTriangles;       // /* total number of triangles that are not clipped in this frame */
    DWORD   NumExtraClippingTriangles;  // /* Number of new triangles generated by clipping */
} D3DDEVINFO_D3DVERTEXSTATS;


typedef struct D3DDEVINFO_VCACHE {
    DWORD   Pattern;                    // /* bit pattern, return value must be FOUR_CC('C', 'A', 'C', 'H') */
    DWORD   OptMethod;                  // /* optimization method 0 means longest strips, 1 means vertex cache based */
    DWORD   CacheSize;                  // /* cache size to optimize for  (only required if type is 1) */
    DWORD   MagicNumber;                // /* used to determine when to restart strips (only required if type is 1)*/
} D3DDEVINFO_VCACHE;

typedef struct D3DDEVINFO_D3D9PIPELINETIMINGS
{
    FLOAT VertexProcessingTimePercent;
    FLOAT PixelProcessingTimePercent;
    FLOAT OtherGPUProcessingTimePercent;
    FLOAT GPUIdleTimePercent;
} D3DDEVINFO_D3D9PIPELINETIMINGS;

typedef struct D3DDEVINFO_D3D9INTERFACETIMINGS
{
    FLOAT WaitingForGPUToUseApplicationResourceTimePercent;
    FLOAT WaitingForGPUToAcceptMoreCommandsTimePercent;
    FLOAT WaitingForGPUToStayWithinLatencyTimePercent;
    FLOAT WaitingForGPUExclusiveResourceTimePercent;
    FLOAT WaitingForGPUOtherTimePercent;
} D3DDEVINFO_D3D9INTERFACETIMINGS;

typedef struct D3DDEVINFO_D3D9STAGETIMINGS
{
    FLOAT MemoryProcessingPercent;
    FLOAT ComputationProcessingPercent;
} D3DDEVINFO_D3D9STAGETIMINGS;

typedef struct D3DDEVINFO_D3D9BANDWIDTHTIMINGS
{
    FLOAT MaxBandwidthUtilized;
    FLOAT FrontEndUploadMemoryUtilizedPercent;
    FLOAT VertexRateUtilizedPercent;
    FLOAT TriangleSetupRateUtilizedPercent;
    FLOAT FillRateUtilizedPercent;
} D3DDEVINFO_D3D9BANDWIDTHTIMINGS;

typedef struct D3DDEVINFO_D3D9CACHEUTILIZATION
{
    FLOAT TextureCacheHitRate; // Percentage of cache hits
    FLOAT PostTransformVertexCacheHitRate;
} D3DDEVINFO_D3D9CACHEUTILIZATION;

/* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

typedef struct D3DMEMORYPRESSURE
{
    UINT64  BytesEvictedFromProcess;
    UINT64  SizeOfInefficientAllocation;
    DWORD   LevelOfEfficiency;
} D3DMEMORYPRESSURE;

typedef enum D3DCOMPOSERECTSOP {
    D3DCOMPOSERECTS_COPY = 1,
    D3DCOMPOSERECTS_OR = 2,
    D3DCOMPOSERECTS_AND = 3,
    D3DCOMPOSERECTS_NEG = 4,
    D3DCOMPOSERECTS_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DCOMPOSERECTSOP;

typedef struct D3DCOMPOSERECTDESC
{
    USHORT  X;
    USHORT  Y;           // Top-left coordinates of a rect in the source surface
    USHORT  Width;
    USHORT Height;  // Dimensions of the rect
} D3DCOMPOSERECTDESC;

typedef struct D3DCOMPOSERECTDESTINATION
{
    USHORT SrcRectIndex;    // Index of D3DCOMPOSERECTDESC
    USHORT Reserved;        // For alignment
    SHORT  X;
    SHORT  Y;            // Top-left coordinates of the rect in the destination surface
} D3DCOMPOSERECTDESTINATION;

//#define D3DCOMPOSERECTS_MAXNUMRECTS 0xFFFF
//#define D3DCONVOLUTIONMONO_MAXWIDTH  7
//#define D3DCONVOLUTIONMONO_MAXHEIGHT D3DCONVOLUTIONMONO_MAXWIDTH
//#define D3DFMT_A1_SURFACE_MAXWIDTH  8192
//#define D3DFMT_A1_SURFACE_MAXHEIGHT 2048


typedef struct D3DPRESENTSTATS {
    UINT PresentCount;
    UINT PresentRefreshCount;
    UINT SyncRefreshCount;
    LARGE_INTEGER SyncQPCTime;
    LARGE_INTEGER SyncGPUTime;
} D3DPRESENTSTATS;

typedef enum D3DSCANLINEORDERING
{
    D3DSCANLINEORDERING_UNKNOWN = 0,
    D3DSCANLINEORDERING_PROGRESSIVE = 1,
    D3DSCANLINEORDERING_INTERLACED = 2,
} D3DSCANLINEORDERING;


typedef struct D3DDISPLAYMODEEX
{
    UINT                    Size;
    UINT                    Width;
    UINT                    Height;
    UINT                    RefreshRate;
    D3DFORMAT               Format;
    D3DSCANLINEORDERING     ScanLineOrdering;
} D3DDISPLAYMODEEX;

typedef struct D3DDISPLAYMODEFILTER
{
    UINT                    Size;
    D3DFORMAT               Format;
    D3DSCANLINEORDERING     ScanLineOrdering;
} D3DDISPLAYMODEFILTER;


typedef enum D3DDISPLAYROTATION
{
    D3DDISPLAYROTATION_IDENTITY = 1, // No rotation.           
    D3DDISPLAYROTATION_90 = 2, // Rotated 90 degrees.
    D3DDISPLAYROTATION_180 = 3, // Rotated 180 degrees.
    D3DDISPLAYROTATION_270 = 4  // Rotated 270 degrees.
} D3DDISPLAYROTATION;

/* For use in ID3DResource9::SetPriority calls */
typedef enum D3D9_RESOURCE_PRIORITY
{
     D3D9_RESOURCE_PRIORITY_MINIMUM = 0x28000000,
     D3D9_RESOURCE_PRIORITY_LOW = 0x50000000,
     D3D9_RESOURCE_PRIORITY_NORMAL = 0x78000000,
     D3D9_RESOURCE_PRIORITY_HIGH = 0xa0000000,
     D3D9_RESOURCE_PRIORITY_MAXIMUM = 0xc8000000
} D3D9_RESOURCE_PRIORITY;
//#define D3D_OMAC_SIZE    16

typedef struct D3D_OMAC
{
    BYTE Omac[16];
} D3D_OMAC;

typedef enum D3DAUTHENTICATEDCHANNELTYPE
{
    D3DAUTHENTICATEDCHANNEL_D3D9 = 1,
    D3DAUTHENTICATEDCHANNEL_DRIVER_SOFTWARE = 2,
    D3DAUTHENTICATEDCHANNEL_DRIVER_HARDWARE = 3,
} D3DAUTHENTICATEDCHANNELTYPE;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERY_INPUT
{
    UUID                               QueryType;
    LongPtr                             hChannel;
    UINT                               SequenceNumber;
} D3DAUTHENTICATEDCHANNEL_QUERY_INPUT;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT
{
    D3D_OMAC                           omac;
    UUID                               QueryType;
    LongPtr                             hChannel;
    UINT                               SequenceNumber;
    HRESULT                            ReturnCode;
} D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT;

//DEFINE_GUID(D3DAUTHENTICATEDQUERY_PROTECTION,  0xa84eb584, 0xc495, 0x48aa, 0xb9, 0x4d, 0x8b, 0xd2, 0xd6, 0xfb, 0xce, 0x5);

typedef struct D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS
{
    //union
    //{
    //    struct
    //    {
    //        UINT ProtectionEnabled : 1;
    //        UINT OverlayOrFullscreenRequired : 1;
    //        UINT Reserved : 30;
    //    };
        UINT  Value;
    //};

} D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYPROTECTION_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS ProtectionFlags;

} D3DAUTHENTICATEDCHANNEL_QUERYPROTECTION_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_CHANNELTYPE,  0xbc1b18a5, 0xb1fb, 0x42ab, 0xbd, 0x94, 0xb5, 0x82, 0x8b, 0x4b, 0xf7, 0xbe);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYCHANNELTYPE_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    D3DAUTHENTICATEDCHANNELTYPE ChannelType;

} D3DAUTHENTICATEDCHANNEL_QUERYCHANNELTYPE_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_DEVICEHANDLE,  0xec1c539d, 0x8cff, 0x4e2a, 0xbc, 0xc4, 0xf5, 0x69, 0x2f, 0x99, 0xf4, 0x80);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYDEVICEHANDLE_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    LongPtr   DeviceHandle;

} D3DAUTHENTICATEDCHANNEL_QUERYDEVICEHANDLE_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_CRYPTOSESSION, 0x2634499e, 0xd018, 0x4d74, 0xac, 0x17, 0x7f, 0x72, 0x40, 0x59, 0x52, 0x8d);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_INPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;

    LongPtr   DXVA2DecodeHandle;

} D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_INPUT;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    LongPtr   DXVA2DecodeHandle;
    LongPtr   CryptoSessionHandle;
    LongPtr   DeviceHandle;

} D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_RESTRICTEDSHAREDRESOURCEPROCESSCOUNT,  0xdb207b3, 0x9450, 0x46a6, 0x82, 0xde, 0x1b, 0x96, 0xd4, 0x4f, 0x9c, 0xf2);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESSCOUNT_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    UINT   NumRestrictedSharedResourceProcesses;

} D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESSCOUNT_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_RESTRICTEDSHAREDRESOURCEPROCESS,  0x649bbadb, 0xf0f4, 0x4639, 0xa1, 0x5b, 0x24, 0x39, 0x3f, 0xc3, 0xab, 0xac);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_INPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;

    UINT     ProcessIndex;

} D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_INPUT;

typedef enum D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE
{
    PROCESSIDTYPE_UNKNOWN = 0,
    PROCESSIDTYPE_DWM = 1,
    PROCESSIDTYPE_HANDLE = 2
} D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    UINT                                          ProcessIndex;
    D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE ProcessIdentifer;
    LongPtr                                        ProcessHandle;

} D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_UNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT,   0x12f0bd6, 0xe662, 0x4474, 0xbe, 0xfd, 0xaa, 0x53, 0xe5, 0x14, 0x3c, 0x6d);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYUNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    UINT   NumUnrestrictedProtectedSharedResources;

} D3DAUTHENTICATEDCHANNEL_QUERYUNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_OUTPUTIDCOUNT,  0x2c042b5e, 0x8c07, 0x46d5, 0xaa, 0xbe, 0x8f, 0x75, 0xcb, 0xad, 0x4c, 0x31);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_INPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;

    LongPtr  DeviceHandle;
    LongPtr  CryptoSessionHandle;

} D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_INPUT;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    LongPtr  DeviceHandle;
    LongPtr  CryptoSessionHandle;
    UINT    NumOutputIDs;

} D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_OUTPUTID,  0x839ddca3, 0x9b4e, 0x41e4, 0xb0, 0x53, 0x89, 0x2b, 0xd2, 0xa1, 0x1e, 0xe7);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_INPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;

    LongPtr  DeviceHandle;
    LongPtr  CryptoSessionHandle;
    UINT    OutputIDIndex;

} D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_INPUT;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    LongPtr  DeviceHandle;
    LongPtr  CryptoSessionHandle;
    UINT    OutputIDIndex;
    UINT64  OutputID;

} D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_ACCESSIBILITYATTRIBUTES,  0x6214d9d2, 0x432c, 0x4abb, 0x9f, 0xce, 0x21, 0x6e, 0xea, 0x26, 0x9e, 0x3b);

typedef enum D3DBUSTYPE
{
    D3DBUSTYPE_OTHER = 0x00000000,
    D3DBUSTYPE_PCI = 0x00000001,
    D3DBUSTYPE_PCIX = 0x00000002,
    D3DBUSTYPE_PCIEXPRESS = 0x00000003,
    D3DBUSTYPE_AGP = 0x00000004,
    D3DBUSIMPL_MODIFIER_INSIDE_OF_CHIPSET = 0x00010000,
    D3DBUSIMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = 0x00020000,
    D3DBUSIMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = 0x00030000,
    D3DBUSIMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR = 0x00040000,
    D3DBUSIMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 0x00050000,
    D3DBUSIMPL_MODIFIER_NON_STANDARD = 0x80000000,
} D3DBUSTYPE;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYINFOBUSTYPE_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    D3DBUSTYPE BusType;
    BOOL bAccessibleInContiguousBlocks;
    BOOL bAccessibleInNonContiguousBlocks;

} D3DAUTHENTICATEDCHANNEL_QUERYINFOBUSTYPE_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_ENCRYPTIONWHENACCESSIBLEGUIDCOUNT, 0xb30f7066, 0x203c, 0x4b07, 0x93, 0xfc, 0xce, 0xaa, 0xfd, 0x61, 0x24, 0x1e);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUIDCOUNT_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    UINT   NumEncryptionGuids;

} D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUIDCOUNT_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_ENCRYPTIONWHENACCESSIBLEGUID,  0xf83a5958, 0xe986, 0x4bda, 0xbe, 0xb0, 0x41, 0x1f, 0x6a, 0x7a, 0x1, 0xb7);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_INPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;

    UINT EncryptionGuidIndex;

} D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_INPUT;

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    UINT       EncryptionGuidIndex;
    UUID       EncryptionGuid;

} D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_OUTPUT;


//DEFINE_GUID(D3DAUTHENTICATEDQUERY_CURRENTENCRYPTIONWHENACCESSIBLE,  0xec1791c7, 0xdad3, 0x4f15, 0x9e, 0xc3, 0xfa, 0xa9, 0x3d, 0x60, 0xd4, 0xf0);

typedef struct D3DAUTHENTICATEDCHANNEL_QUERYUNCOMPRESSEDENCRYPTIONLEVEL_OUTPUT
{
    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;

    UUID       EncryptionGuid;

} D3DAUTHENTICATEDCHANNEL_QUERYUNCOMPRESSEDENCRYPTIONLEVEL_OUTPUT;


typedef struct D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT
{
    D3D_OMAC                            omac;
    UUID                                ConfigureType;
    LongPtr                              hChannel;
    UINT                                SequenceNumber;

} D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT;

typedef struct D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT
{
    D3D_OMAC                            omac;
    UUID                                ConfigureType;
    LongPtr                              hChannel;
    UINT                                SequenceNumber;
    HRESULT                             ReturnCode;

} D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT;

//DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_INITIALIZE,  0x6114bdb, 0x3523, 0x470a, 0x8d, 0xca, 0xfb, 0xc2, 0x84, 0x51, 0x54, 0xf0);

typedef struct D3DAUTHENTICATEDCHANNEL_CONFIGUREINITIALIZE
{
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT   Parameters;

    UINT   StartSequenceQuery;
    UINT   StartSequenceConfigure;

} D3DAUTHENTICATEDCHANNEL_CONFIGUREINITIALIZE;


//DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_PROTECTION,  0x50455658, 0x3f47, 0x4362, 0xbf, 0x99, 0xbf, 0xdf, 0xcd, 0xe9, 0xed, 0x29);

typedef struct D3DAUTHENTICATEDCHANNEL_CONFIGUREPROTECTION
{
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT   Parameters;

    D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS Protections;

} D3DAUTHENTICATEDCHANNEL_CONFIGUREPROTECTION;


//DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_CRYPTOSESSION,  0x6346cc54, 0x2cfc, 0x4ad4, 0x82, 0x24, 0xd1, 0x58, 0x37, 0xde, 0x77, 0x0);

typedef struct D3DAUTHENTICATEDCHANNEL_CONFIGURECRYPTOSESSION
{
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT   Parameters;

    LongPtr      DXVA2DecodeHandle;
    LongPtr      CryptoSessionHandle;
    LongPtr      DeviceHandle;

} D3DAUTHENTICATEDCHANNEL_CONFIGURECRYPTOSESSION;


//DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_SHAREDRESOURCE,  0x772d047, 0x1b40, 0x48e8, 0x9c, 0xa6, 0xb5, 0xf5, 0x10, 0xde, 0x9f, 0x1);

typedef struct D3DAUTHENTICATEDCHANNEL_CONFIGURESHAREDRESOURCE
{
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT       Parameters;

    D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE ProcessIdentiferType;
    LongPtr                                        ProcessHandle;
    BOOL                                          AllowAccess;

} D3DAUTHENTICATEDCHANNEL_CONFIGURESHAREDRESOURCE;


//DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_ENCRYPTIONWHENACCESSIBLE,  0x41fff286, 0x6ae0, 0x4d43, 0x9d, 0x55, 0xa4, 0x6e, 0x9e, 0xfd, 0x15, 0x8a);

typedef struct D3DAUTHENTICATEDCHANNEL_CONFIGUREUNCOMPRESSEDENCRYPTION
{
    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT   Parameters;

    UUID                                      EncryptionGuid;

} D3DAUTHENTICATEDCHANNEL_CONFIGUREUNCOMPRESSEDENCRYPTION;

typedef struct D3DENCRYPTED_BLOCK_INFO
{
    UINT NumEncryptedBytesAtBeginning;
    UINT NumBytesInSkipPattern;
    UINT NumBytesInEncryptPattern;
} D3DENCRYPTED_BLOCK_INFO;

typedef struct D3DAES_CTR_IV
{
    UINT64   IV;         // Big-Endian IV
    UINT64   Count;      // Big-Endian Block Count
} D3DAES_CTR_IV;














//d3d9caps.h
typedef struct D3DVSHADERCAPS2_0
{
    DWORD Caps;
    INT DynamicFlowControlDepth;
    INT NumTemps;
    INT StaticFlowControlDepth;
} D3DVSHADERCAPS2_0;

//#define D3DVS20CAPS_PREDICATION             (1<<0)
//
//#define D3DVS20_MAX_DYNAMICFLOWCONTROLDEPTH  24
//#define D3DVS20_MIN_DYNAMICFLOWCONTROLDEPTH  0
//#define D3DVS20_MAX_NUMTEMPS    32
//#define D3DVS20_MIN_NUMTEMPS    12
//#define D3DVS20_MAX_STATICFLOWCONTROLDEPTH    4
//#define D3DVS20_MIN_STATICFLOWCONTROLDEPTH    1

typedef struct D3DPSHADERCAPS2_0
{
    DWORD Caps;
    INT DynamicFlowControlDepth;
    INT NumTemps;
    INT StaticFlowControlDepth;
    INT NumInstructionSlots;
} D3DPSHADERCAPS2_0;

typedef enum D3D9Caps20
{
     D3DPS20CAPS_ARBITRARYSWIZZLE = 1, //(1<<0)
     D3DPS20CAPS_GRADIENTINSTRUCTIONS = 2, //(1<<1)
     D3DPS20CAPS_PREDICATION = 4, //(1<<2)
     D3DPS20CAPS_NODEPENDENTREADLIMIT = 8, //(1<<3)
     D3DPS20CAPS_NOTEXINSTRUCTIONLIMIT = 16 //(1<<4)
} D3D9Caps20;


//#define D3DPS20_MAX_DYNAMICFLOWCONTROLDEPTH    24
//#define D3DPS20_MIN_DYNAMICFLOWCONTROLDEPTH    0
//#define D3DPS20_MAX_NUMTEMPS    32
//#define D3DPS20_MIN_NUMTEMPS    12
//#define D3DPS20_MAX_STATICFLOWCONTROLDEPTH    4
//#define D3DPS20_MIN_STATICFLOWCONTROLDEPTH    0
//#define D3DPS20_MAX_NUMINSTRUCTIONSLOTS    512
//#define D3DPS20_MIN_NUMINSTRUCTIONSLOTS    96
//
//#define D3DMIN30SHADERINSTRUCTIONS 512
//#define D3DMAX30SHADERINSTRUCTIONS 32768

/* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

typedef struct D3DOVERLAYCAPS
{
    UINT   Caps;
    UINT   MaxOverlayDisplayWidth;
    UINT   MaxOverlayDisplayHeight;
} D3DOVERLAYCAPS;

typedef enum D3D9OverlayCapsFlags
{
    D3DOVERLAYCAPS_FULLRANGERGB          = 0x00000001,
    D3DOVERLAYCAPS_LIMITEDRANGERGB       = 0x00000002,
    D3DOVERLAYCAPS_YCbCr_BT601           = 0x00000004,
    D3DOVERLAYCAPS_YCbCr_BT709           = 0x00000008,
    D3DOVERLAYCAPS_YCbCr_BT601_xvYCC     = 0x00000010,
    D3DOVERLAYCAPS_YCbCr_BT709_xvYCC     = 0x00000020,
    D3DOVERLAYCAPS_STRETCHX              = 0x00000040,
    D3DOVERLAYCAPS_STRETCHY              = 0x00000080
} D3D9OverlayCapsFlags;

typedef struct D3DCONTENTPROTECTIONCAPS
{
    DWORD     Caps;
    UUID      KeyExchangeType;
    UINT      BufferAlignmentStart;
    UINT      BlockAlignmentSize;
    ULONGLONG ProtectedMemorySize;
} D3DCONTENTPROTECTIONCAPS;

typedef enum D3D9ContentProtectionCapsFlags
{
    D3DCPCAPS_SOFTWARE              = 0x00000001,
    D3DCPCAPS_HARDWARE              = 0x00000002,
    D3DCPCAPS_PROTECTIONALWAYSON    = 0x00000004,
    D3DCPCAPS_PARTIALDECRYPTION     = 0x00000008,
    D3DCPCAPS_CONTENTKEY            = 0x00000010,
    D3DCPCAPS_FRESHENSESSIONKEY     = 0x00000020,
    D3DCPCAPS_ENCRYPTEDREADBACK     = 0x00000040,
    D3DCPCAPS_ENCRYPTEDREADBACKKEY  = 0x00000080,
    D3DCPCAPS_SEQUENTIAL_CTR_IV     = 0x00000100,
    D3DCPCAPS_ENCRYPTSLICEDATAONLY  = 0x00000200
} D3D9ContentProtectionCapsFlags;


//DEFINE_GUID(D3DCRYPTOTYPE_AES128_CTR,   = 0x9b6bd711, = 0x4f74, = 0x41c9, = 0x9e, = 0x7b, = 0xb, = 0xe2, = 0xd7, = 0xd9, = 0x3b, = 0x4f);
//DEFINE_GUID(D3DCRYPTOTYPE_PROPRIETARY,   = 0xab4e9afd, = 0x1d1c, = 0x46e6, = 0xa7, = 0x2f, = 0x8, = 0x69, = 0x91, = 0x7b, = 0xd, = 0xe8);
//
//DEFINE_GUID(D3DKEYEXCHANGE_RSAES_OAEP,    = 0xc1949895, = 0xd72a, = 0x4a1d, = 0x8e, = 0x5d, = 0xed, = 0x85, = 0x7d, = 0x17, = 0x15, = 0x20);
//DEFINE_GUID(D3DKEYEXCHANGE_DXVA,   = 0x43d3775c, = 0x38e5, = 0x4924, = 0x8d, = 0x86, = 0xd3, = 0xfc, = 0xcf, = 0x15, = 0x3e, = 0x9b);

//#endif // !D3D_DISABLE_9EX
/* -- D3D9Ex only */

typedef struct D3DCAPS9
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT        AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture9's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture9's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture9's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture9's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture9's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth;
    DWORD   MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   PixelShader1xMaxValue;      // max value storable in registers of ps.1.x shaders

    // Here are the DX9 specific ones
    DWORD   DevCaps2;

    float   MaxNpatchTessellationLevel;
    DWORD   Reserved5;

    UINT    MasterAdapterOrdinal;       // ordinal of master adaptor for adapter group
    UINT    AdapterOrdinalInGroup;      // ordinal inside the adapter group
    UINT    NumberOfAdaptersInGroup;    // number of adapters in this adapter group (only if master)
    DWORD   DeclTypes;                  // Data types, supported in vertex declarations
    DWORD   NumSimultaneousRTs;         // Will be at least 1
    DWORD   StretchRectFilterCaps;      // Filter caps supported by StretchRect
    D3DVSHADERCAPS2_0 VS20Caps;
    D3DPSHADERCAPS2_0 PS20Caps;
    DWORD   VertexTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DTexture9's for texture, used in vertex shaders
    DWORD   MaxVShaderInstructionsExecuted; // maximum number of vertex shader instructions that can be executed
    DWORD   MaxPShaderInstructionsExecuted; // maximum number of pixel shader instructions that can be executed
    DWORD   MaxVertexShader30InstructionSlots;
    DWORD   MaxPixelShader30InstructionSlots;
} D3DCAPS9;

//
// BIT DEFINES FOR D3DCAPS9 DWORD MEMBERS
//

//
// Caps
//
typedef enum D3DCAPS
{
    D3DCAPS_OVERLAY                 = 0x00000800,
    D3DCAPS_READ_SCANLINE           = 0x00020000,
} D3DCAPS;
//
// Caps2
//
typedef enum D3DCAPS2
{
    D3DCAPS2_FULLSCREENGAMMA        = 0x00020000,
    D3DCAPS2_CANCALIBRATEGAMMA      = 0x00100000,
    D3DCAPS2_RESERVED               = 0x02000000,
    D3DCAPS2_CANMANAGERESOURCE      = 0x10000000,
    D3DCAPS2_DYNAMICTEXTURES        = 0x20000000,
    D3DCAPS2_CANAUTOGENMIPMAP       = 0x40000000,

/* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DCAPS2_CANSHARERESOURCE       = 0x80000000  

//#endif // !D3D_DISABLE_9EX
/* -- D3D9Ex only */
} D3DCAPS2;
//
// Caps3
//
typedef enum D3DCAPS3
{
    D3DCAPS3_RESERVED               = 0x8000001f,  

// Indicates that the device can respect the ALPHABLENDENABLE render state
// when fullscreen while using the FLIP or DISCARD swap effect.
// COPY and COPYVSYNC swap effects work whether or not this flag is set.
    D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD   = 0x00000020,

// Indicates that the device can perform a gamma correction from 
// a windowed back buffer containing linear content to the sRGB desktop.
    D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION = 0x00000080,

    D3DCAPS3_COPY_TO_VIDMEM         = 0x00000100, /* Device can acclerate copies from sysmem to local vidmem */
    D3DCAPS3_COPY_TO_SYSTEMMEM      = 0x00000200, /* Device can acclerate copies from local vidmem to sysmem */
    D3DCAPS3_DXVAHD                 = 0x00000400,
    D3DCAPS3_DXVAHD_LIMITED         = 0x00000800 
} D3DCAPS3;

//
// PresentationIntervals
//
typedef enum D3D9PresentIntervals
{
    D3DPRESENT_INTERVAL_DEFAULT     = 0x00000000,
    D3DPRESENT_INTERVAL_ONE         = 0x00000001,
    D3DPRESENT_INTERVAL_TWO         = 0x00000002,
    D3DPRESENT_INTERVAL_THREE       = 0x00000004,
    D3DPRESENT_INTERVAL_FOUR        = 0x00000008,
    D3DPRESENT_INTERVAL_IMMEDIATE   = 0x80000000 
} D3D9PresentIntervals;
//
// CursorCaps
//
typedef enum D3D9CursorCaps
{
// Driver supports HW color cursor in at least hi-res modes(height >=400)
    D3DCURSORCAPS_COLOR             = 0x00000001,
// Driver supports HW cursor also in low-res modes(height < 400)
    D3DCURSORCAPS_LOWRES            = 0x00000002 
} D3D9CursorCaps;
//
// DevCaps
//
typedef enum D3D9DevCaps
{
    D3DDEVCAPS_EXECUTESYSTEMMEMORY  = 0x00000010, /* Device can use execute buffers from system memory */
    D3DDEVCAPS_EXECUTEVIDEOMEMORY   = 0x00000020, /* Device can use execute buffers from video memory */
    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY = 0x00000040, /* Device can use TL buffers from system memory */
    D3DDEVCAPS_TLVERTEXVIDEOMEMORY  = 0x00000080, /* Device can use TL buffers from video memory */
    D3DDEVCAPS_TEXTURESYSTEMMEMORY  = 0x00000100, /* Device can texture from system memory */
    D3DDEVCAPS_TEXTUREVIDEOMEMORY   = 0x00000200, /* Device can texture from device memory */
    D3DDEVCAPS_DRAWPRIMTLVERTEX     = 0x00000400, /* Device can draw TLVERTEX primitives */
    D3DDEVCAPS_CANRENDERAFTERFLIP   = 0x00000800, /* Device can render without waiting for flip to complete */
    D3DDEVCAPS_TEXTURENONLOCALVIDMEM = 0x00001000, /* Device can texture from nonlocal video memory */
    D3DDEVCAPS_DRAWPRIMITIVES2      = 0x00002000, /* Device can support DrawPrimitives2 */
    D3DDEVCAPS_SEPARATETEXTUREMEMORIES = 0x00004000, /* Device is texturing from separate memory pools */
    D3DDEVCAPS_DRAWPRIMITIVES2EX    = 0x00008000, /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
    D3DDEVCAPS_HWTRANSFORMANDLIGHT  = 0x00010000, /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
    D3DDEVCAPS_CANBLTSYSTONONLOCAL  = 0x00020000, /* Device supports a Tex Blt from system memory to non-local vidmem */
    D3DDEVCAPS_HWRASTERIZATION      = 0x00080000, /* Device has HW acceleration for rasterization */
    D3DDEVCAPS_PUREDEVICE           = 0x00100000, /* Device supports D3DCREATE_PUREDEVICE */
    D3DDEVCAPS_QUINTICRTPATCHES     = 0x00200000, /* Device supports quintic Beziers and BSplines */
    D3DDEVCAPS_RTPATCHES            = 0x00400000, /* Device supports Rect and Tri patches */
    D3DDEVCAPS_RTPATCHHANDLEZERO    = 0x00800000, /* Indicates that RT Patches may be drawn efficiently using handle 0 */
    D3DDEVCAPS_NPATCHES             = 0x01000000, /* Device supports N-Patches */
} D3D9DevCaps;
//
// PrimitiveMiscCaps
//
typedef enum D3D9PrimitiveMiscCaps
{
    D3DPMISCCAPS_MASKZ              = 0x00000002,
    D3DPMISCCAPS_CULLNONE           = 0x00000010,
    D3DPMISCCAPS_CULLCW             = 0x00000020,
    D3DPMISCCAPS_CULLCCW            = 0x00000040,
    D3DPMISCCAPS_COLORWRITEENABLE   = 0x00000080,
    D3DPMISCCAPS_CLIPPLANESCALEDPOINTS = 0x00000100, /* Device correctly clips scaled points to clip planes */
    D3DPMISCCAPS_CLIPTLVERTS        = 0x00000200, /* device will clip post-transformed vertex primitives */
    D3DPMISCCAPS_TSSARGTEMP         = 0x00000400, /* device supports D3DTA_TEMP for temporary register */
    D3DPMISCCAPS_BLENDOP            = 0x00000800, /* device supports D3DRS_BLENDOP */
    D3DPMISCCAPS_NULLREFERENCE      = 0x00001000, /* Reference Device that doesnt render */
    D3DPMISCCAPS_INDEPENDENTWRITEMASKS     = 0x00004000, /* Device supports independent write masks for MET or MRT */
    D3DPMISCCAPS_PERSTAGECONSTANT   = 0x00008000, /* Device supports per-stage constants */
    D3DPMISCCAPS_FOGANDSPECULARALPHA   = 0x00010000, /* Device supports separate fog and specular alpha (many devices
                                                          use the specular alpha channel to store fog factor) */
    D3DPMISCCAPS_SEPARATEALPHABLEND         = 0x00020000, /* Device supports separate blend settings for the alpha channel */
    D3DPMISCCAPS_MRTINDEPENDENTBITDEPTHS    = 0x00040000, /* Device supports different bit depths for MRT */
    D3DPMISCCAPS_MRTPOSTPIXELSHADERBLENDING = 0x00080000, /* Device supports post-pixel shader operations for MRT */
    D3DPMISCCAPS_FOGVERTEXCLAMPED           = 0x00100000, /* Device clamps fog blend factor per vertex */

                                                          /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DPMISCCAPS_POSTBLENDSRGBCONVERT       = 0x00200000, /* Indicates device can perform conversion to sRGB after blending. */

//#endif // !D3D_DISABLE_9EX
/* -- D3D9Ex only */
} D3D9PrimitiveMiscCaps;

//
// LineCaps
//
typedef enum D3DLINECAPS
{
    D3DLINECAPS_TEXTURE             = 0x00000001,
    D3DLINECAPS_ZTEST               = 0x00000002,
    D3DLINECAPS_BLEND               = 0x00000004,
    D3DLINECAPS_ALPHACMP            = 0x00000008,
    D3DLINECAPS_FOG                 = 0x00000010,
    D3DLINECAPS_ANTIALIAS           = 0x00000020,
} D3DLINECAPS;
//
// RasterCaps
//
typedef enum D3DPRASTERCAPS
{
    D3DPRASTERCAPS_DITHER                 = 0x00000001,
    D3DPRASTERCAPS_ZTEST                  = 0x00000010,
    D3DPRASTERCAPS_FOGVERTEX              = 0x00000080,
    D3DPRASTERCAPS_FOGTABLE               = 0x00000100,
    D3DPRASTERCAPS_MIPMAPLODBIAS          = 0x00002000,
    D3DPRASTERCAPS_ZBUFFERLESSHSR         = 0x00008000,
    D3DPRASTERCAPS_FOGRANGE               = 0x00010000,
    D3DPRASTERCAPS_ANISOTROPY             = 0x00020000,
    D3DPRASTERCAPS_WBUFFER                = 0x00040000,
    D3DPRASTERCAPS_WFOG                   = 0x00100000,
    D3DPRASTERCAPS_ZFOG                   = 0x00200000,
    D3DPRASTERCAPS_COLORPERSPECTIVE       = 0x00400000, /* Device iterates colors perspective correct */
    D3DPRASTERCAPS_SCISSORTEST            = 0x01000000,
    D3DPRASTERCAPS_SLOPESCALEDEPTHBIAS    = 0x02000000,
    D3DPRASTERCAPS_DEPTHBIAS              = 0x04000000, 
    D3DPRASTERCAPS_MULTISAMPLE_TOGGLE     = 0x08000000,
} D3DPRASTERCAPS;
//
// ZCmpCaps, AlphaCmpCaps
//
typedef enum D3DPCMPCAPS
{
    D3DPCMPCAPS_NEVER               = 0x00000001,
    D3DPCMPCAPS_LESS                = 0x00000002,
    D3DPCMPCAPS_EQUAL               = 0x00000004,
    D3DPCMPCAPS_LESSEQUAL           = 0x00000008,
    D3DPCMPCAPS_GREATER             = 0x00000010,
    D3DPCMPCAPS_NOTEQUAL            = 0x00000020,
    D3DPCMPCAPS_GREATEREQUAL        = 0x00000040,
    D3DPCMPCAPS_ALWAYS              = 0x00000080,
} D3DPCMPCAPS;
//
// SourceBlendCaps, DestBlendCaps
//
typedef enum D3DPBLENDCAPS
{
    D3DPBLENDCAPS_ZERO              = 0x00000001,
    D3DPBLENDCAPS_ONE               = 0x00000002,
    D3DPBLENDCAPS_SRCCOLOR          = 0x00000004,
    D3DPBLENDCAPS_INVSRCCOLOR       = 0x00000008,
    D3DPBLENDCAPS_SRCALPHA          = 0x00000010,
    D3DPBLENDCAPS_INVSRCALPHA       = 0x00000020,
    D3DPBLENDCAPS_DESTALPHA         = 0x00000040,
    D3DPBLENDCAPS_INVDESTALPHA      = 0x00000080,
    D3DPBLENDCAPS_DESTCOLOR         = 0x00000100,
    D3DPBLENDCAPS_INVDESTCOLOR      = 0x00000200,
    D3DPBLENDCAPS_SRCALPHASAT       = 0x00000400,
    D3DPBLENDCAPS_BOTHSRCALPHA      = 0x00000800,
    D3DPBLENDCAPS_BOTHINVSRCALPHA   = 0x00001000,
    D3DPBLENDCAPS_BLENDFACTOR       = 0x00002000, /* Supports both D3DBLEND_BLENDFACTOR and D3DBLEND_INVBLENDFACTOR */

/* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DPBLENDCAPS_SRCCOLOR2         = 0x00004000,
    D3DPBLENDCAPS_INVSRCCOLOR2      = 0x00008000,

//#endif // !D3D_DISABLE_9EX
/* -- D3D9Ex only */
} D3DPBLENDCAPS;

//
// ShadeCaps
//
typedef enum D3DPSHADECAPS
{
    D3DPSHADECAPS_COLORGOURAUDRGB       = 0x00000008,
    D3DPSHADECAPS_SPECULARGOURAUDRGB    = 0x00000200,
    D3DPSHADECAPS_ALPHAGOURAUDBLEND     = 0x00004000,
    D3DPSHADECAPS_FOGGOURAUD            = 0x00080000,
} D3DPSHADECAPS;
//
// TextureCaps
//
typedef enum D3DPTEXTURECAPS
{
    D3DPTEXTURECAPS_PERSPECTIVE         = 0x00000001, /* Perspective-correct texturing is supported */
    D3DPTEXTURECAPS_POW2                = 0x00000002, /* Power-of-2 texture dimensions are required - applies to non-Cube/Volume textures only. */
    D3DPTEXTURECAPS_ALPHA               = 0x00000004, /* Alpha in texture pixels is supported */
    D3DPTEXTURECAPS_SQUAREONLY          = 0x00000020, /* Only square textures are supported */
    D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE = 0x00000040, /* Texture indices are not scaled by the texture size prior to interpolation */
    D3DPTEXTURECAPS_ALPHAPALETTE        = 0x00000080, /* Device can draw alpha from texture palettes */
    // Device can use non-POW2 textures if:
    //  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
    //  2) D3DRS_WRAP(N) is zero for this texture's coordinates
    //  3) mip mapping is not enabled (use magnification filter only)
    D3DPTEXTURECAPS_NONPOW2CONDITIONAL  = 0x00000100,
    D3DPTEXTURECAPS_PROJECTED           = 0x00000400, /* Device can do D3DTTFF_PROJECTED */
    D3DPTEXTURECAPS_CUBEMAP             = 0x00000800, /* Device can do cubemap textures */
    D3DPTEXTURECAPS_VOLUMEMAP           = 0x00002000, /* Device can do volume textures */
    D3DPTEXTURECAPS_MIPMAP              = 0x00004000, /* Device can do mipmapped textures */
    D3DPTEXTURECAPS_MIPVOLUMEMAP        = 0x00008000, /* Device can do mipmapped volume textures */
    D3DPTEXTURECAPS_MIPCUBEMAP          = 0x00010000, /* Device can do mipmapped cube maps */
    D3DPTEXTURECAPS_CUBEMAP_POW2        = 0x00020000, /* Device requires that cubemaps be power-of-2 dimension */
    D3DPTEXTURECAPS_VOLUMEMAP_POW2      = 0x00040000, /* Device requires that volume maps be power-of-2 dimension */
    D3DPTEXTURECAPS_NOPROJECTEDBUMPENV  = 0x00200000, /* Device does not support projected bump env lookup operation 
                                                           in programmable and fixed function pixel shaders */
} D3DPTEXTURECAPS;
                                                           //
                                                           // TextureFilterCaps, StretchRectFilterCaps
                                                           //
typedef enum D3DPTFILTERCAPS
{
    D3DPTFILTERCAPS_MINFPOINT           = 0x00000100, /* Min Filter */
    D3DPTFILTERCAPS_MINFLINEAR          = 0x00000200,
    D3DPTFILTERCAPS_MINFANISOTROPIC     = 0x00000400,
    D3DPTFILTERCAPS_MINFPYRAMIDALQUAD   = 0x00000800,
    D3DPTFILTERCAPS_MINFGAUSSIANQUAD    = 0x00001000,
    D3DPTFILTERCAPS_MIPFPOINT           = 0x00010000, /* Mip Filter */
    D3DPTFILTERCAPS_MIPFLINEAR          = 0x00020000,

    /* D3D9Ex only -- */
//#if !defined(D3D_DISABLE_9EX)

    D3DPTFILTERCAPS_CONVOLUTIONMONO     = 0x00040000, /* Min and Mag for the convolution mono filter */

//#endif // !D3D_DISABLE_9EX
/* -- D3D9Ex only */

    D3DPTFILTERCAPS_MAGFPOINT           = 0x01000000, /* Mag Filter */
    D3DPTFILTERCAPS_MAGFLINEAR          = 0x02000000,
    D3DPTFILTERCAPS_MAGFANISOTROPIC     = 0x04000000,
    D3DPTFILTERCAPS_MAGFPYRAMIDALQUAD   = 0x08000000,
    D3DPTFILTERCAPS_MAGFGAUSSIANQUAD    = 0x10000000,
} D3DPTFILTERCAPS;
//
// TextureAddressCaps
//
typedef enum D3DPTADDRESSCAPS
{
    D3DPTADDRESSCAPS_WRAP           = 0x00000001,
    D3DPTADDRESSCAPS_MIRROR         = 0x00000002,
    D3DPTADDRESSCAPS_CLAMP          = 0x00000004,
    D3DPTADDRESSCAPS_BORDER         = 0x00000008,
    D3DPTADDRESSCAPS_INDEPENDENTUV  = 0x00000010,
    D3DPTADDRESSCAPS_MIRRORONCE     = 0x00000020,
} D3DPTADDRESSCAPS;
//
// StencilCaps
//
typedef enum D3DSTENCILCAPS
{
    D3DSTENCILCAPS_KEEP             = 0x00000001,
    D3DSTENCILCAPS_ZERO             = 0x00000002,
    D3DSTENCILCAPS_REPLACE          = 0x00000004,
    D3DSTENCILCAPS_INCRSAT          = 0x00000008,
    D3DSTENCILCAPS_DECRSAT          = 0x00000010,
    D3DSTENCILCAPS_INVERT           = 0x00000020,
    D3DSTENCILCAPS_INCR             = 0x00000040,
    D3DSTENCILCAPS_DECR             = 0x00000080,
    D3DSTENCILCAPS_TWOSIDED         = 0x00000100,
} D3DSTENCILCAPS;
//
// TextureOpCaps
//
typedef enum D3DTEXOPCAPS
{
    D3DTEXOPCAPS_DISABLE                    = 0x00000001,
    D3DTEXOPCAPS_SELECTARG1                 = 0x00000002,
    D3DTEXOPCAPS_SELECTARG2                 = 0x00000004,
    D3DTEXOPCAPS_MODULATE                   = 0x00000008,
    D3DTEXOPCAPS_MODULATE2X                 = 0x00000010,
    D3DTEXOPCAPS_MODULATE4X                 = 0x00000020,
    D3DTEXOPCAPS_ADD                        = 0x00000040,
    D3DTEXOPCAPS_ADDSIGNED                  = 0x00000080,
    D3DTEXOPCAPS_ADDSIGNED2X                = 0x00000100,
    D3DTEXOPCAPS_SUBTRACT                   = 0x00000200,
    D3DTEXOPCAPS_ADDSMOOTH                  = 0x00000400,
    D3DTEXOPCAPS_BLENDDIFFUSEALPHA          = 0x00000800,
    D3DTEXOPCAPS_BLENDTEXTUREALPHA          = 0x00001000,
    D3DTEXOPCAPS_BLENDFACTORALPHA           = 0x00002000,
    D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        = 0x00004000,
    D3DTEXOPCAPS_BLENDCURRENTALPHA          = 0x00008000,
    D3DTEXOPCAPS_PREMODULATE                = 0x00010000,
    D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     = 0x00020000,
    D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     = 0x00040000,
    D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  = 0x00080000,
    D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  = 0x00100000,
    D3DTEXOPCAPS_BUMPENVMAP                 = 0x00200000,
    D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        = 0x00400000,
    D3DTEXOPCAPS_DOTPRODUCT3                = 0x00800000,
    D3DTEXOPCAPS_MULTIPLYADD                = 0x01000000,
    D3DTEXOPCAPS_LERP                       = 0x02000000,
} D3DTEXOPCAPS;
//
// FVFCaps
//
typedef enum D3DFVFCAPS
{
    D3DFVFCAPS_TEXCOORDCOUNTMASK    = 0x0000ffff, /* mask for texture coordinate count field */
    D3DFVFCAPS_DONOTSTRIPELEMENTS   = 0x00080000, /* Device prefers that vertex elements not be stripped */
    D3DFVFCAPS_PSIZE                = 0x00100000, /* Device can receive point size */
} D3DFVFCAPS;
//
// VertexProcessingCaps
//
typedef enum D3DVTXPCAPS
{
    D3DVTXPCAPS_TEXGEN              = 0x00000001, /* device can do texgen */
    D3DVTXPCAPS_MATERIALSOURCE7     = 0x00000002, /* device can do DX7-level colormaterialsource ops */
    D3DVTXPCAPS_DIRECTIONALLIGHTS   = 0x00000008, /* device can do directional lights */
    D3DVTXPCAPS_POSITIONALLIGHTS    = 0x00000010, /* device can do positional lights (includes point and spot) */
    D3DVTXPCAPS_LOCALVIEWER         = 0x00000020, /* device can do local viewer */
    D3DVTXPCAPS_TWEENING            = 0x00000040, /* device can do vertex tweening */
    D3DVTXPCAPS_TEXGEN_SPHEREMAP    = 0x00000100, /* device supports D3DTSS_TCI_SPHEREMAP */
    D3DVTXPCAPS_NO_TEXGEN_NONLOCALVIEWER   = 0x00000200, /* device does not support TexGen in non-local
                                                            viewer mode */
} D3DVTXPCAPS;
                                                            //
                                                            // DevCaps2
                                                            //
typedef enum D3DDEVCAPS2
{
    D3DDEVCAPS2_STREAMOFFSET                        = 0x00000001, /* Device supports offsets in streams. Must be set by DX9 drivers */
    D3DDEVCAPS2_DMAPNPATCH                          = 0x00000002, /* Device supports displacement maps for N-Patches*/
    D3DDEVCAPS2_ADAPTIVETESSRTPATCH                 = 0x00000004, /* Device supports adaptive tesselation of RT-patches*/
    D3DDEVCAPS2_ADAPTIVETESSNPATCH                  = 0x00000008, /* Device supports adaptive tesselation of N-patches*/
    D3DDEVCAPS2_CAN_STRETCHRECT_FROM_TEXTURES       = 0x00000010, /* Device supports StretchRect calls with a texture as the source*/
    D3DDEVCAPS2_PRESAMPLEDDMAPNPATCH                = 0x00000020, /* Device supports presampled displacement maps for N-Patches */
    D3DDEVCAPS2_VERTEXELEMENTSCANSHARESTREAMOFFSET  = 0x00000040, /* Vertex elements in a vertex declaration can share the same stream offset */
} D3DDEVCAPS2;
//
// DeclTypes
//
typedef enum D3DDTCAPS
{
    D3DDTCAPS_UBYTE4     = 0x00000001,
    D3DDTCAPS_UBYTE4N    = 0x00000002,
    D3DDTCAPS_SHORT2N    = 0x00000004,
    D3DDTCAPS_SHORT4N    = 0x00000008,
    D3DDTCAPS_USHORT2N   = 0x00000010,
    D3DDTCAPS_USHORT4N   = 0x00000020,
    D3DDTCAPS_UDEC3      = 0x00000040,
    D3DDTCAPS_DEC3N      = 0x00000080,
    D3DDTCAPS_FLOAT16_2  = 0x00000100,
    D3DDTCAPS_FLOAT16_4  = 0x00000200,
} D3DDTCAPS;

typedef enum D3DSPD
{
    D3DSPD_NONE = 0,
D3DSPD_IUNKNOWN = 1
} D3DSPD;

typedef enum D3DCREATE
{
     D3DCREATE_FPU_PRESERVE                 = 0x00000002,
     D3DCREATE_MULTITHREADED                = 0x00000004,

     D3DCREATE_PUREDEVICE                   = 0x00000010,
     D3DCREATE_SOFTWARE_VERTEXPROCESSING    = 0x00000020,
     D3DCREATE_HARDWARE_VERTEXPROCESSING    = 0x00000040,
     D3DCREATE_MIXED_VERTEXPROCESSING       = 0x00000080,

     D3DCREATE_DISABLE_DRIVER_MANAGEMENT    = 0x00000100,
     D3DCREATE_ADAPTERGROUP_DEVICE          = 0x00000200,
     D3DCREATE_DISABLE_DRIVER_MANAGEMENT_EX = 0x00000400,

    // This flag causes the D3D runtime not to alter the focus 
    // window in any way. Use with caution- the burden of supporting
    // focus management events (alt-tab, etc.) falls on the 
    // application, and appropriate responses (switching display
    // mode, etc.) should be coded.
     D3DCREATE_NOWINDOWCHANGES = 0x00000800,

/* D3D9Ex only -- */
 
// Disable multithreading for software vertex processing
     D3DCREATE_DISABLE_PSGP_THREADING       = 0x00002000,
// This flag enables present statistics on device.
     D3DCREATE_ENABLE_PRESENTSTATS          = 0x00004000,
// This flag disables printscreen support in the runtime for this device
     D3DCREATE_DISABLE_PRINTSCREEN          = 0x00008000,

     D3DCREATE_SCREENSAVER                  = 0x10000000
} D3DCREATE;

typedef enum D3D9SetGammaRampFlags
{
     D3DSGR_NO_CALIBRATION = 0x00000000,
     D3DSGR_CALIBRATE = 0x00000001
} D3D9SetGammaRampFlags;

typedef enum D3D9SetCursorPosFlags
{
    D3DCURSOR_IMMEDIATE_UPDATE = 0x00000001

} D3D9SetCursorPosFlags;

typedef enum D3DPRESENT
{
     D3DPRESENT_DONOTWAIT = 0x00000001,
     D3DPRESENT_LINEAR_CONTENT = 0x00000002,

    /* D3D9Ex only -- */
 
     D3DPRESENT_DONOTFLIP = 0x00000004,
     D3DPRESENT_FLIPRESTART = 0x00000008,
     D3DPRESENT_VIDEO_RESTRICT_TO_MONITOR = 0x00000010,
     D3DPRESENT_UPDATEOVERLAYONLY = 0x00000020,
     D3DPRESENT_HIDEOVERLAY = 0x00000040,
     D3DPRESENT_UPDATECOLORKEY = 0x00000080,
     D3DPRESENT_FORCEIMMEDIATE = 0x00000100
} D3DPRESENT;

typedef [helpstring("The following is a list of the values that can be returned by Direct3D methods. See the individual method descriptions for lists of the values that each can return.")]
enum D3D9ERR {
    D3D_OK = 0,
    D3DERR_WRONGTEXTUREFORMAT = -2005530600,
    D3DERR_UNSUPPORTEDCOLOROPERATION = -2005530599,
    D3DERR_UNSUPPORTEDCOLORARG = -2005530598,
    D3DERR_UNSUPPORTEDALPHAOPERATION = -2005530597,
    D3DERR_UNSUPPORTEDALPHAARG = -2005530596,
    D3DERR_TOOMANYOPERATIONS = -2005530595,
    D3DERR_CONFLICTINGTEXTUREFILTER = -2005530594,
    D3DERR_UNSUPPORTEDFACTORVALUE = -2005530593,
    D3DERR_CONFLICTINGRENDERSTATE = -2005530591,
    D3DERR_UNSUPPORTEDTEXTUREFILTER = -2005530590,
    D3DERR_CONFLICTINGTEXTUREPALETTE = -2005530586,
    D3DERR_DRIVERINTERNALERROR = -2005530585,
    D3DERR_NOTFOUND = -2005530522,
    D3DERR_MOREDATA = -2005530521,
    D3DERR_DEVICELOST = -2005530520,
    D3DERR_DEVICENOTRESET = -2005530519,
    D3DERR_NOTAVAILABLE = -2005530518,
    D3DERR_OUTOFVIDEOMEMORY = -2005532292,
    D3DERR_INVALIDDEVICE = -2005530517,
    D3DERR_INVALIDCALL = -2005530516,
    D3DERR_DRIVERINVALIDCALL = -2005530515,
    D3DERR_WASSTILLDRAWING = -2005532132,
    D3DOK_NOAUTOGEN = -2005530513,

     D3DERR_DEVICEREMOVED = 0x88760870,
     S_NOT_RESIDENT = 0x8760875,
     S_RESIDENT_IN_SHARED_MEMORY = 0x8760876,
     S_PRESENT_MODE_CHANGED = 0x8760877,
     S_PRESENT_OCCLUDED = 0x8760878,
     D3DERR_DEVICEHUNG = 0x88760874,
     D3DERR_UNSUPPORTEDOVERLAY = 0x8876087b,
     D3DERR_UNSUPPORTEDOVERLAYFORMAT = 0x8876087c,
     D3DERR_CANNOTPROTECTCONTENT = 0x8876087d,
     D3DERR_UNSUPPORTEDCRYPTO = 0x8876087e,
     D3DERR_PRESENT_STATISTICS_DISJOINT = 0x88760884
} D3D9ERR;

interface IDirect3DDevice9;
interface IDirect3DSurface9;
interface IDirect3DResource9;
interface IDirect3DSwapChain9;
interface IDirect3DTexture9;
interface IDirect3DBaseTexture9;
interface IDirect3DVolumeTexture9;
interface IDirect3DVolume9;
interface IDirect3DCubeTexture9;
interface IDirect3DVertexBuffer9;
interface IDirect3DIndexBuffer9;
interface IDirect3DStateBlock9;
interface IDirect3DVertexDeclaration9;
interface IDirect3DVertexShader9;
interface IDirect3DPixelShader9;
interface IDirect3DQuery9;
[
    odl,
        uuid(81BDCBCA-64D4-426D-AE8D-AD0147F4275C),
        helpstring("Applications use the methods of the IDirect3D9 interface to create Microsoft Direct3D objects and set up the environment. This interface includes methods for enumerating and retrieving capabilities of the device.")
]
interface IDirect3D9 : stdole.IUnknown {
    [helpstring("Registers a pluggable software device. Software devices provide software rasterization enabling applications to access a variety of software rasterizers.")]
        HRESULT _stdcall RegisterSoftwareDevice([in] void* InitializeFunction);
    [helpstring("Returns the number of adapters on the system.")]
        int _stdcall GetAdapterCount();
    [helpstring("Describes the physical display adapters present in the system when the IDirect3D9 interface was instantiated.")]
        HRESULT _stdcall GetAdapterIdentifier(
            [in] int Adapter,
            [in] long flags,
            [in, out] D3DADAPTER_IDENTIFIER9* Identifier);
    [helpstring("Returns the number of display modes available on this adapter.")]
        int _stdcall GetAdapterModeCount(
            [in] int Adapter,
            [in] D3DFORMAT Format);
    [helpstring("Queries the device to determine whether the specified adapter supports the requested format and display mode. This method could be used in a loop to enumerate all the available adapter modes.")]
        HRESULT _stdcall EnumAdapterModes(
            [in] int Adapter,
            [in] D3DFORMAT Format,
            [in] int Mode,
            [in, out] D3DDISPLAYMODE* DisplayMode);
    [helpstring("Retrieves the current display mode of the adapter.")]
        HRESULT _stdcall GetAdapterDisplayMode(
            [in] int Adapter,
            [in, out] D3DDISPLAYMODE* DisplayMode);
    [helpstring("Verifies whether a hardware accelerated device type can be used on this adapter.")]
        HRESULT _stdcall CheckDeviceType(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT DisplayFormat,
            [in] D3DFORMAT BackBufferFormat,
            [in] long bWindowed);
    [helpstring("Determines whether a surface format is available as a specified resource type and can be used as a texture, depth-stencil buffer, or render target, or any combination of the three, on a device representing this adapter.")]
        HRESULT _stdcall CheckDeviceFormat(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT AdapterFormat,
            [in] long Usage,
            [in] D3DRESOURCETYPE RType,
            [in] D3DFORMAT CheckFormat);
    [helpstring("Determines if a multisampling technique is available on this device.")]
        HRESULT _stdcall CheckDeviceMultiSampleType(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT SurfaceFormat,
            [in] long Windowed,
            [in] D3DMULTISAMPLE_TYPE MultiSampleType,
            [out] long* pQualityLevels);
    [helpstring("Determines whether a depth-stencil format is compatible with a render-target format in a particular display mode.")]
        HRESULT _stdcall CheckDepthStencilMatch(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT AdapterFormat,
            [in] D3DFORMAT RenderTargetFormat,
            [in] D3DFORMAT DepthStencilFormat);
    [helpstring("Tests the device to see if it supports conversion from one display format to another.")]
        HRESULT _stdcall CheckDeviceFormatConversion(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT SourceFormat,
            [in] D3DFORMAT TargetFormat);
    [helpstring("Retrieves device-specific information about a device.")]
        HRESULT _stdcall GetDeviceCaps(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [out] D3DCAPS9* pCaps);
    [helpstring("Returns the handle of the monitor associated with the Direct3D object.")]
        long _stdcall GetAdapterMonitor([in] int Adapter);
    [helpstring("Creates a device to represent the display adapter.")]
        HRESULT _stdcall CreateDevice(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] LongPtr hFocusWindow,
            [in] D3DCREATE BehaviorFlags,
            [in, out] D3DPRESENT_PARAMETERS* pPresentationParameters,
            [out, retval] IDirect3DDevice9** ppReturnedDeviceInterface);
};


[
    odl,
        uuid(D0223B96-BF7A-43FD-92BD-A43B0D82B9EB),
        helpstring("Applications use the methods of the IDirect3DDevice9 interface to perform DrawPrimitive-based rendering, create resources, work with system-level variables, adjust gamma ramp levels, work with palettes, and create shaders.")
]
interface IDirect3DDevice9 : stdole.IUnknown {
    [helpstring("Reports the current cooperative-level status of the Direct3D device for a windowed or full-screen application.")]
        HRESULT _stdcall TestCooperativeLevel();
    [helpstring("Returns an estimate of the amount of available texture memory.")]
        long _stdcall GetAvailableTextureMem();
    [helpstring("Evicts all managed resources, including both Direct3D and driver-managed resources.")]
        HRESULT _stdcall EvictManagedResources();
    [helpstring("Returns an interface to the instance of the Direct3D object that created the device.")]
        HRESULT _stdcall GetDirect3D([out, retval] IDirect3D9** ppD3D9);
    [helpstring("Retrieves the capabilities of the rendering device.")]
        HRESULT _stdcall GetDeviceCaps([out] D3DCAPS9* pCaps);
    [helpstring("Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.")]
        HRESULT _stdcall GetDisplayMode(
            [in] long iSwapChain,
            [out] D3DDISPLAYMODE* pMode);
    [helpstring("Retrieves the creation parameters of the device.")]
        HRESULT _stdcall GetCreationParameters([out] D3DDEVICE_CREATION_PARAMETERS* pParameters);
    [helpstring("Sets properties for the cursor.")]
        HRESULT _stdcall SetCursorProperties(
            [in] int XHotSpot,
            [in] int YHotSpot,
            [in] IDirect3DSurface9* pCursorBitmap);
    [helpstring("Sets the cursor position and update options.")]
        void _stdcall SetCursorPosition(
            [in] int X,
            [in] int Y,
            [in] D3D9SetCursorPosFlags flags);
    [helpstring("Displays or hides the cursor.")]
        long _stdcall ShowCursor([in] long bShow);
    [helpstring("Creates an additional swap chain for rendering multiple views.")]
        HRESULT _stdcall CreateAdditionalSwapChain(
            [in, out] D3DPRESENT_PARAMETERS* pPresentationParameters,
            [out, retval] IDirect3DSwapChain9** ppSwapChain);
    [helpstring("Gets a pointer to a swap chain.")]
        HRESULT _stdcall GetSwapChain(
            [in] int iSwapChain,
            [in] IDirect3DSwapChain9** ppSwapChain);
    [helpstring("Gets the number of implicit swap chains.")]
        long _stdcall GetNumberOfSwapChains();
    [helpstring("Resets the type, size, and format of the swap chain.")]
        HRESULT _stdcall Reset([in, out] D3DPRESENT_PARAMETERS* pPresentationParameters);
    [helpstring("Presents the contents of the next buffer in the sequence of back buffers owned by the device.")]
        HRESULT _stdcall Present(
            [in] void* pSourceRect,
            [in] void* pDestRect,
            [in] LongPtr hDestWindowOverride,
            [in] void* pDirtyRegion);
    [helpstring("Retrieves a back buffer from the device's swap chain.")]
        HRESULT _stdcall GetBackBuffer(
            [in] int iSwapChain,
            [in] int BackBuffer,
            [in] D3DBACKBUFFER_TYPE Type,
            [out, retval] IDirect3DSurface9** ppBackBuffer);
    [helpstring("Returns information describing the raster of the monitor on which the swap chain is presented.")]
        HRESULT _stdcall GetRasterStatus(
            [in] int iSwapChain,
            [out] D3DRASTER_STATUS* pRasterStatus);
    [helpstring("This method allows the use of GDI dialog boxes in full-screen mode applications.")]
        HRESULT _stdcall SetDialogBoxMode([in] int bEnableDialogs);
    [helpstring("Sets the gamma correction ramp for the implicit swap chain. This method will affect the entire screen (not just the active window if you are running in windowed mode).")]
        void _stdcall SetGammaRamp(
            [in] int iSwapChain,
            [in] D3D9SetGammaRampFlags flags,
            [in] D3DGAMMARAMP* pRamp);
    [helpstring("Retrieves the gamma correction ramp for the swap chain.")]
        void _stdcall GetGammaRamp(
            [in] int iSwapChain,
            [in, out] D3DGAMMARAMP* pRamp);
    [helpstring("Creates a texture resource.")]
        HRESULT _stdcall CreateTexture(
            [in] int Width,
            [in] int Height,
            [in] int Levels,
            [in] D3DUSAGE Usage,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DTexture9** ppTexture,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a volume texture resource.")]
        HRESULT _stdcall CreateVolumeTexture(
            [in] int Width,
            [in] int Height,
            [in] int Depth,
            [in] int Levels,
            [in] D3DUSAGE Usage,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DVolumeTexture9** ppVolumeTexture,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a cube texture resource.")]
        HRESULT _stdcall CreateCubeTexture(
            [in] int EdgeLength,
            [in] int Levels,
            [in] D3DUSAGE Usage,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DCubeTexture9** ppCubeTexture,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a vertex buffer.")]
        HRESULT _stdcall CreateVertexBuffer(
            [in] int Length,
            [in] D3DUSAGE Usage,
            [in] D3D9VertexFormatBits FVF,
            [in] D3DPOOL Pool,
            [out] IDirect3DVertexBuffer9** ppVertexBuffer,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates an index buffer.")]
        HRESULT _stdcall CreateIndexBuffer(
            [in] int Length,
            [in] D3DUSAGE Usage,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DIndexBuffer9** ppIndexBuffer,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a render-target surface.")]
        HRESULT _stdcall CreateRenderTarget(
            [in] int Width,
            [in] int Height,
            [in] D3DFORMAT Format,
            [in] D3DMULTISAMPLE_TYPE MultiSample,
            [in] long MultiSampleQuality,
            [in] long Lockable,
            [out] IDirect3DSurface9** ppSurface,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a depth-stencil resource.")]
        HRESULT _stdcall CreateDepthStencilSurface(
            [in] int Width,
            [in] int Height,
            [in] D3DFORMAT Format,
            [in] D3DMULTISAMPLE_TYPE MultiSample,
            [in] long MultiSampleQuality,
            [in] long Discard,
            [out] IDirect3DSurface9** ppSurface,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Copies rectangular subsets of pixels from one surface to another.")]
        HRESULT _stdcall UpdateSurface(
            [in] IDirect3DSurface9* pSourceSurface,
            [in] void* pSourceRect,
            [in] IDirect3DSurface9* pDestinationSurface,
            [in] void* pDestinationPoint);
    [helpstring("Updates the dirty portions of a texture.")]
        HRESULT _stdcall UpdateTexture(
            [in] IDirect3DBaseTexture9* pSourceTexture,
            [in] IDirect3DBaseTexture9* pDestinationTexture);
    [helpstring("Copies the render-target data from device memory to system memory.")]
        HRESULT _stdcall GetRenderTargetData(
            [in] IDirect3DSurface9* pRenderTarget,
            [in] IDirect3DSurface9* pDestSurface);
    [helpstring("Generates a copy of the device's front buffer and places that copy in a system memory buffer provided by the application.")]
        HRESULT _stdcall GetFrontBufferData(
            [in] int iSwapChain,
            [in] IDirect3DSurface9* pDestSurface);
    [helpstring("Copy the contents of the source rectangle to the destination rectangle. The source rectangle can be stretched and filtered by the copy. This function is often used to change the aspect ratio of a video stream.")]
        HRESULT _stdcall StretchRect(
            [in] IDirect3DSurface9* pSourceSurface,
            [in] void* pSourceRect,
            [in] IDirect3DSurface9* pDestSurface,
            [in] void* pDestRect,
            [in] D3DTEXTUREFILTERTYPE Filter);
    [helpstring("Allows an application to fill a rectangular area of a D3DPOOL_DEFAULT surface with a specified color.")]
        HRESULT _stdcall ColorFill(
            [in] IDirect3DSurface9* pSurface,
            [in] void* pRect,
            [in] int color);
    [helpstring("Create an off-screen surface.")]
        HRESULT _stdcall CreateOffscreenPlainSurface(
            [in] int Width,
            [in] int Height,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DSurface9** ppSurface,
            [in, defaultvalue(0)] long pSharedHandle);
    [helpstring("Sets a new color buffer for the device.")]
        HRESULT _stdcall SetRenderTarget(
            [in] int RenderTargetIndex,
            [in] IDirect3DSurface9* pRenderTarget);
    [helpstring("Retrieves a render-target surface.")]
        HRESULT _stdcall GetRenderTarget(
            [in] int RenderTargetIndex,
            [out, retval] IDirect3DSurface9** ppRenderTarget);
    [helpstring("Sets the depth stencil surface.")]
        HRESULT _stdcall SetDepthStencilSurface([in] IDirect3DSurface9* pNewZStencil);
    [helpstring("Gets the depth-stencil surface owned by the Direct3DDevice object.")]
        HRESULT _stdcall GetDepthStencilSurface([out, retval] IDirect3DSurface9** ppZStencilSurface);
    [helpstring("Begins a scene.")]
        HRESULT _stdcall BeginScene();
    [helpstring("Ends a scene that was begun by calling IDirect3DDevice9.BeginScene.")]
        HRESULT _stdcall EndScene();
    [helpstring("Clears one or more surfaces such as a render target, multiple render targets, a stencil buffer, and a depth buffer.")]
        HRESULT _stdcall Clear(
            [in] long Count,
            [in] void* pRects,
            [in] D3DCLEAR flags,
            [in] int color,
            [in] single Z,
            [in] long Stencil);
    [helpstring("Sets a single device transformation-related state.")]
        HRESULT _stdcall SetTransform(
            [in] D3DTRANSFORMSTATETYPE State,
            [in] D3DMATRIX* pMatrix);
    [helpstring("Retrieves a matrix describing a transformation state.")]
        HRESULT _stdcall GetTransform(
            [in] D3DTRANSFORMSTATETYPE State,
            [out] D3DMATRIX* pMatrix);
    [helpstring("Multiplies a device's world, view, or projection matrices by a specified matrix.")]
        HRESULT _stdcall MultiplyTransform(
            [in] D3DTRANSFORMSTATETYPE State,
            [in] D3DMATRIX* pMatrix);
    [helpstring("Sets the viewport parameters for the device.")]
        HRESULT _stdcall SetViewport([in] D3DVIEWPORT9* pViewport);
    [helpstring("Retrieves the viewport parameters currently set for the device.")]
        HRESULT _stdcall GetViewport([out] D3DVIEWPORT9* pViewport);
    [helpstring("Sets the material properties for the device.")]
        HRESULT _stdcall SetMaterial([in] D3DMATERIAL9* pMaterial);
    [helpstring("Retrieves the current material properties for the device.")]
        HRESULT _stdcall GetMaterial([out] D3DMATERIAL9* pMaterial);
    [helpstring("Assigns a set of lighting properties for this device.")]
        HRESULT _stdcall SetLight(
            [in] int Index,
            [in] D3DLIGHT9* pLight);
    [helpstring("Retrieves a set of lighting properties that this device uses.")]
        HRESULT _stdcall GetLight(
            [in] int Index,
            [out] D3DLIGHT9* pLight);
    [helpstring("Enables or disables a set of lighting parameters within a device.")]
        HRESULT _stdcall LightEnable(
            [in] int LightIndex,
            [in] int bEnable);
    [helpstring("Retrieves the activity status - enabled or disabled - for a set of lighting parameters within a device.")]
        HRESULT _stdcall GetLightEnable(
            [in] int Index,
            [out, retval] int* pEnable);
    [helpstring("Sets the coefficients of a user-defined clipping plane for the device.")]
        HRESULT _stdcall SetClipPlane(
            [in] int Index,
            [in] single* pPlane);
    [helpstring("Retrieves the coefficients of a user-defined clipping plane for the device.")]
        HRESULT _stdcall GetClipPlane(
            [in] int Index,
            [out, retval] single* pPlane);
    [helpstring("Sets a single device render-state parameter.")]
        HRESULT _stdcall SetRenderState(
            [in] D3DRENDERSTATETYPE State,
            [in] long Value);
    [helpstring("Retrieves a render-state value for a device.")]
        HRESULT _stdcall GetRenderState(
            [in] D3DRENDERSTATETYPE State,
            [out, retval] long* pValue);
    [helpstring("Creates a new state block that contains the values for all device states, vertex-related states, or pixel-related states.")]
        HRESULT _stdcall CreateStateBlock(
            [in] D3DSTATEBLOCKTYPE Type,
            [out, retval] IDirect3DStateBlock9** ppSB);
    [helpstring("Signals Direct3D to begin recording a device-state block.")]
        HRESULT _stdcall BeginStateBlock();
    [helpstring("Signals Direct3D to stop recording a device-state block and retrieve a pointer to the state block interface.")]
        HRESULT _stdcall EndStateBlock([out, retval] IDirect3DStateBlock9** ppSB);
    [helpstring("Sets the clip status.")]
        HRESULT _stdcall SetClipStatus([in] D3DCLIPSTATUS9* pClipStatus);
    [helpstring("Retrieves the clip status.")]
        HRESULT _stdcall GetClipStatus([out] D3DCLIPSTATUS9* pClipStatus);
    [helpstring("Retrieves a texture assigned to a stage for a device.")]
        HRESULT _stdcall GetTexture(
            [in] long Stage,
            [out, retval] IDirect3DBaseTexture9** ppTexture);
    [helpstring("Assigns a texture to a stage for a device.")]
        HRESULT _stdcall SetTexture(
            [in] long Sampler,
            [in] IDirect3DBaseTexture9* pTexture);
    [helpstring("Retrieves a state value for an assigned texture.")]
        HRESULT _stdcall GetTextureStageState(
            [in] long Stage,
            [in] D3DTEXTURESTAGESTATETYPE Type,
            [out, retval] long* pValue);
    [helpstring("Sets the state value for the currently assigned texture.")]
        HRESULT _stdcall SetTextureStageState(
            [in] long Stage,
            [in] D3DTEXTURESTAGESTATETYPE Type,
            [in] long Value);
    [helpstring("Gets the sampler state value.")]
        HRESULT _stdcall GetSamplerState(
            [in] long Sampler,
            [in] D3DSAMPLERSTATETYPE Type,
            [out] long* pValue);
    [helpstring("Sets the sampler state value.")]
        HRESULT _stdcall SetSamplerState(
            [in] long Sampler,
            [in] D3DSAMPLERSTATETYPE Type,
            [in] long Value);
    [helpstring("Reports the device's ability to render the current texture-blending operations and arguments in a single pass.")]
        HRESULT _stdcall ValidateDevice([out, retval] long* pNumPasses);
    [helpstring("Sets palette entries.")]
        HRESULT _stdcall SetPaletteEntries(
            [in] int PaletteNumber,
            [in] PALETTEENTRY* pEntries);
    [helpstring("Retrieves palette entries.")]
        HRESULT _stdcall GetPaletteEntries(
            [in] int PaletteNumber,
            [in, out] PALETTEENTRY* pEntries);
    [helpstring("Sets the current texture palette.")]
        HRESULT _stdcall SetCurrentTexturePalette([in] int PaletteNumber);
    [helpstring("Retrieves the current texture palette.")]
        HRESULT _stdcall GetCurrentTexturePalette([out, retval] int* pPaletteNumber);
    [helpstring("Sets the scissor rectangle.")]
        HRESULT _stdcall SetScissorRect([in] void* pRect);
    [helpstring("Gets the scissor rectangle.")]
        HRESULT _stdcall GetScissorRect([out] RECT* pRect);
    [helpstring("Use this method to switch between software and hardware vertex processing.")]
        HRESULT _stdcall SetSoftwareVertexProcessing([in] long bSoftware);
    [helpstring("Gets the vertex processing (hardware or software) mode.")]
        long _stdcall GetSoftwareVertexProcessing();
    [helpstring("Enable or disable N-patches.")]
        HRESULT _stdcall SetNPatchMode([in] single nSegments);
    [helpstring("Gets the N-patch mode segments.")]
        single _stdcall GetNPatchMode();
    [helpstring("Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.")]
        HRESULT _stdcall DrawPrimitive(
            [in] D3DPRIMITIVETYPE PrimitiveType,
            [in] int StartVertex,
            [in] int PrimitiveCount);
    [helpstring("Based on indexing, renders the specified geometric primitive into an array of vertices.")]
        HRESULT _stdcall DrawIndexedPrimitive(
            [in] D3DPRIMITIVETYPE Type,
            [in] int BaseVertexIndex,
            [in] int MinIndex,
            [in] int NumVertices,
            [in] int StartIndex,
            [in] int PrimitiveCount);
    [helpstring("Renders data specified by a user memory pointer as a sequence of geometric primitives of the specified type.")]
        HRESULT _stdcall DrawPrimitiveUP(
            [in] D3DPRIMITIVETYPE PrimitiveType,
            [in] int PrimitiveCount,
            [in] void* pVertexStreamZeroData,
            [in] int VertexStreamZeroStride);
    [helpstring("Renders the specified geometric primitive with data specified by a user memory pointer.")]
        HRESULT _stdcall DrawIndexedPrimitiveUP(
            [in] D3DPRIMITIVETYPE PrimitiveType,
            [in] int MinVertexIndex,
            [in] int NumVertices,
            [in] int PrimitiveCount,
            [in] void* pIndexData,
            [in] D3DFORMAT IndexDataFormat,
            [in] void* pVertexStreamZeroData,
            [in] int VertexStreamZeroStride);
    [helpstring("Applies the vertex processing defined by the vertex shader to the set of input data streams, generating a single stream of interleaved vertex data to the destination vertex buffer.")]
        HRESULT _stdcall ProcessVertices(
            [in] int SrcStartIndex,
            [in] int DestIndex,
            [in] int VertexCount,
            [in] IDirect3DVertexBuffer9* pDestBuffer,
            [in] IDirect3DVertexDeclaration9* pVertexDecl,
            [in] long flags);
    [helpstring("Create a vertex shader declaration from the device and the vertex elements.")]
        HRESULT _stdcall CreateVertexDeclaration(
            [in] D3DVERTEXELEMENT9* pVertexElements,
            [out, retval] IDirect3DVertexDeclaration9** ppDecl);
    [helpstring("Sets a Vertex Declaration.")]
        HRESULT _stdcall SetVertexDeclaration([in] IDirect3DVertexDeclaration9* pDecl);
    [helpstring("Gets a vertex shader declaration.")]
        HRESULT _stdcall GetVertexDeclaration([out, retval] IDirect3DVertexDeclaration9** ppDecl);
    [helpstring("Sets the current vertex stream declaration.")]
        HRESULT _stdcall SetFVF([in] D3D9VertexFormatBits FVF);
    [helpstring("Gets the fixed vertex function declaration.")]
        HRESULT _stdcall GetFVF([out, retval] D3D9VertexFormatBits* pFVF);
    [helpstring("Creates a vertex shader.")]
        HRESULT _stdcall CreateVertexShader(
            [in] void* pFunction,
            [out, retval] IDirect3DVertexShader9** ppShader);
    [helpstring("Sets the vertex shader.")]
        HRESULT _stdcall SetVertexShader([in] IDirect3DVertexShader9* pShader);
    [helpstring("Retrieves the currently set vertex shader.")]
        HRESULT _stdcall GetVertexShader([out, retval] IDirect3DVertexShader9** ppShader);
    [helpstring("Sets a floating-point vertex shader constant.")]
        HRESULT _stdcall SetVertexShaderConstantF(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets a floating-point vertex shader constant.")]
        HRESULT _stdcall GetVertexShaderConstantF(
            [in] int StartRegister,
            [in, out] single* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Sets an integer vertex shader constant.")]
        HRESULT _stdcall SetVertexShaderConstantI(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets an integer vertex shader constant.")]
        HRESULT _stdcall GetVertexShaderConstantI(
            [in] int StartRegister,
            [in, out] int* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Sets a boolean vertex shader constant.")]
        HRESULT _stdcall SetVertexShaderConstantB(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets a boolean vertex shader constant.")]
        HRESULT _stdcall GetVertexShaderConstantB(
            [in] int StartRegister,
            [in, out] int* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Binds a vertex buffer to a device data stream.")]
        HRESULT _stdcall SetStreamSource(
            [in] int StreamNumber,
            [in] IDirect3DVertexBuffer9* pStreamData,
            [in] int OffsetInBytes,
            [in] int Stride);
    [helpstring("Retrieves a vertex buffer bound to the specified data stream.")]
        HRESULT _stdcall GetStreamSource(
            [in] int StreamNumber,
            [in, out] IDirect3DVertexBuffer9** ppStreamData,
            [out] int* pOffsetInBytes,
            [out] int* pStride);
    [helpstring("Sets the stream source frequency divider value. This may be used to draw several instances of geometry.")]
        HRESULT _stdcall SetStreamSourceFreq(
            [in] int StreamNumber,
            [in] int FrequencyParameter);
    [helpstring("Gets the stream source frequency divider value.")]
        HRESULT _stdcall GetStreamSourceFreq(
            [in] int StreamNumber,
            [out, retval] int* pDivider);
    [helpstring("Sets index data.")]
        HRESULT _stdcall SetIndices([in] IDirect3DIndexBuffer9* pIndexData);
    [helpstring("Retrieves index data.")]
        HRESULT _stdcall GetIndices(
            [out] IDirect3DIndexBuffer9** ppIndexData,
            [out] int* pBaseVertexIndex);
    [helpstring("Creates a pixel shader.")]
        HRESULT _stdcall CreatePixelShader(
            [in] void* pFunction,
            [out, retval] IDirect3DPixelShader9** ppShader);
    [helpstring("Sets the pixel shader.")]
        HRESULT _stdcall SetPixelShader([in] IDirect3DPixelShader9* pShader);
    [helpstring("Retrieves the currently set pixel shader.")]
        HRESULT _stdcall GetPixelShader([out, retval] IDirect3DPixelShader9** ppShader);
    [helpstring("Sets a floating-point pixel shader constant.")]
        HRESULT _stdcall SetPixelShaderConstantF(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets a floating-point pixel shader constant.")]
        HRESULT _stdcall GetPixelShaderConstantF(
            [in] int StartRegister,
            [in, out] single* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Sets an integer pixel shader constant.")]
        HRESULT _stdcall SetPixelShaderConstantI(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets an integer pixel shader constant.")]
        HRESULT _stdcall GetPixelShaderConstantI(
            [in] int StartRegister,
            [in, out] int* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Sets a boolean pixel shader constant.")]
        HRESULT _stdcall SetPixelShaderConstantB(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets a boolean pixel shader constant.")]
        HRESULT _stdcall GetPixelShaderConstantB(
            [in] int StartRegister,
            [in, out] int* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Draws a rectangular patch using the currently set streams.")]
        HRESULT _stdcall DrawRectPatch(
            [in] int Handle,
            [in] single* pNumSegs,
            [in] D3DRECTPATCH_INFO* pRectPatchInfo);
    [helpstring("Draws a triangular patch using the currently set streams.")]
        HRESULT _stdcall DrawTriPatch(
            [in] int Handle,
            [in] single* pNumSegs,
            [in] D3DTRIPATCH_INFO* pTriPatchInfo);
    [helpstring("Frees a cached high-order patch.")]
        HRESULT _stdcall DeletePatch([in] long Handle);
    [helpstring("Creates a status query.")]
        HRESULT _stdcall CreateQuery(
            [in] D3DQUERYTYPE Type,
            [out, retval] IDirect3DQuery9** ppQuery);
};

[
    odl,
        uuid(05EEC05D-8F7D-4362-B999-D1BAF357C704),
        helpstring("Applications use the methods of the IDirect3DResource9 interface to query and prepare resources.")
]
interface IDirect3DResource9 : stdole.IUnknown{
    [helpstring("Retrieves the device associated with a resource.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9 * *ppDevice);
    [helpstring("Associates data with the resource that is intended for use by the application, not by Direct3D. Data is passed by value, and multiple sets of data can be associated with a single resource.")]
        HRESULT _stdcall SetPrivateData(
            [in] UUID* refguid,
            [in] void* Data,
            [in] long SizeOfData,
            [in] D3DSPD flags);
    [helpstring("Copies the private data associated with the resource to a provided buffer.")]
        HRESULT _stdcall GetPrivateData(
            [in] UUID* refguid,
            [in] void* Data,
            [in, out] long* SizeOfData);
    [helpstring("Frees the specified private data associated with this resource.")]
        HRESULT _stdcall FreePrivateData([in] UUID* refguid);
    [helpstring("Assigns the priority of a resource for scheduling purposes.")]
        long _stdcall SetPriority([in] D3D9_RESOURCE_PRIORITY PriorityNew);
    [helpstring("Retrieves the priority for this resource.")]
        D3D9_RESOURCE_PRIORITY _stdcall GetPriority();
    [helpstring("Preloads a managed resource.")]
        void _stdcall PreLoad();
    [helpstring("Returns the type of the resource.")]
        D3DRESOURCETYPE _stdcall GetType();
};

[
    odl,
        uuid(0CFBAF3A-9FF6-429A-99B3-A2796AF8B89B),
        helpstring("Applications use the methods of the IDirect3DSurface9 interface to query and prepare surfaces.")
]
interface IDirect3DSurface9 : IDirect3DResource9 {
    [helpstring("Provides access to the parent cube texture or texture (mipmap) object, if this surface is a child level of a cube texture or a mipmap. This method can also provide access to the parent swap chain if the surface is a back-buffer child.")]
        HRESULT _stdcall GetContainer(
            [in] UUID* riid,
            [out] void** ppContainer);
    [helpstring("Retrieves a description of the surface.")]
        HRESULT _stdcall GetDesc([out] D3DSURFACE_DESC* pDesc);
    [helpstring("Locks a rectangle on a surface.")]
        HRESULT _stdcall LockRect(
            [out] D3DLOCKED_RECT* pLockedRect,
            [in] void* pRect,
            [in] D3DLOCK flags);
    [helpstring("Unlocks a rectangle on a surface.")]
        HRESULT _stdcall UnlockRect();
    [helpstring("Retrieves a device context.")]
        HRESULT _stdcall GetDC([out, retval] LongPtr* phdc);
    [helpstring("Release a device context handle.")]
        HRESULT _stdcall ReleaseDC([in] LongPtr hdc);
};



[
    odl,
        uuid(794950F2-ADFC-458A-905E-10A10B0B503B),
        helpstring("Applications use the methods of the IDirect3DSwapChain9 interface to manipulate a swap chain.")
]
interface IDirect3DSwapChain9 : stdole.IUnknown {
    [helpstring("Presents the contents of the next buffer in the sequence of back buffers owned by the swap chain.")]
        HRESULT _stdcall Present(
            [in] void* pSourceRect,
            [in] void* pDestRect,
            [in] LongPtr hDestWindowOverride,
            [in] void* pDirtyRegion,
            [in] long dwFlags);
    [helpstring("Generates a copy of the swapchain's front buffer and places that copy in a system memory buffer provided by the application.")]
        HRESULT _stdcall GetFrontBufferData([in] IDirect3DSurface9* pDestSurface);
    [helpstring("Retrieves a back buffer from the swap chain of the device.")]
        HRESULT _stdcall GetBackBuffer(
            [in] int BackBuffer,
            [in] D3DBACKBUFFER_TYPE Type,
            [out, retval] IDirect3DSurface9** ppBackBuffer);
    [helpstring("Returns information describing the raster of the monitor on which the swap chain is presented.")]
        HRESULT _stdcall GetRasterStatus([out] D3DRASTER_STATUS* pRasterStatus);
    [helpstring("Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.")]
        HRESULT _stdcall GetDisplayMode([out] D3DDISPLAYMODE* pMode);
    [helpstring("Retrieves the device associated with the swap chain.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9** ppDevice);
    [helpstring("Retrieves the presentation parameters associated with a swap chain.")]
        HRESULT _stdcall GetPresentParameters([out, retval] D3DPRESENT_PARAMETERS* pPresentationParameters);
};

[
    odl,
        uuid(580CA87E-1D3C-4D54-991D-B7D3E3C298CE),
        helpstring("Applications use the methods of the IDirect3DBaseTexture9 interface to manipulate texture resources including cube and volume textures.")
]
interface IDirect3DBaseTexture9 : IDirect3DResource9 {
    [helpstring("Sets the most detailed level-of-detail for a managed texture.")]
        long _stdcall SetLOD([in] long LODNew);
    [helpstring("Returns a value clamped to the maximum level-of-detail set for a managed texture (this method is not supported for an unmanaged texture).")]
        long _stdcall GetLOD();
    [helpstring("Returns the number of texture levels in a multilevel texture.")]
        long _stdcall GetLevelCount();
    [helpstring("Set the filter type that is used for automatically generated mipmap sublevels.")]
        HRESULT _stdcall SetAutoGenFilterType([in] D3DTEXTUREFILTERTYPE FilterType);
    [helpstring("Get the filter type that is used for automatically generated mipmap sublevels.")]
        D3DTEXTUREFILTERTYPE _stdcall GetAutoGenFilterType();
    [helpstring("Generate mipmap sublevels.")]
        void _stdcall GenerateMipSubLevels();
};

[
    odl,
        uuid(85C31227-3DE5-4F00-9B3A-F11AC38C18B5),
        helpstring("Applications use the methods of the IDirect3DTexture9 interface to manipulate a texture resource.")
]
interface IDirect3DTexture9 : IDirect3DBaseTexture9 {
    [helpstring("Retrieves a level description of a texture resource.")]
        HRESULT _stdcall GetLevelDesc(
            [in] int Level,
            [out] D3DSURFACE_DESC* pDesc);
    [helpstring("Retrieves the specified texture surface level.")]
        HRESULT _stdcall GetSurfaceLevel(
            [in] int Level,
            [out, retval] IDirect3DSurface9** ppSurfaceLevel);
    [helpstring("Locks a rectangle on a texture resource.")]
        HRESULT _stdcall LockRect(
            [in] int Level,
            [out] D3DLOCKED_RECT* pLockedRect,
            [in] void* pRect,
            [in] D3DLOCK flags);
    [helpstring("Unlocks a rectangle on a texture resource.")]
        HRESULT _stdcall UnlockRect([in] int Level);
    [helpstring("Adds a dirty region to a texture resource.")]
        HRESULT _stdcall AddDirtyRect([in] void* pDirtyRect);
};



[
    odl,
        uuid(2518526C-E789-4111-A7B9-47EF328D13E6),
        helpstring("Applications use the methods of the IDirect3DVolumeTexture9 interface to manipulate a volume texture resource.")
]
interface IDirect3DVolumeTexture9 : IDirect3DBaseTexture9 {
    [helpstring("Retrieves a level description of a volume texture resource.")]
        HRESULT _stdcall GetLevelDesc(
            [in] int Level,
            [out] D3DVOLUME_DESC* pDesc);
    [helpstring("Retrieves the specified volume texture level.")]
        HRESULT _stdcall GetVolumeLevel(
            [in] int Level,
            [out, retval] IDirect3DVolume9** ppVolumeLevel);
    [helpstring("Locks a box on a volume texture resource.")]
        HRESULT _stdcall LockBox(
            [in] int Level,
            [out] D3DLOCKED_BOX* pLockedVolume,
            [in] void* pBox,
            [in] D3DLOCK flags);
    [helpstring("Unlocks a box on a volume texture resource.")]
        HRESULT _stdcall UnlockBox([in] int Level);
    [helpstring("Adds a dirty region to a volume texture resource.")]
        HRESULT _stdcall AddDirtyBox([in] void* pDirtyBox);
};

[
    odl,
        uuid(24F416E6-1F67-4AA7-B88E-D33F6F3128A1),
        helpstring("Applications use the methods of the IDirect3DVolume9 interface to manipulate volume resources.")
]
interface IDirect3DVolume9 : stdole.IUnknown {
    [helpstring("Retrieves the device associated with a volume.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9** ppDevice);
    [helpstring("Associates data with the volume that is intended for use by the application, not by Direct3D.")]
        HRESULT _stdcall SetPrivateData(
            [in] UUID refguid,
            [in] void* pData,
            [in] int SizeOfData,
            [in] D3DSPD flags);
    [helpstring("Copies the private data associated with the volume to a provided buffer.")]
        HRESULT _stdcall GetPrivateData(
            [in] UUID refguid,
            [in, out] void* pData,
            [in, out] int* pSizeOfData);
    [helpstring("Frees the specified private data associated with this volume.")]
        HRESULT _stdcall FreePrivateData([in] UUID refguid);
    [helpstring("Provides access to the parent volume texture object, if this surface is a child level of a volume texture.")]
        HRESULT _stdcall GetContainer(
            [in] UUID riid,
            [out, retval] long* ppContainer);
    [helpstring("Retrieves a description of the volume.")]
        HRESULT _stdcall GetDesc([out] D3DVOLUME_DESC* pDesc);
    [helpstring("Locks a box on a volume resource.")]
        HRESULT _stdcall LockBox(
            [out] D3DLOCKED_BOX* pLockedVolume,
            [in] void* pBox,
            [in] D3DLOCK flags);
    [helpstring("Unlocks a box on a volume resource.")]
        HRESULT _stdcall UnlockBox();
};

[
    odl,
        uuid(FFF32F81-D953-473A-9223-93D652ABA93F),
        helpstring("Applications use the methods of the IDirect3DCubeTexture9 interface to manipulate a cube texture resource.")
]
interface IDirect3DCubeTexture9 : IDirect3DBaseTexture9 {
    [helpstring("Retrieves a description of one face of the specified cube texture level.")]
        HRESULT _stdcall GetLevelDesc(
            [in] int Level,
            [out] D3DSURFACE_DESC* pDesc);
    [helpstring("Retrieves a cube texture map surface.")]
        HRESULT _stdcall GetCubeMapSurface(
            [in] D3DCUBEMAP_FACES FaceType,
            [in] int Level,
            [out] IDirect3DSurface9** ppCubeMapSurface);
    [helpstring("Locks a rectangle on a cube texture resource.")]
        HRESULT _stdcall LockRect(
            [in] D3DCUBEMAP_FACES FaceType,
            [in] int Level,
            [out] D3DLOCKED_RECT* pLockedRect,
            [in] void* pRect,
            [in] D3DLOCK flags);
    [helpstring("Unlocks a rectangle on a cube texture resource.")]
        HRESULT _stdcall UnlockRect(
            [in] D3DCUBEMAP_FACES FaceType,
            [in] int Level);
    [helpstring("Adds a dirty region to a cube texture resource.")]
        HRESULT _stdcall AddDirtyRect(
            [in] D3DCUBEMAP_FACES FaceType,
            [in] void* pDirtyRect);
};

[
    odl,
        uuid(B64BB1B5-FD70-4DF6-BF91-19D0A12455E3),
        helpstring("Applications use the methods of the IDirect3DVertexBuffer9 interface to manipulate vertex buffer resources.")
]
interface IDirect3DVertexBuffer9 : IDirect3DResource9 {
    [helpstring("Locks a range of vertex data and obtains a pointer to the vertex buffer memory.")]
        HRESULT _stdcall Lock(
            [in] int OffsetToLock,
            [in] int SizeToLock,
            [out] void* ppbData,
            [in] D3DLOCK flags);
    [helpstring("Unlocks vertex data.")]
        HRESULT _stdcall Unlock();
    [helpstring("Retrieves a description of the vertex buffer resource.")]
        HRESULT _stdcall GetDesc([out] D3DVERTEXBUFFER_DESC* pDesc);
};

[
    odl,
        uuid(7C9DD65E-D3F7-4529-ACEE-785830ACDE35),
        helpstring("Applications use the methods of the IDirect3DIndexBuffer9 interface to manipulate an index buffer resource.")
]
interface IDirect3DIndexBuffer9 : IDirect3DResource9 
{
    [helpstring("Locks a range of index data and obtains a pointer to the index buffer memory.")]
        HRESULT _stdcall Lock(
            [in] int OffsetToLock,
            [in] int SizeToLock,
            [out] void* ppbData,
            [in] D3DLOCK flags);
    [helpstring("Unlocks index data.")]
        HRESULT _stdcall Unlock();
    [helpstring("Retrieves a description of the index buffer resource.")]
        HRESULT _stdcall GetDesc([out] D3DINDEXBUFFER_DESC* pDesc);
};

[
    odl,
        uuid(B07C4FE5-310D-4BA8-A23C-4F0F206F218B),
        helpstring("Applications use the methods of the IDirect3DStateBlock9 interface to encapsulate render states.")
]
interface IDirect3DStateBlock9 : stdole.IUnknown 
{
    [helpstring("Gets the device.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9** ppDevice);
    [helpstring("Capture the current value of states that are included in a stateblock.")]
        HRESULT _stdcall Capture();
    [helpstring("Apply the state block to the current device state.")]
        HRESULT _stdcall Apply();
};

[
    odl,
        uuid(DD13C59C-36FA-4098-A8FB-C7ED39DC8546),
        helpstring("Applications use the methods of the IDirect3DVertexDeclaration9 interface to encapsulate the vertex shader declaration.")
]
interface IDirect3DVertexDeclaration9 : stdole.IUnknown 
{
    [helpstring("Gets the current device.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9** ppDevice);
    [helpstring("Gets the vertex shader declaration.")]
        HRESULT _stdcall GetDeclaration(
            [in, out] D3DVERTEXELEMENT9* pDecl,
            [out] int* pNumElements);
};

[
    odl,
        uuid(EFC5557E-6265-4613-8A94-43857889EB36),
        helpstring("Applications use the methods of the IDirect3DVertexShader9 interface to encapsulate the functionality of a vertex shader.")
]
interface IDirect3DVertexShader9 : stdole.IUnknown 
{
    [helpstring("Gets the device.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9** ppDevice);
    [helpstring("Gets a pointer to the shader data.")]
        HRESULT _stdcall GetFunction(
            [in, out] void* pData,
            [in, out] int* pSizeOfData);
};

[
    odl,
        uuid(6D3BDBDC-5B02-4415-B852-CE5E8BCCB289),
        helpstring("Applications use the methods of the IDirect3DPixelShader9 interface to encapsulate the functionality of a pixel shader.")
]
interface IDirect3DPixelShader9 : stdole.IUnknown 
{
    [helpstring("Gets the device.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9** ppDevice);
    [helpstring("Gets a pointer to the shader data.")]
        HRESULT _stdcall GetFunction(
            [in, out] void* pData,
            [in, out] int* pSizeOfData);
};

[
    odl,
        uuid(D9771460-A695-4F26-BBD3-27B840B541CC),
        helpstring("Applications use the methods of the IDirect3DQuery9 interface to perform asynchronous queries on a driver.")
]
interface IDirect3DQuery9 : stdole.IUnknown 
{
    [helpstring("Gets the device that is being queried.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9** ppDevice);
    [helpstring("Gets the query type.")]
        D3DQUERYTYPE _stdcall GetType();
    [helpstring("Gets the number of bytes in the query data.")]
        long _stdcall GetDataSize();
    [helpstring("Issue a query.")]
        HRESULT _stdcall Issue([in] D3DISSUE dwIssueFlags);
    [helpstring("Polls a queried resource to get the query state or a query result.")]
        HRESULT _stdcall GetData(
            [in, out] void* pData,
            [in] int dwSize,
            [in] long dwGetDataFlags);
};

interface IDirect3DDevice9Ex;

[
    odl,
    uuid(02177241-69FC-400C-8FF1-93A44DF6861D)
]
interface IDirect3D9Ex : stdole.IUnknown
{
    [helpstring("Registers a pluggable software device. Software devices provide software rasterization enabling applications to access a variety of software rasterizers.")]
        HRESULT _stdcall RegisterSoftwareDevice([in] LongPtr InitializeFunction);
    [helpstring("Returns the number of adapters on the system.")]
        int _stdcall GetAdapterCount();
    [helpstring("Describes the physical display adapters present in the system when the IDirect3D9 interface was instantiated.")]
        HRESULT _stdcall GetAdapterIdentifier(
            [in] int Adapter,
            [in] long flags,
            [in, out] D3DADAPTER_IDENTIFIER9 * Identifier);
    [helpstring("Returns the number of display modes available on this adapter.")]
        int _stdcall GetAdapterModeCount(
            [in] int Adapter,
            [in] D3DFORMAT Format);
    [helpstring("Queries the device to determine whether the specified adapter supports the requested format and display mode. This method could be used in a loop to enumerate all the available adapter modes.")]
        HRESULT _stdcall EnumAdapterModes(
            [in] int Adapter,
            [in] D3DFORMAT Format,
            [in] int Mode,
            [in, out] D3DDISPLAYMODE * DisplayMode);
    [helpstring("Retrieves the current display mode of the adapter.")]
        HRESULT _stdcall GetAdapterDisplayMode(
            [in] int Adapter,
            [in, out] D3DDISPLAYMODE * DisplayMode);
    [helpstring("Verifies whether a hardware accelerated device type can be used on this adapter.")]
        HRESULT _stdcall CheckDeviceType(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT DisplayFormat,
            [in] D3DFORMAT BackBufferFormat,
            [in] long bWindowed);
    [helpstring("Determines whether a surface format is available as a specified resource type and can be used as a texture, depth-stencil buffer, or render target, or any combination of the three, on a device representing this adapter.")]
        HRESULT _stdcall CheckDeviceFormat(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT AdapterFormat,
            [in] long Usage,
            [in] D3DRESOURCETYPE RType,
            [in] D3DFORMAT CheckFormat);
    [helpstring("Determines if a multisampling technique is available on this device.")]
        HRESULT _stdcall CheckDeviceMultiSampleType(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT SurfaceFormat,
            [in] long Windowed,
            [in] D3DMULTISAMPLE_TYPE MultiSampleType,
            [out] long* pQualityLevels);
    [helpstring("Determines whether a depth-stencil format is compatible with a render-target format in a particular display mode.")]
        HRESULT _stdcall CheckDepthStencilMatch(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT AdapterFormat,
            [in] D3DFORMAT RenderTargetFormat,
            [in] D3DFORMAT DepthStencilFormat);
    [helpstring("Tests the device to see if it supports conversion from one display format to another.")]
        HRESULT _stdcall CheckDeviceFormatConversion(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] D3DFORMAT SourceFormat,
            [in] D3DFORMAT TargetFormat);
    [helpstring("Retrieves device-specific information about a device.")]
        HRESULT _stdcall GetDeviceCaps(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [out] D3DCAPS9 * pCaps);
    [helpstring("Returns the handle of the monitor associated with the Direct3D object.")]
        long _stdcall GetAdapterMonitor([in] int Adapter);
    [helpstring("Creates a device to represent the display adapter.")]
        HRESULT _stdcall CreateDevice(
            [in] int Adapter,
            [in] D3DDEVTYPE DeviceType,
            [in] LongPtr hFocusWindow,
            [in] D3DCREATE BehaviorFlags,
            [in, out] D3DPRESENT_PARAMETERS * pPresentationParameters,
            [out, retval] IDirect3DDevice9 * *ppReturnedDeviceInterface);
    UINT _stdcall GetAdapterModeCountEx([in] UINT Adapter, [in] D3DDISPLAYMODEFILTER* pFilter);
    HRESULT _stdcall EnumAdapterModesEx([in] UINT Adapter, [in] D3DDISPLAYMODEFILTER * pFilter, [in] UINT Mode, [in] D3DDISPLAYMODEEX * pMode);
    HRESULT _stdcall GetAdapterDisplayModeEx([in] UINT Adapter, [in] D3DDISPLAYMODEEX * pMode, [in] D3DDISPLAYROTATION * pRotation);
    HRESULT _stdcall CreateDeviceEx([in] UINT Adapter, [in] D3DDEVTYPE DeviceType, [in] LongPtr hFocusWindow, [in] DWORD BehaviorFlags, [in] D3DPRESENT_PARAMETERS * pPresentationParameters, [in] D3DDISPLAYMODEEX * pFullscreenDisplayMode, [out] IDirect3DDevice9Ex * *ppReturnedDeviceInterface);
    HRESULT _stdcall GetAdapterLUID([in] UINT Adapter, [in, out] LUID * pLUID);
};

[
    odl,
    uuid(B18B10CE-2649-405a-870F-95F777D4313A)
]
interface IDirect3DDevice9Ex : stdole.IUnknown
{
    [helpstring("Reports the current cooperative-level status of the Direct3D device for a windowed or full-screen application.")]
        HRESULT _stdcall TestCooperativeLevel();
    [helpstring("Returns an estimate of the amount of available texture memory.")]
        long _stdcall GetAvailableTextureMem();
    [helpstring("Evicts all managed resources, including both Direct3D and driver-managed resources.")]
        HRESULT _stdcall EvictManagedResources();
    [helpstring("Returns an interface to the instance of the Direct3D object that created the device.")]
        HRESULT _stdcall GetDirect3D([out, retval] IDirect3D9 * *ppD3D9);
    [helpstring("Retrieves the capabilities of the rendering device.")]
        HRESULT _stdcall GetDeviceCaps([out] D3DCAPS9 * pCaps);
    [helpstring("Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.")]
        HRESULT _stdcall GetDisplayMode(
            [in] long iSwapChain,
            [out] D3DDISPLAYMODE * pMode);
    [helpstring("Retrieves the creation parameters of the device.")]
        HRESULT _stdcall GetCreationParameters([out] D3DDEVICE_CREATION_PARAMETERS * pParameters);
    [helpstring("Sets properties for the cursor.")]
        HRESULT _stdcall SetCursorProperties(
            [in] int XHotSpot,
            [in] int YHotSpot,
            [in] IDirect3DSurface9 * pCursorBitmap);
    [helpstring("Sets the cursor position and update options.")]
        void _stdcall SetCursorPosition(
            [in] int X,
            [in] int Y,
            [in] D3D9SetCursorPosFlags flags);
    [helpstring("Displays or hides the cursor.")]
        long _stdcall ShowCursor([in] long bShow);
    [helpstring("Creates an additional swap chain for rendering multiple views.")]
        HRESULT _stdcall CreateAdditionalSwapChain(
            [in, out] D3DPRESENT_PARAMETERS * pPresentationParameters,
            [out, retval] IDirect3DSwapChain9 * *ppSwapChain);
    [helpstring("Gets a pointer to a swap chain.")]
        HRESULT _stdcall GetSwapChain(
            [in] int iSwapChain,
            [in] IDirect3DSwapChain9 * *ppSwapChain);
    [helpstring("Gets the number of implicit swap chains.")]
        long _stdcall GetNumberOfSwapChains();
    [helpstring("Resets the type, size, and format of the swap chain.")]
        HRESULT _stdcall Reset([in, out] D3DPRESENT_PARAMETERS * pPresentationParameters);
    [helpstring("Presents the contents of the next buffer in the sequence of back buffers owned by the device.")]
        HRESULT _stdcall Present(
            [in] void* pSourceRect,
            [in] void* pDestRect,
            [in] LongPtr hDestWindowOverride,
            [in] void* pDirtyRegion);
    [helpstring("Retrieves a back buffer from the device's swap chain.")]
        HRESULT _stdcall GetBackBuffer(
            [in] int iSwapChain,
            [in] int BackBuffer,
            [in] D3DBACKBUFFER_TYPE Type,
            [out, retval] IDirect3DSurface9 * *ppBackBuffer);
    [helpstring("Returns information describing the raster of the monitor on which the swap chain is presented.")]
        HRESULT _stdcall GetRasterStatus(
            [in] int iSwapChain,
            [out] D3DRASTER_STATUS * pRasterStatus);
    [helpstring("This method allows the use of GDI dialog boxes in full-screen mode applications.")]
        HRESULT _stdcall SetDialogBoxMode([in] int bEnableDialogs);
    [helpstring("Sets the gamma correction ramp for the implicit swap chain. This method will affect the entire screen (not just the active window if you are running in windowed mode).")]
        void _stdcall SetGammaRamp(
            [in] int iSwapChain,
            [in] D3D9SetGammaRampFlags flags,
            [in] D3DGAMMARAMP * pRamp);
    [helpstring("Retrieves the gamma correction ramp for the swap chain.")]
        void _stdcall GetGammaRamp(
            [in] int iSwapChain,
            [in, out] D3DGAMMARAMP * pRamp);
    [helpstring("Creates a texture resource.")]
        HRESULT _stdcall CreateTexture(
            [in] int Width,
            [in] int Height,
            [in] int Levels,
            [in] D3DUSAGE Usage,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DTexture9 * *ppTexture,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a volume texture resource.")]
        HRESULT _stdcall CreateVolumeTexture(
            [in] int Width,
            [in] int Height,
            [in] int Depth,
            [in] int Levels,
            [in] D3DUSAGE Usage,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DVolumeTexture9 * *ppVolumeTexture,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a cube texture resource.")]
        HRESULT _stdcall CreateCubeTexture(
            [in] int EdgeLength,
            [in] int Levels,
            [in] D3DUSAGE Usage,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DCubeTexture9 * *ppCubeTexture,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a vertex buffer.")]
        HRESULT _stdcall CreateVertexBuffer(
            [in] int Length,
            [in] D3DUSAGE Usage,
            [in] D3D9VertexFormatBits FVF,
            [in] D3DPOOL Pool,
            [out] IDirect3DVertexBuffer9 * *ppVertexBuffer,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates an index buffer.")]
        HRESULT _stdcall CreateIndexBuffer(
            [in] int Length,
            [in] D3DUSAGE Usage,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DIndexBuffer9 * *ppIndexBuffer,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a render-target surface.")]
        HRESULT _stdcall CreateRenderTarget(
            [in] int Width,
            [in] int Height,
            [in] D3DFORMAT Format,
            [in] D3DMULTISAMPLE_TYPE MultiSample,
            [in] long MultiSampleQuality,
            [in] long Lockable,
            [out] IDirect3DSurface9 * *ppSurface,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Creates a depth-stencil resource.")]
        HRESULT _stdcall CreateDepthStencilSurface(
            [in] int Width,
            [in] int Height,
            [in] D3DFORMAT Format,
            [in] D3DMULTISAMPLE_TYPE MultiSample,
            [in] long MultiSampleQuality,
            [in] long Discard,
            [out] IDirect3DSurface9 * *ppSurface,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Copies rectangular subsets of pixels from one surface to another.")]
        HRESULT _stdcall UpdateSurface(
            [in] IDirect3DSurface9 * pSourceSurface,
            [in] void* pSourceRect,
            [in] IDirect3DSurface9 * pDestinationSurface,
            [in] void* pDestinationPoint);
    [helpstring("Updates the dirty portions of a texture.")]
        HRESULT _stdcall UpdateTexture(
            [in] IDirect3DBaseTexture9 * pSourceTexture,
            [in] IDirect3DBaseTexture9 * pDestinationTexture);
    [helpstring("Copies the render-target data from device memory to system memory.")]
        HRESULT _stdcall GetRenderTargetData(
            [in] IDirect3DSurface9 * pRenderTarget,
            [in] IDirect3DSurface9 * pDestSurface);
    [helpstring("Generates a copy of the device's front buffer and places that copy in a system memory buffer provided by the application.")]
        HRESULT _stdcall GetFrontBufferData(
            [in] int iSwapChain,
            [in] IDirect3DSurface9 * pDestSurface);
    [helpstring("Copy the contents of the source rectangle to the destination rectangle. The source rectangle can be stretched and filtered by the copy. This function is often used to change the aspect ratio of a video stream.")]
        HRESULT _stdcall StretchRect(
            [in] IDirect3DSurface9 * pSourceSurface,
            [in] void* pSourceRect,
            [in] IDirect3DSurface9 * pDestSurface,
            [in] void* pDestRect,
            [in] D3DTEXTUREFILTERTYPE Filter);
    [helpstring("Allows an application to fill a rectangular area of a D3DPOOL_DEFAULT surface with a specified color.")]
        HRESULT _stdcall ColorFill(
            [in] IDirect3DSurface9 * pSurface,
            [in] void* pRect,
            [in] int color);
    [helpstring("Create an off-screen surface.")]
        HRESULT _stdcall CreateOffscreenPlainSurface(
            [in] int Width,
            [in] int Height,
            [in] D3DFORMAT Format,
            [in] D3DPOOL Pool,
            [out] IDirect3DSurface9 * *ppSurface,
            [in, defaultvalue(0)] LongPtr pSharedHandle);
    [helpstring("Sets a new color buffer for the device.")]
        HRESULT _stdcall SetRenderTarget(
            [in] int RenderTargetIndex,
            [in] IDirect3DSurface9 * pRenderTarget);
    [helpstring("Retrieves a render-target surface.")]
        HRESULT _stdcall GetRenderTarget(
            [in] int RenderTargetIndex,
            [out, retval] IDirect3DSurface9 * *ppRenderTarget);
    [helpstring("Sets the depth stencil surface.")]
        HRESULT _stdcall SetDepthStencilSurface([in] IDirect3DSurface9 * pNewZStencil);
    [helpstring("Gets the depth-stencil surface owned by the Direct3DDevice object.")]
        HRESULT _stdcall GetDepthStencilSurface([out, retval] IDirect3DSurface9 * *ppZStencilSurface);
    [helpstring("Begins a scene.")]
        HRESULT _stdcall BeginScene();
    [helpstring("Ends a scene that was begun by calling IDirect3DDevice9.BeginScene.")]
        HRESULT _stdcall EndScene();
    [helpstring("Clears one or more surfaces such as a render target, multiple render targets, a stencil buffer, and a depth buffer.")]
        HRESULT _stdcall Clear(
            [in] long Count,
            [in] void* pRects,
            [in] D3DCLEAR flags,
            [in] int color,
            [in] single Z,
            [in] long Stencil);
    [helpstring("Sets a single device transformation-related state.")]
        HRESULT _stdcall SetTransform(
            [in] D3DTRANSFORMSTATETYPE State,
            [in] D3DMATRIX * pMatrix);
    [helpstring("Retrieves a matrix describing a transformation state.")]
        HRESULT _stdcall GetTransform(
            [in] D3DTRANSFORMSTATETYPE State,
            [out] D3DMATRIX * pMatrix);
    [helpstring("Multiplies a device's world, view, or projection matrices by a specified matrix.")]
        HRESULT _stdcall MultiplyTransform(
            [in] D3DTRANSFORMSTATETYPE State,
            [in] D3DMATRIX * pMatrix);
    [helpstring("Sets the viewport parameters for the device.")]
        HRESULT _stdcall SetViewport([in] D3DVIEWPORT9 * pViewport);
    [helpstring("Retrieves the viewport parameters currently set for the device.")]
        HRESULT _stdcall GetViewport([out] D3DVIEWPORT9 * pViewport);
    [helpstring("Sets the material properties for the device.")]
        HRESULT _stdcall SetMaterial([in] D3DMATERIAL9 * pMaterial);
    [helpstring("Retrieves the current material properties for the device.")]
        HRESULT _stdcall GetMaterial([out] D3DMATERIAL9 * pMaterial);
    [helpstring("Assigns a set of lighting properties for this device.")]
        HRESULT _stdcall SetLight(
            [in] int Index,
            [in] D3DLIGHT9 * pLight);
    [helpstring("Retrieves a set of lighting properties that this device uses.")]
        HRESULT _stdcall GetLight(
            [in] int Index,
            [out] D3DLIGHT9 * pLight);
    [helpstring("Enables or disables a set of lighting parameters within a device.")]
        HRESULT _stdcall LightEnable(
            [in] int LightIndex,
            [in] int bEnable);
    [helpstring("Retrieves the activity status - enabled or disabled - for a set of lighting parameters within a device.")]
        HRESULT _stdcall GetLightEnable(
            [in] int Index,
            [out, retval] int* pEnable);
    [helpstring("Sets the coefficients of a user-defined clipping plane for the device.")]
        HRESULT _stdcall SetClipPlane(
            [in] int Index,
            [in] single * pPlane);
    [helpstring("Retrieves the coefficients of a user-defined clipping plane for the device.")]
        HRESULT _stdcall GetClipPlane(
            [in] int Index,
            [out, retval] single * pPlane);
    [helpstring("Sets a single device render-state parameter.")]
        HRESULT _stdcall SetRenderState(
            [in] D3DRENDERSTATETYPE State,
            [in] long Value);
    [helpstring("Retrieves a render-state value for a device.")]
        HRESULT _stdcall GetRenderState(
            [in] D3DRENDERSTATETYPE State,
            [out, retval] long* pValue);
    [helpstring("Creates a new state block that contains the values for all device states, vertex-related states, or pixel-related states.")]
        HRESULT _stdcall CreateStateBlock(
            [in] D3DSTATEBLOCKTYPE Type,
            [out, retval] IDirect3DStateBlock9 * *ppSB);
    [helpstring("Signals Direct3D to begin recording a device-state block.")]
        HRESULT _stdcall BeginStateBlock();
    [helpstring("Signals Direct3D to stop recording a device-state block and retrieve a pointer to the state block interface.")]
        HRESULT _stdcall EndStateBlock([out, retval] IDirect3DStateBlock9 * *ppSB);
    [helpstring("Sets the clip status.")]
        HRESULT _stdcall SetClipStatus([in] D3DCLIPSTATUS9 * pClipStatus);
    [helpstring("Retrieves the clip status.")]
        HRESULT _stdcall GetClipStatus([out] D3DCLIPSTATUS9 * pClipStatus);
    [helpstring("Retrieves a texture assigned to a stage for a device.")]
        HRESULT _stdcall GetTexture(
            [in] long Stage,
            [out, retval] IDirect3DBaseTexture9 * *ppTexture);
    [helpstring("Assigns a texture to a stage for a device.")]
        HRESULT _stdcall SetTexture(
            [in] long Sampler,
            [in] IDirect3DBaseTexture9 * pTexture);
    [helpstring("Retrieves a state value for an assigned texture.")]
        HRESULT _stdcall GetTextureStageState(
            [in] long Stage,
            [in] D3DTEXTURESTAGESTATETYPE Type,
            [out, retval] long* pValue);
    [helpstring("Sets the state value for the currently assigned texture.")]
        HRESULT _stdcall SetTextureStageState(
            [in] long Stage,
            [in] D3DTEXTURESTAGESTATETYPE Type,
            [in] long Value);
    [helpstring("Gets the sampler state value.")]
        HRESULT _stdcall GetSamplerState(
            [in] long Sampler,
            [in] D3DSAMPLERSTATETYPE Type,
            [out] long* pValue);
    [helpstring("Sets the sampler state value.")]
        HRESULT _stdcall SetSamplerState(
            [in] long Sampler,
            [in] D3DSAMPLERSTATETYPE Type,
            [in] long Value);
    [helpstring("Reports the device's ability to render the current texture-blending operations and arguments in a single pass.")]
        HRESULT _stdcall ValidateDevice([out, retval] long* pNumPasses);
    [helpstring("Sets palette entries.")]
        HRESULT _stdcall SetPaletteEntries(
            [in] int PaletteNumber,
            [in] PALETTEENTRY * pEntries);
    [helpstring("Retrieves palette entries.")]
        HRESULT _stdcall GetPaletteEntries(
            [in] int PaletteNumber,
            [in, out] PALETTEENTRY * pEntries);
    [helpstring("Sets the current texture palette.")]
        HRESULT _stdcall SetCurrentTexturePalette([in] int PaletteNumber);
    [helpstring("Retrieves the current texture palette.")]
        HRESULT _stdcall GetCurrentTexturePalette([out, retval] int* pPaletteNumber);
    [helpstring("Sets the scissor rectangle.")]
        HRESULT _stdcall SetScissorRect([in] void* pRect);
    [helpstring("Gets the scissor rectangle.")]
        HRESULT _stdcall GetScissorRect([out] RECT * pRect);
    [helpstring("Use this method to switch between software and hardware vertex processing.")]
        HRESULT _stdcall SetSoftwareVertexProcessing([in] long bSoftware);
    [helpstring("Gets the vertex processing (hardware or software) mode.")]
        long _stdcall GetSoftwareVertexProcessing();
    [helpstring("Enable or disable N-patches.")]
        HRESULT _stdcall SetNPatchMode([in] single nSegments);
    [helpstring("Gets the N-patch mode segments.")]
        single _stdcall GetNPatchMode();
    [helpstring("Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams.")]
        HRESULT _stdcall DrawPrimitive(
            [in] D3DPRIMITIVETYPE PrimitiveType,
            [in] int StartVertex,
            [in] int PrimitiveCount);
    [helpstring("Based on indexing, renders the specified geometric primitive into an array of vertices.")]
        HRESULT _stdcall DrawIndexedPrimitive(
            [in] D3DPRIMITIVETYPE Type,
            [in] int BaseVertexIndex,
            [in] int MinIndex,
            [in] int NumVertices,
            [in] int StartIndex,
            [in] int PrimitiveCount);
    [helpstring("Renders data specified by a user memory pointer as a sequence of geometric primitives of the specified type.")]
        HRESULT _stdcall DrawPrimitiveUP(
            [in] D3DPRIMITIVETYPE PrimitiveType,
            [in] int PrimitiveCount,
            [in] void* pVertexStreamZeroData,
            [in] int VertexStreamZeroStride);
    [helpstring("Renders the specified geometric primitive with data specified by a user memory pointer.")]
        HRESULT _stdcall DrawIndexedPrimitiveUP(
            [in] D3DPRIMITIVETYPE PrimitiveType,
            [in] int MinVertexIndex,
            [in] int NumVertices,
            [in] int PrimitiveCount,
            [in] void* pIndexData,
            [in] D3DFORMAT IndexDataFormat,
            [in] void* pVertexStreamZeroData,
            [in] int VertexStreamZeroStride);
    [helpstring("Applies the vertex processing defined by the vertex shader to the set of input data streams, generating a single stream of interleaved vertex data to the destination vertex buffer.")]
        HRESULT _stdcall ProcessVertices(
            [in] int SrcStartIndex,
            [in] int DestIndex,
            [in] int VertexCount,
            [in] IDirect3DVertexBuffer9 * pDestBuffer,
            [in] IDirect3DVertexDeclaration9 * pVertexDecl,
            [in] long flags);
    [helpstring("Create a vertex shader declaration from the device and the vertex elements.")]
        HRESULT _stdcall CreateVertexDeclaration(
            [in] D3DVERTEXELEMENT9 * pVertexElements,
            [out, retval] IDirect3DVertexDeclaration9 * *ppDecl);
    [helpstring("Sets a Vertex Declaration.")]
        HRESULT _stdcall SetVertexDeclaration([in] IDirect3DVertexDeclaration9 * pDecl);
    [helpstring("Gets a vertex shader declaration.")]
        HRESULT _stdcall GetVertexDeclaration([out, retval] IDirect3DVertexDeclaration9 * *ppDecl);
    [helpstring("Sets the current vertex stream declaration.")]
        HRESULT _stdcall SetFVF([in] D3D9VertexFormatBits FVF);
    [helpstring("Gets the fixed vertex function declaration.")]
        HRESULT _stdcall GetFVF([out, retval] D3D9VertexFormatBits* pFVF);
    [helpstring("Creates a vertex shader.")]
        HRESULT _stdcall CreateVertexShader(
            [in] void* pFunction,
            [out, retval] IDirect3DVertexShader9 * *ppShader);
    [helpstring("Sets the vertex shader.")]
        HRESULT _stdcall SetVertexShader([in] IDirect3DVertexShader9 * pShader);
    [helpstring("Retrieves the currently set vertex shader.")]
        HRESULT _stdcall GetVertexShader([out, retval] IDirect3DVertexShader9 * *ppShader);
    [helpstring("Sets a floating-point vertex shader constant.")]
        HRESULT _stdcall SetVertexShaderConstantF(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets a floating-point vertex shader constant.")]
        HRESULT _stdcall GetVertexShaderConstantF(
            [in] int StartRegister,
            [in, out] single * pConstantData,
            [in] int Vector4fCount);
    [helpstring("Sets an integer vertex shader constant.")]
        HRESULT _stdcall SetVertexShaderConstantI(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets an integer vertex shader constant.")]
        HRESULT _stdcall GetVertexShaderConstantI(
            [in] int StartRegister,
            [in, out] int* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Sets a boolean vertex shader constant.")]
        HRESULT _stdcall SetVertexShaderConstantB(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets a boolean vertex shader constant.")]
        HRESULT _stdcall GetVertexShaderConstantB(
            [in] int StartRegister,
            [in, out] int* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Binds a vertex buffer to a device data stream.")]
        HRESULT _stdcall SetStreamSource(
            [in] int StreamNumber,
            [in] IDirect3DVertexBuffer9 * pStreamData,
            [in] int OffsetInBytes,
            [in] int Stride);
    [helpstring("Retrieves a vertex buffer bound to the specified data stream.")]
        HRESULT _stdcall GetStreamSource(
            [in] int StreamNumber,
            [in, out] IDirect3DVertexBuffer9 * *ppStreamData,
            [out] int* pOffsetInBytes,
            [out] int* pStride);
    [helpstring("Sets the stream source frequency divider value. This may be used to draw several instances of geometry.")]
        HRESULT _stdcall SetStreamSourceFreq(
            [in] int StreamNumber,
            [in] int FrequencyParameter);
    [helpstring("Gets the stream source frequency divider value.")]
        HRESULT _stdcall GetStreamSourceFreq(
            [in] int StreamNumber,
            [out, retval] int* pDivider);
    [helpstring("Sets index data.")]
        HRESULT _stdcall SetIndices([in] IDirect3DIndexBuffer9 * pIndexData);
    [helpstring("Retrieves index data.")]
        HRESULT _stdcall GetIndices(
            [out] IDirect3DIndexBuffer9 * *ppIndexData,
            [out] int* pBaseVertexIndex);
    [helpstring("Creates a pixel shader.")]
        HRESULT _stdcall CreatePixelShader(
            [in] void* pFunction,
            [out, retval] IDirect3DPixelShader9 * *ppShader);
    [helpstring("Sets the pixel shader.")]
        HRESULT _stdcall SetPixelShader([in] IDirect3DPixelShader9 * pShader);
    [helpstring("Retrieves the currently set pixel shader.")]
        HRESULT _stdcall GetPixelShader([out, retval] IDirect3DPixelShader9 * *ppShader);
    [helpstring("Sets a floating-point pixel shader constant.")]
        HRESULT _stdcall SetPixelShaderConstantF(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets a floating-point pixel shader constant.")]
        HRESULT _stdcall GetPixelShaderConstantF(
            [in] int StartRegister,
            [in, out] single * pConstantData,
            [in] int Vector4fCount);
    [helpstring("Sets an integer pixel shader constant.")]
        HRESULT _stdcall SetPixelShaderConstantI(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets an integer pixel shader constant.")]
        HRESULT _stdcall GetPixelShaderConstantI(
            [in] int StartRegister,
            [in, out] int* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Sets a boolean pixel shader constant.")]
        HRESULT _stdcall SetPixelShaderConstantB(
            [in] int StartRegister,
            [in] void* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Gets a boolean pixel shader constant.")]
        HRESULT _stdcall GetPixelShaderConstantB(
            [in] int StartRegister,
            [in, out] int* pConstantData,
            [in] int Vector4fCount);
    [helpstring("Draws a rectangular patch using the currently set streams.")]
        HRESULT _stdcall DrawRectPatch(
            [in] int Handle,
            [in] single * pNumSegs,
            [in] D3DRECTPATCH_INFO * pRectPatchInfo);
    [helpstring("Draws a triangular patch using the currently set streams.")]
        HRESULT _stdcall DrawTriPatch(
            [in] int Handle,
            [in] single * pNumSegs,
            [in] D3DTRIPATCH_INFO * pTriPatchInfo);
    [helpstring("Frees a cached high-order patch.")]
        HRESULT _stdcall DeletePatch([in] long Handle);
    [helpstring("Creates a status query.")]
        HRESULT _stdcall CreateQuery(
            [in] D3DQUERYTYPE Type,
            [out, retval] IDirect3DQuery9 * *ppQuery);
    STDMETHOD(SetConvolutionMonoKernel)([in] UINT width, [in] UINT height, [in] float* rows, [in] float* columns);
    STDMETHOD(ComposeRects)([in] IDirect3DSurface9 * pSrc, [in] IDirect3DSurface9 * pDst, [in] IDirect3DVertexBuffer9 * pSrcRectDescs, [in] UINT NumRects, [in] IDirect3DVertexBuffer9 * pDstRectDescs, [in] D3DCOMPOSERECTSOP Operation, [in] int Xoffset, [in] int Yoffset);
    STDMETHOD(PresentEx)([in] RECT * pSourceRect, [in] RECT * pDestRect, [in] LongPtr hDestWindowOverride, [in] void* pDirtyRegion, [in] DWORD dwFlags);
    STDMETHOD(GetGPUThreadPriority)([in, out] INT * pPriority);
    STDMETHOD(SetGPUThreadPriority)([in] INT Priority);
    STDMETHOD(WaitForVBlank)([in] UINT iSwapChain);
    STDMETHOD(CheckResourceResidency)([in] IDirect3DResource9 * *pResourceArray, [in] UINT32 NumResources);
    STDMETHOD(SetMaximumFrameLatency)([in] UINT MaxLatency);
    STDMETHOD(GetMaximumFrameLatency)([in, out] UINT * pMaxLatency);
    STDMETHOD(CheckDeviceState)([in] LongPtr hDestinationWindow);
    STDMETHOD(CreateRenderTargetEx)([in] UINT Width, [in] UINT Height, [in] D3DFORMAT Format, [in] D3DMULTISAMPLE_TYPE MultiSample, [in] DWORD MultisampleQuality, [in] BOOL Lockable, [in, out] IDirect3DSurface9 * *ppSurface, [in] LongPtr pSharedHandle, [in] DWORD Usage);
    STDMETHOD(CreateOffscreenPlainSurfaceEx)([in] UINT Width, [in] UINT Height, [in] D3DFORMAT Format, [in] D3DPOOL Pool, [in, out] IDirect3DSurface9 * *ppSurface, [in] LongPtr pSharedHandle, [in] DWORD Usage);
    STDMETHOD(CreateDepthStencilSurfaceEx)([in] UINT Width, [in] UINT Height, [in] D3DFORMAT Format, [in] D3DMULTISAMPLE_TYPE MultiSample, [in] DWORD MultisampleQuality, [in] BOOL Discard, [in, out] IDirect3DSurface9 * *ppSurface, [in] LongPtr pSharedHandle, [in] DWORD Usage);
    STDMETHOD(ResetEx)([in] D3DPRESENT_PARAMETERS * pPresentationParameters, [in]  D3DDISPLAYMODEEX * pFullscreenDisplayMode);
    STDMETHOD(GetDisplayModeEx)([in] UINT iSwapChain, [in, out] D3DDISPLAYMODEEX * pMode, [in, out] D3DDISPLAYROTATION * pRotation);
};

[
    odl,
    uuid(91886CAF-1C3D-4d2e-A0AB-3E4C7D8D3303)
]
interface IDirect3DSwapChain9Ex : stdole.IUnknown
{
    [helpstring("Presents the contents of the next buffer in the sequence of back buffers owned by the swap chain.")]
        HRESULT _stdcall Present(
            [in] void* pSourceRect,
            [in] void* pDestRect,
            [in] LongPtr hDestWindowOverride,
            [in] void* pDirtyRegion,
            [in] long dwFlags);
    [helpstring("Generates a copy of the swapchain's front buffer and places that copy in a system memory buffer provided by the application.")]
        HRESULT _stdcall GetFrontBufferData([in] IDirect3DSurface9 * pDestSurface);
    [helpstring("Retrieves a back buffer from the swap chain of the device.")]
        HRESULT _stdcall GetBackBuffer(
            [in] int BackBuffer,
            [in] D3DBACKBUFFER_TYPE Type,
            [out, retval] IDirect3DSurface9 * *ppBackBuffer);
    [helpstring("Returns information describing the raster of the monitor on which the swap chain is presented.")]
        HRESULT _stdcall GetRasterStatus([out] D3DRASTER_STATUS * pRasterStatus);
    [helpstring("Retrieves the display mode's spatial resolution, color resolution, and refresh frequency.")]
        HRESULT _stdcall GetDisplayMode([out] D3DDISPLAYMODE * pMode);
    [helpstring("Retrieves the device associated with the swap chain.")]
        HRESULT _stdcall GetDevice([out, retval] IDirect3DDevice9 * *ppDevice);
    [helpstring("Retrieves the presentation parameters associated with a swap chain.")]
        HRESULT _stdcall GetPresentParameters([out, retval] D3DPRESENT_PARAMETERS * pPresentationParameters);
    STDMETHOD(GetLastPresentCount)([in, out] UINT * pLastPresentCount);
    STDMETHOD(GetPresentStats)([in, out] D3DPRESENTSTATS * pPresentationStatistics);
    STDMETHOD(GetDisplayModeEx)([in, out] D3DDISPLAYMODEEX * pMode, [in, out] D3DDISPLAYROTATION * pRotation);
};

[
    odl,
    uuid(187AEB13-AAF5-4C59-876D-E059088C0DF8)
]
interface IDirect3D9ExOverlayExtension : stdole.IUnknown
{
 

    /*** IDirect3D9ExOverlayExtension methods ***/
    STDMETHOD(CheckDeviceOverlayType)([in] UINT Adapter,[in] D3DDEVTYPE DevType,[in] UINT OverlayWidth, [in] UINT OverlayHeight, [in] D3DFORMAT OverlayFormat, [in] D3DDISPLAYMODEEX * pDisplayMode,[in] D3DDISPLAYROTATION DisplayRotation,[in] D3DOVERLAYCAPS * pOverlayCaps);
};

interface IDirect3DAuthenticatedChannel9;
interface IDirect3DCryptoSession9;
[
    odl,
    uuid(26DC4561-A1EE-4ae7-96DA-118A36C0EC95)
]
interface IDirect3DDevice9Video : stdole.IUnknown
{
    /*** IDirect3DDevice9Video methods ***/
    STDMETHOD(GetContentProtectionCaps)([in] UUID* pCryptoType, [in] UUID* pDecodeProfile, [in, out] D3DCONTENTPROTECTIONCAPS * pCaps);
    STDMETHOD(CreateAuthenticatedChannel)([in] D3DAUTHENTICATEDCHANNELTYPE ChannelType, [out] IDirect3DAuthenticatedChannel9 * *ppAuthenticatedChannel, [in, out] LongPtr * pChannelHandle);
    STDMETHOD(CreateCryptoSession)([in] UUID* pCryptoType, [in] UUID* pDecodeProfile, [out] IDirect3DCryptoSession9 * *ppCryptoSession, [in, out] LongPtr * pCryptoHandle);
};

[
    odl,
    uuid(FF24BEEE-DA21-4beb-98B5-D2F899F98AF9)
]
interface IDirect3DAuthenticatedChannel9 : stdole.IUnknown
{

    /*** IDirect3DAuthenticatedChannel9 methods ***/
    STDMETHOD(GetCertificateSize)([in, out] UINT * pCertificateSize);
    STDMETHOD(GetCertificate)([in] UINT CertifacteSize, [in, out] BYTE * ppCertificate);
    STDMETHOD(NegotiateKeyExchange)([in] UINT DataSize, [in] VOID * pData);
    STDMETHOD(Query)([in] UINT InputSize, [in] VOID * pInput, [in] UINT OutputSize, [in, out] VOID * pOutput);
    STDMETHOD(Configure)([in] UINT InputSize, [in] VOID * pInput, [in] D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT * pOutput);
};

[
    odl,
    uuid(FA0AB799-7A9C-48CA-8C5B-237E71A54434)
]
interface IDirect3DCryptoSession9 : stdole.IUnknown
{
    /*** IDirect3DCryptoSession9 methods ***/
    STDMETHOD(GetCertificateSize)([in, out] UINT * pCertificateSize);
    STDMETHOD(GetCertificate)([in] UINT CertifacteSize, [in, out] BYTE * ppCertificate);
    STDMETHOD(NegotiateKeyExchange)([in] UINT DataSize, [in, out] VOID * pData);
    STDMETHOD(EncryptionBlt)([in] IDirect3DSurface9 * pSrcSurface, [in] IDirect3DSurface9 * pDstSurface, [in] UINT DstSurfaceSize, [in, out] VOID * pIV);
    STDMETHOD(DecryptionBlt)([in] IDirect3DSurface9 * pSrcSurface, [in] IDirect3DSurface9 * pDstSurface, [in] UINT SrcSurfaceSize, [in] D3DENCRYPTED_BLOCK_INFO * pEncryptedBlockInfo, [in] VOID * pContentKey, [in] VOID * pIV);
    STDMETHOD(GetSurfacePitch)([in] IDirect3DSurface9 * pSrcSurface, [in, out] UINT * pSurfacePitch);
    STDMETHOD(StartSessionKeyRefresh)([in] VOID * pRandomNumber, [in] UINT RandomNumberSize);
    STDMETHOD(FinishSessionKeyRefresh)(void);
    STDMETHOD(GetEncryptionBltKey)([in] VOID * pReadbackKey, [in] UINT KeySize);
};



interface ID3DXConstantTable;
interface ID3DXInclude;
interface ID3DXBuffer;

typedef [public]
LongPtr D3DXHANDLE;

// NOTE: This module has no entry points and thus is invalid.
//       There is no way to extract the dllname of a module
//       with no entry points
// 
[
    dllname("<invalid typelib>")
]
module D3DX_CONSTS{
    const int D3DXSHADER_DEBUG = 1;
    const int D3DXSHADER_SKIPVALIDATION = 2;
    const int D3DXSHADER_SKIPOPTIMIZATION = 4;
    const int D3DXSHADER_PACKMATRIX_ROWMAJOR = 8;
    const int D3DXSHADER_PACKMATRIX_COLUMNMAJOR = 16;
    const int D3DXSHADER_PARTIALPRECISION = 32;
    const int D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT = 64;
    const int D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT = 128;
    const int D3DXSHADER_NO_PRESHADER = 256;
    const int D3DXSHADER_AVOID_FLOW_CONTROL = 512;
    const int D3DXSHADER_PREFER_FLOW_CONTROL = 1024;
    const int D3DXSHADER_ENABLE_BACKWARDS_COMPATIBILITY = 4096;
    const int D3DXSHADER_IEEE_STRICTNESS = 8192;
    const int D3DXSHADER_USE_LEGACY_D3DX9_31_DLL = 65536;
    const int D3DXSHADER_OPTIMIZATION_LEVEL0 = 16384;
    const int D3DXSHADER_OPTIMIZATION_LEVEL1 = 0;
    const int D3DXSHADER_OPTIMIZATION_LEVEL2 = 49152;
    const int D3DXSHADER_OPTIMIZATION_LEVEL3 = 32768;
    const int D3DXCONSTTABLE_LARGEADDRESSAWARE = 131072;
};

typedef [helpstring("Data type of the register.")]
enum D3DXREGISTER_SET {
    D3DXRS_BOOL = 0,
    D3DXRS_INT4 = 1,
    D3DXRS_FLOAT4 = 2,
    D3DXRS_SAMPLER = 3,
    D3DXRS_FORCE_DWORD = 2147483647
} D3DXREGISTER_SET;

typedef [helpstring("The type of object.")]
enum D3DXPARAMETER_CLASS {
    D3DXPC_SCALAR = 0,
    D3DXPC_VECTOR = 1,
    D3DXPC_MATRIX_ROWS = 2,
    D3DXPC_MATRIX_COLUMNS = 3,
    D3DXPC_OBJECT = 4,
    D3DXPC_STRUCT = 5,
    D3DXPC_FORCE_DWORD = 2147483647
} D3DXPARAMETER_CLASS;

typedef [helpstring("Describes the data contained by the enumeration.")]
enum D3DXPARAMETER_TYPE  {
    D3DXPT_VOID = 0,
    D3DXPT_BOOL = 1,
    D3DXPT_INT = 2,
    D3DXPT_FLOAT = 3,
    D3DXPT_STRING = 4,
    D3DXPT_TEXTURE = 5,
    D3DXPT_TEXTURE1D = 6,
    D3DXPT_TEXTURE2D = 7,
    D3DXPT_TEXTURE3D = 8,
    D3DXPT_TEXTURECUBE = 9,
    D3DXPT_SAMPLER = 10,
    D3DXPT_SAMPLER1D = 11,
    D3DXPT_SAMPLER2D = 12,
    D3DXPT_SAMPLER3D = 13,
    D3DXPT_SAMPLERCUBE = 14,
    D3DXPT_PIXELSHADER = 15,
    D3DXPT_VERTEXSHADER = 16,
    D3DXPT_PIXELFRAGMENT = 17,
    D3DXPT_VERTEXFRAGMENT = 18,
    D3DXPT_UNSUPPORTED = 19,
    D3DXPT_FORCE_DWORD = 2147483647
} D3DXPARAMETER_TYPE;

typedef [helpstring("Describes the location for the include file.")]
enum  D3DXINCLUDE_TYPE {
    D3DXINC_LOCAL = 0,
    D3DXINC_SYSTEM = 1,
    D3DXINC_FORCE_DWORD = 2147483647
} D3DXINCLUDE_TYPE;

typedef [helpstring("Describes preprocessor definitions used by an effect object.")]
struct D3DXMACRO {

    LongPtr Name;

    LongPtr Definition;
} D3DXMACRO;

typedef [helpstring("Semantics map a parameter to vertex or pixel shader registers.")]
struct D3DXSEMANTIC {

    long Usage;

    long UsageIndex;
} D3DXSEMANTIC;

typedef [helpstring("A description of the constant table.")]
struct D3DXCONSTANTTABLE_DESC {

    LongPtr Creator;

    long Version;

    long Constants;
} D3DXCONSTANTTABLE_DESC;

typedef [helpstring("A description of a constant in a constant table.")]
struct D3DXCONSTANT_DESC {

    LongPtr Name;

    D3DXREGISTER_SET RegisterSet;

    long RegisterIndex;

    long RegisterCount;

    D3DXPARAMETER_CLASS Class;

    D3DXPARAMETER_TYPE Type;

    long Rows;

    long Columns;

    long Elements;

    long StructMembers;

    long Bytes;

    LongPtr DefaultValue;
} D3DXCONSTANT_DESC;

typedef [helpstring("Describes a four-component vector.")]
struct D3DVECTOR4 {

    single X;

    single Y;

    single Z;

    single W;
} D3DVECTOR4;

 

[
    odl,
        uuid(AB3C758F-093E-4356-B762-4DB18F1B3A01)
]
interface ID3DXConstantTable : stdole.IUnknown {
    long _stdcall GetBufferPointer();
    long _stdcall GetBufferSize();
    HRESULT _stdcall GetDesc([in, out] D3DXCONSTANTTABLE_DESC* pDesc);
    HRESULT _stdcall GetConstantDesc(
        [in] D3DXHANDLE hConstant,
        [in, out] D3DXCONSTANT_DESC* pConstantDesc,
        [in, out] long* pCount);
    long _stdcall GetSamplerIndex([in] D3DXHANDLE hConstant);
    D3DXHANDLE _stdcall GetConstant(
        [in] D3DXHANDLE hConstant,
        [in] long Index);
    D3DXHANDLE _stdcall GetConstantByName(
        [in] D3DXHANDLE hConstant,
        [in] LongPtr pName);
    D3DXHANDLE _stdcall GetConstantElement(
        [in] D3DXHANDLE hConstant,
        [in] long Index);
    HRESULT _stdcall SetDefaults([in] IDirect3DDevice9* pDevice);
    HRESULT _stdcall SetValue(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] void* pData,
        [in] long Bytes);
    HRESULT _stdcall SetBool(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] long b);
    HRESULT _stdcall SetBoolArray(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] long* pb,
        [in] long Count);
    HRESULT _stdcall SetInt(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] long n);
    HRESULT _stdcall SetIntArray(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] long* pn,
        [in] long Count);
    HRESULT _stdcall SetFloat(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] single f);
    HRESULT _stdcall SetFloatArray(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] single* pf,
        [in] long Count);
    HRESULT _stdcall SetVector(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] D3DVECTOR4* pVector);
    HRESULT _stdcall SetVectorArray(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] D3DVECTOR4* pVector,
        [in] long Count);
    HRESULT _stdcall SetMatrix(
        [in]  IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] D3DMATRIX* pMatrix);
    HRESULT _stdcall SetMatrixArray(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] D3DMATRIX* pMatrix,
        [in] long Count);
    HRESULT _stdcall SetMatrixPointerArray(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] void* ppMatrix,
        [in] long Count);
    HRESULT _stdcall SetMatrixTranspose(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] D3DMATRIX* pMatrix);
    HRESULT _stdcall SetMatrixTransposeArray(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] D3DMATRIX* pMatrix,
        [in] long Count);
    HRESULT _stdcall SetMatrixTransposePointerArray(
        [in] IDirect3DDevice9* pDevice,
        [in] D3DXHANDLE hConstant,
        [in] void* ppMatrix,
        [in] long Count);
};

[
    odl,
        uuid(D3914005-8E8C-49D3-9A97-4B402FD89AAB)
]
interface ID3DXInclude : stdole.IUnknown {
    HRESULT _stdcall Open(
        [in] D3DXINCLUDE_TYPE IncludeType,
        [in] LPSTR pFileName,
        [in] LongPtr pParentData,
        [in] LongPtr ppData,
        [in, out] LongPtr* pBytes);
    HRESULT _stdcall Close([in] LongPtr pData);
};

//[
//    odl,
//        uuid(8BA5FB08-5195-40E2-AC58-0D989C3A0102)
//]
//interface ID3DXBuffer : stdole.IUnknown {
//    long _stdcall GetBufferPointer();
//    long _stdcall GetBufferSize();
//};





#define WINAPI _stdcall
[
    dllname("D3d9.dll")
]
module D3d9
{
    [entry("Direct3DCreate9"), helpstring("Create an IDirect3D9 object and return an interface to it.")]
    IDirect3D9 * _stdcall Direct3DCreate9([in, defaultvalue(32)] long SDKVersion);
[entry("D3DPERF_BeginEvent")]
int WINAPI D3DPERF_BeginEvent([in] DWORD col, [in] LPCWSTR wszName);

[entry("D3DPERF_EndEvent")]
int WINAPI D3DPERF_EndEvent(void);

[entry("D3DPERF_SetMarker")]
void WINAPI D3DPERF_SetMarker([in] DWORD col, [in] LPCWSTR wszName);
[entry("D3DPERF_SetRegion")]
void WINAPI D3DPERF_SetRegion([in] DWORD col, [in] LPCWSTR wszName);
[entry("D3DPERF_QueryRepeatFrame")]
BOOL WINAPI D3DPERF_QueryRepeatFrame(void);
[entry("D3DPERF_SetOptions")]
void WINAPI D3DPERF_SetOptions([in] DWORD dwOptions);
[entry("D3DPERF_GetStatus")]
DWORD WINAPI D3DPERF_GetStatus(void);

[entry("Direct3DCreate9Ex")]
HRESULT WINAPI Direct3DCreate9Ex([in] UINT SDKVersion, [out] IDirect3D9Ex** pd3dex);

const int  D3DMAXUSERCLIPPLANES = 32;
const int  D3D_MAX_SIMULTANEOUS_RENDERTARGETS = 4;
const int  D3DRENDERSTATE_WRAPBIAS = 128;

const int  D3DDMAPSAMPLER = 256;

const int  D3DVERTEXTEXTURESAMPLER0 = 257; //(D3DDMAPSAMPLER+1)
const int  D3DVERTEXTEXTURESAMPLER1 = 258; //(D3DDMAPSAMPLER+2)
const int  D3DVERTEXTEXTURESAMPLER2 = 259; // (D3DDMAPSAMPLER+3)
const int  D3DVERTEXTEXTURESAMPLER3 = 260; //(D3DDMAPSAMPLER+4)

const int  MAXD3DDECLUSAGE = 13; //D3DDECLUSAGE_SAMPLE
const int  MAXD3DDECLUSAGEINDEX = 15;
const int  MAXD3DDECLLENGTH = 64; // does not include "end" marker vertex element

const int  MAXD3DDECLMETHOD = 6; // D3DDECLMETHOD_LOOKUPPRESAMPLED

const int  MAXD3DDECLTYPE = 17; // D3DDECLTYPE_UNUSED

//const int  D3DDECL_END() {0xFF,0,D3DDECLTYPE_UNUSED,0,0,0}

// Maximum supported number of texture coordinate sets
const int  D3DDP_MAXTEXCOORD = 8;

const int  D3DSI_OPCODE_MASK = 0x0000FFFF;

const int  D3DSI_INSTLENGTH_MASK = 0x0F000000;
const int  D3DSI_INSTLENGTH_SHIFT = 24;

//const int  D3DSINCOSCONST1 -1.5500992e-006f, -2.1701389e-005f,  0.0026041667f, 0.00026041668f
//const int  D3DSINCOSCONST2 -0.020833334f, -0.12500000f, 1.0f, 0.50000000f

//---------------------------------------------------------------------
// Co-Issue Instruction Modifier - if set then this instruction is to be
// issued in parallel with the previous instruction(s) for which this bit
// is not set.
//
const int  D3DSI_COISSUE = 0x40000000;

//---------------------------------------------------------------------
// Opcode specific controls

const int  D3DSP_OPCODESPECIFICCONTROL_MASK = 0x00ff0000;
const int  D3DSP_OPCODESPECIFICCONTROL_SHIFT = 16;

// ps_2_0 texld controls
const int  D3DSI_TEXLD_PROJECT = 65536; // (0x01 << D3DSP_OPCODESPECIFICCONTROL_SHIFT)
const int  D3DSI_TEXLD_BIAS = 131072; // (0x02 << D3DSP_OPCODESPECIFICCONTROL_SHIFT)

    // Comparison is part of instruction opcode token:
const int  D3DSHADER_COMPARISON_SHIFT = 16; // D3DSP_OPCODESPECIFICCONTROL_SHIFT
const int  D3DSHADER_COMPARISON_MASK = 0x70000; // (0x7 << D3DSHADER_COMPARISON_SHIFT)

//---------------------------------------------------------------------
// Predication flags on instruction token
const int  D3DSHADER_INSTRUCTION_PREDICATED = 0x10000000; // (0x1 << 28)


const int  D3DSP_DCL_USAGE_SHIFT = 0;
const int  D3DSP_DCL_USAGE_MASK = 0x0000000f;

const int  D3DSP_DCL_USAGEINDEX_SHIFT = 16;
const int  D3DSP_DCL_USAGEINDEX_MASK = 0x000f0000;

// DCL pixel shader sampler info token.
const int  D3DSP_TEXTURETYPE_SHIFT = 27;
const int  D3DSP_TEXTURETYPE_MASK = 0x78000000;

const int  D3DSP_REGNUM_MASK = 0x000007FF;

const int  D3DVS_ADDRESSMODE_SHIFT = 13;
const int  D3DVS_ADDRESSMODE_MASK = 0x2000; // (1 << D3DVS_ADDRESSMODE_SHIFT)

const int  D3DSHADER_ADDRESSMODE_SHIFT = 13;
const int  D3DSHADER_ADDRESSMODE_MASK = 0x2000; // (1 << D3DSHADER_ADDRESSMODE_SHIFT)

// pixel shader version token
//const int  D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))
//
//// vertex shader version token
//const int  D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))

// extract major/minor from version cap
/*const int  D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
const int  D3DSHADER_VERSION_MINOR(_Version) (((_Version) >> 0) & 0xFF)*/

// destination/source parameter register type
const int  D3DSI_COMMENTSIZE_SHIFT = 16;
const int  D3DSI_COMMENTSIZE_MASK = 0x7FFF0000;
//const int  D3DSHADER_COMMENT(_DWordSize) \
//((((_DWordSize) << D3DSI_COMMENTSIZE_SHIFT)& D3DSI_COMMENTSIZE_MASK) | D3DSIO_COMMENT)

// pixel/vertex shader end token
const int  D3DPS_END = 0x0000FFFF;
const int  D3DVS_END = 0x0000FFFF;

const int  D3DFVF_TEXTUREFORMAT2 = 0;         // Two floating point values
const int  D3DFVF_TEXTUREFORMAT1 = 3;         // One floating point value
const int  D3DFVF_TEXTUREFORMAT3 = 1;         // Three floating point values
const int  D3DFVF_TEXTUREFORMAT4 = 2;         // Four floating point values

//const int  D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex * 2 + 16))
//const int  D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
//const int  D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex * 2 + 16))
//const int  D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex * 2 + 16))

const int  D3DPRESENT_RATE_DEFAULT = 0x00000000;

const int  MAX_DEVICE_IDENTIFIER_STRING = 512;

const int  D3DRTYPECOUNT = 8; // (D3DRTYPE_INDEXBUFFER+1)

const int  D3DCOMPOSERECTS_MAXNUMRECTS = 0xFFFF;
const int  D3DCONVOLUTIONMONO_MAXWIDTH = 7;
const int  D3DCONVOLUTIONMONO_MAXHEIGHT = 7; // D3DCONVOLUTIONMONO_MAXWIDTH
const int  D3DFMT_A1_SURFACE_MAXWIDTH = 8192;
const int  D3DFMT_A1_SURFACE_MAXHEIGHT = 2048;

const int  D3D_OMAC_SIZE = 16;

const int  D3DVS20CAPS_PREDICATION = 2; // (1 << 0)

const int  D3DVS20_MAX_DYNAMICFLOWCONTROLDEPTH = 24;
const int  D3DVS20_MIN_DYNAMICFLOWCONTROLDEPTH = 0;
const int  D3DVS20_MAX_NUMTEMPS = 32;
const int  D3DVS20_MIN_NUMTEMPS = 12;
const int  D3DVS20_MAX_STATICFLOWCONTROLDEPTH = 4;
const int  D3DVS20_MIN_STATICFLOWCONTROLDEPTH = 1;


const int  D3DPS20_MAX_DYNAMICFLOWCONTROLDEPTH = 24;
const int  D3DPS20_MIN_DYNAMICFLOWCONTROLDEPTH = 0;
const int  D3DPS20_MAX_NUMTEMPS = 32;
const int  D3DPS20_MIN_NUMTEMPS = 12;
const int  D3DPS20_MAX_STATICFLOWCONTROLDEPTH = 4;
const int  D3DPS20_MIN_STATICFLOWCONTROLDEPTH = 0;
const int  D3DPS20_MAX_NUMINSTRUCTIONSLOTS = 512;
const int  D3DPS20_MIN_NUMINSTRUCTIONSLOTS = 96;

const int  D3DMIN30SHADERINSTRUCTIONS = 512;
const int  D3DMAX30SHADERINSTRUCTIONS = 32768;


const int  DIRECT3D_VERSION = 0x0900;

const int  D3D_SDK_VERSION = 32;
const int  D3D9b_SDK_VERSION = 31;

const int D3DADAPTER_DEFAULT = 0;

const int D3DENUM_WHQL_LEVEL = 0x00000002;

/* D3D9Ex only -- */
 
/* NO_DRIVERVERSION will not fill out the DriverVersion field, nor will the
   DriverVersion be incorporated into the DeviceIdentifier GUID. WINNT only */
const int D3DENUM_NO_DRIVERVERSION = 0x00000004;

const int D3DPRESENT_BACK_BUFFERS_MAX = 3;

const int D3DPRESENT_BACK_BUFFERS_MAX_EX = 30;



};
