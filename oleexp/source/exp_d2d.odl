interface ID2D1RectangleGeometry;
interface ID2D1Geometry;
interface ID2D1Resource;
interface ID2D1StrokeStyle;
interface ID2D1SimplifiedGeometrySink;
interface ID2D1TessellationSink;
interface ID2D1RoundedRectangleGeometry;
interface ID2D1EllipseGeometry;
interface ID2D1GeometryGroup;
interface ID2D1TransformedGeometry;
interface ID2D1PathGeometry;
interface ID2D1GeometrySink;
interface ID2D1DrawingStateBlock;
//interface ID2D1RenderTarget;
interface ID2D1Bitmap;
interface ID2D1BitmapBrush;
interface ID2D1Brush;
interface ID2D1SolidColorBrush;
interface ID2D1GradientStopCollection;
interface ID2D1LinearGradientBrush;
interface ID2D1RadialGradientBrush;
interface ID2D1BitmapRenderTarget;
interface ID2D1Layer;
interface ID2D1Mesh;
interface ID2D1HwndRenderTarget;
interface ID2D1DCRenderTarget;
interface ID2D1GdiInteropRenderTarget;


/// <summary>
/// Qualifies how alpha is to be treated in a bitmap or render target containing
/// alpha.
/// </summary>
typedef enum D2D1_ALPHA_MODE
{

    /// <summary>
    /// Alpha mode should be determined implicitly. Some target surfaces do not supply
    /// or imply this information in which case alpha must be specified.
    /// </summary>
    D2D1_ALPHA_MODE_UNKNOWN = 0,

    /// <summary>
    /// Treat the alpha as premultipled.
    /// </summary>
    D2D1_ALPHA_MODE_PREMULTIPLIED = 1,

    /// <summary>
    /// Opacity is in the 'A' component only.
    /// </summary>
    D2D1_ALPHA_MODE_STRAIGHT = 2,

    /// <summary>
    /// Ignore any alpha channel information.
    /// </summary>
    D2D1_ALPHA_MODE_IGNORE = 3,

    D2D1_ALPHA_MODE_FORCE_DWORD = 0xffffffff

} D2D1_ALPHA_MODE;

/// <summary>
/// Description of a pixel format.
/// </summary>
typedef struct D2D1_PIXEL_FORMAT
{
    DXGI_FORMAT format;
    D2D1_ALPHA_MODE alphaMode;

} D2D1_PIXEL_FORMAT;

/// <summary>
/// Represents an x-coordinate and y-coordinate pair in two-dimensional space.
/// </summary>
typedef struct D2D_POINT_2U
{
    UINT32 x;
    UINT32 y;

} D2D_POINT_2U;
typedef struct D2D1_POINT_2U
{
    UINT32 x;
    UINT32 y;

} D2D1_POINT_2U;
/// <summary>
/// Represents an x-coordinate and y-coordinate pair in two-dimensional space.
/// </summary>
typedef struct D2D_POINT_2F
{
    FLOAT x;
    FLOAT y;

} D2D_POINT_2F;

//typedef POINT D2D_POINT_2L;
typedef struct D2D_POINT_2L
{
    long x;
    long y;
} D2D_POINT_2L;



/// <summary>
/// A vector of 3 FLOAT values (x, y, z).
/// </summary>
typedef struct D2D_VECTOR_3F
{
    FLOAT x;
    FLOAT y;
    FLOAT z;

} D2D_VECTOR_3F;
typedef struct D2D1_VECTOR_3F
{
    FLOAT x;
    FLOAT y;
    FLOAT z;

} D2D1_VECTOR_3F;

/// <summary>
/// A vector of 4 FLOAT values (x, y, z, w).
/// </summary>
typedef struct D2D_VECTOR_4F
{
    FLOAT x;
    FLOAT y;
    FLOAT z;
    FLOAT w;

} D2D_VECTOR_4F;
typedef struct D2D1_VECTOR_4F
{
    FLOAT x;
    FLOAT y;
    FLOAT z;
    FLOAT w;

} D2D1_VECTOR_4F;

/// <summary>
/// Represents a rectangle defined by the coordinates of the upper-left corner
/// (left, top) and the coordinates of the lower-right corner (right, bottom).
/// </summary>

typedef struct D2D1_RECT_F
{
    FLOAT left;
    FLOAT top;
    FLOAT right;
    FLOAT bottom;

} D2D1_RECT_F;

/// <summary>
/// Represents a rectangle defined by the coordinates of the upper-left corner
/// (left, top) and the coordinates of the lower-right corner (right, bottom).
/// </summary>
typedef struct D2D_RECT_U
{
    UINT32 left;
    UINT32 top;
    UINT32 right;
    UINT32 bottom;

} D2D_RECT_U;
typedef struct D2D1_RECT_U
{
    UINT32 left;
    UINT32 top;
    UINT32 right;
    UINT32 bottom;

} D2D1_RECT_U;
//typedef RECT D2D_RECT_L;
typedef struct D2D_RECT_L
{
    long left;
    long top;
    long right;
    long bottom;
} D2D_RECT_L;
typedef struct D2D1_RECT_L
{
    long left;
    long top;
    long right;
    long bottom;
} D2D1_RECT_L;
/// <summary>
/// Stores an ordered pair of floats, typically the width and height of a rectangle.
/// </summary>
typedef struct D2D_SIZE_F
{
    FLOAT width;
    FLOAT height;

} D2D_SIZE_F;
typedef struct D2D1_SIZE_F
{
    FLOAT width;
    FLOAT height;

} D2D1_SIZE_F;

/// <summary>
/// Stores an ordered pair of integers, typically the width and height of a
/// rectangle.
/// </summary>
typedef struct D2D_SIZE_U
{
    UINT32 width;
    UINT32 height;

} D2D_SIZE_U;


/// <summary>
/// Represents a 3-by-2 matrix.
/// </summary>
typedef struct D2D_MATRIX_3X2_F
{
    //union
    //{
    //    struct
    //    {
    //        /// <summary>
    //        /// Horizontal scaling / cosine of rotation
    //        /// </summary>
    //        FLOAT m11;

    //        /// <summary>
    //        /// Vertical shear / sine of rotation
    //        /// </summary>
    //        FLOAT m12;

    //        /// <summary>
    //        /// Horizontal shear / negative sine of rotation
    //        /// </summary>
    //        FLOAT m21;

    //        /// <summary>
    //        /// Vertical scaling / cosine of rotation
    //        /// </summary>
    //        FLOAT m22;

    //        /// <summary>
    //        /// Horizontal shift (always orthogonal regardless of rotation)
    //        /// </summary>
    //        FLOAT dx;

    //        /// <summary>
    //        /// Vertical shift (always orthogonal regardless of rotation)
    //        /// </summary>
    //        FLOAT dy;
    //    };

    //    struct
    //    {
    //        FLOAT _11, _12;
    //        FLOAT _21, _22;
    //        FLOAT _31, _32;
    //    };

        FLOAT m[3][2];
    //};

} D2D_MATRIX_3X2_F;
typedef struct D2D1_MATRIX_3X2_F
{
    //union
    //{
    //    struct
    //    {
    //        /// <summary>
    //        /// Horizontal scaling / cosine of rotation
    //        /// </summary>
    //        FLOAT m11;

    //        /// <summary>
    //        /// Vertical shear / sine of rotation
    //        /// </summary>
    //        FLOAT m12;

    //        /// <summary>
    //        /// Horizontal shear / negative sine of rotation
    //        /// </summary>
    //        FLOAT m21;

    //        /// <summary>
    //        /// Vertical scaling / cosine of rotation
    //        /// </summary>
    //        FLOAT m22;

    //        /// <summary>
    //        /// Horizontal shift (always orthogonal regardless of rotation)
    //        /// </summary>
    //        FLOAT dx;

    //        /// <summary>
    //        /// Vertical shift (always orthogonal regardless of rotation)
    //        /// </summary>
    //        FLOAT dy;
    //    };

    //    struct
    //    {
    //        FLOAT _11, _12;
    //        FLOAT _21, _22;
    //        FLOAT _31, _32;
    //    };

    FLOAT m[3][2];
    //};

} D2D1_MATRIX_3X2_F;


/// <summary>
/// Represents a 4-by-3 matrix.
/// </summary>
typedef struct D2D_MATRIX_4X3_F
{
    //union
    //{
    //    struct
    //    {
    //        FLOAT _11, _12, _13;
    //        FLOAT _21, _22, _23;
    //        FLOAT _31, _32, _33;
    //        FLOAT _41, _42, _43;
    //    };

        FLOAT m[4][3];
    //};

} D2D_MATRIX_4X3_F;
typedef struct D2D1_MATRIX_4X3_F
{
    //union
    //{
    //    struct
    //    {
    //        FLOAT _11, _12, _13;
    //        FLOAT _21, _22, _23;
    //        FLOAT _31, _32, _33;
    //        FLOAT _41, _42, _43;
    //    };

    FLOAT m[4][3];
    //};

} D2D1_MATRIX_4X3_F;

/// <summary>
/// Represents a 4-by-4 matrix.
/// </summary>
typedef struct D2D_MATRIX_4X4_F
{
    //union
    //{
    //    struct
    //    {
    //        FLOAT _11, _12, _13, _14;
    //        FLOAT _21, _22, _23, _24;
    //        FLOAT _31, _32, _33, _34;
    //        FLOAT _41, _42, _43, _44;
    //    };

        FLOAT m[4][4];
    //};

} D2D_MATRIX_4X4_F;
typedef struct D2D1_MATRIX_4X4_F
{
    //union
    //{
    //    struct
    //    {
    //        FLOAT _11, _12, _13, _14;
    //        FLOAT _21, _22, _23, _24;
    //        FLOAT _31, _32, _33, _34;
    //        FLOAT _41, _42, _43, _44;
    //    };

    FLOAT m[4][4];
    //};

} D2D1_MATRIX_4X4_F;

/// <summary>
/// Represents a 5-by-4 matrix.
/// </summary>
typedef struct D2D_MATRIX_5X4_F
{
    //union
    //{
    //    struct
        //{
        //    FLOAT _11, _12, _13, _14;
        //    FLOAT _21, _22, _23, _24;
        //    FLOAT _31, _32, _33, _34;
        //    FLOAT _41, _42, _43, _44;
        //    FLOAT _51, _52, _53, _54;
        //};

        FLOAT m[5][4];
    //};

} D2D_MATRIX_5X4_F;
typedef struct D2D1_MATRIX_5X4_F
{
    //union
    //{
    //    struct
        //{
        //    FLOAT _11, _12, _13, _14;
        //    FLOAT _21, _22, _23, _24;
        //    FLOAT _31, _32, _33, _34;
        //    FLOAT _41, _42, _43, _44;
        //    FLOAT _51, _52, _53, _54;
        //};

    FLOAT m[5][4];
    //};

} D2D1_MATRIX_5X4_F;

/*typedef D2D_POINT_2F D2D1_POINT_2F;
typedef D2D_POINT_2U D2D1_POINT_2U;
typedef D2D_POINT_2L D2D1_POINT_2L;
typedef D2D_RECT_F D2D1_RECT_F;
typedef D2D_RECT_U D2D1_RECT_U;
typedef D2D_RECT_L D2D1_RECT_L;
typedef D2D_SIZE_F D2D1_SIZE_F;
typedef D2D_SIZE_U D2D1_SIZE_U;
typedef D2D_MATRIX_3X2_F D2D1_MATRIX_3X2_F;
*/

//typedef enum {
//    DWRITE_MEASURING_MODE_NATURAL = 0,
//    DWRITE_MEASURING_MODE_GDI_CLASSIC = 1,
//    DWRITE_MEASURING_MODE_GDI_NATURAL = 2
//} DWRITE_MEASURING_MODE;

// NOTE: This module has no entry points. There is no way to
//       extract the dllname of a module with no entry points!
// 
[
    dllname("<no entry points>")
]
module D2DConst{
    const int D2D1_APPEND_ALIGNED_ELEMENT = (0xffffffff);
    const int FACILITY_D2D = 2201;
    const int D2DERR_UNSUPPORTED_PIXEL_FORMAT = 0x88982f80;
    const int D2DERR_INSUFFICIENT_BUFFER = 0x8007007a;
    const int D2DERR_WRONG_STATE = 0x88990001;
    const int D2DERR_NOT_INITIALIZED = 0x88990002;
    const int D2DERR_UNSUPPORTED_OPERATION = 0x88990003;
    const int D2DERR_SCANNER_FAILED = 0x88990004;
    const int D2DERR_SCREEN_ACCESS_DENIED = 0x88990005;
    const int D2DERR_DISPLAY_STATE_INVALID = 0x88990006;
    const int D2DERR_ZERO_VECTOR = 0x88990007;
    const int D2DERR_INTERNAL_ERROR = 0x88990008;
    const int D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED = 0x88990009;
    const int D2DERR_INVALID_CALL = 0x8899000a;
    const int D2DERR_NO_HARDWARE_DEVICE = 0x8899000b;
    const int D2DERR_RECREATE_TARGET = 0x8899000c;
    const int D2DERR_TOO_MANY_SHADER_ELEMENTS = 0x8899000d;
    const int D2DERR_SHADER_COMPILE_FAILED = 0x8899000e;
    const int D2DERR_MAX_TEXTURE_SIZE_EXCEEDED = 0x8899000f;
    const int D2DERR_UNSUPPORTED_VERSION = 0x88990010;
    const int D2DERR_BAD_NUMBER = 0x88990011;
    const int D2DERR_WRONG_FACTORY = 0x88990012;
    const int D2DERR_LAYER_ALREADY_IN_USE = 0x88990013;
    const int D2DERR_POP_CALL_DID_NOT_MATCH_PUSH = 0x88990014;
    const int D2DERR_WRONG_RESOURCE_DOMAIN = 0x88990015;
    const int D2DERR_PUSH_POP_UNBALANCED = 0x88990016;
    const int D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT = 0x88990017;
    const int D2DERR_INCOMPATIBLE_BRUSH_TYPES = 0x88990018;
    const int D2DERR_WIN32_ERROR = 0x88990019;
    const int D2DERR_TARGET_NOT_GDI_COMPATIBLE = 0x8899001a;
    const int D2DERR_TEXT_EFFECT_IS_WRONG_TYPE = 0x8899001b;
    const int D2DERR_TEXT_RENDERER_NOT_RELEASED = 0x8899001c;
    const int D2DERR_EXCEEDS_MAX_BITMAP_SIZE = 0x8899001d;
};



typedef struct D2D1_TRIANGLE {

    D2D1_POINT_2F point1;

    D2D1_POINT_2F point2;

    D2D1_POINT_2F point3;
} D2D1_TRIANGLE;

typedef enum D2D1_COMBINE_MODE {
    D2D1_COMBINE_MODE_UNION = 0,
    D2D1_COMBINE_MODE_INTERSECT = 1,
    D2D1_COMBINE_MODE_XOR = 2,
    D2D1_COMBINE_MODE_EXCLUDE = 3,
    D2D1_COMBINE_MODE_FORCE_DWORD = 0xffffffff
} D2D1_COMBINE_MODE;

typedef struct D2D1_ROUNDED_RECT {

    D2D1_RECT_F rect;

    single radiusX;

    single radiusY;
} D2D1_ROUNDED_RECT;

typedef struct D2D1_ELLIPSE {

    D2D1_POINT_2F point;

    single radiusX;

    single radiusY;
} D2D1_ELLIPSE;



typedef enum D2D1_FILL_MODE {
    D2D1_FILL_MODE_ALTERNATE = 0,
    D2D1_FILL_MODE_WINDING = 1,
    D2D1_FILL_MODE_FORCE_DWORD = 0xffffffff
} D2D1_FILL_MODE;

typedef enum D2D1_PATH_SEGMENT {
    D2D1_PATH_SEGMENT_NONE = 0,
    D2D1_PATH_SEGMENT_FORCE_UNSTROKED = 1,
    D2D1_PATH_SEGMENT_FORCE_ROUND_LINE_JOIN = 2,
    D2D1_PATH_SEGMENT_FORCE_DWORD = 0xffffffff
} D2D1_PATH_SEGMENT;

typedef enum D2D1_FIGURE_BEGIN {
    D2D1_FIGURE_BEGIN_FILLED = 0,
    D2D1_FIGURE_BEGIN_HOLLOW = 1,
    D2D1_FIGURE_BEGIN_FORCE_DWORD = 0xffffffff
} D2D1_FIGURE_BEGIN;

typedef struct D2D1_BEZIER_SEGMENT {

    D2D1_POINT_2F point1;

    D2D1_POINT_2F point2;

    D2D1_POINT_2F point3;
} D2D1_BEZIER_SEGMENT;

typedef enum D2D1_FIGURE_END {
    D2D1_FIGURE_END_OPEN = 0,
    D2D1_FIGURE_END_CLOSED = 1,
    D2D1_FIGURE_END_FORCE_DWORD = 0xffffffff
} D2D1_FIGURE_END;

typedef struct D2D1_QUADRATIC_BEZIER_SEGMENT {

    D2D1_POINT_2F point1;

    D2D1_POINT_2F point2;
} D2D1_QUADRATIC_BEZIER_SEGMENT;

typedef struct D2D1_VECTOR_2F {
    FLOAT x;
    FLOAT y;
} D2D_VECTOR_2F;
typedef struct D2D_VECTOR_2F {
    FLOAT x;
    FLOAT y;
} D2D1_VECTOR_2F;

typedef enum D2D1_SWEEP_DIRECTION {
    D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE = 0,
    D2D1_SWEEP_DIRECTION_CLOCKWISE = 1,
    D2D1_SWEEP_DIRECTION_FORCE_DWORD = 0xffffffff
} D2D1_SWEEP_DIRECTION;


typedef enum D2D1_ARC_SIZE {
    D2D1_ARC_SIZE_SMALL = 0,
    D2D1_ARC_SIZE_LARGE = 1,
    D2D1_ARC_SIZE_FORCE_DWORD = 0xffffffff
} D2D1_ARC_SIZE;

typedef struct D2D1_ARC_SEGMENT {

    D2D1_POINT_2F point;

    D2D1_SIZE_F size;

    single rotationAngle;

    D2D1_SWEEP_DIRECTION sweepDirection;

    D2D1_ARC_SIZE arcSize;
} D2D1_ARC_SEGMENT;

typedef enum D2D1_COMPOSITE_MODE {
    D2D1_COMPOSITE_MODE_SOURCE_OVER = 0,
    D2D1_COMPOSITE_MODE_DESTINATION_OVER = 1,
    D2D1_COMPOSITE_MODE_SOURCE_IN = 2,
    D2D1_COMPOSITE_MODE_DESTINATION_IN = 3,
    D2D1_COMPOSITE_MODE_SOURCE_OUT = 4,
    D2D1_COMPOSITE_MODE_DESTINATION_OUT = 5,
    D2D1_COMPOSITE_MODE_SOURCE_ATOP = 6,
    D2D1_COMPOSITE_MODE_DESTINATION_ATOP = 7,
    D2D1_COMPOSITE_MODE_XOR = 8,
    D2D1_COMPOSITE_MODE_PLUS = 9,
    D2D1_COMPOSITE_MODE_SOURCE_COPY = 10,
    D2D1_COMPOSITE_MODE_BOUNDED_SOURCE_COPY = 11,
    D2D1_COMPOSITE_MODE_MASK_INVERT = 12,
    D2D1_COMPOSITE_MODE_FORCE_DWORD = 0xffffffff
} D2D1_COMPOSITE_MODE;

typedef enum D2D1_CAP_STYLE {
    D2D1_CAP_STYLE_FLAT = 0,
    D2D1_CAP_STYLE_SQUARE = 1,
    D2D1_CAP_STYLE_ROUND = 2,
    D2D1_CAP_STYLE_TRIANGLE = 3,
    D2D1_CAP_STYLE_FORCE_DWORD = 0xffffffff
} D2D1_CAP_STYLE;

typedef enum D2D1_LINE_JOIN {
    D2D1_LINE_JOIN_MITER = 0,
    D2D1_LINE_JOIN_BEVEL = 1,
    D2D1_LINE_JOIN_ROUND = 2,
    D2D1_LINE_JOIN_MITER_OR_BEVEL = 3,
    D2D1_LINE_JOIN_FORCE_DWORD = 0xffffffff
} D2D1_LINE_JOIN;

typedef enum D2D1_DASH_STYLE {
    D2D1_DASH_STYLE_SOLID = 0,
    D2D1_DASH_STYLE_DASH = 1,
    D2D1_DASH_STYLE_DOT = 2,
    D2D1_DASH_STYLE_DASH_DOT = 3,
    D2D1_DASH_STYLE_DASH_DOT_DOT = 4,
    D2D1_DASH_STYLE_CUSTOM = 5,
    D2D1_DASH_STYLE_FORCE_DWORD = 0xffffffff
} D2D1_DASH_STYLE;

typedef enum D2D1_GEOMETRY_RELATION {
    D2D1_GEOMETRY_RELATION_UNKNOWN = 0,
    D2D1_GEOMETRY_RELATION_DISJOINT = 1,
    D2D1_GEOMETRY_RELATION_IS_CONTAINED = 2,
    D2D1_GEOMETRY_RELATION_CONTAINS = 3,
    D2D1_GEOMETRY_RELATION_OVERLAP = 4,
    D2D1_GEOMETRY_RELATION_FORCE_DWORD = 0xffffffff
} D2D1_GEOMETRY_RELATION;

typedef enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION {
    D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES = 0,
    D2D1_GEOMETRY_SIMPLIFICATION_OPTION_LINES = 1,
    D2D1_GEOMETRY_SIMPLIFICATION_OPTION_FORCE_DWORD = 0xffffffff
} D2D1_GEOMETRY_SIMPLIFICATION_OPTION;

typedef struct D2D1_STROKE_STYLE_PROPERTIES {

    D2D1_CAP_STYLE startCap;

    D2D1_CAP_STYLE endCap;

    D2D1_CAP_STYLE dashCap;

    D2D1_LINE_JOIN lineJoin;

    single miterLimit;

    D2D1_DASH_STYLE dashStyle;

    single dashOffset;
} D2D1_STROKE_STYLE_PROPERTIES;

typedef enum D2D1_ANTIALIAS_MODE {
    D2D1_ANTIALIAS_MODE_PER_PRIMITIVE = 0,
    D2D1_ANTIALIAS_MODE_ALIASED = 1,
    D2D1_ANTIALIAS_MODE_FORCE_DWORD = 0xffffffff
} D2D1_ANTIALIAS_MODE;

typedef enum D2D1_TEXT_ANTIALIAS_MODE {
    D2D1_TEXT_ANTIALIAS_MODE_DEFAULT = 0,
    D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE = 1,
    D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE = 2,
    D2D1_TEXT_ANTIALIAS_MODE_ALIASED = 3,
    D2D1_TEXT_ANTIALIAS_MODE_FORCE_DWORD = 0xffffffff
} D2D1_TEXT_ANTIALIAS_MODE;

typedef struct D2D1_DRAWING_STATE_DESCRIPTION {

    D2D1_ANTIALIAS_MODE antialiasMode;

    D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode;

    CURRENCY tag1;

    CURRENCY tag2;

    D2D1_MATRIX_3X2_F transform;
} D2D1_DRAWING_STATE_DESCRIPTION;

typedef enum D2D1_RENDER_TARGET_TYPE {
    D2D1_RENDER_TARGET_TYPE_DEFAULT = 0,
    D2D1_RENDER_TARGET_TYPE_SOFTWARE = 1,
    D2D1_RENDER_TARGET_TYPE_HARDWARE = 2,
    D2D1_RENDER_TARGET_TYPE_FORCE_DWORD = 0xffffffff
} D2D1_RENDER_TARGET_TYPE;

typedef enum D2D1_RENDER_TARGET_USAGE {
    D2D1_RENDER_TARGET_USAGE_NONE = 0,
    D2D1_RENDER_TARGET_USAGE_FORCE_BITMAP_REMOTING = 1,
    D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE = 2,
    D2D1_RENDER_TARGET_USAGE_FORCE_DWORD = 0xffffffff
} D2D1_RENDER_TARGET_USAGE;

typedef enum D2D1_FEATURE_LEVEL {
    D2D1_FEATURE_LEVEL_DEFAULT = 0,
    D2D1_FEATURE_LEVEL_9 = 37120,
    D2D1_FEATURE_LEVEL_10 = 40960,
    D2D1_FEATURE_LEVEL_FORCE_DWORD = 0xffffffff
} D2D1_FEATURE_LEVEL;

typedef struct D2D1_RENDER_TARGET_PROPERTIES {

    D2D1_RENDER_TARGET_TYPE type;

    D2D1_PIXEL_FORMAT pixelFormat;

    single dpiX;

    single dpiY;

    D2D1_RENDER_TARGET_USAGE usage;

    D2D1_FEATURE_LEVEL minLevel;
} D2D1_RENDER_TARGET_PROPERTIES;




typedef struct D2D1_BITMAP_PROPERTIES {

    D2D1_PIXEL_FORMAT pixelFormat;

    single dpiX;

    single dpiY;
} D2D1_BITMAP_PROPERTIES;




typedef enum
{
    D2D1_INTERPOLATION_MODE_DEFINITION_NEAREST_NEIGHBOR = 0,
    D2D1_INTERPOLATION_MODE_DEFINITION_LINEAR = 1,
    D2D1_INTERPOLATION_MODE_DEFINITION_CUBIC = 2,
    D2D1_INTERPOLATION_MODE_DEFINITION_MULTI_SAMPLE_LINEAR = 3,
    D2D1_INTERPOLATION_MODE_DEFINITION_ANISOTROPIC = 4,
    D2D1_INTERPOLATION_MODE_DEFINITION_HIGH_QUALITY_CUBIC = 5,
    D2D1_INTERPOLATION_MODE_DEFINITION_FANT = 6,
    D2D1_INTERPOLATION_MODE_DEFINITION_MIPMAP_LINEAR = 7

} D2D1_INTERPOLATION_MODE_DEFINITION;

typedef enum {
    D2D1_GAMMA_2_2 = 0,
    D2D1_GAMMA_1_0 = 1,
    D2D1_GAMMA_FORCE_DWORD = 0xffffffff
} D2D1_GAMMA;

typedef enum {
    D2D1_EXTEND_MODE_CLAMP = 0,
    D2D1_EXTEND_MODE_WRAP = 1,
    D2D1_EXTEND_MODE_MIRROR = 2,
    D2D1_EXTEND_MODE_FORCE_DWORD = 0xffffffff
} D2D1_EXTEND_MODE;

typedef enum {
    D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_BITMAP_INTERPOLATION_MODE_LINEAR = 1,
    D2D1_BITMAP_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff
} D2D1_BITMAP_INTERPOLATION_MODE;

typedef struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES {

    D2D1_POINT_2F startPoint;

    D2D1_POINT_2F endPoint;
} D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES;

typedef struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES {

    D2D1_POINT_2F center;

    D2D1_POINT_2F gradientOriginOffset;

    single radiusX;

    single radiusY;
} D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES;

typedef enum {
    D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE = 0,
    D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE = 1,
    D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_FORCE_DWORD = 0xffffffff
} D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS;

typedef enum {
    D2D1_OPACITY_MASK_CONTENT_GRAPHICS = 0,
    D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL = 1,
    D2D1_OPACITY_MASK_CONTENT_TEXT_GDI_COMPATIBLE = 2,
    D2D1_OPACITY_MASK_CONTENT_FORCE_DWORD = 0xffffffff
} D2D1_OPACITY_MASK_CONTENT;

typedef enum {
    D2D1_DRAW_TEXT_OPTIONS_NO_SNAP = 1,
    D2D1_DRAW_TEXT_OPTIONS_CLIP = 2,
    D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT = 4,
    D2D1_DRAW_TEXT_OPTIONS_DISABLE_COLOR_BITMAP_SNAPPING = 8,
    D2D1_DRAW_TEXT_OPTIONS_NONE = 0,
    D2D1_DRAW_TEXT_OPTIONS_FORCE_DWORD = 0xffffffff
} D2D1_DRAW_TEXT_OPTIONS;

typedef enum {
    D2D1_LAYER_OPTIONS_NONE = 0,
    D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE = 1,
    D2D1_LAYER_OPTIONS_FORCE_DWORD = 0xffffffff
} D2D1_LAYER_OPTIONS;

typedef struct D2D1_LAYER_PARAMETERS {

    D2D1_RECT_F contentBounds;

    ID2D1Geometry* geometricMask;

    D2D1_ANTIALIAS_MODE maskAntialiasMode;

    D2D1_MATRIX_3X2_F maskTransform;

    single opacity;

    ID2D1Brush* opacityBrush;

    D2D1_LAYER_OPTIONS layerOptions;
} D2D1_LAYER_PARAMETERS;


typedef enum {
    D2D1_PRESENT_OPTIONS_NONE = 0,
    D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS = 1,
    D2D1_PRESENT_OPTIONS_IMMEDIATELY = 2,
    D2D1_PRESENT_OPTIONS_FORCE_DWORD = 0xffffffff
} D2D1_PRESENT_OPTIONS;

typedef struct D2D1_HWND_RENDER_TARGET_PROPERTIES {

    LongPtr hwnd;

    D2D1_SIZE_U pixelSize;

    D2D1_PRESENT_OPTIONS presentOptions;
} D2D1_HWND_RENDER_TARGET_PROPERTIES;


typedef enum {
    D2D1_WINDOW_STATE_NONE = 0,
    D2D1_WINDOW_STATE_OCCLUDED = 1,
    D2D1_WINDOW_STATE_FORCE_DWORD = 0xffffffff
} D2D1_WINDOW_STATE;

typedef enum {
    D2D1_DC_INITIALIZE_MODE_COPY = 0,
    D2D1_DC_INITIALIZE_MODE_CLEAR = 1,
    D2D1_DC_INITIALIZE_MODE_FORCE_DWORD = 0xffffffff
} D2D1_DC_INITIALIZE_MODE;

typedef enum {
    D2D1_DEBUG_LEVEL_NONE = 0,
    D2D1_DEBUG_LEVEL_ERROR = 1,
    D2D1_DEBUG_LEVEL_WARNING = 2,
    D2D1_DEBUG_LEVEL_INFORMATION = 3,
    D2D1_DEBUG_LEVEL_FORCE_DWORD = 0xffffffff
} D2D1_DEBUG_LEVEL;

typedef enum {
    D2D1_FACTORY_TYPE_SINGLE_THREADED = 0,
    D2D1_FACTORY_TYPE_MULTI_THREADED = 1,
    D2D1_FACTORY_TYPE_FORCE_DWORD = 0xffffffff
} D2D1_FACTORY_TYPE;

typedef struct D2D1_BRUSH_PROPERTIES {

    single opacity;

    D2D1_MATRIX_3X2_F transform;
} D2D1_BRUSH_PROPERTIES;

typedef struct D2D1_BITMAP_BRUSH_PROPERTIES {

    D2D1_EXTEND_MODE extendModeX;

    D2D1_EXTEND_MODE extendModeY;

    D2D1_BITMAP_INTERPOLATION_MODE interpolationMode;
} D2D1_BITMAP_BRUSH_PROPERTIES;

typedef struct D2D1_FACTORY_OPTIONS {

    D2D1_DEBUG_LEVEL debugLevel;
} D2D1_FACTORY_OPTIONS;


[
    odl,
    uuid(06152247-6F50-465A-9245-118BFD3B6007),
    helpstring("Creates Direct2D resources.")
]
interface ID2D1Factory : stdole.IUnknown {
    [helpstring("Forces the factory to refresh any system defaults that it might have changed since factory creation.")]
    HRESULT _stdcall ReloadSystemMetrics();
    [helpstring("Retrieves the current desktop DPI. To refresh this, call ReloadSystemMetrics.")]
    void _stdcall GetDesktopDpi(
        [in, out] single* dpiX,
        [in, out] single* dpiY);
    [helpstring("Creates an ID2D1RectangleGeometry.")]
    HRESULT _stdcall CreateRectangleGeometry(
        [in] D2D1_RECT_F* rectangle,
        [out, retval] ID2D1RectangleGeometry** rectangleGeometry);
    [helpstring("Creates an ID2D1RoundedRectangleGeometry.")]
    HRESULT _stdcall CreateRoundedRectangleGeometry(
        [in] D2D1_ROUNDED_RECT* roundedRectangle,
        [out, retval] ID2D1RoundedRectangleGeometry** roundedRectangleGeometry);
    [helpstring("Creates an ID2D1EllipseGeometry.")]
    HRESULT _stdcall CreateEllipseGeometry(
        [in] D2D1_ELLIPSE* ellipse,
        [out, retval] ID2D1EllipseGeometry** ellipseGeometry);
    [helpstring("Creates an ID2D1GeometryGroup, which is an object that holds other geometries.")]
    HRESULT _stdcall CreateGeometryGroup(
        [in] D2D1_FILL_MODE fillMode,
        [in] ID2D1Geometry* geometries,
        [in] long geometriesCount,
        [out, retval] ID2D1GeometryGroup** geometryGroup);
    [helpstring("Transforms the specified geometry and stores the result as an ID2D1TransformedGeometry object.")]
    HRESULT _stdcall CreateTransformedGeometry(
        [in] ID2D1Geometry* sourceGeometry,
        [in] D2D1_MATRIX_3X2_F* transform,
        [out, retval] ID2D1TransformedGeometry** transformedGeometry);
    [helpstring("Creates an empty ID2D1PathGeometry.")]
    HRESULT _stdcall CreatePathGeometry([out, retval] ID2D1PathGeometry** pathGeometry);
    [helpstring("Creates an ID2D1StrokeStyle that describes start cap, dash pattern, and other features of a stroke.")]
    HRESULT _stdcall CreateStrokeStyle(
        [in] D2D1_STROKE_STYLE_PROPERTIES* strokeStyleProperties,
        [in] void* dashes,
        [in] long dashesCount,
        [out, retval] ID2D1StrokeStyle** strokeStyle);
    [helpstring("Creates an ID2D1DrawingStateBlock that can be used with the SaveDrawingState and RestoreDrawingState methods of a render target.")]
    HRESULT _stdcall CreateDrawingStateBlock(
        [in, out] void* drawingStateDescription,
        [in] void* textRenderingParams,
        [out, retval] ID2D1DrawingStateBlock** drawingStateBlock);
    [helpstring("Creates a render target that renders to a Microsoft Windows Imaging Component (WIC) bitmap.")]
    HRESULT _stdcall CreateWicBitmapRenderTarget(
        [in] void* target,
        [in] D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,
        [out, retval] ID2D1RenderTarget** renderTarget);
    [helpstring("Creates an ID2D1HwndRenderTarget, a render target that renders to a window.")]
    HRESULT _stdcall CreateHwndRenderTarget(
        [in] D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,
        [in] D2D1_HWND_RENDER_TARGET_PROPERTIES* hwndRenderTargetProperties,
        [out, retval] ID2D1HwndRenderTarget** hwndRenderTarget);
    [helpstring("Creates a render target that draws to a DirectX Graphics Infrastructure (DXGI) surface.")]
    HRESULT _stdcall CreateDxgiSurfaceRenderTarget(
        [in] void* dxgiSurface,
        [in] D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,
        [out, retval] ID2D1RenderTarget** renderTarget);
    [helpstring("Creates a render target that draws to a Windows Graphics Device Interface (GDI) device context.")]
    HRESULT _stdcall CreateDCRenderTarget(
        [in] D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,
        [out, retval] ID2D1DCRenderTarget** dcRenderTarget);
};

[
    odl,
    uuid(2CD90691-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents a Direct2D drawing resource.")
]
interface ID2D1Resource : stdole.IUnknown{
    [helpstring("Retrieve the factory associated with this resource.")]
    void _stdcall GetFactory([out] ID2D1Factory * *factory);
};

[
    odl,
    uuid(2CD9069E-12E2-11DC-9FED-001143A055F9),
    helpstring("Describes a geometric path that does not contain quadratic bezier curves or arcs.")
]
interface ID2D1SimplifiedGeometrySink : stdole.IUnknown{
    [helpstring("Specifies the method used to determine which points are inside the geometry described by this geometry sink and which points are outside.")]
    void _stdcall SetFillMode([in] D2D1_FILL_MODE fillMode);
    [helpstring("Specifies stroke and join options to be applied to new segments added to the geometry sink.")]
    void _stdcall SetSegmentFlags([in] D2D1_PATH_SEGMENT vertexFlags);
    [helpstring("Starts a new figure at the specified point.")]
    void _stdcall BeginFigure(
        [in] single startPointX,
        [in] single startPointY,
        [in] D2D1_FIGURE_BEGIN figureBegin);
    [helpstring("Creates a sequence of lines using the specified points and adds them to the geometry sink.")]
    void _stdcall AddLines(
        [in] D2D1_POINT_2F* points,
        [in] long pointsCount);
    [helpstring("Creates a sequence of cubic Bezier curves and adds them to the geometry sink.")]
    void _stdcall AddBeziers(
        [in] D2D1_BEZIER_SEGMENT* beziers,
        [in] long beziersCount);
    [helpstring("Ends the current figure; optionally, closes it.")]
    void _stdcall EndFigure([in] D2D1_FIGURE_END figureEnd);
    [helpstring("Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state.")]
    HRESULT _stdcall Close();
};



[
    odl,
    uuid(2CD906C1-12E2-11DC-9FED-001143A055F9),
    helpstring("Populates an ID2D1Mesh object with triangles.")
]
interface ID2D1TessellationSink : stdole.IUnknown{
    [helpstring("Copies the specified triangles to the sink.")]
    void _stdcall AddTriangles(
        [in] D2D1_TRIANGLE * triangles,
        [in] long trianglesCount);
    [helpstring("Closes the sink and returns its error status.")]
    HRESULT _stdcall Close();
};



[
    odl,
    uuid(E0DB51C3-6F77-4BAE-B3D5-E47509B35838),
    helpstring("Provides access to an device context that can accept GDI drawing commands.")
]
interface ID2D1GdiInteropRenderTarget : stdole.IUnknown{
    [helpstring("Retrieves the device context associated with this render target.")]
    HRESULT _stdcall GetDC(
        [in] D2D1_DC_INITIALIZE_MODE mode,
        [out, retval] long* hDC);
    [helpstring("Indicates that drawing with the device context retrieved using the GetDC method is finished.")]
    HRESULT _stdcall ReleaseDC([in, out] void* rect_update);
};

[
    odl,
    uuid(2CD906A2-12E2-11DC-9FED-001143A055F9),
    helpstring("Describes a two-dimensional rectangle.")
]
interface ID2D1RectangleGeometry : ID2D1Geometry {
    [helpstring("Retrieves the rectangle that describes the rectangle geometry's dimensions.")]
    void _stdcall GetRect([out] D2D1_RECT_F* rect);
};

[
    odl,
    uuid(2CD906A1-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents a geometry resource and defines a set of helper methods for manipulating and measuring geometric shapes. Interfaces that inherit from ID2D1Geometry define specific shapes.")
]
interface ID2D1Geometry : ID2D1Resource {
    [helpstring("Retrieve the bounds of the geometry, with an optional applied transform.")]
    HRESULT _stdcall GetBounds(
        [in, out] void* worldTransform,
        [out, retval] D2D1_RECT_F* bounds);
    [helpstring("Get the bounds of the corresponding geometry after it has been widened or have an optional pen style applied.")]
    HRESULT _stdcall GetWidenedBounds(
        [in] single strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle,
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [out, retval] D2D1_RECT_F* bounds);
    [helpstring("Checks to see whether the corresponding penned and widened geometry contains the given point.")]
    HRESULT _stdcall StrokeContainsPoint(
        [in] single pointX,
        [in] single pointY,
        [in] single strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle,
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [out, retval] long* contains);
    [helpstring("Test whether the given fill of this geometry would contain this point.")]
    HRESULT _stdcall FillContainsPoint(
        [in] single pointX,
        [in] single pointY,
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [out, retval] long* contains);
    [helpstring("Compare how one geometry intersects or contains another geometry.")]
    HRESULT _stdcall CompareWithGeometry(
        [in] ID2D1Geometry* inputGeometry,
        [in, out] void* inputGeometryTransform,
        [in] single flatteningTolerance,
        [out, retval] D2D1_GEOMETRY_RELATION* relation);
    [helpstring("Converts a geometry to a simplified geometry that has arcs and quadratic beziers removed.")]
    HRESULT _stdcall Simplify(
        [in] D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [in] ID2D1SimplifiedGeometrySink* geometrySink);
    [helpstring("Tessellates a geometry into triangles.")]
    HRESULT _stdcall Tessellate(
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [in] ID2D1TessellationSink* tessellationSink);
    [helpstring("Performs a combine operation between the two geometries to produce a resulting geometry.")]
    HRESULT _stdcall CombineWithGeometry(
        [in] ID2D1Geometry* inputGeometry,
        [in] D2D1_COMBINE_MODE combineMode,
        [in, out] void* inputGeometryTransform,
        [in] single flatteningTolerance,
        [in] ID2D1SimplifiedGeometrySink* geometrySink);
    [helpstring("Computes the outline of the geometry. The result is written back into a simplified geometry sink.")]
    HRESULT _stdcall Outline(
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [in] ID2D1SimplifiedGeometrySink* geometrySink);
    [helpstring("Computes the area of the geometry.")]
    HRESULT _stdcall ComputeArea(
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [out, retval] single* area);
    [helpstring("Computes the length of the geometry.")]
    HRESULT _stdcall ComputeLength(
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [out, retval] single* length);
    [helpstring("Computes the point and tangent a given distance along the path.")]
    HRESULT _stdcall ComputePointAtLength(
        [in] single length,
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [in, out] void* point,
        [in, out] void* unitTangentVector);
    [helpstring("Get the geometry and widen it as well as apply an optional pen style.")]
    HRESULT _stdcall Widen(
        [in] single strokeWidth,
        [in, out] void* strokeStyle,
        [in, out] void* worldTransform,
        [in] single flatteningTolerance,
        [in] ID2D1SimplifiedGeometrySink* geometrySink);
};

[
    odl,
    uuid(2CD9069D-12E2-11DC-9FED-001143A055F9),
    helpstring("Describes the caps, miter limit, line join, and dash information for a stroke.")
]
interface ID2D1StrokeStyle : ID2D1Resource {
    [helpstring("Retrieves the type of shape used at the beginning of a stroke.")]
    D2D1_CAP_STYLE _stdcall GetStartCap();
    [helpstring("Retrieves the type of shape used at the end of a stroke.")]
    D2D1_CAP_STYLE _stdcall GetEndCap();
    [helpstring("Gets a value that specifies how the ends of each dash are drawn.")]
    D2D1_CAP_STYLE _stdcall GetDashCap();
    [helpstring("Retrieves the limit on the ratio of the miter length to half the stroke's thickness.")]
    single _stdcall GetMiterLimit();
    [helpstring("Retrieves the type of joint used at the vertices of a shape's outline.")]
    D2D1_LINE_JOIN _stdcall GetLineJoin();
    [helpstring("Retrieves a value that specifies how far in the dash sequence the stroke will start.")]
    single _stdcall GetDashOffset();
    [helpstring("Gets a value that describes the stroke's dash pattern.")]
    D2D1_DASH_STYLE _stdcall GetDashStyle();
    [helpstring("Retrieves the number of entries in the dashes array.")]
    long _stdcall GetDashesCount();
    [helpstring("Copies the dash pattern to the specified array.")]
    void _stdcall GetDashes(
        [in, out] single* dashes,
        [in] long dashesCount);
};


[
    odl,
    uuid(2CD906A3-12E2-11DC-9FED-001143A055F9),
    helpstring("Describes a rounded rectangle.")
]
interface ID2D1RoundedRectangleGeometry : ID2D1Geometry {
    [helpstring("Retrieves a rounded rectangle that describes this rounded rectangle geometry.")]
    void _stdcall GetRoundedRect([out] D2D1_ROUNDED_RECT* roundedRect);
};


[
    odl,
    uuid(2CD906A4-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents an ellipse.")
]
interface ID2D1EllipseGeometry : ID2D1Geometry {
    [helpstring("Gets the D2D1_ELLIPSE structure that describes this ellipse geometry.")]
    void _stdcall GetEllipse([out] D2D1_ELLIPSE* ellipse);
};

[
    odl,
    uuid(2CD906A6-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents a composite geometry, composed of other ID2D1Geometry objects.")
]
interface ID2D1GeometryGroup : ID2D1Geometry {
    [helpstring("Indicates how the intersecting areas of the geometries contained in this geometry group are combined.")]
    D2D1_FILL_MODE _stdcall GetFillMode();
    [helpstring("Indicates the number of geometry objects in the geometry group.")]
    long _stdcall GetSourceGeometryCount();
    [helpstring("Retrieves the geometries in the geometry group.")]
    void _stdcall GetSourceGeometries(
        [in, out] ID2D1Geometry** geometries,
        [in] long geometriesCount);
};

[
    odl,
    uuid(2CD906BB-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents a geometry that has been transformed.")
]
interface ID2D1TransformedGeometry : ID2D1Geometry {
    [helpstring("Retrieves the source geometry of this transformed geometry object.")]
    HRESULT _stdcall GetSourceGeometry([out, retval] ID2D1Geometry** sourceGeometry);
    [helpstring("Retrieves the matrix used to transform the ID2D1TransformedGeometry object's source geometry.")]
    void _stdcall GetTransform([out] D2D1_MATRIX_3X2_F* transform);
};

[
    odl,
    uuid(2CD906A5-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents a complex shape that may be composed of arcs, curves, and lines.")
]
interface ID2D1PathGeometry : ID2D1Geometry {
    [helpstring("Retrieves the geometry sink that is used to populate the path geometry with figures and segments.")]
    HRESULT _stdcall Open([out, retval] ID2D1GeometrySink** geometrySink);
    [helpstring("Copies the contents of the path geometry to the specified ID2D1GeometrySink.")]
    HRESULT _stdcall Stream([in] ID2D1GeometrySink* geometrySink);
    [helpstring("Retrieves the number of segments in the path geometry.")]
    HRESULT _stdcall GetSegmentCount([out, retval] long* count);
    [helpstring("Retrieves the number of figures in the path geometry.")]
    HRESULT _stdcall GetFigureCount([out, retval] long* count);
};

[
    odl,
    uuid(2CD9069F-12E2-11DC-9FED-001143A055F9),
    helpstring("Describes a geometric path that can contain lines, arcs, cubic Bezier curves, and quadratic Bezier curves.")
]
interface ID2D1GeometrySink : ID2D1SimplifiedGeometrySink {
    [helpstring("Creates a line segment between the current point and the specified end point and adds it to the geometry sink.")]
    void _stdcall AddLine(
        [in] single pointX,
        [in] single pointY);
    [helpstring("Creates a cubic Bezier curve between the current point and the specified end point and adds it to the geometry sink.")]
    void _stdcall AddBezier([in] D2D1_BEZIER_SEGMENT* bezier);
    [helpstring("Creates a quadratic Bezier curve between the current point and the specified end point and adds it to the geometry sink.")]
    void _stdcall AddQuadraticBezier([in] D2D1_QUADRATIC_BEZIER_SEGMENT* bezier);
    [helpstring("Adds a sequence of quadratic Bezier segments as an array in a single call.")]
    void _stdcall AddQuadraticBeziers(
        [in] D2D1_QUADRATIC_BEZIER_SEGMENT* beziers,
        [in] long beziersCount);
    [helpstring("Creates a single arc and adds it to the path geometry.")]
    void _stdcall AddArc([in] D2D1_ARC_SEGMENT* arc);
};


[
    odl,
    uuid(28506E39-EBF6-46A1-BB47-FD85565AB957),
    helpstring("Represents the drawing state of a render target: the antialiasing mode, transform, tags, and text-rendering options.")
]
interface ID2D1DrawingStateBlock : ID2D1Resource {
    [helpstring("Retrieves the state currently contained within this state block resource.")]
    void _stdcall GetDescription([out] D2D1_DRAWING_STATE_DESCRIPTION* stateDescription);
    [helpstring("Sets the state description of this state block resource.")]
    void _stdcall SetDescription([in] D2D1_DRAWING_STATE_DESCRIPTION* stateDescription);
    [helpstring("Sets the text rendering parameters of this state block resource.")]
    void _stdcall SetTextRenderingParams([in] void* textRenderingParams);
    [helpstring("Retrieves the text rendering parameters contained within this state block resource. If a Nothing text rendering parameter was specified, Nothing will be returned.")]
    void _stdcall GetTextRenderingParams([out] void** textRenderingParams);
};


[
    odl,
    uuid(2CD90694-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents an object that can receive drawing commands. Interfaces that inherit from ID2D1RenderTarget render the drawing commands they receive in different ways.")
]
interface ID2D1RenderTarget : ID2D1Resource {
    [helpstring("Create a D2D bitmap by copying from memory, or create uninitialized.")]
    HRESULT _stdcall CreateBitmap(
        [in] int width,
        [in] int height,
        [in, out] void* srcData,
        [in] long pitch,
        [in] D2D1_BITMAP_PROPERTIES* bitmapProperties,
        [out, retval] ID2D1Bitmap** bitmap);
    [helpstring("Create a D2D bitmap by copying a WIC bitmap.")]
    HRESULT _stdcall CreateBitmapFromWicBitmap(
        [in] void* wicBitmapSource,
        [in, out] void* bitmapProperties,
        [out, retval] ID2D1Bitmap** bitmap);
    [helpstring("Create a D2D bitmap by sharing bits from another resource. The bitmap must be compatible with the render target for the call to succeed.")]
    HRESULT _stdcall CreateSharedBitmap(
        [in, out] void* riid,
        [in, out] void* data,
        [in, out] void* bitmapProperties,
        [out, retval] ID2D1Bitmap** bitmap);
    [helpstring("Creates a bitmap brush. The bitmap is scaled, rotated, skewed or tiled to fill or pen a geometry.")]
    HRESULT _stdcall CreateBitmapBrush(
        [in] ID2D1Bitmap* bitmap,
        [in, out] void* bitmapBrushProperties,
        [in, out] void* brushProperties,
        [out, retval] ID2D1BitmapBrush** bitmapBrush);
    [helpstring("Creates a new ID2D1SolidColorBrush that can be used to paint areas with a solid color.")]
    HRESULT _stdcall CreateSolidColorBrush(
        [in] D2D1_COLOR_F* color,
        [in, out] void* brushProperties,
        [out, retval] ID2D1SolidColorBrush** solidColorBrush);
    [helpstring("Creates an ID2D1GradientStopCollection from the specified array of D2D1_GRADIENT_STOP structures.")]
    HRESULT _stdcall CreateGradientStopCollection(
        [in] D2D1_GRADIENT_STOP* gradientStops,
        [in] long gradientStopsCount,
        [in] D2D1_GAMMA colorInterpolationGamma,
        [in] D2D1_EXTEND_MODE extendMode,
        [out, retval] ID2D1GradientStopCollection** gradientStopCollection);
    [helpstring("Creates an ID2D1LinearGradientBrush object for painting areas with a linear gradient.")]
    HRESULT _stdcall CreateLinearGradientBrush(
        [in] D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES* linearGradientBrushProperties,
        [in, out] void* brushProperties,
        [in] ID2D1GradientStopCollection* gradientStopCollection,
        [out, retval] ID2D1LinearGradientBrush** linearGradientBrush);
    [helpstring("Creates an ID2D1RadialGradientBrush object that can be used to paint areas with a radial gradient.")]
    HRESULT _stdcall CreateRadialGradientBrush(
        [in] D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,
        [in, out] void* brushProperties,
        [in] ID2D1GradientStopCollection* gradientStopCollection,
        [out, retval] ID2D1RadialGradientBrush** radialGradientBrush);
    [helpstring("Creates a new bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target.")]
    HRESULT _stdcall CreateCompatibleRenderTarget(
        [in] void* desiredSize,
        [in] void* desiredPixelSize,
        [in] void* desiredFormat,
        [in] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,
        [out, retval] ID2D1BitmapRenderTarget** bitmapRenderTarget);
    [helpstring("Creates a layer resource that can be used with this render target and its compatible render targets.")]
    HRESULT _stdcall CreateLayer(
        [in, out] void* size,
        [out, retval] ID2D1Layer** layer);
    [helpstring("Create a mesh that uses triangles to describe a shape.")]
    HRESULT _stdcall CreateMesh([out, retval] ID2D1Mesh** mesh);
    [helpstring("Draws a line between the specified points using the specified stroke style.")]
    void _stdcall DrawLine(
        [in] single point0_x,
        [in] single point0_y,
        [in] single point1_x,
        [in] single point1_y,
        [in] ID2D1Brush* brush,
        [in] single strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle);
    [helpstring("Draws the outline of a rectangle that has the specified dimensions and stroke style.")]
    void _stdcall DrawRectangle(
        [in] D2D1_RECT_F* rect,
        [in] ID2D1Brush* brush,
        [in] single strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle);
    [helpstring("Paints the interior of the specified rectangle.")]
    void _stdcall FillRectangle(
        [in] D2D1_RECT_F* rect,
        [in] ID2D1Brush* brush);
    [helpstring("Draws the outline of the specified rounded rectangle using the specified stroke style.")]
    void _stdcall DrawRoundedRectangle(
        [in] D2D1_ROUNDED_RECT* roundedRect,
        [in] ID2D1Brush* brush,
        [in] single strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle);
    [helpstring("Paints the interior of the specified rounded rectangle.")]
    void _stdcall FillRoundedRectangle(
        [in] D2D1_ROUNDED_RECT* roundedRect,
        [in] ID2D1Brush* brush);
    [helpstring("Draws the outline of an ellipse with the specified dimensions and stroke.")]
    void _stdcall DrawEllipse(
        [in] D2D1_ELLIPSE* ellipse,
        [in] ID2D1Brush* brush,
        [in] single strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle);
    [helpstring("Paints the interior of the specified ellipse.")]
    void _stdcall FillEllipse(
        [in] D2D1_ELLIPSE* ellipse,
        [in] ID2D1Brush* brush);
    [helpstring("Draws the outline of the specified geometry using the specified stroke style.")]
    void _stdcall DrawGeometry(
        [in] ID2D1Geometry* geometry,
        [in] ID2D1Brush* brush,
        [in] single strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle);
    [helpstring("Paints the interior of the specified geometry.")]
    void _stdcall FillGeometry(
        [in] ID2D1Geometry* geometry,
        [in] ID2D1Brush* brush,
        [in] ID2D1Brush* opacityBrush);
    [helpstring("Paints the interior of the specified mesh.")]
    void _stdcall FillMesh(
        [in] ID2D1Mesh* mesh,
        [in] ID2D1Brush* brush);
    [helpstring("Applies the opacity mask described by the specified bitmap to a brush and uses that brush to paint a region of the render target.")]
    void _stdcall FillOpacityMask(
        [in] ID2D1Bitmap* opacityMask,
        [in] ID2D1Brush* brush,
        [in] D2D1_OPACITY_MASK_CONTENT content,
        [in, out] void* destinationRectangle,
        [in, out] void* sourceRectangle);
    [helpstring("Draws the specified ID2D1Bitmap.")]
    void _stdcall DrawBitmap(
        [in] ID2D1Bitmap* bitmap,
        [in] void* destinationRectangle,
        [in] single opacity,
        [in] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,
        [in] void* sourceRectangle);
    [helpstring("Draws the specified text using the format information provided by an IDWriteTextFormat object.")]
    void _stdcall DrawText(
        [in] LPWSTR string,
        [in] long stringLength,
        [in] void* textFormat,
        [in] D2D1_RECT_F* layoutRect,
        [in] ID2D1Brush* defaultForegroundBrush,
        [in] D2D1_DRAW_TEXT_OPTIONS options,
        [in] DWRITE_MEASURING_MODE measuringMode);
    [helpstring("Draws the formatted text described by the specified IDWriteTextLayout object.")]
    void _stdcall DrawTextLayout(
        [in] single originX,
        [in] single originY,
        [in] void* textLayout,
        [in] ID2D1Brush* defaultForegroundBrush,
        [in] D2D1_DRAW_TEXT_OPTIONS options);
    [helpstring("Draws the specified glyphs.")]
    void _stdcall DrawGlyphRun(
        [in] single baselineOriginX,
        [in] single baselineOriginY,
        [in] void* glyphRun,
        [in] ID2D1Brush* foregroundBrush,
        [in] DWRITE_MEASURING_MODE measuringMode);
    [helpstring("Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.")]
    void _stdcall SetTransform([in] D2D1_MATRIX_3X2_F* transform);
    [helpstring("Gets the current transform of the render target.")]
    void _stdcall GetTransform([out] D2D1_MATRIX_3X2_F* transform);
    [helpstring("Sets the antialiasing mode of the render target. The antialiasing mode applies to all subsequent drawing operations, excluding text and glyph drawing operations.")]
    void _stdcall SetAntialiasMode([in] D2D1_ANTIALIAS_MODE antialiasMode);
    [helpstring("Retrieves the current antialiasing mode for nontext drawing operations.")]
    D2D1_ANTIALIAS_MODE _stdcall GetAntialiasMode();
    [helpstring("Specifies the antialiasing mode to use for subsequent text and glyph drawing operations.")]
    void _stdcall SetTextAntialiasMode([in] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode);
    [helpstring("Gets the current antialiasing mode for text and glyph drawing operations.")]
    D2D1_TEXT_ANTIALIAS_MODE _stdcall GetTextAntialiasMode();
    [helpstring("Specifies text rendering options to be applied to all subsequent text and glyph drawing operations.")]
    void _stdcall SetTextRenderingParams([in] void* textRenderingParams);
    [helpstring("Retrieves the render target's current text rendering options.")]
    HRESULT _stdcall GetTextRenderingParams([out, retval] IUnknown** textRenderingParams);
    [helpstring("Specifies a label for subsequent drawing operations.")]
    void _stdcall SetTags(
        [in] CURRENCY tag1,
        [in] CURRENCY tag2);
    [helpstring("Gets the label for subsequent drawing operations.")]
    void _stdcall GetTags(
        [in, out] void* tag1,
        [in, out] void* tag2);
    [helpstring("Adds the specified layer to the render target so that it receives all subsequent drawing operations until PopLayer is called.")]
    void _stdcall PushLayer(
        [in] D2D1_LAYER_PARAMETERS* layerParameters,
        [in] ID2D1Layer* layer);
    [helpstring("Stops redirecting drawing operations to the layer that is specified by the last PushLayer call.")]
    void _stdcall PopLayer();
    [helpstring("Executes all pending drawing commands.")]
    HRESULT _stdcall Flush(
        [in] void* tag1,
        [in] void* tag2);
    [helpstring("Saves the current drawing state to the specified ID2D1DrawingStateBlock.")]
    void _stdcall SaveDrawingState([in] ID2D1DrawingStateBlock* drawingStateBlock);
    [helpstring("Sets the render target's drawing state to that of the specified ID2D1DrawingStateBlock.")]
    void _stdcall RestoreDrawingState([in] ID2D1DrawingStateBlock* drawingStateBlock);
    [helpstring("Specifies a rectangle to which all subsequent drawing operations are clipped.")]
    void _stdcall PushAxisAlignedClip(
        [in] D2D1_RECT_F* clipRect,
        [in] D2D1_ANTIALIAS_MODE antialiasMode);
    [helpstring("Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations.")]
    void _stdcall PopAxisAlignedClip();
    [helpstring("Clears the drawing area to the specified color.")]
    void _stdcall Clear([in] void* clearColor);
    [helpstring("Initiates drawing on this render target.")]
    void _stdcall BeginDraw();
    [helpstring("Ends drawing operations on the render target and indicates the current error state and associated tags.")]
    HRESULT _stdcall EndDraw(
        [in] void* tag1,
        [in] void* tag2);
    [helpstring("Retrieves the pixel format and alpha mode of the render target.")]
    D2D1_PIXEL_FORMAT _stdcall GetPixelFormat();
    [helpstring("Sets the dots per inch (DPI) of the render target.")]
    void _stdcall SetDpi(
        [in] single dpiX,
        [in] single dpiY);
    [helpstring("Return the render target's dots per inch (DPI).")]
    void _stdcall GetDpi(
        [in, out] single* dpiX,
        [in, out] single* dpiY);
    [helpstring("Returns the size of the render target in device-independent pixels.")]
    D2D1_SIZE_F _stdcall GetSize();
    [helpstring("Returns the size of the render target in device pixels.")]
    D2D1_SIZE_U _stdcall GetPixelSize();
    [helpstring("Gets the maximum size, in device-dependent units (pixels), of any one bitmap dimension supported by the render target.")]
    long _stdcall GetMaximumBitmapSize();
    [helpstring("Indicates whether the render target supports the specified properties.")]
    long _stdcall IsSupported([in] D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties);
};


[
    odl,
    uuid(A2296057-EA42-4099-983B-539FB6505426),
    helpstring("Root bitmap resource, linearly scaled on a draw call.")
]
interface ID2D1Bitmap : ID2D1Resource {
    [helpstring("Returns the size of the bitmap in resolution independent units.")]
    D2D1_SIZE_F _stdcall GetSize();
    [helpstring("Returns the size of the bitmap in resolution dependent units, (pixels).")]
    D2D1_SIZE_U _stdcall GetPixelSize();
    [helpstring("Retrieve the format of the bitmap.")]
    D2D1_PIXEL_FORMAT _stdcall GetPixelFormat();
    [helpstring("Return the DPI of the bitmap.")]
    void _stdcall GetDpi(
        [in, out] single* dpiX,
        [in, out] single* dpiY);
    [helpstring("Copies the specified region from the specified bitmap into the current bitmap.")]
    HRESULT _stdcall CopyFromBitmap(
        [in] void* destPoint,
        [in] ID2D1Bitmap* bitmap,
        [in] void* srcRect);
    [helpstring("Copies the specified region from the specified render target into the current bitmap.")]
    HRESULT _stdcall CopyFromRenderTarget(
        [in] void* destPoint,
        [in] ID2D1RenderTarget* renderTarget,
        [in] void* srcRect);
    [helpstring("Copies the specified region from memory into the current bitmap.")]
    HRESULT _stdcall CopyFromMemory(
        [in] void* dstRect,
        [in] void* srcData,
        [in] long pitch);
};

[
    odl,
    uuid(2CD906A8-12E2-11DC-9FED-001143A055F9),
    helpstring("The root brush interface. All brushes can be used to fill or pen a geometry.")
]
interface ID2D1Brush : ID2D1Resource {
    [helpstring("Sets the opacity for when the brush is drawn over the entire fill of the brush.")]
    void _stdcall SetOpacity([in] single opacity);
    [helpstring("Sets the transform that applies to everything drawn by the brush.")]
    void _stdcall SetTransform([in] D2D1_MATRIX_3X2_F* transform);
    [helpstring("Gets the degree of opacity of this brush.")]
    single _stdcall GetOpacity();
    [helpstring("Gets the transform applied to this brush.")]
    void _stdcall GetTransform([in, out] D2D1_MATRIX_3X2_F* transform);
};

[
    odl,
    uuid(2CD906AA-12E2-11DC-9FED-001143A055F9),
    helpstring("A bitmap brush allows a bitmap to be used to fill a geometry.")
]
interface ID2D1BitmapBrush : ID2D1Brush {
    [helpstring("Sets how the bitmap is to be treated outside of its natural extent on the X axis.")]
    void _stdcall SetExtendModeX([in] D2D1_EXTEND_MODE extendModeX);
    [helpstring("Sets how the bitmap is to be treated outside of its natural extent on the Y axis.")]
    void _stdcall SetExtendModeY([in] D2D1_EXTEND_MODE extendModeY);
    [helpstring("Sets the interpolation mode used when this brush is used.")]
    void _stdcall SetInterpolationMode([in] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode);
    [helpstring("Sets the bitmap associated as the source of this brush.")]
    void _stdcall SetBitmap([in] ID2D1Bitmap* bitmap);
    [helpstring("Gets the method by which the brush horizontally tiles those areas that extend past its bitmap.")]
    D2D1_EXTEND_MODE _stdcall GetExtendModeX();
    [helpstring("Gets the method by which the brush vertically tiles those areas that extend past its bitmap.")]
    D2D1_EXTEND_MODE _stdcall GetExtendModeY();
    [helpstring("Gets the interpolation method used when the brush bitmap is scaled or rotated.")]
    D2D1_BITMAP_INTERPOLATION_MODE _stdcall GetInterpolationMode();
    [helpstring("Gets the bitmap source that this brush uses to paint.")]
    HRESULT _stdcall GetBitmap([out, retval] ID2D1Bitmap** bitmap);
};



[
    odl,
    uuid(2CD906A9-12E2-11DC-9FED-001143A055F9),
    helpstring("Paints an area with a solid color.")
]
interface ID2D1SolidColorBrush : ID2D1Brush {
    [helpstring("Specifies the color of this solid color brush.")]
    void _stdcall SetColor([in] D2D1_COLOR_F* color);
    [helpstring("Retrieves the color of the solid color brush.")]
    D2D1_COLOR_F _stdcall GetColor();
};

[
    odl,
    uuid(2CD906A7-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents an collection of gradient stops that can then be the source resource for either a linear or radial gradient brush.")
]
interface ID2D1GradientStopCollection : ID2D1Resource {
    [helpstring("Returns the number of stops in the gradient.")]
    long _stdcall GetGradientStopCount();
    [helpstring("Copies the gradient stops from the collection into the caller's interface.")]
    void _stdcall GetGradientStops(
        [in, out] D2D1_GRADIENT_STOP* gradientStops,
        [in] long gradientStopsCount);
    [helpstring("Returns whether the interpolation occurs with 1.0 or 2.2 gamma.")]
    D2D1_GAMMA _stdcall GetColorInterpolationGamma();
    [helpstring("Indicates the behavior of the gradient outside the normalized gradient range.")]
    D2D1_EXTEND_MODE _stdcall GetExtendMode();
};


[
    odl,
    uuid(2CD906AB-12E2-11DC-9FED-001143A055F9),
    helpstring("Paints an area with a linear gradient.")
]
interface ID2D1LinearGradientBrush : ID2D1Brush {
    [helpstring("Sets the starting coordinates of the linear gradient in the brush's coordinate space.")]
    void _stdcall SetStartPoint(
        [in] single startPointX,
        [in] single startPointY);
    [helpstring("Sets the end point of the gradient in local coordinate space. This is not influenced by the geometry being filled.")]
    void _stdcall SetEndPoint(
        [in] single startPointX,
        [in] single startPointY);
    [helpstring("Retrieves the starting coordinates of the linear gradient.")]
    D2D1_POINT_2F _stdcall GetStartPoint();
    [helpstring("Retrieves the ending coordinates of the linear gradient.")]
    D2D1_POINT_2F _stdcall GetEndPoint();
    [helpstring("Retrieves the ID2D1GradientStopCollection associated with this linear gradient brush.")]
    HRESULT _stdcall GetGradientStopCollection([out, retval] ID2D1GradientStopCollection** gradientStopCollection);
};



[
    odl,
    uuid(2CD906AC-12E2-11DC-9FED-001143A055F9),
    helpstring("Paints an area with a radial gradient.")
]
interface ID2D1RadialGradientBrush : ID2D1Brush {
    [helpstring("Sets the center of the radial gradient. This will be in local coordinates and will not depend on the geometry being filled.")]
    void _stdcall SetCenter(
        [in] single centerX,
        [in] single centerY);
    [helpstring("Sets offset of the origin relative to the radial gradient center.")]
    void _stdcall SetGradientOriginOffset(
        [in] single gradientOriginOffsetX,
        [in] single gradientOriginOffsetY);
    [helpstring("Specifies the x-radius of the gradient ellipse, in the brush's coordinate space.")]
    void _stdcall SetRadiusX([in] single radiusX);
    [helpstring("Specifies the y-radius of the gradient ellipse, in the brush's coordinate space.")]
    void _stdcall SetRadiusY([in] single radiusY);
    [helpstring("Retrieves the center of the gradient ellipse.")]
    D2D1_POINT_2F _stdcall GetCenter();
    [helpstring("Retrieves the offset of the gradient origin relative to the gradient ellipse's center.")]
    D2D1_POINT_2F _stdcall GetGradientOriginOffset();
    [helpstring("Retrieves the x-radius of the gradient ellipse.")]
    single _stdcall GetRadiusX();
    [helpstring("Retrieves the y-radius of the gradient ellipse.")]
    single _stdcall GetRadiusY();
    [helpstring("Retrieves the ID2D1GradientStopCollection associated with this radial gradient brush object.")]
    HRESULT _stdcall GetGradientStopCollection([out, retval] ID2D1GradientStopCollection** gradientStopCollection);
};


[
    odl,
    uuid(2CD90695-12E2-11DC-9FED-001143A055F9),
    helpstring("Renders to an intermediate texture created by the CreateCompatibleRenderTarget method.")
]
interface ID2D1BitmapRenderTarget : ID2D1RenderTarget {
    [helpstring("Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations.")]
    HRESULT _stdcall GetBitmap([out, retval] ID2D1Bitmap** bitmap);
};

[
    odl,
    uuid(2CD9069B-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents the backing store required to render a layer.")
]
interface ID2D1Layer : ID2D1Resource {
    [helpstring("Gets the size of the layer in device-independent pixels.")]
    D2D1_SIZE_F _stdcall GetSize();
};

[
    odl,
    uuid(2CD906C2-12E2-11DC-9FED-001143A055F9),
    helpstring("Represents a set of vertices that form a list of triangles.")
]
interface ID2D1Mesh : ID2D1Resource {
    [helpstring("Opens the mesh for population.")]
    HRESULT _stdcall Open([out, retval] ID2D1TessellationSink** tessellationSink);
};

[
    odl,
    uuid(2CD90698-12E2-11DC-9FED-001143A055F9),
    helpstring("Renders drawing instructions to a window.")
]
interface ID2D1HwndRenderTarget : ID2D1RenderTarget {
    [helpstring("Indicates whether the HWND associated with this render target is occluded.")]
    D2D1_WINDOW_STATE _stdcall CheckWindowState();
    [helpstring("Changes the size of the render target to the specified pixel size.")]
    HRESULT _stdcall Resize([in] D2D1_SIZE_U* pixelSize);
    [helpstring("Returns the HWND associated with this render target.")]
    LongPtr _stdcall GetHwnd();
};

[
    odl,
    uuid(1C51BC64-DE61-46FD-9899-63A5D8F03950),
    helpstring("Issues drawing commands to a GDI device context.")
]
interface ID2D1DCRenderTarget : ID2D1RenderTarget {
    [helpstring("Binds the render target to the device context to which it issues drawing commands.")]
    HRESULT _stdcall BindDC(
        [in] long hDC,
        [in] RECT* pSubRect);
};


interface ID2D1Device;
interface ID2D1Effect;

typedef enum D2D1_PROPERTY_TYPE
{
    D2D1_PROPERTY_TYPE_UNKNOWN = 0,
    D2D1_PROPERTY_TYPE_STRING = 1,
    D2D1_PROPERTY_TYPE_BOOL = 2,
    D2D1_PROPERTY_TYPE_UINT32 = 3,
    D2D1_PROPERTY_TYPE_INT32 = 4,
    D2D1_PROPERTY_TYPE_FLOAT = 5,
    D2D1_PROPERTY_TYPE_VECTOR2 = 6,
    D2D1_PROPERTY_TYPE_VECTOR3 = 7,
    D2D1_PROPERTY_TYPE_VECTOR4 = 8,
    D2D1_PROPERTY_TYPE_BLOB = 9,
    D2D1_PROPERTY_TYPE_IUNKNOWN = 10,
    D2D1_PROPERTY_TYPE_ENUM = 11,
    D2D1_PROPERTY_TYPE_ARRAY = 12,
    D2D1_PROPERTY_TYPE_CLSID = 13,
    D2D1_PROPERTY_TYPE_MATRIX_3X2 = 14,
    D2D1_PROPERTY_TYPE_MATRIX_4X3 = 15,
    D2D1_PROPERTY_TYPE_MATRIX_4X4 = 16,
    D2D1_PROPERTY_TYPE_MATRIX_5X4 = 17,
    D2D1_PROPERTY_TYPE_COLOR_CONTEXT = 18,
    D2D1_PROPERTY_TYPE_FORCE_DWORD = 0xffffffff

} D2D1_PROPERTY_TYPE;


/// <summary>
/// This defines the list of system properties present on the root effect property
/// interface.
/// </summary>
typedef enum D2D1_PROPERTY
{
    D2D1_PROPERTY_CLSID = 0x80000000,
    D2D1_PROPERTY_DISPLAYNAME = 0x80000001,
    D2D1_PROPERTY_AUTHOR = 0x80000002,
    D2D1_PROPERTY_CATEGORY = 0x80000003,
    D2D1_PROPERTY_DESCRIPTION = 0x80000004,
    D2D1_PROPERTY_INPUTS = 0x80000005,
    D2D1_PROPERTY_CACHED = 0x80000006,
    D2D1_PROPERTY_PRECISION = 0x80000007,
    D2D1_PROPERTY_MIN_INPUTS = 0x80000008,
    D2D1_PROPERTY_MAX_INPUTS = 0x80000009,
    D2D1_PROPERTY_FORCE_DWORD = 0xffffffff

} D2D1_PROPERTY;


/// <summary>
/// This defines the indices of sub-properties that may be present on any parent
/// property.
/// </summary>
typedef enum D2D1_SUBPROPERTY
{
    D2D1_SUBPROPERTY_DISPLAYNAME = 0x80000000,
    D2D1_SUBPROPERTY_ISREADONLY = 0x80000001,
    D2D1_SUBPROPERTY_MIN = 0x80000002,
    D2D1_SUBPROPERTY_MAX = 0x80000003,
    D2D1_SUBPROPERTY_DEFAULT = 0x80000004,
    D2D1_SUBPROPERTY_FIELDS = 0x80000005,
    D2D1_SUBPROPERTY_INDEX = 0x80000006,
    D2D1_SUBPROPERTY_FORCE_DWORD = 0xffffffff

} D2D1_SUBPROPERTY;


/// <summary>
/// Specifies how the bitmap can be used.
/// </summary>
typedef enum D2D1_BITMAP_OPTIONS
{

    /// <summary>
    /// The bitmap is created with default properties.
    /// </summary>
    D2D1_BITMAP_OPTIONS_NONE = 0x00000000,

    /// <summary>
    /// The bitmap can be specified as a target in ID2D1DeviceContext::SetTarget
    /// </summary>
    D2D1_BITMAP_OPTIONS_TARGET = 0x00000001,

    /// <summary>
    /// The bitmap cannot be used as an input to DrawBitmap, DrawImage, in a bitmap
    /// brush or as an input to an effect.
    /// </summary>
    D2D1_BITMAP_OPTIONS_CANNOT_DRAW = 0x00000002,

    /// <summary>
    /// The bitmap can be read from the CPU.
    /// </summary>
    D2D1_BITMAP_OPTIONS_CPU_READ = 0x00000004,

    /// <summary>
    /// The bitmap works with the ID2D1GdiInteropRenderTarget::GetDC API.
    /// </summary>
    D2D1_BITMAP_OPTIONS_GDI_COMPATIBLE = 0x00000008,
    D2D1_BITMAP_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_BITMAP_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_BITMAP_OPTIONS);



/// <summary>
/// This specifies the precision that should be used in buffers allocated by D2D.
/// </summary>
typedef enum D2D1_BUFFER_PRECISION
{
    D2D1_BUFFER_PRECISION_UNKNOWN = 0,
    D2D1_BUFFER_PRECISION_8BPC_UNORM = 1,
    D2D1_BUFFER_PRECISION_8BPC_UNORM_SRGB = 2,
    D2D1_BUFFER_PRECISION_16BPC_UNORM = 3,
    D2D1_BUFFER_PRECISION_16BPC_FLOAT = 4,
    D2D1_BUFFER_PRECISION_32BPC_FLOAT = 5,
    D2D1_BUFFER_PRECISION_FORCE_DWORD = 0xffffffff

} D2D1_BUFFER_PRECISION;


/// <summary>
/// This describes how the individual mapping operation should be performed.
/// </summary>
typedef enum D2D1_MAP_OPTIONS
{

    /// <summary>
    /// The mapped pointer has undefined behavior.
    /// </summary>
    D2D1_MAP_OPTIONS_NONE = 0,

    /// <summary>
    /// The mapped pointer can be read from.
    /// </summary>
    D2D1_MAP_OPTIONS_READ = 1,

    /// <summary>
    /// The mapped pointer can be written to.
    /// </summary>
    D2D1_MAP_OPTIONS_WRITE = 2,

    /// <summary>
    /// The previous contents of the bitmap are discarded when it is mapped.
    /// </summary>
    D2D1_MAP_OPTIONS_DISCARD = 4,
    D2D1_MAP_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_MAP_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_MAP_OPTIONS);


/// <summary>
/// This is used to specify the quality of image scaling with
/// ID2D1DeviceContext::DrawImage and with the 2D Affine Transform Effect.
/// </summary>
typedef enum D2D1_INTERPOLATION_MODE
{
    D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0, // D2D1_INTERPOLATION_MODE_DEFINITION_NEAREST_NEIGHBOR,
    D2D1_INTERPOLATION_MODE_LINEAR,// = D2D1_INTERPOLATION_MODE_DEFINITION_LINEAR,
    D2D1_INTERPOLATION_MODE_CUBIC, // = D2D1_INTERPOLATION_MODE_DEFINITION_CUBIC,
    D2D1_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR, // = D2D1_INTERPOLATION_MODE_DEFINITION_MULTI_SAMPLE_LINEAR,
    D2D1_INTERPOLATION_MODE_ANISOTROPIC, // = D2D1_INTERPOLATION_MODE_DEFINITION_ANISOTROPIC,
    D2D1_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC, // = D2D1_INTERPOLATION_MODE_DEFINITION_HIGH_QUALITY_CUBIC,
    D2D1_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_INTERPOLATION_MODE;


/// <summary>
/// This specifies what units should be accepted by the D2D API.
/// </summary>
typedef enum D2D1_UNIT_MODE
{
    D2D1_UNIT_MODE_DIPS = 0,
    D2D1_UNIT_MODE_PIXELS = 1,
    D2D1_UNIT_MODE_FORCE_DWORD = 0xffffffff

} D2D1_UNIT_MODE;


/// <summary>
/// Defines a color space.
/// </summary>
typedef enum D2D1_COLOR_SPACE
{

    /// <summary>
    /// The color space is described by accompanying data, such as a color profile.
    /// </summary>
    D2D1_COLOR_SPACE_CUSTOM = 0,

    /// <summary>
    /// The sRGB color space.
    /// </summary>
    D2D1_COLOR_SPACE_SRGB = 1,

    /// <summary>
    /// The scRGB color space.
    /// </summary>
    D2D1_COLOR_SPACE_SCRGB = 2,
    D2D1_COLOR_SPACE_FORCE_DWORD = 0xffffffff

} D2D1_COLOR_SPACE;


/// <summary>
/// This specifies options that apply to the device context for its lifetime.
/// </summary>
typedef enum D2D1_DEVICE_CONTEXT_OPTIONS
{
    D2D1_DEVICE_CONTEXT_OPTIONS_NONE = 0,

    /// <summary>
    /// Geometry rendering will be performed on many threads in parallel, a single
    /// thread is the default.
    /// </summary>
    D2D1_DEVICE_CONTEXT_OPTIONS_ENABLE_MULTITHREADED_OPTIMIZATIONS = 1,
    D2D1_DEVICE_CONTEXT_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_DEVICE_CONTEXT_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_DEVICE_CONTEXT_OPTIONS);


/// <summary>
/// Defines how the world transform, dots per inch (dpi), and stroke width affect
/// the shape of the pen used to stroke a primitive.
/// </summary>
typedef enum D2D1_STROKE_TRANSFORM_TYPE
{

    /// <summary>
    /// The stroke respects the world transform, the DPI, and the stroke width.
    /// </summary>
    D2D1_STROKE_TRANSFORM_TYPE_NORMAL = 0,

    /// <summary>
    /// The stroke does not respect the world transform, but it does respect the DPI and
    /// the stroke width.
    /// </summary>
    D2D1_STROKE_TRANSFORM_TYPE_FIXED = 1,

    /// <summary>
    /// The stroke is forced to one pixel wide.
    /// </summary>
    D2D1_STROKE_TRANSFORM_TYPE_HAIRLINE = 2,
    D2D1_STROKE_TRANSFORM_TYPE_FORCE_DWORD = 0xffffffff

} D2D1_STROKE_TRANSFORM_TYPE;


/// <summary>
/// A blend mode that applies to all primitives drawn on the context.
/// </summary>
typedef enum D2D1_PRIMITIVE_BLEND
{
    D2D1_PRIMITIVE_BLEND_SOURCE_OVER = 0,
    D2D1_PRIMITIVE_BLEND_COPY = 1,
    D2D1_PRIMITIVE_BLEND_MIN = 2,
    D2D1_PRIMITIVE_BLEND_ADD = 3,
    D2D1_PRIMITIVE_BLEND_FORCE_DWORD = 0xffffffff

} D2D1_PRIMITIVE_BLEND;


/// <summary>
/// This specifies the threading mode used while simultaneously creating the device,
/// factory, and device context.
/// </summary>
typedef enum D2D1_THREADING_MODE
{

    /// <summary>
    /// Resources may only be invoked serially.  Reference counts on resources are
    /// interlocked, however, resource and render target state is not protected from
    /// multi-threaded access
    /// </summary>
    D2D1_THREADING_MODE_SINGLE_THREADED = 0, //D2D1_FACTORY_TYPE_SINGLE_THREADED,

    /// <summary>
    /// Resources may be invoked from multiple threads. Resources use interlocked
    /// reference counting and their state is protected.
    /// </summary>
    D2D1_THREADING_MODE_MULTI_THREADED = 1, //D2D1_FACTORY_TYPE_MULTI_THREADED,
    D2D1_THREADING_MODE_FORCE_DWORD = 0xffffffff

} D2D1_THREADING_MODE;


/// <summary>
/// This specifies how colors are interpolated.
/// </summary>
typedef enum D2D1_COLOR_INTERPOLATION_MODE
{

    /// <summary>
    /// Colors will be interpolated in straight alpha space.
    /// </summary>
    D2D1_COLOR_INTERPOLATION_MODE_STRAIGHT = 0,

    /// <summary>
    /// Colors will be interpolated in premultiplied alpha space.
    /// </summary>
    D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED = 1,
    D2D1_COLOR_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_COLOR_INTERPOLATION_MODE;

//typedef D2D_VECTOR_2F D2D1_VECTOR_2F;
//typedef D2D_VECTOR_3F D2D1_VECTOR_3F;
//typedef D2D_VECTOR_4F D2D1_VECTOR_4F;
interface ID2D1ColorContext;
/// <summary>
/// Extended bitmap properties.
/// </summary>
typedef struct D2D1_BITMAP_PROPERTIES1
{
    D2D1_PIXEL_FORMAT pixelFormat;
    FLOAT dpiX;
    FLOAT dpiY;

    /// <summary>
    /// Specifies how the bitmap can be used.
    /// </summary>
    D2D1_BITMAP_OPTIONS bitmapOptions;
    ID2D1ColorContext* colorContext;

} D2D1_BITMAP_PROPERTIES1;


/// <summary>
/// Describes mapped memory from the ID2D1Bitmap1::Map API.
/// </summary>
typedef struct D2D1_MAPPED_RECT
{
    UINT32 pitch;
    LongPtr bits;

} D2D1_MAPPED_RECT;


/// <summary>
/// This controls advanced settings of the Direct2D imaging pipeline.
/// </summary>
typedef struct D2D1_RENDERING_CONTROLS
{

    /// <summary>
    /// The default buffer precision, used if the precision isn't otherwise specified.
    /// </summary>
    D2D1_BUFFER_PRECISION bufferPrecision;

    /// <summary>
    /// The size of allocated tiles used to render imaging effects.
    /// </summary>
    D2D1_SIZE_U tileSize;

} D2D1_RENDERING_CONTROLS;


/// <summary>
/// This identifies a certain input connection of a certain effect.
/// </summary>
typedef struct D2D1_EFFECT_INPUT_DESCRIPTION
{

    /// <summary>
    /// The effect whose input connection is being specified.
    /// </summary>
    ID2D1Effect* effect;

    /// <summary>
    /// The index of the input connection into the specified effect.
    /// </summary>
    UINT32 inputIndex;

    /// <summary>
    /// The rectangle which would be available on the specified input connection during
    /// render operations.
    /// </summary>
    D2D1_RECT_F inputRectangle;

} D2D1_EFFECT_INPUT_DESCRIPTION;

//typedef D2D_MATRIX_4X3_F D2D1_MATRIX_4X3_F;
//typedef D2D_MATRIX_4X4_F D2D1_MATRIX_4X4_F;
//typedef D2D_MATRIX_5X4_F D2D1_MATRIX_5X4_F;

/// <summary>
/// Describes a point along a path.
/// </summary>
typedef struct D2D1_POINT_DESCRIPTION
{
    D2D1_POINT_2F point;
    D2D1_POINT_2F unitTangentVector;
    UINT32 endSegment;
    UINT32 endFigure;
    FLOAT lengthToEndSegment;

} D2D1_POINT_DESCRIPTION;


/// <summary>
/// Creation properties for an image brush.
/// </summary>
typedef struct D2D1_IMAGE_BRUSH_PROPERTIES
{
    D2D1_RECT_F sourceRectangle;
    D2D1_EXTEND_MODE extendModeX;
    D2D1_EXTEND_MODE extendModeY;
    D2D1_INTERPOLATION_MODE interpolationMode;

} D2D1_IMAGE_BRUSH_PROPERTIES;


/// <summary>
/// Describes the extend modes and the interpolation mode of an ID2D1BitmapBrush.
/// </summary>
typedef struct D2D1_BITMAP_BRUSH_PROPERTIES1
{
    D2D1_EXTEND_MODE extendModeX;
    D2D1_EXTEND_MODE extendModeY;
    D2D1_INTERPOLATION_MODE interpolationMode;

} D2D1_BITMAP_BRUSH_PROPERTIES1;


/// <summary>
/// This defines how geometries should be drawn and widened.
/// </summary>
typedef struct D2D1_STROKE_STYLE_PROPERTIES1
{
    D2D1_CAP_STYLE startCap;
    D2D1_CAP_STYLE endCap;
    D2D1_CAP_STYLE dashCap;
    D2D1_LINE_JOIN lineJoin;
    FLOAT miterLimit;
    D2D1_DASH_STYLE dashStyle;
    FLOAT dashOffset;

    /// <summary>
    /// How the nib of the stroke is influenced by the context properties.
    /// </summary>
    D2D1_STROKE_TRANSFORM_TYPE transformType;

} D2D1_STROKE_STYLE_PROPERTIES1;


/// <summary>
/// Specifies how the layer contents should be prepared.
/// </summary>
typedef enum D2D1_LAYER_OPTIONS1
{
    D2D1_LAYER_OPTIONS1_NONE = 0,
    D2D1_LAYER_OPTIONS1_INITIALIZE_FROM_BACKGROUND = 1,
    D2D1_LAYER_OPTIONS1_IGNORE_ALPHA = 2,
    D2D1_LAYER_OPTIONS1_FORCE_DWORD = 0xffffffff

} D2D1_LAYER_OPTIONS1;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_LAYER_OPTIONS1);


/// <summary>
/// All parameters related to pushing a layer.
/// </summary>
typedef struct D2D1_LAYER_PARAMETERS1
{
    D2D1_RECT_F contentBounds;
    ID2D1Geometry* geometricMask;
    D2D1_ANTIALIAS_MODE maskAntialiasMode;
    D2D1_MATRIX_3X2_F maskTransform;
    FLOAT opacity;
    ID2D1Brush* opacityBrush;
    D2D1_LAYER_OPTIONS1 layerOptions;

} D2D1_LAYER_PARAMETERS1;


/// <summary>
/// Defines when font resources should be subset during printing.
/// </summary>
typedef enum D2D1_PRINT_FONT_SUBSET_MODE
{

    /// <summary>
    /// Subset for used glyphs, send and discard font resource after every five pages
    /// </summary>
    D2D1_PRINT_FONT_SUBSET_MODE_DEFAULT = 0,

    /// <summary>
    /// Subset for used glyphs, send and discard font resource after each page
    /// </summary>
    D2D1_PRINT_FONT_SUBSET_MODE_EACHPAGE = 1,

    /// <summary>
    /// Do not subset, reuse font for all pages, send it after first page
    /// </summary>
    D2D1_PRINT_FONT_SUBSET_MODE_NONE = 2,
    D2D1_PRINT_FONT_SUBSET_MODE_FORCE_DWORD = 0xffffffff

} D2D1_PRINT_FONT_SUBSET_MODE;

typedef UINT64 D2D1_TAG;
/// <summary>
/// This describes the drawing state.
/// </summary>
typedef struct D2D1_DRAWING_STATE_DESCRIPTION1
{
    D2D1_ANTIALIAS_MODE antialiasMode;
    D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode;
    D2D1_TAG tag1;
    D2D1_TAG tag2;
    D2D1_MATRIX_3X2_F transform;
    D2D1_PRIMITIVE_BLEND primitiveBlend;
    D2D1_UNIT_MODE unitMode;

} D2D1_DRAWING_STATE_DESCRIPTION1;


/// <summary>
/// The creation properties for a ID2D1PrintControl object.
/// </summary>
typedef struct D2D1_PRINT_CONTROL_PROPERTIES
{
    D2D1_PRINT_FONT_SUBSET_MODE fontSubset;

    /// <summary>
    /// DPI for rasterization of all unsupported D2D commands or options, defaults to
    /// 150.0
    /// </summary>
    FLOAT rasterDPI;

    /// <summary>
    /// Color space for vector graphics in XPS package
    /// </summary>
    D2D1_COLOR_SPACE colorSpace;

} D2D1_PRINT_CONTROL_PROPERTIES;


/// <summary>
/// This specifies the options while simultaneously creating the device, factory,
/// and device context.
/// </summary>
typedef struct D2D1_CREATION_PROPERTIES
{

    /// <summary>
    /// Describes locking behavior of D2D resources
    /// </summary>
    D2D1_THREADING_MODE threadingMode;
    D2D1_DEBUG_LEVEL debugLevel;
    D2D1_DEVICE_CONTEXT_OPTIONS options;

} D2D1_CREATION_PROPERTIES;


[
    odl,
    uuid(82237326-8111-4f7c-bcf4-b5c1175564fe)
]
interface ID2D1GdiMetafileSink : stdole.IUnknown
{
    HRESULT ProcessRecord([in] DWORD recordType,[in] void* recordData,[in] DWORD recordDataSize);
};

[
    odl,
    uuid(2f543dc3-cfc1-4211-864f-cfd91c6f3395)
]
interface ID2D1GdiMetafile : ID2D1Resource
{
    HRESULT Stream([in] ID2D1GdiMetafileSink* sink);
    HRESULT GetBounds([out] D2D1_RECT_F* bounds);
};


[
    odl,
    uuid(65019f75-8da2-497c-b32c-dfa34e48ede6)
]
interface ID2D1Image : ID2D1Resource
{
};

[
    odl,
    uuid(54d7898a-a061-40a7-bec7-e465bcba2c4f)
]
interface ID2D1CommandSink : stdole.IUnknown
{
    HRESULT BeginDraw(
        );

    HRESULT EndDraw(
        );

    HRESULT SetAntialiasMode(
        [in] D2D1_ANTIALIAS_MODE antialiasMode
        );

    HRESULT SetTags(
        [in] D2D1_TAG tag1,
        [in] D2D1_TAG tag2
        );

    HRESULT SetTextAntialiasMode(
        [in] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode
        );

    HRESULT SetTextRenderingParams(
        [in] IDWriteRenderingParams* textRenderingParams
        );

    HRESULT SetTransform(
        [in] D2D1_MATRIX_3X2_F* transform
        );

    HRESULT SetPrimitiveBlend(
        [in] D2D1_PRIMITIVE_BLEND primitiveBlend
        );

    HRESULT SetUnitMode(
        [in] D2D1_UNIT_MODE unitMode
        );

    HRESULT Clear(
        [in] D2D1_COLOR_F* color
        );

    HRESULT DrawGlyphRun(
        //[in] D2D1_POINT_2F baselineOrigin,
        [in] CURRENCY baselineOrigin,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
        [in] ID2D1Brush* foregroundBrush,
        [in] DWRITE_MEASURING_MODE measuringMode
        );

    HRESULT DrawLine(
        //[in] D2D1_POINT_2F point0,
        //[in] D2D1_POINT_2F point1,
        [in] CURRENCY point0,
        [in] CURRENCY point1,
        [in] ID2D1Brush* brush,
        [in] FLOAT strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle
        );

    HRESULT DrawGeometry(
        [in] ID2D1Geometry* geometry,
        [in] ID2D1Brush* brush,
        [in] FLOAT strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle
        );

    HRESULT DrawRectangle(
        [in] D2D1_RECT_F* rect,
        [in] ID2D1Brush* brush,
        [in] FLOAT strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle
        );

    HRESULT DrawBitmap(
        [in] ID2D1Bitmap* bitmap,
        [in] D2D1_RECT_F* destinationRectangle,
        [in] FLOAT opacity,
        [in] D2D1_INTERPOLATION_MODE interpolationMode,
        [in] D2D1_RECT_F* sourceRectangle,
        [in] D2D1_MATRIX_4X4_F* perspectiveTransform
        );

    HRESULT DrawImage(
        [in] ID2D1Image* image,
        [in] D2D1_POINT_2F* targetOffset,
        [in] D2D1_RECT_F* imageRectangle,
        [in] D2D1_INTERPOLATION_MODE interpolationMode,
        [in] D2D1_COMPOSITE_MODE compositeMode
        );

    HRESULT DrawGdiMetafile(
        [in] ID2D1GdiMetafile* gdiMetafile,
        [in] D2D1_POINT_2F* targetOffset
        );

    HRESULT FillMesh(
        [in] ID2D1Mesh* mesh,
        [in] ID2D1Brush* brush
        );

    HRESULT FillOpacityMask(
        [in] ID2D1Bitmap* opacityMask,
        [in] ID2D1Brush* brush,
        [in] D2D1_RECT_F* destinationRectangle,
        [in] D2D1_RECT_F* sourceRectangle
        );

    HRESULT FillGeometry(
        [in] ID2D1Geometry* geometry,
        [in] ID2D1Brush* brush,
        [in] ID2D1Brush* opacityBrush
        );

    HRESULT FillRectangle(
        [in] D2D1_RECT_F* rect,
        [in] ID2D1Brush* brush
        );

    HRESULT PushAxisAlignedClip(
        [in] D2D1_RECT_F* clipRect,
        [in] D2D1_ANTIALIAS_MODE antialiasMode
        );

    HRESULT PushLayer(
        [in] D2D1_LAYER_PARAMETERS1* layerParameters1,
        [in] ID2D1Layer* layer
        );

    HRESULT PopAxisAlignedClip(
        );

    HRESULT PopLayer(
        );
};

[
    odl,
    uuid(b4f34a19-2383-4d76-94f6-ec343657c3dc)
]
interface ID2D1CommandList : ID2D1Image
{
    /// <summary>
    /// Play the command list into a caller-supplied sink interface.
    /// </summary>
    HRESULT Stream(
        [in] ID2D1CommandSink* sink
        );

    /// <summary>
    /// Marks the command list as ready for use.
    /// </summary>
    HRESULT Close(
        );
};

[
    odl,
    uuid(2c1d867d-c290-41c8-ae7e-34a98702e9a5)
]
interface ID2D1PrintControl : stdole.IUnknown
{
    HRESULT AddPage(
        [in] ID2D1CommandList* commandList,
        /*[in] D2D_SIZE_F pageSize,*/ [in] CURRENCY pageSize,
        [in] IStream* pagePrintTicketStream,
        [out] D2D1_TAG* tag1,
        [out] D2D1_TAG* tag2
        );

    HRESULT Close(
        );
};

[
    odl,
    uuid(fe9e984d-3f95-407c-b5db-cb94d4e8f87c)
]
interface ID2D1ImageBrush : ID2D1Brush
{

    void SetImage(
        [in] ID2D1Image* image
        );

    void SetExtendModeX(
        [in] D2D1_EXTEND_MODE extendModeX
        );

    void SetExtendModeY(
        [in] D2D1_EXTEND_MODE extendModeY
        );

    void SetInterpolationMode(
        [in] D2D1_INTERPOLATION_MODE interpolationMode
        );

    void SetSourceRectangle(
        [in] D2D1_RECT_F* sourceRectangle
        );

    void GetImage(
        [out] ID2D1Image** image
        );

    D2D1_EXTEND_MODE GetExtendModeX(
        );

    D2D1_EXTEND_MODE GetExtendModeY(
        );

    D2D1_INTERPOLATION_MODE GetInterpolationMode(
        );

    void GetSourceRectangle(
        [out] D2D1_RECT_F* sourceRectangle
        );
};

[
    odl,
    uuid(41343a53-e41a-49a2-91cd-21793bbb62e5)
]
interface ID2D1BitmapBrush1 : ID2D1BitmapBrush
{
    /// Sets the interpolation mode used when this brush is used.
    /// </summary>
    void SetInterpolationMode1(
        [in] D2D1_INTERPOLATION_MODE interpolationMode
        );

    D2D1_INTERPOLATION_MODE GetInterpolationMode1(
        );
};

[
    odl,
    uuid(10a72a66-e91c-43f4-993f-ddf4b82b0b4a)
]
interface ID2D1StrokeStyle1 : ID2D1StrokeStyle
{
    D2D1_STROKE_TRANSFORM_TYPE GetStrokeTransformType(
        );
};

[
    odl,
    uuid(62baa2d2-ab54-41b7-b872-787e0106a421)
]
interface ID2D1PathGeometry1 : ID2D1PathGeometry
{

    HRESULT ComputePointAndSegmentAtLength(
        [in] FLOAT length,
        [in] UINT32 startSegment,
        [in] D2D1_MATRIX_3X2_F* worldTransform,
        [in] FLOAT flatteningTolerance,
        [out] D2D1_POINT_DESCRIPTION* pointDescription
        );

    /*COM_DECLSPEC_NOTHROW
        HRESULT
        ComputePointAndSegmentAtLength(
            FLOAT length,
            UINT32 startSegment,
            CONST D2D1_MATRIX_3X2_F& worldTransform,
            FLOAT flatteningTolerance,
            [out] D2D1_POINT_DESCRIPTION* pointDescription
        ) CONST
    {
        return ComputePointAndSegmentAtLength(length, startSegment, &worldTransform, flatteningTolerance, pointDescription);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        ComputePointAndSegmentAtLength(
            FLOAT length,
            UINT32 startSegment,
            [in] D2D1_MATRIX_3X2_F* worldTransform,
            [out] D2D1_POINT_DESCRIPTION* pointDescription
        ) CONST
    {
        return ComputePointAndSegmentAtLength(length, startSegment, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, pointDescription);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        ComputePointAndSegmentAtLength(
            FLOAT length,
            UINT32 startSegment,
            CONST D2D1_MATRIX_3X2_F& worldTransform,
            [out] D2D1_POINT_DESCRIPTION* pointDescription
        ) CONST
    {
        return ComputePointAndSegmentAtLength(length, startSegment, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, pointDescription);
    }*/

};

[
    odl,
    uuid(483473d7-cd46-4f9d-9d3a-3112aa80159d)
]
interface ID2D1Properties : stdole.IUnknown
{

    /// <summary>
    /// Returns the total number of custom properties in this interface.
    /// </summary>
    UINT32 GetPropertyCount(
        );

    /// <summary>
    /// Retrieves the property name from the given property index.
    /// </summary>
    HRESULT GetPropertyName(
        [in] UINT32 index,
        [out] LongPtr *name,
        [in] UINT32 nameCount
        );

    /// <summary>
    /// Returns the length of the property name from the given index.
    /// </summary>
    UINT32 GetPropertyNameLength(
        [in] UINT32 index
        );

    /// <summary>
    /// Retrieves the type of the given property.
    /// </summary>
    D2D1_PROPERTY_TYPE GetType(
        [in] UINT32 index
        );

    /// <summary>
    /// Retrieves the property index for the given property name.
    /// </summary>
    UINT32 GetPropertyIndex(
        [in] LongPtr name
        );

    /// <summary>
    /// Sets the value of the given property using its name.
    /// </summary>
    HRESULT SetValueByName(
        [in] LongPtr name,
        [in] D2D1_PROPERTY_TYPE type,
        [in] BYTE* data,
        [in] UINT32 dataSize
        );

    /// <summary>
    /// Sets the given value using the property index.
    /// </summary>
    HRESULT SetValue(
        [in] UINT32 index,
        [in] D2D1_PROPERTY_TYPE type,
        [in] BYTE* data,
        [in] UINT32 dataSize
        );

    /// <summary>
    /// Retrieves the given property or sub-property by name. '.' is the delimiter for
    /// sub-properties.
    /// </summary>
    HRESULT GetValueByName(
        [in] LongPtr name,
        [in] D2D1_PROPERTY_TYPE type,
        [out] BYTE* data,
        [in] UINT32 dataSize
        );

    /// <summary>
    /// Retrieves the given value by index.
    /// </summary>
    HRESULT GetValue(
        [in] UINT32 index,
        [in] D2D1_PROPERTY_TYPE type,
        [out] BYTE* data,
        [in] UINT32 dataSize
        );

    /// <summary>
    /// Returns the value size for the given property index.
    /// </summary>
    UINT32 GetValueSize(
        [in] UINT32 index
        );

    /// <summary>
    /// Retrieves the sub-properties of the given property by index.
    /// </summary>
    HRESULT GetSubProperties(
        [in] UINT32 index,
        [out]  ID2D1Properties** subProperties
        );
/*
    COM_DECLSPEC_NOTHROW
    HRESULT
    SetValueByName(
        [in] LongPtr name,
        [in] BYTE* data,
        UINT32 dataSize
        )
    {
        return SetValueByName(name, D2D1_PROPERTY_TYPE_UNKNOWN, data, dataSize);
    }

    COM_DECLSPEC_NOTHROW
    HRESULT
    SetValue(
        UINT32 index,
        [in] BYTE* data,
        UINT32 dataSize
        )
    {
        return SetValue(index, D2D1_PROPERTY_TYPE_UNKNOWN, data, dataSize);
    }

    COM_DECLSPEC_NOTHROW
    HRESULT
    GetValueByName(
        [in] LongPtr name,
        [out] BYTE* data,
        UINT32 dataSize
        ) CONST
    {
        return GetValueByName(name, D2D1_PROPERTY_TYPE_UNKNOWN, data, dataSize);
    }

    COM_DECLSPEC_NOTHROW
    HRESULT
    GetValue(
        UINT32 index,
        [out] BYTE* data,
        UINT32 dataSize
        ) CONST
    {
        return GetValue(index, D2D1_PROPERTY_TYPE_UNKNOWN, data, dataSize);
    }*/

};

[
    odl,
    uuid(28211a43-7d89-476f-8181-2d6159b220ad)
]
interface ID2D1Effect : ID2D1Properties
{

    /// <summary>
    /// Sets the input to the given effect. The input can be a concrete bitmap or the
    /// output of another effect.
    /// </summary>
    void SetInput(
        [in] UINT32 index,
        [in] ID2D1Image* input,
        [in] BOOL invalidate
        );

    /// <summary>
    /// If the effect supports a variable number of inputs, this sets the number of
    /// input that are currently active on the effect.
    /// </summary>
    HRESULT SetInputCount(
        [in] UINT32 inputCount
        );

    /// <summary>
    /// Returns the input image to the effect. The input could be another effect or a
    /// bitmap.
    /// </summary>
    void GetInput(
        [in] UINT32 index,
        [out] ID2D1Image** input
        );

    /// <summary>
    /// This returns the number of input that are bound into this effect.
    /// </summary>
    UINT32 GetInputCount(
        );

    /// <summary>
    /// Returns the output image of the given effect. This can be set as the input to
    /// another effect or can be drawn with DrawImage.
    /// </summary>
    void GetOutput(
        [out] ID2D1Image** outputImage
        );
    /*
    COM_DECLSPEC_NOTHROW
        void
        SetInputEffect(
            UINT32 index,
            [in] ID2D1Effect* inputEffect,
            BOOL invalidate = TRUE
        )
    {

        ID2D1Image* output = NULL;
        if(inputEffect != NULL)
        {
            inputEffect->GetOutput(&output);
        }
        SetInput(index, output, invalidate);
        if(output != NULL)
        {
            output->Release();
        }
    }
*/
};

[
    odl,
    uuid(a898a84c-3873-4588-b08b-ebbf978df041)
]
interface ID2D1Bitmap1 : ID2D1Bitmap
{
    /// <summary>
     /// Retrieves the color context information associated with the bitmap.
     /// </summary>
    void GetColorContext(
        [out] ID2D1ColorContext** colorContext
        );

    /// <summary>
    /// Retrieves the bitmap options used when creating the API.
    /// </summary>
    D2D1_BITMAP_OPTIONS GetOptions(
        );

    /// <summary>
    /// Retrieves the DXGI surface from the corresponding bitmap, if the bitmap was
    /// created from a device derived from a D3D device.
    /// </summary>
    HRESULT GetSurface(
        [out] IDXGISurface** dxgiSurface
        );

    /// <summary>
    /// Maps the given bitmap into memory. The bitmap must have been created with the
    /// D2D1_BITMAP_OPTIONS_CPU_READ flag.
    /// </summary>
    HRESULT Map(
        [in] D2D1_MAP_OPTIONS options,
        [out] D2D1_MAPPED_RECT* mappedRect
        );

    /// <summary>
    /// Unmaps the given bitmap from memory.
    /// </summary>
    HRESULT Unmap(
        );
};

[
    odl,
    uuid(1c4820bb-5771-4518-a581-2fe4dd0ec657)
]
interface ID2D1ColorContext : ID2D1Resource
{

    /// <summary>
    /// Retrieves the color space of the color context.
    /// </summary>
    D2D1_COLOR_SPACE GetColorSpace(
        );

    /// <summary>
    /// Retrieves the size of the color profile, in bytes.
    /// </summary>
    UINT32 GetProfileSize(
        );

    /// <summary>
    /// Retrieves the color profile bytes.
    /// </summary>
    HRESULT GetProfile(
        [out] BYTE* profile,
        [in] UINT32 profileSize
        );
};

[
    odl,
    uuid(ae1572f4-5dd0-4777-998b-9279472ae63b)
]
interface ID2D1GradientStopCollection1 : ID2D1GradientStopCollection
{
    void GetGradientStops1(
        [out] D2D1_GRADIENT_STOP* gradientStops,
        [in] UINT32 gradientStopsCount
        );

    /// <summary>
    /// Returns the color space in which interpolation occurs. If this object was
    /// created using ID2D1RenderTarget::CreateGradientStopCollection, this method
    /// returns the color space related to the color interpolation gamma.
    /// </summary>
    D2D1_COLOR_SPACE GetPreInterpolationSpace(
        );

    /// <summary>
    /// Returns the color space colors will be converted to after interpolation occurs.
    /// If this object was created using
    /// ID2D1RenderTarget::CreateGradientStopCollection, this method returns
    /// D2D1_COLOR_SPACE_SRGB.
    /// </summary>
    D2D1_COLOR_SPACE GetPostInterpolationSpace(
        );

    /// <summary>
    /// Returns the buffer precision of this gradient. If this object was created using
    /// ID2D1RenderTarget::CreateGradientStopCollection, this method returns
    /// D2D1_BUFFER_PRECISION_8BPC_UNORM.
    /// </summary>
    D2D1_BUFFER_PRECISION GetBufferPrecision(
        );

    /// <summary>
    /// Returns the interpolation mode used to interpolate colors in the gradient.
    /// </summary>
    D2D1_COLOR_INTERPOLATION_MODE GetColorInterpolationMode(
        );
};

[
    odl,
    uuid(689f1f85-c72e-4e33-8f19-85754efd5ace)
]
interface ID2D1DrawingStateBlock1 : ID2D1DrawingStateBlock
{
    /// <summary>
    /// Retrieves the state currently contained within this state block resource.
    /// </summary>
    void GetDescription(
        [out] D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription
        );

    //using ID2D1DrawingStateBlock::GetDescription;

    /// <summary>
    /// Sets the state description of this state block resource.
    /// </summary>
    void SetDescription(
        [in] D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription
        );
};

[
    odl,
    uuid(e8f7fe7a-191c-466d-ad95-975678bda998)
]
interface ID2D1DeviceContext : ID2D1RenderTarget
{
    /// <summary>
     /// Creates a bitmap with extended bitmap properties, potentially from a block of
     /// memory.
     /// </summary>
    HRESULT CreateBitmap(
        /*[in] D2D1_SIZE_U size,*/[in] CURRENCY size,
        [in] void* sourceData,
        [in] UINT32 pitch,
        [in] D2D1_BITMAP_PROPERTIES1* bitmapProperties,
        [out] ID2D1Bitmap1** bitmap
        );

   // using ID2D1RenderTarget::CreateBitmap;

    /// <summary>
    /// Create a D2D bitmap by copying a WIC bitmap.
    /// </summary>
    HRESULT CreateBitmapFromWicBitmap(
        [in] IWICBitmapSource* wicBitmapSource,
        [in] D2D1_BITMAP_PROPERTIES1* bitmapProperties,
        [out] ID2D1Bitmap1** bitmap
        );

    //using ID2D1RenderTarget::CreateBitmapFromWicBitmap;

    /// <summary>
    /// Creates a color context from a color space.  If the space is Custom, the context
    /// is initialized from the profile/profileSize arguments.  Otherwise the context is
    /// initialized with the profile bytes associated with the space and
    /// profile/profileSize are ignored.
    /// </summary>
    HRESULT CreateColorContext(
        [in] D2D1_COLOR_SPACE space,
        [in] BYTE* profile,
        [in] UINT32 profileSize,
        [out] ID2D1ColorContext** colorContext
        );

    HRESULT CreateColorContextFromFilename(
        [in] LongPtr filename,
        [out] ID2D1ColorContext** colorContext
        );

    HRESULT CreateColorContextFromWicColorContext(
        [in] IWICColorContext* wicColorContext,
        [out] ID2D1ColorContext** colorContext
        );

    /// <summary>
    /// Creates a bitmap from a DXGI surface with a set of extended properties.
    /// </summary>
    HRESULT CreateBitmapFromDxgiSurface(
        [in] IDXGISurface* surface,
        [in] D2D1_BITMAP_PROPERTIES1* bitmapProperties,
        [out] ID2D1Bitmap1** bitmap
        );

    /// <summary>
    /// Create a new effect, the effect must either be built in or previously registered
    /// through ID2D1Factory1::RegisterEffectFromStream or
    /// ID2D1Factory1::RegisterEffectFromString.
    /// </summary>
    HRESULT CreateEffect(
        [in] REFCLSID effectId,
        [out] ID2D1Effect** effect
        );

    /// <summary>
    /// A gradient stop collection represents a set of stops in an ideal unit length.
    /// This is the source resource for a linear gradient and radial gradient brush.
    /// </summary>
    /// <param name="preInterpolationSpace">Specifies both the input color space and the
    /// space in which the color interpolation occurs.</param>
    /// <param name="postInterpolationSpace">Specifies the color space colors will be
    /// converted to after interpolation occurs.</param>
    /// <param name="bufferPrecision">Specifies the precision in which the gradient
    /// buffer will be held.</param>
    /// <param name="extendMode">Specifies how the gradient will be extended outside of
    /// the unit length.</param>
    /// <param name="colorInterpolationMode">Determines if colors will be interpolated
    /// in straight alpha or premultiplied alpha space.</param>
    HRESULT CreateGradientStopCollection(
        [in] D2D1_GRADIENT_STOP* straightAlphaGradientStops,
        [in] UINT32 straightAlphaGradientStopsCount,
        [in] D2D1_COLOR_SPACE preInterpolationSpace,
        [in] D2D1_COLOR_SPACE postInterpolationSpace,
        [in] D2D1_BUFFER_PRECISION bufferPrecision,
        [in] D2D1_EXTEND_MODE extendMode,
        [in] D2D1_COLOR_INTERPOLATION_MODE colorInterpolationMode,
        [out] ID2D1GradientStopCollection1** gradientStopCollection1
        );

   //using ID2D1RenderTarget::CreateGradientStopCollection;

    /// <summary>
    /// Creates an image brush, the input image can be any type of image, including a
    /// bitmap, effect and a command list.
    /// </summary>
    HRESULT CreateImageBrush(
        [in] ID2D1Image* image,
        [in] D2D1_IMAGE_BRUSH_PROPERTIES* imageBrushProperties,
        [in] D2D1_BRUSH_PROPERTIES* brushProperties,
        [out] ID2D1ImageBrush** imageBrush
        );

    HRESULT CreateBitmapBrush(
        [in] ID2D1Bitmap* bitmap,
        [in] D2D1_BITMAP_BRUSH_PROPERTIES1* bitmapBrushProperties,
        [in] D2D1_BRUSH_PROPERTIES* brushProperties,
        [out] ID2D1BitmapBrush1** bitmapBrush
        );

    //using ID2D1RenderTarget::CreateBitmapBrush;

    /// <summary>
    /// Creates a new command list.
    /// </summary>
    HRESULT CreateCommandList(
        [out] ID2D1CommandList** commandList
        );

    /// <summary>
    /// Indicates whether the format is supported by D2D.
    /// </summary>
    BOOL IsDxgiFormatSupported(
        [in] DXGI_FORMAT format
        );

    /// <summary>
    /// Indicates whether the buffer precision is supported by D2D.
    /// </summary>
    BOOL IsBufferPrecisionSupported(
        [in] D2D1_BUFFER_PRECISION bufferPrecision
        );

    /// <summary>
    /// This retrieves the local-space bounds in DIPs of the current image using the
    /// device context DPI.
    /// </summary>
    HRESULT GetImageLocalBounds(
        [in] ID2D1Image* image,
        [out] D2D1_RECT_F* localBounds
        );

    /// <summary>
    /// This retrieves the world-space bounds in DIPs of the current image using the
    /// device context DPI.
    /// </summary>
    HRESULT GetImageWorldBounds(
        [in] ID2D1Image* image,
        [out] D2D1_RECT_F* worldBounds
        );

    /// <summary>
    /// Retrieves the world-space bounds in DIPs of the glyph run using the device
    /// context DPI.
    /// </summary>
    HRESULT GetGlyphRunWorldBounds(
        /*[in] D2D1_POINT_2F baselineOrigin,*/[in] CURRENCY baselineOrigin,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] DWRITE_MEASURING_MODE measuringMode,
        [out] D2D1_RECT_F* bounds
        );

    /// <summary>
    /// Retrieves the device associated with this device context.
    /// </summary>
    void GetDevice(
        [out] ID2D1Device** device
        );

    /// <summary>
    /// Sets the target for this device context to point to the given image. The image
    /// can be a command list or a bitmap created with the D2D1_BITMAP_OPTIONS_TARGET
    /// flag.
    /// </summary>
    void SetTarget(
        [in] ID2D1Image* image
        );

    /// <summary>
    /// Gets the target that this device context is currently pointing to.
    /// </summary>
    void GetTarget(
        [out] ID2D1Image** image
        );

    /// <summary>
    /// Sets tuning parameters for internal rendering inside the device context.
    /// </summary>
    void SetRenderingControls(
        [in] D2D1_RENDERING_CONTROLS* renderingControls
        );

    /// <summary>
    /// This retrieves the rendering controls currently selected into the device
    /// context.
    /// </summary>
    void GetRenderingControls(
        [out] D2D1_RENDERING_CONTROLS* renderingControls
        );

    /// <summary>
    /// Changes the primitive blending mode for all of the rendering operations.
    /// </summary>
    void SetPrimitiveBlend(
        [in] D2D1_PRIMITIVE_BLEND primitiveBlend
        );

    /// <summary>
    /// Returns the primitive blend currently selected into the device context.
    /// </summary>
    D2D1_PRIMITIVE_BLEND GetPrimitiveBlend(
        );

    /// <summary>
    /// Changes the units used for all of the rendering operations.
    /// </summary>
    void SetUnitMode(
        [in] D2D1_UNIT_MODE unitMode
        );

    /// <summary>
    /// Returns the unit mode currently set on the device context.
    /// </summary>
    D2D1_UNIT_MODE GetUnitMode(
        );

    /// <summary>
    /// Draws the glyph run with an extended description to describe the glyphs.
    /// </summary>
    void DrawGlyphRun(
        /*[in] D2D1_POINT_2F baselineOrigin,*/[in] CURRENCY baselineOrigin,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
        [in] ID2D1Brush* foregroundBrush,
        [in] DWRITE_MEASURING_MODE measuringMode
        );

    //using ID2D1RenderTarget::DrawGlyphRun;

    /// <summary>
    /// Draw an image to the device context. The image represents either a concrete
    /// bitmap or the output of an effect graph.
    /// </summary>
    void DrawImage(
        [in] ID2D1Image* image,
        [in] D2D1_POINT_2F* targetOffset,
        [in] D2D1_RECT_F* imageRectangle,
        [in] D2D1_INTERPOLATION_MODE interpolationMode, // = D2D1_INTERPOLATION_MODE_LINEAR,
        [in] D2D1_COMPOSITE_MODE compositeMode // = D2D1_COMPOSITE_MODE_SOURCE_OVER
        );

    /// <summary>
    /// Draw a metafile to the device context.
    /// </summary>
    void DrawGdiMetafile(
        [in] ID2D1GdiMetafile* gdiMetafile,
        [in] D2D1_POINT_2F* targetOffset // = NULL
        );

    void DrawBitmap(
        [in] ID2D1Bitmap* bitmap,
        [in] D2D1_RECT_F* destinationRectangle,
        [in] FLOAT opacity,
        [in] D2D1_INTERPOLATION_MODE interpolationMode,
        [in] D2D1_RECT_F* sourceRectangle,
        [in] D2D1_MATRIX_4X4_F* perspectiveTransform
        );

    //using ID2D1RenderTarget::DrawBitmap;

    /// <summary>
    /// Push a layer on the device context.
    /// </summary>
    void PushLayer(
        [in] D2D1_LAYER_PARAMETERS1* layerParameters,
        [in] ID2D1Layer* layer
        );

    //using ID2D1RenderTarget::PushLayer;

    /// <summary>
    /// This indicates that a portion of an effect's input is invalid. This method can
    /// be called many times.
    /// </summary>
    HRESULT InvalidateEffectInputRectangle(
        [in] ID2D1Effect* effect,
        [in] UINT32 input,
        [in] D2D1_RECT_F* inputRectangle
        );

    /// <summary>
    /// Gets the number of invalid ouptut rectangles that have accumulated at the
    /// effect.
    /// </summary>
    HRESULT GetEffectInvalidRectangleCount(
        [in] ID2D1Effect* effect,
        [out] UINT32* rectangleCount
        );

    /// <summary>
    /// Gets the invalid rectangles that are at the output of the effect.
    /// </summary>
    HRESULT GetEffectInvalidRectangles(
        [in] ID2D1Effect* effect,
        [out] D2D1_RECT_F* rectangles,
        [in] UINT32 rectanglesCount
        );

    /// <summary>
    /// Gets the maximum region of each specified input which would be used during a
    /// subsequent rendering operation
    /// </summary>
    HRESULT GetEffectRequiredInputRectangles(
        [in] ID2D1Effect* renderEffect,
        [in] D2D1_RECT_F* renderImageRectangle,
        [in] D2D1_EFFECT_INPUT_DESCRIPTION* inputDescriptions,
        [out] D2D1_RECT_F* requiredInputRects,
        [in] UINT32 inputCount
        );

    /// <summary>
    /// Fill using the alpha channel of the supplied opacity mask bitmap. The brush
    /// opacity will be modulated by the mask. The render target antialiasing mode must
    /// be set to aliased.
    /// </summary>
    void FillOpacityMask(
        [in] ID2D1Bitmap* opacityMask,
        [in] ID2D1Brush* brush,
        [in] D2D1_RECT_F* destinationRectangle,
        [in] D2D1_RECT_F* sourceRectangle //= NULL
        );
/*
    using ID2D1RenderTarget::FillOpacityMask;

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateBitmap(
            D2D1_SIZE_U size,
            [in] void* sourceData,
            UINT32 pitch,
            CONST D2D1_BITMAP_PROPERTIES1& bitmapProperties,
            [out] ID2D1Bitmap1** bitmap
        )
    {
        return CreateBitmap(size, sourceData, pitch, &bitmapProperties, bitmap);
    }

    /// <summary>
    /// Create a D2D bitmap by copying a WIC bitmap.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateBitmapFromWicBitmap(
            [in] IWICBitmapSource* wicBitmapSource,
            CONST D2D1_BITMAP_PROPERTIES1& bitmapProperties,
            [out] ID2D1Bitmap1** bitmap
        )
    {
        return CreateBitmapFromWicBitmap(wicBitmapSource, &bitmapProperties, bitmap);
    }

    /// <summary>
    /// Create a D2D bitmap by copying a WIC bitmap.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateBitmapFromWicBitmap(
            [in] IWICBitmapSource* wicBitmapSource,
            [out] ID2D1Bitmap1** bitmap
        )
    {
        return CreateBitmapFromWicBitmap(wicBitmapSource, NULL, bitmap);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateBitmapFromDxgiSurface(
            [in] IDXGISurface* surface,
            CONST D2D1_BITMAP_PROPERTIES1& bitmapProperties,
            [out] ID2D1Bitmap1** bitmap
        )
    {
        return CreateBitmapFromDxgiSurface(surface, &bitmapProperties, bitmap);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateImageBrush(
            [in] ID2D1Image* image,
            CONST D2D1_IMAGE_BRUSH_PROPERTIES& imageBrushProperties,
            CONST D2D1_BRUSH_PROPERTIES& brushProperties,
            [out] ID2D1ImageBrush** imageBrush
        )
    {
        return CreateImageBrush(image, &imageBrushProperties, &brushProperties, imageBrush);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateImageBrush(
            [in] ID2D1Image* image,
            CONST D2D1_IMAGE_BRUSH_PROPERTIES& imageBrushProperties,
            [out] ID2D1ImageBrush** imageBrush
        )
    {
        return CreateImageBrush(image, &imageBrushProperties, NULL, imageBrush);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateBitmapBrush(
            [in] ID2D1Bitmap* bitmap,
            [out] ID2D1BitmapBrush1** bitmapBrush
        )
    {
        return CreateBitmapBrush(bitmap, NULL, NULL, bitmapBrush);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateBitmapBrush(
            [in] ID2D1Bitmap* bitmap,
            CONST D2D1_BITMAP_BRUSH_PROPERTIES1& bitmapBrushProperties,
            [out] ID2D1BitmapBrush1** bitmapBrush
        )
    {
        return CreateBitmapBrush(bitmap, &bitmapBrushProperties, NULL, bitmapBrush);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateBitmapBrush(
            [in] ID2D1Bitmap* bitmap,
            CONST D2D1_BITMAP_BRUSH_PROPERTIES1& bitmapBrushProperties,
            CONST D2D1_BRUSH_PROPERTIES& brushProperties,
            [out] ID2D1BitmapBrush1** bitmapBrush
        )
    {
        return CreateBitmapBrush(bitmap, &bitmapBrushProperties, &brushProperties, bitmapBrush);
    }

    /// <summary>
    /// Draws the output of the effect as an image.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        void
        DrawImage(
            [in] ID2D1Effect* effect,
            [in] D2D1_POINT_2F* targetOffset,
            [in] D2D1_RECT_F* imageRectangle,
            D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
            D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER
        )
    {

        ID2D1Image* output = NULL;
        effect->GetOutput(&output);
        DrawImage(output, targetOffset, imageRectangle, interpolationMode, compositeMode);
        output->Release();
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawImage(
            [in] ID2D1Image* image,
            D2D1_INTERPOLATION_MODE interpolationMode,
            D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER
        )
    {
        DrawImage(image, NULL, NULL, interpolationMode, compositeMode);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawImage(
            [in] ID2D1Effect* effect,
            D2D1_INTERPOLATION_MODE interpolationMode,
            D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER
        )
    {
        DrawImage(effect, NULL, NULL, interpolationMode, compositeMode);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawImage(
            [in] ID2D1Image* image,
            D2D1_POINT_2F targetOffset,
            D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
            D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER
        )
    {
        DrawImage(image, &targetOffset, NULL, interpolationMode, compositeMode);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawImage(
            [in] ID2D1Effect* effect,
            D2D1_POINT_2F targetOffset,
            D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
            D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER
        )
    {
        DrawImage(effect, &targetOffset, NULL, interpolationMode, compositeMode);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawImage(
            [in] ID2D1Image* image,
            D2D1_POINT_2F targetOffset,
            CONST D2D1_RECT_F& imageRectangle,
            D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
            D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER
        )
    {
        DrawImage(image, &targetOffset, &imageRectangle, interpolationMode, compositeMode);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawImage(
            [in] ID2D1Effect* effect,
            D2D1_POINT_2F targetOffset,
            CONST D2D1_RECT_F& imageRectangle,
            D2D1_INTERPOLATION_MODE interpolationMode = D2D1_INTERPOLATION_MODE_LINEAR,
            D2D1_COMPOSITE_MODE compositeMode = D2D1_COMPOSITE_MODE_SOURCE_OVER
        )
    {
        DrawImage(effect, &targetOffset, &imageRectangle, interpolationMode, compositeMode);
    }

    COM_DECLSPEC_NOTHROW
        void
        PushLayer(
            CONST D2D1_LAYER_PARAMETERS1& layerParameters,
            [in] ID2D1Layer* layer
        )
    {
        PushLayer(&layerParameters, layer);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawGdiMetafile(
            [in] ID2D1GdiMetafile* gdiMetafile,
            D2D1_POINT_2F targetOffset
        )
    {
        DrawGdiMetafile(gdiMetafile, &targetOffset);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawBitmap(
            [in] ID2D1Bitmap* bitmap,
            CONST D2D1_RECT_F& destinationRectangle,
            FLOAT opacity,
            D2D1_INTERPOLATION_MODE interpolationMode,
            [in] D2D1_RECT_F* sourceRectangle,
            [in] D2D1_MATRIX_4X4_F* perspectiveTransform = NULL
        )
    {
        DrawBitmap(bitmap, &destinationRectangle, opacity, interpolationMode, sourceRectangle, perspectiveTransform);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawBitmap(
            [in] ID2D1Bitmap* bitmap,
            CONST D2D1_RECT_F& destinationRectangle,
            FLOAT opacity,
            D2D1_INTERPOLATION_MODE interpolationMode,
            CONST D2D1_RECT_F& sourceRectangle,
            [in] D2D1_MATRIX_4X4_F* perspectiveTransform = NULL
        )
    {
        DrawBitmap(bitmap, &destinationRectangle, opacity, interpolationMode, &sourceRectangle, perspectiveTransform);
    }

    COM_DECLSPEC_NOTHROW
        void
        DrawBitmap(
            [in] ID2D1Bitmap* bitmap,
            CONST D2D1_RECT_F& destinationRectangle,
            FLOAT opacity,
            D2D1_INTERPOLATION_MODE interpolationMode,
            CONST D2D1_RECT_F& sourceRectangle,
            CONST D2D1_MATRIX_4X4_F& perspectiveTransform
        )
    {
        DrawBitmap(bitmap, &destinationRectangle, opacity, interpolationMode, &sourceRectangle, &perspectiveTransform);
    }

    COM_DECLSPEC_NOTHROW
        void
        FillOpacityMask(
            [in] ID2D1Bitmap* opacityMask,
            [in] ID2D1Brush* brush,
            CONST D2D1_RECT_F& destinationRectangle,
            [in] D2D1_RECT_F* sourceRectangle = NULL
        )
    {
        FillOpacityMask(opacityMask, brush, &destinationRectangle, sourceRectangle);
    }

    COM_DECLSPEC_NOTHROW
        void
        FillOpacityMask(
            [in] ID2D1Bitmap* opacityMask,
            [in] ID2D1Brush* brush,
            CONST D2D1_RECT_F& destinationRectangle,
            CONST D2D1_RECT_F& sourceRectangle
        )
    {
        FillOpacityMask(opacityMask, brush, &destinationRectangle, &sourceRectangle);
    }

    /// <summary>
    /// Sets tuning parameters for internal rendering inside the device context.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        void
        SetRenderingControls(
            CONST D2D1_RENDERING_CONTROLS& renderingControls
        )
    {
        return SetRenderingControls(&renderingControls);
    }*/
};

[
    odl,
    uuid(47dd575d-ac05-4cdd-8049-9b02cd16f44c)
]
interface ID2D1Device : ID2D1Resource
{

    /// <summary>
    /// Creates a new device context with no initially assigned target.
    /// </summary>
    HRESULT CreateDeviceContext(
        [in] D2D1_DEVICE_CONTEXT_OPTIONS options,
        [out] ID2D1DeviceContext** deviceContext
        );

    /// <summary>
    /// Creates a D2D print control.
    /// </summary>
    HRESULT CreatePrintControl(
        [in] IWICImagingFactory* wicFactory,
        //[in] IPrintDocumentPackageTarget* documentTarget,
        [in] LPVOID documentTarget,
        [in] D2D1_PRINT_CONTROL_PROPERTIES* printControlProperties,
        [out] ID2D1PrintControl** printControl
        );

    /// <summary>
    /// Sets the maximum amount of texture memory to maintain before evicting caches.
    /// </summary>
    void SetMaximumTextureMemory(
        [in] UINT64 maximumInBytes
        );

    /// <summary>
    /// Gets the maximum amount of texture memory to maintain before evicting caches.
    /// </summary>
    UINT64 GetMaximumTextureMemory(
        );

    /// <summary>
    /// Clears all resources that are cached but not held in use by the application
    /// through an interface reference.
    /// </summary>
    void ClearResources(
        [in] UINT32 millisecondsSinceUse //= 0
        );

    /*COM_DECLSPEC_NOTHROW
        HRESULT
        CreatePrintControl(
            [in] IWICImagingFactory* wicFactory,
            [in] IPrintDocumentPackageTarget* documentTarget,
            CONST D2D1_PRINT_CONTROL_PROPERTIES& printControlProperties,
            [out] ID2D1PrintControl** printControl
        )*/
};


/// <summary>
/// Defines a property binding to a function. The name must match the property
/// defined in the registration schema.
/// </summary>
typedef struct D2D1_PROPERTY_BINDING
{

    /// <summary>
    /// The name of the property.
    /// </summary>
    LongPtr propertyName;

    /// <summary>
    /// The function that will receive the data to set.
    /// </summary>
    LongPtr setFunction;

    /// <summary>
    /// The function that will be asked to write the output data.
    /// </summary>
    LongPtr getFunction;

} D2D1_PROPERTY_BINDING;

[
    odl,
    uuid(bb12d362-daee-4b9a-aa1d-14ba401cfa1f)
]
interface ID2D1Factory1 : ID2D1Factory
{

    /// <summary>
    /// This creates a new Direct2D device from the given IDXGIDevice.
    /// </summary>
    HRESULT CreateDevice(
        [in] IDXGIDevice* dxgiDevice,
        [out] ID2D1Device** d2dDevice
        );

    /// <summary>
    /// This creates a stroke style with the ability to preserve stroke width in various
    /// ways.
    /// </summary>
    HRESULT CreateStrokeStyle(
        [in] D2D1_STROKE_STYLE_PROPERTIES1* strokeStyleProperties,
        [in] FLOAT* dashes,
        [in] UINT32 dashesCount,
        [out] ID2D1StrokeStyle1** strokeStyle
        );

    //using ID2D1Factory::CreateStrokeStyle;

    /// <summary>
    /// Creates a path geometry with new operational methods.
    /// </summary>
    HRESULT CreatePathGeometry(
        [out] ID2D1PathGeometry1** pathGeometry
        );

    //using ID2D1Factory::CreatePathGeometry;

    /// <summary>
    /// Creates a new drawing state block, this can be used in subsequent
    /// SaveDrawingState and RestoreDrawingState operations on the render target.
    /// </summary>
    HRESULT CreateDrawingStateBlock(
        [in] D2D1_DRAWING_STATE_DESCRIPTION1* drawingStateDescription,
        [in] IDWriteRenderingParams* textRenderingParams,
        [out] ID2D1DrawingStateBlock1** drawingStateBlock
        );

    //using ID2D1Factory::CreateDrawingStateBlock;

    /// <summary>
    /// Creates a new GDI metafile.
    /// </summary>
    HRESULT CreateGdiMetafile(
        [in] IStream* metafileStream,
        [out] ID2D1GdiMetafile** metafile
        );

    /// <summary>
    /// This globally registers the given effect. The effect can later be instantiated
    /// by using the registered class id. The effect registration is reference counted.
    /// </summary>
    HRESULT RegisterEffectFromStream(
        [in] REFCLSID classId,
        [in] IStream* propertyXml,
        [in] D2D1_PROPERTY_BINDING* bindings,
        [in] UINT32 bindingsCount,
        [in] LongPtr effectFactory
        );

    /// <summary>
    /// This globally registers the given effect. The effect can later be instantiated
    /// by using the registered class id. The effect registration is reference counted.
    /// </summary>
    HRESULT RegisterEffectFromString(
        [in] REFCLSID classId,
        [in] LongPtr propertyXml,
        [in] D2D1_PROPERTY_BINDING* bindings,
        [in] UINT32 bindingsCount,
        [in] LongPtr effectFactory
        );

    /// <summary>
    /// This unregisters the given effect by its class id, you need to call
    /// UnregisterEffect for every call to ID2D1Factory1::RegisterEffectFromStream and
    /// ID2D1Factory1::RegisterEffectFromString to completely unregister it.
    /// </summary>
    HRESULT UnregisterEffect(
        [in] REFCLSID classId
        );

    /// <summary>
    /// This returns all of the registered effects in the process, including any
    /// built-in effects.
    /// </summary>
    /// <param name="effectsReturned">The number of effects returned into the passed in
    /// effects array.</param>
    /// <param name="effectsRegistered">The number of effects currently registered in
    /// the system.</param>
    HRESULT GetRegisteredEffects(
        [out] CLSID* effects,
        [in] UINT32 effectsCount,
        [out] UINT32* effectsReturned,
        [out] UINT32* effectsRegistered
        );

    /// <summary>
    /// This retrieves the effect properties for the given effect, all of the effect
    /// properties will be set to a default value since an effect is not instantiated to
    /// implement the returned property interface.
    /// </summary>
    HRESULT GetEffectProperties(
        [in] REFCLSID effectId,
        [out] ID2D1Properties** d2d1properties
        );

    /*COM_DECLSPEC_NOTHROW
        HRESULT
        CreateStrokeStyle(
            CONST D2D1_STROKE_STYLE_PROPERTIES1& strokeStyleProperties,
            _In_reads_opt_(dashesCount) CONST FLOAT* dashes,
            UINT32 dashesCount,
            [out] ID2D1StrokeStyle1** strokeStyle
        )
    {
        return CreateStrokeStyle(&strokeStyleProperties, dashes, dashesCount, strokeStyle);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateDrawingStateBlock(
            CONST D2D1_DRAWING_STATE_DESCRIPTION1& drawingStateDescription,
            [out] ID2D1DrawingStateBlock1** drawingStateBlock
        )
    {
        return CreateDrawingStateBlock(&drawingStateDescription, NULL, drawingStateBlock);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateDrawingStateBlock(
            [out] ID2D1DrawingStateBlock1** drawingStateBlock
        )*/
};

[
    odl,
    uuid(31e6e7bc-e0ff-4d46-8c64-a0a8c41c15d3)
]
interface ID2D1Multithread : stdole.IUnknown
{
    BOOL GetMultithreadProtected(
        );

    /// <summary>
    /// Enters the D2D API critical section, if it exists.
    /// </summary>
    void Enter(
        );

    /// <summary>
    /// Leaves the D2D API critical section, if it exists.
    /// </summary>
    void Leave(
        );
};

interface ID2D1Device1;

typedef enum D2D1_RENDERING_PRIORITY
{
    D2D1_RENDERING_PRIORITY_NORMAL = 0,
    D2D1_RENDERING_PRIORITY_LOW = 1,
    D2D1_RENDERING_PRIORITY_FORCE_DWORD = 0xffffffff

} D2D1_RENDERING_PRIORITY;

[
    odl,
    uuid(a16907d7-bc02-4801-99e8-8cf7f485f774)
]
interface ID2D1GeometryRealization : ID2D1Resource
{
};

[
    odl,
    uuid(d37f57e4-6908-459f-a199-e72f24f79987)
]
interface ID2D1DeviceContext1 : ID2D1DeviceContext
{
    HRESULT CreateFilledGeometryRealization(
        [in] ID2D1Geometry* geometry,
        [in] FLOAT flatteningTolerance,
        [out] ID2D1GeometryRealization** geometryRealization
        );

    HRESULT CreateStrokedGeometryRealization(
        [in] ID2D1Geometry* geometry,
        [in] FLOAT flatteningTolerance,
        [in] FLOAT strokeWidth,
        [in] ID2D1StrokeStyle* strokeStyle,
        [out] ID2D1GeometryRealization** geometryRealization
        );

    void DrawGeometryRealization(
        [in] ID2D1GeometryRealization* geometryRealization,
        [in] ID2D1Brush* brush
        );
};

[
    odl,
    uuid(d21768e1-23a4-4823-a14b-7c3eba85d658)
]
interface ID2D1Device1 : ID2D1Device
{
    D2D1_RENDERING_PRIORITY GetRenderingPriority(
        );

    /// <summary>
    /// Sets the rendering priority of the device.
    /// </summary>
    void SetRenderingPriority(
        [in] D2D1_RENDERING_PRIORITY renderingPriority
        );

    /// <summary>
    /// Creates a new device context with no initially assigned target.
    /// </summary>
    HRESULT CreateDeviceContext(
        [in] D2D1_DEVICE_CONTEXT_OPTIONS options,
        [out] ID2D1DeviceContext1** deviceContext1
        );
};

[
    odl,
    uuid(94f81a73-9212-4376-9c58-b16a3a0d3992)
]
interface ID2D1Factory2 : ID2D1Factory1
{
    HRESULT CreateDevice(
        [in] IDXGIDevice* dxgiDevice,
        [out] ID2D1Device1** d2dDevice1
        );
};

[
    odl,
    uuid(9eb767fd-4269-4467-b8c2-eb30cb305743)
]
interface ID2D1CommandSink1 : ID2D1CommandSink
{
    HRESULT SetPrimitiveBlend1(
        [in] D2D1_PRIMITIVE_BLEND primitiveBlend
        );
};

typedef enum D2D1_INK_NIB_SHAPE
{
    D2D1_INK_NIB_SHAPE_ROUND = 0,
    D2D1_INK_NIB_SHAPE_SQUARE = 1,
    D2D1_INK_NIB_SHAPE_FORCE_DWORD = 0xffffffff

} D2D1_INK_NIB_SHAPE;


/// <summary>
/// Specifies the orientation of an image.
/// </summary>
typedef enum D2D1_ORIENTATION
{
    D2D1_ORIENTATION_DEFAULT = 1,
    D2D1_ORIENTATION_FLIP_HORIZONTAL = 2,
    D2D1_ORIENTATION_ROTATE_CLOCKWISE180 = 3,
    D2D1_ORIENTATION_ROTATE_CLOCKWISE180_FLIP_HORIZONTAL = 4,
    D2D1_ORIENTATION_ROTATE_CLOCKWISE90_FLIP_HORIZONTAL = 5,
    D2D1_ORIENTATION_ROTATE_CLOCKWISE270 = 6,
    D2D1_ORIENTATION_ROTATE_CLOCKWISE270_FLIP_HORIZONTAL = 7,
    D2D1_ORIENTATION_ROTATE_CLOCKWISE90 = 8,
    D2D1_ORIENTATION_FORCE_DWORD = 0xffffffff

} D2D1_ORIENTATION;


/// <summary>
/// Option flags controlling how images sources are loaded during
/// CreateImageSourceFromWic.
/// </summary>
typedef enum D2D1_IMAGE_SOURCE_LOADING_OPTIONS
{
    D2D1_IMAGE_SOURCE_LOADING_OPTIONS_NONE = 0,
    D2D1_IMAGE_SOURCE_LOADING_OPTIONS_RELEASE_SOURCE = 1,
    D2D1_IMAGE_SOURCE_LOADING_OPTIONS_CACHE_ON_DEMAND = 2,
    D2D1_IMAGE_SOURCE_LOADING_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_IMAGE_SOURCE_LOADING_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_IMAGE_SOURCE_LOADING_OPTIONS);


/// <summary>
/// Option flags controlling primary conversion performed by
/// CreateImageSourceFromDxgi, if any.
/// </summary>
typedef enum D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS
{
    D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_NONE = 0,
    D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_LOW_QUALITY_PRIMARY_CONVERSION = 1,
    D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS);


/// <summary>
/// Option flags for transformed image sources.
/// </summary>
typedef enum D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS
{
    D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_NONE = 0,

    /// <summary>
    /// Prevents the image source from being automatically scaled (by a ratio of the
    /// context DPI divided by 96) while drawn.
    /// </summary>
    D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_DISABLE_DPI_SCALE = 1,
    D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS);


/// <summary>
/// Properties of a transformed image source.
/// </summary>
typedef struct D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES
{

    /// <summary>
    /// The orientation at which the image source is drawn.
    /// </summary>
    D2D1_ORIENTATION orientation;

    /// <summary>
    /// The horizontal scale factor at which the image source is drawn.
    /// </summary>
    FLOAT scaleX;

    /// <summary>
    /// The vertical scale factor at which the image source is drawn.
    /// </summary>
    FLOAT scaleY;

    /// <summary>
    /// The interpolation mode used when the image source is drawn.  This is ignored if
    /// the image source is drawn using the DrawImage method, or using an image brush.
    /// </summary>
    D2D1_INTERPOLATION_MODE interpolationMode;

    /// <summary>
    /// Option flags.
    /// </summary>
    D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS options;

} D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES;


/// <summary>
/// Represents a point, radius pair that makes up part of a D2D1_INK_BEZIER_SEGMENT.
/// </summary>
typedef struct D2D1_INK_POINT
{
    FLOAT x;
    FLOAT y;
    FLOAT radius;

} D2D1_INK_POINT;


/// <summary>
/// Represents a Bezier segment to be used in the creation of an ID2D1Ink object.
/// This structure differs from D2D1_BEZIER_SEGMENT in that it is composed of
/// D2D1_INK_POINT s, which contain a radius in addition to x- and y-coordinates.
/// </summary>
typedef struct D2D1_INK_BEZIER_SEGMENT
{
    D2D1_INK_POINT point1;
    D2D1_INK_POINT point2;
    D2D1_INK_POINT point3;

} D2D1_INK_BEZIER_SEGMENT;


/// <summary>
/// Defines the general pen tip shape and the transform used in an ID2D1InkStyle
/// object.
/// </summary>
typedef struct D2D1_INK_STYLE_PROPERTIES
{

    /// <summary>
    /// The general shape of the nib used to draw a given ink object.
    /// </summary>
    D2D1_INK_NIB_SHAPE nibShape;

    /// <summary>
    /// The transform applied to shape of the nib. _31 and _32 are ignored.
    /// </summary>
    D2D1_MATRIX_3X2_F nibTransform;

} D2D1_INK_STYLE_PROPERTIES;


/// <summary>
/// Specifies how to render gradient mesh edges.
/// </summary>
typedef enum D2D1_PATCH_EDGE_MODE
{

    /// <summary>
    /// Render this edge aliased.
    /// </summary>
    D2D1_PATCH_EDGE_MODE_ALIASED = 0,

    /// <summary>
    /// Render this edge antialiased.
    /// </summary>
    D2D1_PATCH_EDGE_MODE_ANTIALIASED = 1,

    /// <summary>
    /// Render this edge aliased and inflated out slightly.
    /// </summary>
    D2D1_PATCH_EDGE_MODE_ALIASED_INFLATED = 2,
    D2D1_PATCH_EDGE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_PATCH_EDGE_MODE;


/// <summary>
/// Represents a tensor patch with 16 control points, 4 corner colors, and boundary
/// flags. An ID2D1GradientMesh is made up of 1 or more gradient mesh patches. Use
/// the GradientMeshPatch function or the GradientMeshPatchFromCoonsPatch function
/// to create one.
/// </summary>
typedef struct D2D1_GRADIENT_MESH_PATCH
{

    /// <summary>
    /// The gradient mesh patch control point at position 00.
    /// </summary>
    D2D1_POINT_2F point00;

    /// <summary>
    /// The gradient mesh patch control point at position 01.
    /// </summary>
    D2D1_POINT_2F point01;

    /// <summary>
    /// The gradient mesh patch control point at position 02.
    /// </summary>
    D2D1_POINT_2F point02;

    /// <summary>
    /// The gradient mesh patch control point at position 03.
    /// </summary>
    D2D1_POINT_2F point03;

    /// <summary>
    /// The gradient mesh patch control point at position 10.
    /// </summary>
    D2D1_POINT_2F point10;

    /// <summary>
    /// The gradient mesh patch control point at position 11.
    /// </summary>
    D2D1_POINT_2F point11;

    /// <summary>
    /// The gradient mesh patch control point at position 12.
    /// </summary>
    D2D1_POINT_2F point12;

    /// <summary>
    /// The gradient mesh patch control point at position 13.
    /// </summary>
    D2D1_POINT_2F point13;

    /// <summary>
    /// The gradient mesh patch control point at position 20.
    /// </summary>
    D2D1_POINT_2F point20;

    /// <summary>
    /// The gradient mesh patch control point at position 21.
    /// </summary>
    D2D1_POINT_2F point21;

    /// <summary>
    /// The gradient mesh patch control point at position 22.
    /// </summary>
    D2D1_POINT_2F point22;

    /// <summary>
    /// The gradient mesh patch control point at position 23.
    /// </summary>
    D2D1_POINT_2F point23;

    /// <summary>
    /// The gradient mesh patch control point at position 30.
    /// </summary>
    D2D1_POINT_2F point30;

    /// <summary>
    /// The gradient mesh patch control point at position 31.
    /// </summary>
    D2D1_POINT_2F point31;

    /// <summary>
    /// The gradient mesh patch control point at position 32.
    /// </summary>
    D2D1_POINT_2F point32;

    /// <summary>
    /// The gradient mesh patch control point at position 33.
    /// </summary>
    D2D1_POINT_2F point33;

    /// <summary>
    /// The color associated with control point at position 00.
    /// </summary>
    D2D1_COLOR_F color00;

    /// <summary>
    /// The color associated with control point at position 03.
    /// </summary>
    D2D1_COLOR_F color03;

    /// <summary>
    /// The color associated with control point at position 30.
    /// </summary>
    D2D1_COLOR_F color30;

    /// <summary>
    /// The color associated with control point at position 33.
    /// </summary>
    D2D1_COLOR_F color33;

    /// <summary>
    /// The edge mode for the top edge of the patch.
    /// </summary>
    D2D1_PATCH_EDGE_MODE topEdgeMode;

    /// <summary>
    /// The edge mode for the left edge of the patch.
    /// </summary>
    D2D1_PATCH_EDGE_MODE leftEdgeMode;

    /// <summary>
    /// The edge mode for the bottom edge of the patch.
    /// </summary>
    D2D1_PATCH_EDGE_MODE bottomEdgeMode;

    /// <summary>
    /// The edge mode for the right edge of the patch.
    /// </summary>
    D2D1_PATCH_EDGE_MODE rightEdgeMode;

} D2D1_GRADIENT_MESH_PATCH;

typedef enum D2D1_SPRITE_OPTIONS
{

    /// <summary>
    /// Use default sprite rendering behavior.
    /// </summary>
    D2D1_SPRITE_OPTIONS_NONE = 0,

    /// <summary>
    /// Bitmap interpolation will be clamped to the sprite's source rectangle.
    /// </summary>
    D2D1_SPRITE_OPTIONS_CLAMP_TO_SOURCE_RECTANGLE = 1,
    D2D1_SPRITE_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_SPRITE_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_SPRITE_OPTIONS);


/// <summary>
/// Specifies the pixel snapping policy when rendering color bitmap glyphs.
/// </summary>
typedef enum D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION
{

    /// <summary>
    /// Color bitmap glyph positions are snapped to the nearest pixel if the bitmap
    /// resolution matches that of the device context.
    /// </summary>
    D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DEFAULT = 0,

    /// <summary>
    /// Color bitmap glyph positions are not snapped.
    /// </summary>
    D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DISABLE = 1,
    D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_FORCE_DWORD = 0xffffffff

} D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION;

[
    odl,
    uuid(bae8b344-23fc-4071-8cb5-d05d6f073848)
]
interface ID2D1InkStyle : ID2D1Resource
{
    void SetNibTransform(
        [in] D2D1_MATRIX_3X2_F* transform
        );

    void GetNibTransform(
        [out] D2D1_MATRIX_3X2_F* transform
        );

    void SetNibShape(
        [in] D2D1_INK_NIB_SHAPE nibShape
        );

    D2D1_INK_NIB_SHAPE GetNibShape(
        );

    /*COM_DECLSPEC_NOTHROW
        void
        SetNibTransform(
            CONST D2D1_MATRIX_3X2_F& transform
        )
    {
        SetNibTransform(&transform);
    }*/
};

[
    odl,
    uuid(b499923b-7029-478f-a8b3-432c7c5f5312)
]
interface ID2D1Ink : ID2D1Resource
{
    void SetStartPoint(
        [in] D2D1_INK_POINT* startPoint
        );

    /// <summary>
    /// Retrieve the start point with which the ink was initialized.
    /// </summary>
    D2D1_INK_POINT GetStartPoint(
        );

    /// <summary>
    /// Add one or more segments to the end of the ink.
    /// </summary>
    HRESULT AddSegments(
        [in] D2D1_INK_BEZIER_SEGMENT* segments,
        [in] UINT32 segmentsCount
        );

    /// <summary>
    /// Remove one or more segments from the end of the ink.
    /// </summary>
    HRESULT RemoveSegmentsAtEnd(
        [in] UINT32 segmentsCount
        );

    /// <summary>
    /// Updates the specified segments with new control points.
    /// </summary>
    HRESULT SetSegments(
        [in] UINT32 startSegment,
        [in] D2D1_INK_BEZIER_SEGMENT* segments,
        [in] UINT32 segmentsCount
        );

    /// <summary>
    /// Update the last segment with new control points.
    /// </summary>
    HRESULT SetSegmentAtEnd(
        [in] D2D1_INK_BEZIER_SEGMENT* segment
        );

    /// <summary>
    /// Returns the number of segments the ink is composed of.
    /// </summary>
    UINT32 GetSegmentCount(
        );

    /// <summary>
    /// Retrieve the segments stored in the ink.
    /// </summary>
    HRESULT GetSegments(
        [in] UINT32 startSegment,
        [out] D2D1_INK_BEZIER_SEGMENT* segments,
        [in] UINT32 segmentsCount
        );

    /// <summary>
    /// Construct a geometric representation of the ink.
    /// </summary>
    HRESULT StreamAsGeometry(
        [in] ID2D1InkStyle* inkStyle,
        [in] D2D1_MATRIX_3X2_F* worldTransform,
        [in] FLOAT flatteningTolerance,
        [in] ID2D1SimplifiedGeometrySink* geometrySink
        );

    /// <summary>
    /// Retrieve the bounds of the ink, with an optional applied transform.
    /// </summary>
    HRESULT GetBounds(
        [in] ID2D1InkStyle* inkStyle,
        [in] D2D1_MATRIX_3X2_F* worldTransform,
        [out] D2D1_RECT_F* bounds
        );

    /// <summary>
    /// Resets the ink start point.
    /// </summary>
    /*COM_DECLSPEC_NOTHROW
        void
        SetStartPoint(
            CONST D2D1_INK_POINT& startPoint
        )
    {
        SetStartPoint(&startPoint);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        SetSegmentAtEnd(
            CONST D2D1_INK_BEZIER_SEGMENT& segment
        )
    {
        return SetSegmentAtEnd(&segment);
    }

    /// <summary>
    /// Construct a geometric representation of the ink.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        HRESULT
        StreamAsGeometry(
            [in] ID2D1InkStyle* inkStyle,
            CONST D2D1_MATRIX_3X2_F& worldTransform,
            FLOAT flatteningTolerance,
            [in] ID2D1SimplifiedGeometrySink* geometrySink
        ) CONST
    {
        return StreamAsGeometry(inkStyle, &worldTransform, flatteningTolerance, geometrySink);
    }

    /// <summary>
    /// Construct a geometric representation of the ink.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        HRESULT
        StreamAsGeometry(
            [in] ID2D1InkStyle* inkStyle,
            [in] D2D1_MATRIX_3X2_F* worldTransform,
            [in] ID2D1SimplifiedGeometrySink* geometrySink
        ) CONST
    {
        return StreamAsGeometry(inkStyle, worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }

    /// <summary>
    /// Construct a geometric representation of the ink.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        HRESULT
        StreamAsGeometry(
            [in] ID2D1InkStyle* inkStyle,
            CONST D2D1_MATRIX_3X2_F& worldTransform,
            [in] ID2D1SimplifiedGeometrySink* geometrySink
        ) CONST
    {
        return StreamAsGeometry(inkStyle, &worldTransform, D2D1_DEFAULT_FLATTENING_TOLERANCE, geometrySink);
    }*/
};

[
    odl,
    uuid(f292e401-c050-4cde-83d7-04962d3b23c2)
]
interface ID2D1GradientMesh : ID2D1Resource
{
    UINT32 GetPatchCount(
        );

    /// <summary>
    /// Retrieve the patch data stored in the gradient mesh.
    /// </summary>
    HRESULT GetPatches(
        [in] UINT32 startIndex,
        [out] D2D1_GRADIENT_MESH_PATCH* patches,
        [in] UINT32 patchesCount
        );
};

[
    odl,
    uuid(c9b664e5-74a1-4378-9ac2-eefc37a3f4d8)
]
interface ID2D1ImageSource : ID2D1Image
{
    HRESULT OfferResources(
        );

    HRESULT TryReclaimResources(
        [out] BOOL* resourcesDiscarded
        );
};

[
    odl,
    uuid(77395441-1c8f-4555-8683-f50dab0fe792)
]
interface ID2D1ImageSourceFromWic : ID2D1ImageSource
{
    HRESULT EnsureCached(
        [in] D2D1_RECT_U* rectangleToFill
        );

    HRESULT TrimCache(
        [in] D2D1_RECT_U* rectangleToPreserve
        );

    void GetSource(
        [out] IWICBitmapSource** wicBitmapSource
        );
    /*
    COM_DECLSPEC_NOTHROW
        HRESULT
        EnsureCached(
            CONST D2D1_RECT_U& rectangleToFill
        )
    {
        return EnsureCached(&rectangleToFill);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        TrimCache(
            CONST D2D1_RECT_U& rectangleToPreserve
        )
    {
        return TrimCache(&rectangleToPreserve);
    }*/
};

[
    odl,
    uuid(7f1f79e5-2796-416c-8f55-700f911445e5)
]
interface ID2D1TransformedImageSource : ID2D1Image
{
    void GetSource(
        [out] ID2D1ImageSource** imageSource
        );

    void GetProperties(
        [out] D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* imageSrcProperties
        );
};

[
    odl,
    uuid(53dd9855-a3b0-4d5b-82e1-26e25c5e5797)
]
interface ID2D1LookupTable3D : ID2D1Resource
{

};

[
    odl,
    uuid(394ea6a3-0c34-4321-950b-6ca20f0be6c7)
]
interface ID2D1DeviceContext2 : ID2D1DeviceContext1
{
    HRESULT CreateInk(
        [in] D2D1_INK_POINT* startPoint,
        [out] ID2D1Ink** ink
        );

    /// <summary>
    /// Creates a new ink style.
    /// </summary>
    HRESULT CreateInkStyle(
        [in] D2D1_INK_STYLE_PROPERTIES* inkStyleProperties,
        [out] ID2D1InkStyle** inkStyle
        );

    HRESULT CreateGradientMesh(
        [in] D2D1_GRADIENT_MESH_PATCH* patches,
        [in] UINT32 patchesCount,
        [out] ID2D1GradientMesh** gradientMesh
        );

    HRESULT CreateImageSourceFromWic(
        [in] IWICBitmapSource* wicBitmapSource,
        [in] D2D1_IMAGE_SOURCE_LOADING_OPTIONS loadingOptions,
        [in] D2D1_ALPHA_MODE alphaMode,
        [out] ID2D1ImageSourceFromWic** imageSource
        );

    /// <summary>
    /// Creates a 3D lookup table for mapping a 3-channel input to a 3-channel output.
    /// The table data must be provided in 4-channel format.
    /// </summary>
    HRESULT CreateLookupTable3D(
        [in] D2D1_BUFFER_PRECISION precision,
        [in] UINT32* extents,
        [in] BYTE* data,
        [in] UINT32 dataCount,
        [in] UINT32* strides,
        [out] ID2D1LookupTable3D** lookupTable
        );

    HRESULT CreateImageSourceFromDxgi(
        [in] IDXGISurface** surfaces,
        [in] UINT32 surfaceCount,
        [in] DXGI_COLOR_SPACE_TYPE colorSpace,
        [in] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,
        [out] ID2D1ImageSource** imageSource
        );

    /// <summary>
    /// Retrieves the world-space bounds in DIPs of the gradient mesh using the device
    /// context DPI.
    /// </summary>
    HRESULT GetGradientMeshWorldBounds(
        [in] ID2D1GradientMesh* gradientMesh,
        [out] D2D1_RECT_F* pBounds
        );

    void DrawInk(
        [in] ID2D1Ink* ink,
        [in] ID2D1Brush* brush,
        [in] ID2D1InkStyle* inkStyle
        );

    void DrawGradientMesh(
        [in] ID2D1GradientMesh* gradientMesh
        );

    /// <summary>
    /// Draw a metafile to the device context.
    /// </summary>
    void DrawGdiMetafile(
        [in] ID2D1GdiMetafile* gdiMetafile,
        [in] D2D1_RECT_F* destinationRectangle,
        [in] D2D1_RECT_F* sourceRectangle //= NULL
        );

    //using ID2D1DeviceContext::DrawGdiMetafile;

    /// <summary>
    /// Creates an image source which shares resources with an original.
    /// </summary>
    HRESULT CreateTransformedImageSource(
        [in] ID2D1ImageSource* imageSource,
        [in] D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* imgSrcProperties,
        [out] ID2D1TransformedImageSource** transformedImageSource
        );

    /*COM_DECLSPEC_NOTHROW
        HRESULT
        CreateInk(
            CONST D2D1_INK_POINT& startPoint,
            [out] ID2D1Ink** ink
        )
    {
        return CreateInk(&startPoint, ink);
    }
    
    /// <summary>
    /// Creates a new ink style.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateInkStyle(
            CONST D2D1_INK_STYLE_PROPERTIES& inkStyleProperties,
            [out] ID2D1InkStyle** inkStyle
        )
    {
        return CreateInkStyle(&inkStyleProperties, inkStyle);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateImageSourceFromWic(
            [in] IWICBitmapSource* wicBitmapSource,
            D2D1_IMAGE_SOURCE_LOADING_OPTIONS loadingOptions,
            [out] ID2D1ImageSourceFromWic** imageSource
        )
    {
        return CreateImageSourceFromWic(wicBitmapSource, loadingOptions, D2D1_ALPHA_MODE_UNKNOWN, imageSource);
    }

    COM_DECLSPEC_NOTHROW
        HRESULT
        CreateImageSourceFromWic(
            [in] IWICBitmapSource* wicBitmapSource,
            [out] ID2D1ImageSourceFromWic** imageSource
        )
    {
        return CreateImageSourceFromWic(wicBitmapSource, D2D1_IMAGE_SOURCE_LOADING_OPTIONS_NONE, D2D1_ALPHA_MODE_UNKNOWN, imageSource);
    }

    /// <summary>
    /// Draw a metafile to the device context.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        void
        DrawGdiMetafile(
            [in] ID2D1GdiMetafile* gdiMetafile,
            CONST D2D1_RECT_F& destinationRectangle,
            CONST D2D1_RECT_F& sourceRectangle
        )
    {
        return DrawGdiMetafile(gdiMetafile, &destinationRectangle, &sourceRectangle);
    }

    /// <summary>
    /// Draw a metafile to the device context.
    /// </summary>
    COM_DECLSPEC_NOTHROW
        void
        DrawGdiMetafile(
            [in] ID2D1GdiMetafile* gdiMetafile,
            CONST D2D1_RECT_F& destinationRectangle,
            [in] D2D1_RECT_F* sourceRectangle = NULL
        )
    {
        return DrawGdiMetafile(gdiMetafile, &destinationRectangle, sourceRectangle);
    }*/
};

[
    odl,
    uuid(a44472e1-8dfb-4e60-8492-6e2861c9ca8b)
]
interface ID2D1Device2 : ID2D1Device1
{
    HRESULT CreateDeviceContext(
        [in] D2D1_DEVICE_CONTEXT_OPTIONS options,
        [out] ID2D1DeviceContext2** deviceContext2
        );

    //using ID2D1Device1::CreateDeviceContext;

    //using ID2D1Device::CreateDeviceContext;

    /// <summary>
    /// Flush all device contexts that reference a given bitmap.
    /// </summary>
    void FlushDeviceContexts(
        [in] ID2D1Bitmap* bitmap
        );

    /// <summary>
    /// Returns the DXGI device associated with this D2D device.
    /// </summary>
    HRESULT GetDxgiDevice(
        [out] IDXGIDevice** dxgiDevice
        );
};

[
    odl,
    uuid(0869759f-4f00-413f-b03e-2bda45404d0f)
]
interface ID2D1Factory3 : ID2D1Factory2
{
    HRESULT CreateDevice(
        [in] IDXGIDevice* dxgiDevice,
        [out] ID2D1Device2** d2dDevice2
        );
};

[
    odl,
    uuid(3bab440e-417e-47df-a2e2-bc0be6a00916)
]
interface ID2D1CommandSink2 : ID2D1CommandSink1
{
    HRESULT DrawInk(
        [in] ID2D1Ink* ink,
        [in] ID2D1Brush* brush,
        [in] ID2D1InkStyle* inkStyle
        );

    HRESULT DrawGradientMesh(
        [in] ID2D1GradientMesh* gradientMesh
        );

    HRESULT DrawGdiMetafile(
        [in] ID2D1GdiMetafile* gdiMetafile,
        [in] D2D1_RECT_F* destinationRectangle,
        [in] D2D1_RECT_F* sourceRectangle
        );
};

[
    odl,
    uuid(2e69f9e8-dd3f-4bf9-95ba-c04f49d788df)
]
interface ID2D1GdiMetafile1 : ID2D1GdiMetafile
{
    HRESULT GetDpi(
        [out] FLOAT* dpiX,
        [out] FLOAT* dpiY
        );

    /// <summary>
    /// Gets the bounds (in DIPs) of the metafile (as specified by the frame rect
    /// declared in the metafile).
    /// </summary>
    HRESULT GetSourceBounds(
        [out] D2D1_RECT_F* bounds
        );
};

[
    odl,
    uuid(fd0ecb6b-91e6-411e-8655-395e760f91b4)
]
interface ID2D1GdiMetafileSink1 : ID2D1GdiMetafileSink
{
    HRESULT ProcessRecord(
        [in] DWORD recordType,
        [in] void* recordData,
        [in] DWORD recordDataSize,
        [in] UINT32 flags
        );
};

[
    odl,
    uuid(4dc583bf-3a10-438a-8722-e9765224f1f1)
]
interface ID2D1SpriteBatch : ID2D1Resource
{
    HRESULT AddSprites(
        [in] UINT32 spriteCount,
        [in] D2D1_RECT_F* destinationRectangles,
        [in] D2D1_RECT_U* sourceRectangles,
        [in] D2D1_COLOR_F* colors,
        [in] D2D1_MATRIX_3X2_F* transforms,
        [in] UINT32 destinationRectanglesStride, // = sizeof(D2D1_RECT_F),
        [in] UINT32 sourceRectanglesStride, // = sizeof(D2D1_RECT_U),
        [in] UINT32 colorsStride, // = sizeof(D2D1_COLOR_F),
        [in] UINT32 transformsStride // = sizeof(D2D1_MATRIX_3X2_F)
        );

    /// <summary>
    /// Set properties for existing sprites. All properties not specified are
    /// unmodified.
    /// </summary>
    HRESULT SetSprites(
        [in] UINT32 startIndex,
        [in] UINT32 spriteCount,
        [in] D2D1_RECT_F* destinationRectangles,
        [in] D2D1_RECT_U* sourceRectangles,
        [in] D2D1_COLOR_F* colors,
        [in] D2D1_MATRIX_3X2_F* transforms,
        [in] UINT32 destinationRectanglesStride, // = sizeof(D2D1_RECT_F),
        [in] UINT32 sourceRectanglesStride, // = sizeof(D2D1_RECT_U),
        [in] UINT32 colorsStride, // = sizeof(D2D1_COLOR_F),
        [in] UINT32 transformsStride //= sizeof(D2D1_MATRIX_3X2_F)
        );

    /// <summary>
    /// Retrieves sprite properties.
    /// </summary>
    HRESULT GetSprites(
        [in] UINT32 startIndex,
        [in] UINT32 spriteCount,
        [out] D2D1_RECT_F* destinationRectangles,
        [out] D2D1_RECT_U* sourceRectangles,
        [out] D2D1_COLOR_F* colors,
        [out] D2D1_MATRIX_3X2_F* transforms //= NULL
        );

    /// <summary>
    /// Retrieves the number of sprites in the sprite batch.
    /// </summary>
    UINT32 GetSpriteCount(
        );

    /// <summary>
    /// Removes all sprites from the sprite batch.
    /// </summary>
    void Clear(
        );
};

[
    odl,
    uuid(235a7496-8351-414c-bcd4-6672ab2d8e00)
]
interface ID2D1DeviceContext3 : ID2D1DeviceContext2
{
    HRESULT CreateSpriteBatch(
        [out] ID2D1SpriteBatch** spriteBatch
        );

    /// <summary>
    /// Draws sprites in a sprite batch.
    /// </summary>
    void DrawSpriteBatch(
        [in] ID2D1SpriteBatch* spriteBatch,
        [in] UINT32 startIndex,
        [in] UINT32 spriteCount,
        [in] ID2D1Bitmap* bitmap,
        [in] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode, // = D2D1_BITMAP_INTERPOLATION_MODE_LINEAR,
        [in] D2D1_SPRITE_OPTIONS spriteOptions // = D2D1_SPRITE_OPTIONS_NONE
        );

    /// <summary>
    /// Draws all sprites in a sprite batch.
    /// </summary>
    /*COM_DECLSPEC_NOTHROW
        void
        DrawSpriteBatch(
            [in] ID2D1SpriteBatch* spriteBatch,
            [in] ID2D1Bitmap* bitmap,
            D2D1_BITMAP_INTERPOLATION_MODE interpolationMode = D2D1_BITMAP_INTERPOLATION_MODE_LINEAR,
            D2D1_SPRITE_OPTIONS spriteOptions = D2D1_SPRITE_OPTIONS_NONE
        )
    {
        return DrawSpriteBatch(spriteBatch, 0, spriteBatch->GetSpriteCount(), bitmap, interpolationMode, spriteOptions);
    }*/
};

[
    odl,
    uuid(852f2087-802c-4037-ab60-ff2e7ee6fc01)
]
interface ID2D1Device3 : ID2D1Device2
{
    HRESULT CreateDeviceContext(
        [in] D2D1_DEVICE_CONTEXT_OPTIONS options,
        [out] ID2D1DeviceContext3** deviceContext3
        );
};

[
    odl,
    uuid(bd4ec2d2-0662-4bee-ba8e-6f29f032e096)
]
interface ID2D1Factory4 : ID2D1Factory3
{
    HRESULT CreateDevice(
        [in] IDXGIDevice* dxgiDevice,
        [out] ID2D1Device3** d2dDevice3
        );
};

[
    odl,
    uuid(18079135-4cf3-4868-bc8e-06067e6d242d)
]
interface ID2D1CommandSink3 : ID2D1CommandSink2
{
    HRESULT DrawSpriteBatch(
        [in] ID2D1SpriteBatch* spriteBatch,
        [in] UINT32 startIndex,
        [in] UINT32 spriteCount,
        [in] ID2D1Bitmap* bitmap,
        [in] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,
        [in] D2D1_SPRITE_OPTIONS spriteOptions
        );
};

[
    odl,
    uuid(af671749-d241-4db8-8e41-dcc2e5c1a438)
]
interface ID2D1SvgGlyphStyle : ID2D1Resource
{
    HRESULT SetFill(
        [in] ID2D1Brush* brush
        );

    /// <summary>
    /// Returns the requested fill parameters.
    /// </summary>
    void GetFill(
        [out] ID2D1Brush** brush
        );

    /// <summary>
    /// Provides values to an SVG glyph for stroke properties. The brush with opacity
    /// set to 1 is used as the 'context-stroke'. The opacity of the brush is used as
    /// the 'context-stroke-opacity' value.
    /// </summary>
    /// <param name="brush">A null brush will cause the context-stroke value to be
    /// 'none'.</param>
    /// <param name="strokeWidth">Specifies the 'context-value' for the 'stroke-width'
    /// property.</param>
    /// <param name="dashes">Specifies the 'context-value' for the 'stroke-dasharray'
    /// property. A null value will cause the stroke-dasharray to be set to 'none'.
    /// </param>
    /// <param name="dashOffset">Specifies the 'context-value' for the
    /// 'stroke-dashoffset' property.</param>
    HRESULT SetStroke(
        [in] ID2D1Brush* brush,
        [in] FLOAT strokeWidth,  // = 1.0f,
        [in] FLOAT* dashes,
        [in] UINT32 dashesCount, // = 0,
        [in] FLOAT dashOffset // = 1.0f
        );

    /// <summary>
    /// Returns the number of dashes in the dash array.
    /// </summary>
    UINT32 GetStrokeDashesCount(
        );

    /// <summary>
    /// Returns the requested stroke parameters.
    /// </summary>
    void GetStroke(
        [out] ID2D1Brush** brush,
        [out] FLOAT* strokeWidth,
        [out] FLOAT* dashes,
        [in] UINT32 dashesCount, // = 0,
        [out] FLOAT* dashOffset //= NULL
        );
};



[
    odl,
    uuid(8c427831-3d90-4476-b647-c4fae349e4db)
]
interface ID2D1DeviceContext4 : ID2D1DeviceContext3
{
    /// <summary>
    /// Creates an SVG glyph style object.
    /// </summary>
    HRESULT CreateSvgGlyphStyle(
        [out] ID2D1SvgGlyphStyle** svgGlyphStyle
        );

    /// <summary>
    /// Draws the text within the given layout rectangle. By default, this method
    /// performs baseline snapping and renders color versions of glyphs in color fonts.
    /// </summary>
    /// <param name="svgGlyphStyle">Object used to style SVG glyphs.</param>
    /// <param name="colorPaletteIndex">The index used to select a color palette within
    /// a color font.</param>
    void DrawText(
        [in] WCHAR* string,
        [in] UINT32 stringLength,
        [in] IDWriteTextFormat* textFormat,
        [in] D2D1_RECT_F* layoutRect,
        [in] ID2D1Brush* defaultFillBrush,
        [in] ID2D1SvgGlyphStyle* svgGlyphStyle,
        [in] UINT32 colorPaletteIndex, // = 0,
        [in] D2D1_DRAW_TEXT_OPTIONS options, // = D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT,
        [in] DWRITE_MEASURING_MODE measuringMode //= DWRITE_MEASURING_MODE_NATURAL
        );

    //using ID2D1RenderTarget::DrawText;

    /// <summary>
    /// Draw a text layout object. If the layout is not subsequently changed, this can
    /// be more efficient than DrawText when drawing the same layout repeatedly.
    /// </summary>
    /// <param name="svgGlyphStyle">Object used to style SVG glyphs.</param>
    /// <param name="colorPaletteIndex">The index used to select a color palette within
    /// a color font.</param>
    /// <param name="options">The specified text options. If D2D1_DRAW_TEXT_OPTIONS_CLIP
    /// is used, the text is clipped to the layout bounds. These bounds are derived from
    /// the origin and the layout bounds of the corresponding IDWriteTextLayout object.
    /// </param>
    void DrawTextLayout(
        /*[in] D2D1_POINT_2F origin,*/[in] CURRENCY origin,
        [in] IDWriteTextLayout* textLayout,
        [in] ID2D1Brush* defaultFillBrush,
        [in] ID2D1SvgGlyphStyle* svgGlyphStyle,
        [in] UINT32 colorPaletteIndex,// = 0,
        [in] D2D1_DRAW_TEXT_OPTIONS options// = D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT
        );

    //using ID2D1RenderTarget::DrawTextLayout;

    /// <summary>
    /// Draws a color glyph run using one (and only one) of the bitmap formats-
    /// DWRITE_GLYPH_IMAGE_FORMATS_PNG, DWRITE_GLYPH_IMAGE_FORMATS_JPEG,
    /// DWRITE_GLYPH_IMAGE_FORMATS_TIFF, or
    /// DWRITE_GLYPH_IMAGE_FORMATS_PREMULTIPLIED_B8G8R8A8.
    /// </summary>
    void DrawColorBitmapGlyphRun(
        [in] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,
        /*[in] D2D1_POINT_2F baselineOrigin,*/[in] CURRENCY baselineOrigin,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] DWRITE_MEASURING_MODE measuringMode, // = DWRITE_MEASURING_MODE_NATURAL,
        [in] D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION bitmapSnapOption// = D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DEFAULT
        );

    /// <summary>
    /// Draws a color glyph run that has the format of DWRITE_GLYPH_IMAGE_FORMATS_SVG.
    /// </summary>
    /// <param name="svgGlyphStyle">Object used to style SVG glyphs.</param>
    /// <param name="colorPaletteIndex">The index used to select a color palette within
    /// a color font. Note that this not the same as the paletteIndex in the
    /// DWRITE_COLOR_GLYPH_RUN struct, which is not relevant for SVG glyphs.</param>
    void DrawSvgGlyphRun(
        /*[in] D2D1_POINT_2F baselineOrigin,*/[in] CURRENCY baselineOrigin,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] ID2D1Brush* defaultFillBrush,
        [in] ID2D1SvgGlyphStyle* svgGlyphStyle,
        [in] UINT32 colorPaletteIndex, // = 0,
        [in] DWRITE_MEASURING_MODE measuringMode// = DWRITE_MEASURING_MODE_NATURAL
        );

    /// <summary>
    /// Retrieves an image of the color bitmap glyph from the color glyph cache. If the
    /// cache does not already contain the requested resource, it will be created. This
    /// method may be used to extend the lifetime of a glyph image even after it is
    /// evicted from the color glyph cache.
    /// </summary>
    /// <param name="fontEmSize">The specified font size affects the choice of which
    /// bitmap to use from the font. It also affects the output glyphTransform, causing
    /// it to properly scale the glyph.</param>
    /// <param name="glyphTransform">Output transform, which transforms from the glyph's
    /// space to the same output space as the worldTransform. This includes the input
    /// glyphOrigin, the glyph's offset from the glyphOrigin, and any other required
    /// transformations.</param>
    HRESULT GetColorBitmapGlyphImage(
        [in] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,
        /*[in] D2D1_POINT_2F glyphOrigin,*/[in] CURRENCY glyphOrigin,
        [in] IDWriteFontFace* fontFace,
        [in] FLOAT fontEmSize,
        [in] UINT16 glyphIndex,
        [in] BOOL isSideways,
        [in] D2D1_MATRIX_3X2_F* worldTransform,
        [in] FLOAT dpiX,
        [in] FLOAT dpiY,
        [out] D2D1_MATRIX_3X2_F* glyphTransform,
        [out] ID2D1Image** glyphImage
        );

    /// <summary>
    /// Retrieves an image of the SVG glyph from the color glyph cache. If the cache
    /// does not already contain the requested resource, it will be created. This method
    /// may be used to extend the lifetime of a glyph image even after it is evicted
    /// from the color glyph cache.
    /// </summary>
    /// <param name="fontEmSize">The specified font size affects the output
    /// glyphTransform, causing it to properly scale the glyph.</param>
    /// <param name="svgGlyphStyle">Object used to style SVG glyphs.</param>
    /// <param name="colorPaletteIndex">The index used to select a color palette within
    /// a color font. Note that this not the same as the paletteIndex in the
    /// DWRITE_COLOR_GLYPH_RUN struct, which is not relevant for SVG glyphs.</param>
    /// <param name="glyphTransform">Output transform, which transforms from the glyph's
    /// space to the same output space as the worldTransform. This includes the input
    /// glyphOrigin, the glyph's offset from the glyphOrigin, and any other required
    /// transformations.</param>
    HRESULT GetSvgGlyphImage(
        /*[in] D2D1_POINT_2F glyphOrigin,*/[in] CURRENCY glyphOrigin,
        [in] IDWriteFontFace* fontFace,
        [in] FLOAT fontEmSize,
        [in] UINT16 glyphIndex,
        [in] BOOL isSideways,
        [in] D2D1_MATRIX_3X2_F* worldTransform,
        [in] ID2D1Brush* defaultFillBrush,
        [in] ID2D1SvgGlyphStyle* svgGlyphStyle,
        [in] UINT32 colorPaletteIndex,
        [out] D2D1_MATRIX_3X2_F* glyphTransform,
        [out] ID2D1CommandList** glyphImage
        );

    /// <summary>
    /// Draws the text within the given layout rectangle. By default, this method
    /// performs baseline snapping and renders color versions of glyphs in color fonts.
    /// </summary>
    /// <param name="svgGlyphStyle">Object used to style SVG glyphs.</param>
    /// <param name="colorPaletteIndex">The index used to select a color palette within
    /// a color font.</param>
    /* COM_DECLSPEC_NOTHROW
        void
        DrawText(
            _In_reads_(stringLength) CONST WCHAR* string,
            UINT32 stringLength,
            [in] IDWriteTextFormat* textFormat,
            CONST D2D1_RECT_F& layoutRect,
            [in] ID2D1Brush* defaultFillBrush,
            [in] ID2D1SvgGlyphStyle* svgGlyphStyle,
            UINT32 colorPaletteIndex = 0,
            D2D1_DRAW_TEXT_OPTIONS options = D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT,
            DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL
        )
    {
        return DrawText(string, stringLength, textFormat, &layoutRect, defaultFillBrush, svgGlyphStyle, colorPaletteIndex, options, measuringMode);
    }*/
};

[
    odl,
    uuid(d7bdb159-5683-4a46-bc9c-72dc720b858b)
]
interface ID2D1Device4 : ID2D1Device3
{
    /// <summary>
    /// Creates a new device context with no initially assigned target.
    /// </summary>
    HRESULT CreateDeviceContext(
        [in] D2D1_DEVICE_CONTEXT_OPTIONS options,
        [out] ID2D1DeviceContext4** deviceContext4
        );

    //using ID2D1Device3::CreateDeviceContext;

    //using ID2D1Device2::CreateDeviceContext;

    //using ID2D1Device1::CreateDeviceContext;

    //using ID2D1Device::CreateDeviceContext;

    /// <summary>
    /// Sets the maximum capacity of the color glyph cache. This cache is used to store
    /// color bitmap glyphs and SVG glyphs, enabling faster performance if the same
    /// glyphs are needed again. If the application still references a glyph using
    /// GetColorBitmapGlyphImage or GetSvgGlyphImage after it has been evicted, this
    /// glyph does not count toward the cache capacity.
    /// </summary>
    void SetMaximumColorGlyphCacheMemory(
        [in] UINT64 maximumInBytes
        );

    /// <summary>
    /// Gets the maximum capacity of the color glyph cache.
    /// </summary>
    UINT64 GetMaximumColorGlyphCacheMemory(
        );
};

[
    odl,
    uuid(c4349994-838e-4b0f-8cab-44997d9eeacc)
]
interface ID2D1Factory5 : ID2D1Factory4
{
    HRESULT CreateDevice(
        [in] IDXGIDevice* dxgiDevice,
        [out] ID2D1Device4** d2dDevice4
        );
};

interface ID2D1EffectContext;
interface ID2D1TransformNode;

typedef enum D2D1_CHANGE_TYPE
{

    /// <summary>
    /// Nothing has changed.
    /// </summary>
    D2D1_CHANGE_TYPE_NONE = 0,

    /// <summary>
    /// The effect's properties have changed.
    /// </summary>
    D2D1_CHANGE_TYPE_PROPERTIES = 1,

    /// <summary>
    /// The internal context has changed and should be inspected.
    /// </summary>
    D2D1_CHANGE_TYPE_CONTEXT = 2,

    /// <summary>
    /// A new graph has been set due to a change in the input count.
    /// </summary>
    D2D1_CHANGE_TYPE_GRAPH = 3,
    D2D1_CHANGE_TYPE_FORCE_DWORD = 0xffffffff

} D2D1_CHANGE_TYPE;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_CHANGE_TYPE);


/// <summary>
/// Indicates options for drawing using a pixel shader.
/// </summary>
typedef enum D2D1_PIXEL_OPTIONS
{

    /// <summary>
    /// Default pixel processing.
    /// </summary>
    D2D1_PIXEL_OPTIONS_NONE = 0,

    /// <summary>
    /// Indicates that the shader samples its inputs only at exactly the same scene
    /// coordinate as the output pixel, and that it returns transparent black whenever
    /// the input pixels are also transparent black.
    /// </summary>
    D2D1_PIXEL_OPTIONS_TRIVIAL_SAMPLING = 1,
    D2D1_PIXEL_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_PIXEL_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_PIXEL_OPTIONS);


/// <summary>
/// Indicates options for drawing custom vertices set by transforms.
/// </summary>
typedef enum D2D1_VERTEX_OPTIONS
{

    /// <summary>
    /// Default vertex processing.
    /// </summary>
    D2D1_VERTEX_OPTIONS_NONE = 0,

    /// <summary>
    /// Indicates that the output rectangle does not need to be cleared before drawing
    /// custom vertices. This must only be used by transforms whose custom vertices
    /// completely cover their output rectangle.
    /// </summary>
    D2D1_VERTEX_OPTIONS_DO_NOT_CLEAR = 1,

    /// <summary>
    /// Causes a depth buffer to be used while drawing custom vertices. This impacts
    /// drawing behavior when primitives overlap one another.
    /// </summary>
    D2D1_VERTEX_OPTIONS_USE_DEPTH_BUFFER = 2,

    /// <summary>
    /// Indicates that custom vertices do not form primitives which overlap one another.
    /// </summary>
    D2D1_VERTEX_OPTIONS_ASSUME_NO_OVERLAP = 4,
    D2D1_VERTEX_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_VERTEX_OPTIONS;

//DEFINE_ENUM_FLAG_OPERATORS(D2D1_VERTEX_OPTIONS);


/// <summary>
/// Describes how a vertex buffer is to be managed.
/// </summary>
typedef enum D2D1_VERTEX_USAGE
{

    /// <summary>
    /// The vertex buffer content do not change frequently from frame to frame.
    /// </summary>
    D2D1_VERTEX_USAGE_STATIC = 0,

    /// <summary>
    /// The vertex buffer is intended to be updated frequently.
    /// </summary>
    D2D1_VERTEX_USAGE_DYNAMIC = 1,
    D2D1_VERTEX_USAGE_FORCE_DWORD = 0xffffffff

} D2D1_VERTEX_USAGE;


/// <summary>
/// Describes a particular blend in the D2D1_BLEND_DESCRIPTION structure.
/// </summary>
typedef enum D2D1_BLEND_OPERATION
{
    D2D1_BLEND_OPERATION_ADD = 1,
    D2D1_BLEND_OPERATION_SUBTRACT = 2,
    D2D1_BLEND_OPERATION_REV_SUBTRACT = 3,
    D2D1_BLEND_OPERATION_MIN = 4,
    D2D1_BLEND_OPERATION_MAX = 5,
    D2D1_BLEND_OPERATION_FORCE_DWORD = 0xffffffff

} D2D1_BLEND_OPERATION;


/// <summary>
/// Describes a particular blend in the D2D1_BLEND_DESCRIPTION structure.
/// </summary>
typedef enum D2D1_BLEND
{
    D2D1_BLEND_ZERO = 1,
    D2D1_BLEND_ONE = 2,
    D2D1_BLEND_SRC_COLOR = 3,
    D2D1_BLEND_INV_SRC_COLOR = 4,
    D2D1_BLEND_SRC_ALPHA = 5,
    D2D1_BLEND_INV_SRC_ALPHA = 6,
    D2D1_BLEND_DEST_ALPHA = 7,
    D2D1_BLEND_INV_DEST_ALPHA = 8,
    D2D1_BLEND_DEST_COLOR = 9,
    D2D1_BLEND_INV_DEST_COLOR = 10,
    D2D1_BLEND_SRC_ALPHA_SAT = 11,
    D2D1_BLEND_BLEND_FACTOR = 14,
    D2D1_BLEND_INV_BLEND_FACTOR = 15,
    D2D1_BLEND_FORCE_DWORD = 0xffffffff

} D2D1_BLEND;


/// <summary>
/// Allows a caller to control the channel depth of a stage in the rendering
/// pipeline.
/// </summary>
typedef enum D2D1_CHANNEL_DEPTH
{
    D2D1_CHANNEL_DEPTH_DEFAULT = 0,
    D2D1_CHANNEL_DEPTH_1 = 1,
    D2D1_CHANNEL_DEPTH_4 = 4,
    D2D1_CHANNEL_DEPTH_FORCE_DWORD = 0xffffffff

} D2D1_CHANNEL_DEPTH;


/// <summary>
/// Represents filtering modes transforms may select to use on their input textures.
/// </summary>
typedef enum D2D1_FILTER
{
    D2D1_FILTER_MIN_MAG_MIP_POINT = 0x00,
    D2D1_FILTER_MIN_MAG_POINT_MIP_LINEAR = 0x01,
    D2D1_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x04,
    D2D1_FILTER_MIN_POINT_MAG_MIP_LINEAR = 0x05,
    D2D1_FILTER_MIN_LINEAR_MAG_MIP_POINT = 0x10,
    D2D1_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
    D2D1_FILTER_MIN_MAG_LINEAR_MIP_POINT = 0x14,
    D2D1_FILTER_MIN_MAG_MIP_LINEAR = 0x15,
    D2D1_FILTER_ANISOTROPIC = 0x55,
    D2D1_FILTER_FORCE_DWORD = 0xffffffff

} D2D1_FILTER;


/// <summary>
/// Defines capabilities of the underlying D3D device which may be queried using
/// CheckFeatureSupport.
/// </summary>
typedef enum D2D1_FEATURE
{
    D2D1_FEATURE_DOUBLES = 0,
    D2D1_FEATURE_D3D10_X_HARDWARE_OPTIONS = 1,
    D2D1_FEATURE_FORCE_DWORD = 0xffffffff

} D2D1_FEATURE;




/// <summary>
/// This is used to define a resource texture when that resource texture is created.
/// </summary>
typedef struct D2D1_RESOURCE_TEXTURE_PROPERTIES
{
    LongPtr extents;
    UINT32 dimensions;
    D2D1_BUFFER_PRECISION bufferPrecision;
    D2D1_CHANNEL_DEPTH channelDepth;
    D2D1_FILTER filter;
    LongPtr extendModes;

} D2D1_RESOURCE_TEXTURE_PROPERTIES;


/// <summary>
/// This defines a single element of the vertex layout.
/// </summary>
typedef struct D2D1_INPUT_ELEMENT_DESC
{
    LongPtr semanticName;
    UINT32 semanticIndex;
    DXGI_FORMAT format;
    UINT32 inputSlot;
    UINT32 alignedByteOffset;

} D2D1_INPUT_ELEMENT_DESC;


/// <summary>
/// This defines the properties of a vertex buffer which uses the default vertex
/// layout.
/// </summary>
typedef struct D2D1_VERTEX_BUFFER_PROPERTIES
{
    UINT32 inputCount;
    D2D1_VERTEX_USAGE usage;
    LongPtr data;
    UINT32 byteWidth;

} D2D1_VERTEX_BUFFER_PROPERTIES;


/// <summary>
/// This defines the input layout of vertices and the vertex shader which processes
/// them.
/// </summary>
typedef struct D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES
{
    LongPtr shaderBufferWithInputSignature;
    UINT32 shaderBufferSize;
    LongPtr inputElements;
    UINT32 elementCount;
    UINT32 stride;

} D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES;


/// <summary>
/// This defines the range of vertices from a vertex buffer to draw.
/// </summary>
typedef struct D2D1_VERTEX_RANGE
{
    UINT32 startVertex;
    UINT32 vertexCount;

} D2D1_VERTEX_RANGE;


/// <summary>
/// Blend description which configures a blend transform object.
/// </summary>
typedef struct D2D1_BLEND_DESCRIPTION
{
    D2D1_BLEND sourceBlend;
    D2D1_BLEND destinationBlend;
    D2D1_BLEND_OPERATION blendOperation;
    D2D1_BLEND sourceBlendAlpha;
    D2D1_BLEND destinationBlendAlpha;
    D2D1_BLEND_OPERATION blendOperationAlpha;
    FLOAT blendFactor[4];

} D2D1_BLEND_DESCRIPTION;


/// <summary>
/// Describes options transforms may select to use on their input textures.
/// </summary>
typedef struct D2D1_INPUT_DESCRIPTION
{
    D2D1_FILTER filter;
    UINT32 levelOfDetailCount;

} D2D1_INPUT_DESCRIPTION;


/// <summary>
/// Indicates whether shader support for doubles is present on the underlying
/// hardware.  This may be populated using CheckFeatureSupport.
/// </summary>
typedef struct D2D1_FEATURE_DATA_DOUBLES
{
    BOOL doublePrecisionFloatShaderOps;

} D2D1_FEATURE_DATA_DOUBLES;


/// <summary>
/// Indicates support for features which are optional on D3D10 feature levels.  This
/// may be populated using CheckFeatureSupport.
/// </summary>
typedef struct D2D1_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS
{
    BOOL computeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x;

} D2D1_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS;


[
    odl,
    uuid(9b8b1336-00a5-4668-92b7-ced5d8bf9b7b)
]
interface ID2D1VertexBuffer : stdole.IUnknown
{
    HRESULT Map(
        [out] BYTE** data,
        [in] UINT32 bufferSize
        );

    HRESULT Unmap(
        );
};

[
    odl,
    uuid(688d15c3-02b0-438d-b13a-d1b44c32c39a)
]
interface ID2D1ResourceTexture : stdole.IUnknown
{
    /// <summary>
    /// Update the vertex text.
    /// </summary>
    HRESULT Update(
        [in] UINT32* minimumExtents,
        [in] UINT32* maximimumExtents,
        [in] UINT32* strides,
        [in] UINT32 dimensions,
        [in] BYTE* data,
        [in] UINT32 dataCount
        );
};

[
    odl,
    uuid(519ae1bd-d19a-420d-b849-364f594776b7)
]
interface ID2D1RenderInfo : stdole.IUnknown
{
    /// <summary>
    /// Sets options for sampling the specified image input
    /// </summary>
    HRESULT SetInputDescription(
        [in] UINT32 inputIndex,
        /*[in] D2D1_INPUT_DESCRIPTION inputDescription*/[in] CURRENCY inputDescriptor
        );

    /// <summary>
    /// Controls the output precision and channel-depth for the associated transform.
    /// </summary>
    HRESULT SetOutputBuffer(
        [in] D2D1_BUFFER_PRECISION bufferPrecision,
        [in] D2D1_CHANNEL_DEPTH channelDepth
        );

    /// <summary>
    /// Controls whether the output of the associated transform is cached.
    /// </summary>
    void SetCached(
        [in] BOOL isCached
        );

    /// <summary>
    /// Provides a hint of the approximate shader instruction count per pixel.  If
    /// provided, it may improve performance when processing large images.  Instructions
    /// should be counted multiple times if occurring within loops.
    /// </summary>
    void SetInstructionCountHint(
        [in] UINT32 instructionCount
        );
};

[
    odl,
    uuid(693ce632-7f2f-45de-93fe-18d88b37aa21)
]
interface ID2D1DrawInfo : ID2D1RenderInfo
{
    /// <summary>
    /// Set the constant buffer for this transform's pixel shader.
    /// </summary>
    HRESULT SetPixelShaderConstantBuffer(
        [in] BYTE* buffer,
        [in] UINT32 bufferCount
        );

    /// <summary>
    /// Sets the resource texture corresponding to the given shader texture index.
    /// </summary>
    HRESULT SetResourceTexture(
        [in] UINT32 textureIndex,
        [in] ID2D1ResourceTexture* resourceTexture
        );

    /// <summary>
    /// Set the constant buffer for this transform's vertex shader.
    /// </summary>
    HRESULT SetVertexShaderConstantBuffer(
        [in] BYTE* buffer,
        [in] UINT32 bufferCount
        );

    /// <summary>
    /// Set the shader instructions for this transform.
    /// </summary>
    HRESULT SetPixelShader(
        [in] REFGUID shaderId,
        [in] D2D1_PIXEL_OPTIONS pixelOptions // = D2D1_PIXEL_OPTIONS_NONE
        );

    /// <summary>
    /// Set custom vertices for the associated transform.  A blend mode if
    /// foreground-over will be used if blendDescription is NULL.
    /// </summary>
    HRESULT SetVertexProcessing(
        [in] ID2D1VertexBuffer* vertexBuffer,
        [in] D2D1_VERTEX_OPTIONS vertexOptions,
        [in] D2D1_BLEND_DESCRIPTION* blendDescription,
        [in] D2D1_VERTEX_RANGE* vertexRange,
        [in] GUID* vertexShader // = NULL
        );
};

[
    odl,
    uuid(5598b14b-9fd7-48b7-9bdb-8f0964eb38bc)
]
interface ID2D1ComputeInfo : ID2D1RenderInfo
{
    /// <summary>
    /// Set the constant buffer for this transform.
    /// </summary>
    HRESULT SetComputeShaderConstantBuffer(
        [in] BYTE* buffer,
        [in] UINT32 bufferCount
        );

    /// <summary>
    /// Set the shader instructions for this transform.
    /// </summary>
    HRESULT SetComputeShader(
        [in] REFGUID shaderId
        );

    /// <summary>
    /// Sets the resource texture corresponding to the given shader texture index.
    /// </summary>
    HRESULT SetResourceTexture(
        [in] UINT32 textureIndex,
        [in] ID2D1ResourceTexture* resourceTexture
        );
};

[
    odl,
    uuid(b2efe1e7-729f-4102-949f-505fa21bf666)
]
interface ID2D1TransformNode : stdole.IUnknown
{
    /// <summary>
    /// Return the number of input this node has.
    /// </summary>
    UINT32 GetInputCount(
        );
};

[
    odl,
    uuid(13d29038-c3e6-4034-9081-13b53a417992)
]
interface ID2D1TransformGraph : stdole.IUnknown
{
    /// <summary>
    /// Return the number of input this graph has.
    /// </summary>
    UINT32 GetInputCount(
        );

    /// <summary>
    /// Sets the graph to contain a single transform whose inputs map 1:1 with effect
    /// inputs.
    /// </summary>
    HRESULT SetSingleTransformNode(
        [in] ID2D1TransformNode* node
        );

    /// <summary>
    /// Adds the given transform node to the graph.
    /// </summary>
    HRESULT AddNode(
        [in] ID2D1TransformNode* node
        );

    /// <summary>
    /// Removes the given transform node from the graph.
    /// </summary>
    HRESULT RemoveNode(
        [in] ID2D1TransformNode* node
        );

    /// <summary>
    /// Indicates that the given transform node should be considered to be the output
    /// node of the graph.
    /// </summary>
    HRESULT SetOutputNode(
        [in] ID2D1TransformNode* node
        );

    /// <summary>
    /// Connects one node to another node inside the graph.
    /// </summary>
    HRESULT ConnectNode(
        [in] ID2D1TransformNode* fromNode,
        [in] ID2D1TransformNode* toNode,
        [in] UINT32 toNodeInputIndex
        );

    /// <summary>
    /// Connects a transform node inside the graph to the corresponding input of the
    /// encapsulating effect.
    /// </summary>
    HRESULT ConnectToEffectInput(
        [in] UINT32 toEffectInputIndex,
        [in] ID2D1TransformNode* node,
        [in] UINT32 toNodeInputIndex
        );

    /// <summary>
    /// Clears all nodes and connections from the transform graph.
    /// </summary>
    void Clear(
        );

    /// <summary>
    /// Uses the specified input as the effect output.
    /// </summary>
    HRESULT SetPassthroughGraph(
        [in] UINT32 effectInputIndex
        );
};

[
    odl,
    uuid(ef1a287d-342a-4f76-8fdb-da0d6ea9f92b)
]
interface ID2D1Transform : ID2D1TransformNode
{
    HRESULT MapOutputRectToInputRects(
        [in] D2D1_RECT_L* outputRect,
        [out] D2D1_RECT_L* inputRects,
        [in] UINT32 inputRectsCount
        );

    HRESULT MapInputRectsToOutputRect(
        [in] D2D1_RECT_L* inputRects,
        [in] D2D1_RECT_L* inputOpaqueSubRects,
        [in] UINT32 inputRectCount,
        [out] D2D1_RECT_L* outputRect,
        [out] D2D1_RECT_L* outputOpaqueSubRect
        );

    HRESULT MapInvalidRect(
        [in] UINT32 inputIndex,
        /*[in] D2D1_RECT_L invalidInputRect,*/[in] long invalidInputRectLeft, [in] long invalidInputRectTop, [in] long invalidInputRectRight, [in] long invalidInputRectBottom,
        [out] D2D1_RECT_L* invalidOutputRect
        );
};

[
    odl,
    uuid(36bfdcb6-9739-435d-a30d-a653beff6a6f)
]
interface ID2D1DrawTransform : ID2D1Transform
{
    HRESULT SetDrawInfo(
        [in] ID2D1DrawInfo* drawInfo
        );
};

[
    odl,
    uuid(0d85573c-01e3-4f7d-bfd9-0d60608bf3c3)
]
interface ID2D1ComputeTransform : ID2D1Transform
{
    HRESULT SetComputeInfo(
        [in] ID2D1ComputeInfo* computeInfo
        );

    HRESULT CalculateThreadgroups(
        [in] D2D1_RECT_L* outputRect,
        [out] UINT32* dimensionX,
        [out] UINT32* dimensionY,
        [out] UINT32* dimensionZ
        );
};

[
    odl,
    uuid(0359dc30-95e6-4568-9055-27720d130e93)
]
interface ID2D1AnalysisTransform : stdole.IUnknown
{
    HRESULT ProcessAnalysisResults(
        [in] BYTE* analysisData,
        [in] UINT32 analysisDataCount
        );
};

[
    odl,
    uuid(db1800dd-0c34-4cf9-be90-31cc0a5653e1)
]
interface ID2D1SourceTransform : ID2D1Transform
{
    HRESULT SetRenderInfo(
        [in] ID2D1RenderInfo* renderInfo
        );

    HRESULT Draw(
        [in] ID2D1Bitmap1* target,
        [in] D2D1_RECT_L* drawRect,
        /*[in] D2D1_POINT_2U targetOrigin*/[in] CURRENCY targetOrigin
        );
};

[
    odl,
    uuid(1a799d8a-69f7-4e4c-9fed-437ccc6684cc)
]
interface ID2D1ConcreteTransform : ID2D1TransformNode
{
    /// <summary>
    /// Controls the output precision and channel-depth for this transform.
    /// </summary>
    HRESULT SetOutputBuffer(
        [in] D2D1_BUFFER_PRECISION bufferPrecision,
        [in] D2D1_CHANNEL_DEPTH channelDepth
        );

    /// <summary>
    /// Controls whether the output of this transform is cached.
    /// </summary>
    void SetCached(
        [in] BOOL isCached
        );
};

[
    odl,
    uuid(63ac0b32-ba44-450f-8806-7f4ca1ff2f1b)
]
interface ID2D1BlendTransform : ID2D1ConcreteTransform
{
    void SetDescription(
        [in] D2D1_BLEND_DESCRIPTION* description
        );

    void GetDescription(
        [out] D2D1_BLEND_DESCRIPTION* description
        );
};

[
    odl,
    uuid(4998735c-3a19-473c-9781-656847e3a347)
]
interface ID2D1BorderTransform : ID2D1ConcreteTransform
{
    void SetExtendModeX(
        [in] D2D1_EXTEND_MODE extendMode
        );

    void SetExtendModeY(
        [in] D2D1_EXTEND_MODE extendMode
        );

    D2D1_EXTEND_MODE GetExtendModeX(
        );

    D2D1_EXTEND_MODE GetExtendModeY(
        );
};

[
    odl,
    uuid(3fe6adea-7643-4f53-bd14-a0ce63f24042)
]
interface ID2D1OffsetTransform : ID2D1TransformNode
{
    void SetOffset(
        /*[in] D2D1_POINT_2L offset*/[in] CURRENCY offset
        );

    D2D1_POINT_2L GetOffset(
        );
};

[
    odl,
    uuid(90f732e2-5092-4606-a819-8651970baccd)
]
interface ID2D1BoundsAdjustmentTransform : ID2D1TransformNode
{
    void SetOutputBounds(
        [in] D2D1_RECT_L* outputBounds
        );

    void GetOutputBounds(
        [out] D2D1_RECT_L* outputBounds
        );
};

[
    odl,
    uuid(a248fd3f-3e6c-4e63-9f03-7f68ecc91db9)
]
interface ID2D1EffectImpl : stdole.IUnknown
{
    /// <summary>
    /// Initialize the effect with a context and a transform graph. The effect must
    /// populate the transform graph with a topology and can update it later.
    /// </summary>
    HRESULT Initialize(
        [in] ID2D1EffectContext* effectContext,
        [in] ID2D1TransformGraph* transformGraph
        );

    /// <summary>
    /// Initialize the effect with a context and a transform graph. The effect must
    /// populate the transform graph with a topology and can update it later.
    /// </summary>
    HRESULT PrepareForRender(
        [in] D2D1_CHANGE_TYPE changeType
        );

    /// <summary>
    /// Sets a new transform graph to the effect.  This happens when the number of
    /// inputs to the effect changes, if the effect support a variable number of inputs.
    /// </summary>
    HRESULT SetGraph(
        [in] ID2D1TransformGraph* transformGraph
        );
};

typedef enum D3D_FEATURE_LEVEL
{
    D3D_FEATURE_LEVEL_9_1 = 0x9100,
    D3D_FEATURE_LEVEL_9_2 = 0x9200,
    D3D_FEATURE_LEVEL_9_3 = 0x9300,
    D3D_FEATURE_LEVEL_10_0 = 0xa000,
    D3D_FEATURE_LEVEL_10_1 = 0xa100,
    D3D_FEATURE_LEVEL_11_0 = 0xb000,
    D3D_FEATURE_LEVEL_11_1 = 0xb100,
    D3D_FEATURE_LEVEL_12_0 = 0xc000,
    D3D_FEATURE_LEVEL_12_1 = 0xc100
} D3D_FEATURE_LEVEL;

[
    odl,
    uuid(3d9f916b-27dc-4ad7-b4f1-64945340f563)
]
interface ID2D1EffectContext : stdole.IUnknown
{
        void GetDpi(
            [out] FLOAT* dpiX,
            [out] FLOAT* dpiY
            );

    /// <summary>
    /// Create a new effect, the effect must either be built in or previously registered
    /// through ID2D1Factory1::RegisterEffect.
    /// </summary>
    HRESULT CreateEffect(
        [in] REFCLSID effectId,
        [out] ID2D1Effect** effect
        );

    HRESULT GetMaximumSupportedFeatureLevel(
        [in] D3D_FEATURE_LEVEL* featureLevels,
        [in] UINT32 featureLevelsCount,
        [out] D3D_FEATURE_LEVEL* maximumSupportedFeatureLevel
        );

    /// <summary>
    /// Create a transform node from the passed in effect.
    /// </summary>
    HRESULT CreateTransformNodeFromEffect(
        [in] ID2D1Effect* effect,
        [out] ID2D1TransformNode** transformNode
        );

    HRESULT CreateBlendTransform(
        [in] UINT32 numInputs,
        [in] D2D1_BLEND_DESCRIPTION* blendDescription,
        [out] ID2D1BlendTransform** transform
        );

    HRESULT CreateBorderTransform(
        [in] D2D1_EXTEND_MODE extendModeX,
        [in] D2D1_EXTEND_MODE extendModeY,
        [out] ID2D1BorderTransform** transform
        );

    HRESULT CreateOffsetTransform(
        /*[in] D2D1_POINT_2L offset,*/[in] CURRENCY offset,
        [out] ID2D1OffsetTransform** transform
        );

    HRESULT CreateBoundsAdjustmentTransform(
        [in] D2D1_RECT_L* outputRectangle,
        [out] ID2D1BoundsAdjustmentTransform** transform
        );

    HRESULT LoadPixelShader(
        [in] REFGUID shaderId,
        [in] BYTE* shaderBuffer,
        [in] UINT32 shaderBufferCount
        );

    HRESULT LoadVertexShader(
        [in] REFGUID resourceId,
        [in] BYTE* shaderBuffer,
        [in] UINT32 shaderBufferCount
        );

    HRESULT LoadComputeShader(
        [in] REFGUID resourceId,
        [in] BYTE* shaderBuffer,
        [in] UINT32 shaderBufferCount
        );

    BOOL IsShaderLoaded(
        [in] REFGUID shaderId
        );

    HRESULT CreateResourceTexture(
        [in] GUID* resourceId,
        [in] D2D1_RESOURCE_TEXTURE_PROPERTIES* resourceTextureProperties,
        [in] BYTE* data,
        [in] UINT32* strides,
        [in] UINT32 dataSize,
        [out] ID2D1ResourceTexture** resourceTexture
        );

    HRESULT FindResourceTexture(
        [in] GUID* resourceId,
        [out] ID2D1ResourceTexture** resourceTexture
        );

    HRESULT CreateVertexBuffer(
        [in] D2D1_VERTEX_BUFFER_PROPERTIES* vertexBufferProperties,
        [in] GUID* resourceId,
        [in] D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES* customVertexBufferProperties,
        [out] ID2D1VertexBuffer** buffer
        );

    HRESULT FindVertexBuffer(
        [in] GUID* resourceId,
        [out] ID2D1VertexBuffer** buffer
        );

    /// <summary>
    /// Creates a color context from a color space.  If the space is Custom, the context
    /// is initialized from the profile/profileSize arguments.  Otherwise the context is
    /// initialized with the profile bytes associated with the space and
    /// profile/profileSize are ignored.
    /// </summary>
    HRESULT CreateColorContext(
        [in] D2D1_COLOR_SPACE space,
        [in] BYTE* profile,
        [in] UINT32 profileSize,
        [out] ID2D1ColorContext** colorContext
        );

    HRESULT CreateColorContextFromFilename(
        [in] LongPtr filename,
        [out] ID2D1ColorContext** colorContext
        );

    HRESULT CreateColorContextFromWicColorContext(
        [in] IWICColorContext* wicColorContext,
        [out] ID2D1ColorContext** colorContext
        );

    HRESULT CheckFeatureSupport(
        [in] D2D1_FEATURE feature,
        [out] void* featureSupportData,
        [in] UINT32 featureSupportDataSize
        );

    /// <summary>
    /// Indicates whether the buffer precision is supported by D2D.
    /// </summary>
    BOOL IsBufferPrecisionSupported(
        [in] D2D1_BUFFER_PRECISION bufferPrecision
        );
};



/// <summary>
/// Specifies how the Crop effect handles the crop rectangle falling on fractional
/// pixel coordinates.
/// </summary>
typedef enum D2D1_BORDER_MODE
{
    D2D1_BORDER_MODE_SOFT = 0,
    D2D1_BORDER_MODE_HARD = 1,
    D2D1_BORDER_MODE_FORCE_DWORD = 0xffffffff

} D2D1_BORDER_MODE;


/// <summary>
/// Specifies the color channel the Displacement map effect extracts the intensity
/// from and uses it to spatially displace the image in the X or Y direction.
/// </summary>
typedef enum D2D1_CHANNEL_SELECTOR
{
    D2D1_CHANNEL_SELECTOR_R = 0,
    D2D1_CHANNEL_SELECTOR_G = 1,
    D2D1_CHANNEL_SELECTOR_B = 2,
    D2D1_CHANNEL_SELECTOR_A = 3,
    D2D1_CHANNEL_SELECTOR_FORCE_DWORD = 0xffffffff

} D2D1_CHANNEL_SELECTOR;


/// <summary>
/// Speficies whether a flip and/or rotation operation should be performed by the
/// Bitmap source effect
/// </summary>
typedef enum D2D1_BITMAPSOURCE_ORIENTATION
{
    D2D1_BITMAPSOURCE_ORIENTATION_DEFAULT = 1,
    D2D1_BITMAPSOURCE_ORIENTATION_FLIP_HORIZONTAL = 2,
    D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE180 = 3,
    D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE180_FLIP_HORIZONTAL = 4,
    D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE270_FLIP_HORIZONTAL = 5,
    D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE90 = 6,
    D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE90_FLIP_HORIZONTAL = 7,
    D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE270 = 8,
    D2D1_BITMAPSOURCE_ORIENTATION_FORCE_DWORD = 0xffffffff

} D2D1_BITMAPSOURCE_ORIENTATION;


/// <summary>
/// The enumeration of the Gaussian Blur effect's top level properties.
/// </summary>
typedef enum D2D1_GAUSSIANBLUR_PROP
{

    /// <summary>
    /// Property Name: "StandardDeviation"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAUSSIANBLUR_PROP_STANDARD_DEVIATION = 0,

    /// <summary>
    /// Property Name: "Optimization"
    /// Property Type: D2D1_GAUSSIANBLUR_OPTIMIZATION
    /// </summary>
    D2D1_GAUSSIANBLUR_PROP_OPTIMIZATION = 1,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_GAUSSIANBLUR_PROP_BORDER_MODE = 2,
    D2D1_GAUSSIANBLUR_PROP_FORCE_DWORD = 0xffffffff

} D2D1_GAUSSIANBLUR_PROP;

typedef enum D2D1_GAUSSIANBLUR_OPTIMIZATION
{
    D2D1_GAUSSIANBLUR_OPTIMIZATION_SPEED = 0,
    D2D1_GAUSSIANBLUR_OPTIMIZATION_BALANCED = 1,
    D2D1_GAUSSIANBLUR_OPTIMIZATION_QUALITY = 2,
    D2D1_GAUSSIANBLUR_OPTIMIZATION_FORCE_DWORD = 0xffffffff

} D2D1_GAUSSIANBLUR_OPTIMIZATION;


/// <summary>
/// The enumeration of the Directional Blur effect's top level properties.
/// </summary>
typedef enum D2D1_DIRECTIONALBLUR_PROP
{

    /// <summary>
    /// Property Name: "StandardDeviation"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DIRECTIONALBLUR_PROP_STANDARD_DEVIATION = 0,

    /// <summary>
    /// Property Name: "Angle"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DIRECTIONALBLUR_PROP_ANGLE = 1,

    /// <summary>
    /// Property Name: "Optimization"
    /// Property Type: D2D1_DIRECTIONALBLUR_OPTIMIZATION
    /// </summary>
    D2D1_DIRECTIONALBLUR_PROP_OPTIMIZATION = 2,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_DIRECTIONALBLUR_PROP_BORDER_MODE = 3,
    D2D1_DIRECTIONALBLUR_PROP_FORCE_DWORD = 0xffffffff

} D2D1_DIRECTIONALBLUR_PROP;

typedef enum D2D1_DIRECTIONALBLUR_OPTIMIZATION
{
    D2D1_DIRECTIONALBLUR_OPTIMIZATION_SPEED = 0,
    D2D1_DIRECTIONALBLUR_OPTIMIZATION_BALANCED = 1,
    D2D1_DIRECTIONALBLUR_OPTIMIZATION_QUALITY = 2,
    D2D1_DIRECTIONALBLUR_OPTIMIZATION_FORCE_DWORD = 0xffffffff

} D2D1_DIRECTIONALBLUR_OPTIMIZATION;


/// <summary>
/// The enumeration of the Shadow effect's top level properties.
/// </summary>
typedef enum D2D1_SHADOW_PROP
{

    /// <summary>
    /// Property Name: "BlurStandardDeviation"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SHADOW_PROP_BLUR_STANDARD_DEVIATION = 0,

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_SHADOW_PROP_COLOR = 1,

    /// <summary>
    /// Property Name: "Optimization"
    /// Property Type: D2D1_SHADOW_OPTIMIZATION
    /// </summary>
    D2D1_SHADOW_PROP_OPTIMIZATION = 2,
    D2D1_SHADOW_PROP_FORCE_DWORD = 0xffffffff

} D2D1_SHADOW_PROP;

typedef enum D2D1_SHADOW_OPTIMIZATION
{
    D2D1_SHADOW_OPTIMIZATION_SPEED = 0,
    D2D1_SHADOW_OPTIMIZATION_BALANCED = 1,
    D2D1_SHADOW_OPTIMIZATION_QUALITY = 2,
    D2D1_SHADOW_OPTIMIZATION_FORCE_DWORD = 0xffffffff

} D2D1_SHADOW_OPTIMIZATION;


/// <summary>
/// The enumeration of the Blend effect's top level properties.
/// </summary>
typedef enum D2D1_BLEND_PROP
{

    /// <summary>
    /// Property Name: "Mode"
    /// Property Type: D2D1_BLEND_MODE
    /// </summary>
    D2D1_BLEND_PROP_MODE = 0,
    D2D1_BLEND_PROP_FORCE_DWORD = 0xffffffff

} D2D1_BLEND_PROP;

typedef enum D2D1_BLEND_MODE
{
    D2D1_BLEND_MODE_MULTIPLY = 0,
    D2D1_BLEND_MODE_SCREEN = 1,
    D2D1_BLEND_MODE_DARKEN = 2,
    D2D1_BLEND_MODE_LIGHTEN = 3,
    D2D1_BLEND_MODE_DISSOLVE = 4,
    D2D1_BLEND_MODE_COLOR_BURN = 5,
    D2D1_BLEND_MODE_LINEAR_BURN = 6,
    D2D1_BLEND_MODE_DARKER_COLOR = 7,
    D2D1_BLEND_MODE_LIGHTER_COLOR = 8,
    D2D1_BLEND_MODE_COLOR_DODGE = 9,
    D2D1_BLEND_MODE_LINEAR_DODGE = 10,
    D2D1_BLEND_MODE_OVERLAY = 11,
    D2D1_BLEND_MODE_SOFT_LIGHT = 12,
    D2D1_BLEND_MODE_HARD_LIGHT = 13,
    D2D1_BLEND_MODE_VIVID_LIGHT = 14,
    D2D1_BLEND_MODE_LINEAR_LIGHT = 15,
    D2D1_BLEND_MODE_PIN_LIGHT = 16,
    D2D1_BLEND_MODE_HARD_MIX = 17,
    D2D1_BLEND_MODE_DIFFERENCE = 18,
    D2D1_BLEND_MODE_EXCLUSION = 19,
    D2D1_BLEND_MODE_HUE = 20,
    D2D1_BLEND_MODE_SATURATION = 21,
    D2D1_BLEND_MODE_COLOR = 22,
    D2D1_BLEND_MODE_LUMINOSITY = 23,
    D2D1_BLEND_MODE_SUBTRACT = 24,
    D2D1_BLEND_MODE_DIVISION = 25,
    D2D1_BLEND_MODE_FORCE_DWORD = 0xffffffff

} D2D1_BLEND_MODE;


/// <summary>
/// The enumeration of the Saturation effect's top level properties.
/// </summary>
typedef enum D2D1_SATURATION_PROP
{

    /// <summary>
    /// Property Name: "Saturation"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SATURATION_PROP_SATURATION = 0,
    D2D1_SATURATION_PROP_FORCE_DWORD = 0xffffffff

} D2D1_SATURATION_PROP;


/// <summary>
/// The enumeration of the Hue Rotation effect's top level properties.
/// </summary>
typedef enum D2D1_HUEROTATION_PROP
{

    /// <summary>
    /// Property Name: "Angle"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_HUEROTATION_PROP_ANGLE = 0,
    D2D1_HUEROTATION_PROP_FORCE_DWORD = 0xffffffff

} D2D1_HUEROTATION_PROP;


/// <summary>
/// The enumeration of the Color Matrix effect's top level properties.
/// </summary>
typedef enum D2D1_COLORMATRIX_PROP
{

    /// <summary>
    /// Property Name: "ColorMatrix"
    /// Property Type: D2D1_MATRIX_5X4_F
    /// </summary>
    D2D1_COLORMATRIX_PROP_COLOR_MATRIX = 0,

    /// <summary>
    /// Property Name: "AlphaMode"
    /// Property Type: D2D1_COLORMATRIX_ALPHA_MODE
    /// </summary>
    D2D1_COLORMATRIX_PROP_ALPHA_MODE = 1,

    /// <summary>
    /// Property Name: "ClampOutput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_COLORMATRIX_PROP_CLAMP_OUTPUT = 2,
    D2D1_COLORMATRIX_PROP_FORCE_DWORD = 0xffffffff

} D2D1_COLORMATRIX_PROP;

typedef enum D2D1_COLORMATRIX_ALPHA_MODE
{
    D2D1_COLORMATRIX_ALPHA_MODE_PREMULTIPLIED = 1,
    D2D1_COLORMATRIX_ALPHA_MODE_STRAIGHT = 2,
    D2D1_COLORMATRIX_ALPHA_MODE_FORCE_DWORD = 0xffffffff

} D2D1_COLORMATRIX_ALPHA_MODE;


/// <summary>
/// The enumeration of the Bitmap Source effect's top level properties.
/// </summary>
typedef enum D2D1_BITMAPSOURCE_PROP
{

    /// <summary>
    /// Property Name: "WicBitmapSource"
    /// Property Type: IUnknown *
    /// </summary>
    D2D1_BITMAPSOURCE_PROP_WIC_BITMAP_SOURCE = 0,

    /// <summary>
    /// Property Name: "Scale"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_BITMAPSOURCE_PROP_SCALE = 1,

    /// <summary>
    /// Property Name: "InterpolationMode"
    /// Property Type: D2D1_BITMAPSOURCE_INTERPOLATION_MODE
    /// </summary>
    D2D1_BITMAPSOURCE_PROP_INTERPOLATION_MODE = 2,

    /// <summary>
    /// Property Name: "EnableDPICorrection"
    /// Property Type: BOOL
    /// </summary>
    D2D1_BITMAPSOURCE_PROP_ENABLE_DPI_CORRECTION = 3,

    /// <summary>
    /// Property Name: "AlphaMode"
    /// Property Type: D2D1_BITMAPSOURCE_ALPHA_MODE
    /// </summary>
    D2D1_BITMAPSOURCE_PROP_ALPHA_MODE = 4,

    /// <summary>
    /// Property Name: "Orientation"
    /// Property Type: D2D1_BITMAPSOURCE_ORIENTATION
    /// </summary>
    D2D1_BITMAPSOURCE_PROP_ORIENTATION = 5,
    D2D1_BITMAPSOURCE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_BITMAPSOURCE_PROP;

typedef enum D2D1_BITMAPSOURCE_INTERPOLATION_MODE
{
    D2D1_BITMAPSOURCE_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_BITMAPSOURCE_INTERPOLATION_MODE_LINEAR = 1,
    D2D1_BITMAPSOURCE_INTERPOLATION_MODE_CUBIC = 2,
    D2D1_BITMAPSOURCE_INTERPOLATION_MODE_FANT = 6,
    D2D1_BITMAPSOURCE_INTERPOLATION_MODE_MIPMAP_LINEAR = 7,
    D2D1_BITMAPSOURCE_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_BITMAPSOURCE_INTERPOLATION_MODE;

typedef enum D2D1_BITMAPSOURCE_ALPHA_MODE
{
    D2D1_BITMAPSOURCE_ALPHA_MODE_PREMULTIPLIED = 1,
    D2D1_BITMAPSOURCE_ALPHA_MODE_STRAIGHT = 2,
    D2D1_BITMAPSOURCE_ALPHA_MODE_FORCE_DWORD = 0xffffffff

} D2D1_BITMAPSOURCE_ALPHA_MODE;


/// <summary>
/// The enumeration of the Composite effect's top level properties.
/// </summary>
typedef enum D2D1_COMPOSITE_PROP
{

    /// <summary>
    /// Property Name: "Mode"
    /// Property Type: D2D1_COMPOSITE_MODE
    /// </summary>
    D2D1_COMPOSITE_PROP_MODE = 0,
    D2D1_COMPOSITE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_COMPOSITE_PROP;


/// <summary>
/// The enumeration of the 3D Transform effect's top level properties.
/// </summary>
typedef enum D2D1_3DTRANSFORM_PROP
{

    /// <summary>
    /// Property Name: "InterpolationMode"
    /// Property Type: D2D1_3DTRANSFORM_INTERPOLATION_MODE
    /// </summary>
    D2D1_3DTRANSFORM_PROP_INTERPOLATION_MODE = 0,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_3DTRANSFORM_PROP_BORDER_MODE = 1,

    /// <summary>
    /// Property Name: "TransformMatrix"
    /// Property Type: D2D1_MATRIX_4X4_F
    /// </summary>
    D2D1_3DTRANSFORM_PROP_TRANSFORM_MATRIX = 2,
    D2D1_3DTRANSFORM_PROP_FORCE_DWORD = 0xffffffff

} D2D1_3DTRANSFORM_PROP;

typedef enum D2D1_3DTRANSFORM_INTERPOLATION_MODE
{
    D2D1_3DTRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_3DTRANSFORM_INTERPOLATION_MODE_LINEAR = 1,
    D2D1_3DTRANSFORM_INTERPOLATION_MODE_CUBIC = 2,
    D2D1_3DTRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_3DTRANSFORM_INTERPOLATION_MODE_ANISOTROPIC = 4,
    D2D1_3DTRANSFORM_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_3DTRANSFORM_INTERPOLATION_MODE;


/// <summary>
/// The enumeration of the 3D Perspective Transform effect's top level properties.
/// </summary>
typedef enum D2D1_3DPERSPECTIVETRANSFORM_PROP
{

    /// <summary>
    /// Property Name: "InterpolationMode"
    /// Property Type: D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE
    /// </summary>
    D2D1_3DPERSPECTIVETRANSFORM_PROP_INTERPOLATION_MODE = 0,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_3DPERSPECTIVETRANSFORM_PROP_BORDER_MODE = 1,

    /// <summary>
    /// Property Name: "Depth"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_3DPERSPECTIVETRANSFORM_PROP_DEPTH = 2,

    /// <summary>
    /// Property Name: "PerspectiveOrigin"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_3DPERSPECTIVETRANSFORM_PROP_PERSPECTIVE_ORIGIN = 3,

    /// <summary>
    /// Property Name: "LocalOffset"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_3DPERSPECTIVETRANSFORM_PROP_LOCAL_OFFSET = 4,

    /// <summary>
    /// Property Name: "GlobalOffset"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_3DPERSPECTIVETRANSFORM_PROP_GLOBAL_OFFSET = 5,

    /// <summary>
    /// Property Name: "RotationOrigin"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_3DPERSPECTIVETRANSFORM_PROP_ROTATION_ORIGIN = 6,

    /// <summary>
    /// Property Name: "Rotation"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_3DPERSPECTIVETRANSFORM_PROP_ROTATION = 7,
    D2D1_3DPERSPECTIVETRANSFORM_PROP_FORCE_DWORD = 0xffffffff

} D2D1_3DPERSPECTIVETRANSFORM_PROP;

typedef enum D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE
{
    D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_LINEAR = 1,
    D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_CUBIC = 2,
    D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_ANISOTROPIC = 4,
    D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE;


/// <summary>
/// The enumeration of the 2D Affine Transform effect's top level properties.
/// </summary>
typedef enum D2D1_2DAFFINETRANSFORM_PROP
{

    /// <summary>
    /// Property Name: "InterpolationMode"
    /// Property Type: D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE
    /// </summary>
    D2D1_2DAFFINETRANSFORM_PROP_INTERPOLATION_MODE = 0,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_2DAFFINETRANSFORM_PROP_BORDER_MODE = 1,

    /// <summary>
    /// Property Name: "TransformMatrix"
    /// Property Type: D2D1_MATRIX_3X2_F
    /// </summary>
    D2D1_2DAFFINETRANSFORM_PROP_TRANSFORM_MATRIX = 2,

    /// <summary>
    /// Property Name: "Sharpness"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_2DAFFINETRANSFORM_PROP_SHARPNESS = 3,
    D2D1_2DAFFINETRANSFORM_PROP_FORCE_DWORD = 0xffffffff

} D2D1_2DAFFINETRANSFORM_PROP;

typedef enum D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE
{
    D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_LINEAR = 1,
    D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_CUBIC = 2,
    D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_ANISOTROPIC = 4,
    D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE;


/// <summary>
/// The enumeration of the DPI Compensation effect's top level properties.
/// </summary>
typedef enum D2D1_DPICOMPENSATION_PROP
{

    /// <summary>
    /// Property Name: "InterpolationMode"
    /// Property Type: D2D1_DPICOMPENSATION_INTERPOLATION_MODE
    /// </summary>
    D2D1_DPICOMPENSATION_PROP_INTERPOLATION_MODE = 0,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_DPICOMPENSATION_PROP_BORDER_MODE = 1,

    /// <summary>
    /// Property Name: "InputDpi"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_DPICOMPENSATION_PROP_INPUT_DPI = 2,
    D2D1_DPICOMPENSATION_PROP_FORCE_DWORD = 0xffffffff

} D2D1_DPICOMPENSATION_PROP;

typedef enum D2D1_DPICOMPENSATION_INTERPOLATION_MODE
{
    D2D1_DPICOMPENSATION_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_DPICOMPENSATION_INTERPOLATION_MODE_LINEAR = 1,
    D2D1_DPICOMPENSATION_INTERPOLATION_MODE_CUBIC = 2,
    D2D1_DPICOMPENSATION_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_DPICOMPENSATION_INTERPOLATION_MODE_ANISOTROPIC = 4,
    D2D1_DPICOMPENSATION_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_DPICOMPENSATION_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_DPICOMPENSATION_INTERPOLATION_MODE;


/// <summary>
/// The enumeration of the Scale effect's top level properties.
/// </summary>
typedef enum D2D1_SCALE_PROP
{

    /// <summary>
    /// Property Name: "Scale"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_SCALE_PROP_SCALE = 0,

    /// <summary>
    /// Property Name: "CenterPoint"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_SCALE_PROP_CENTER_POINT = 1,

    /// <summary>
    /// Property Name: "InterpolationMode"
    /// Property Type: D2D1_SCALE_INTERPOLATION_MODE
    /// </summary>
    D2D1_SCALE_PROP_INTERPOLATION_MODE = 2,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_SCALE_PROP_BORDER_MODE = 3,

    /// <summary>
    /// Property Name: "Sharpness"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SCALE_PROP_SHARPNESS = 4,
    D2D1_SCALE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_SCALE_PROP;

typedef enum D2D1_SCALE_INTERPOLATION_MODE
{
    D2D1_SCALE_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_SCALE_INTERPOLATION_MODE_LINEAR = 1,
    D2D1_SCALE_INTERPOLATION_MODE_CUBIC = 2,
    D2D1_SCALE_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_SCALE_INTERPOLATION_MODE_ANISOTROPIC = 4,
    D2D1_SCALE_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_SCALE_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_SCALE_INTERPOLATION_MODE;


/// <summary>
/// The enumeration of the Turbulence effect's top level properties.
/// </summary>
typedef enum D2D1_TURBULENCE_PROP
{

    /// <summary>
    /// Property Name: "Offset"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_TURBULENCE_PROP_OFFSET = 0,

    /// <summary>
    /// Property Name: "Size"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_TURBULENCE_PROP_SIZE = 1,

    /// <summary>
    /// Property Name: "BaseFrequency"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_TURBULENCE_PROP_BASE_FREQUENCY = 2,

    /// <summary>
    /// Property Name: "NumOctaves"
    /// Property Type: UINT32
    /// </summary>
    D2D1_TURBULENCE_PROP_NUM_OCTAVES = 3,

    /// <summary>
    /// Property Name: "Seed"
    /// Property Type: INT32
    /// </summary>
    D2D1_TURBULENCE_PROP_SEED = 4,

    /// <summary>
    /// Property Name: "Noise"
    /// Property Type: D2D1_TURBULENCE_NOISE
    /// </summary>
    D2D1_TURBULENCE_PROP_NOISE = 5,

    /// <summary>
    /// Property Name: "Stitchable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_TURBULENCE_PROP_STITCHABLE = 6,
    D2D1_TURBULENCE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_TURBULENCE_PROP;

typedef enum D2D1_TURBULENCE_NOISE
{
    D2D1_TURBULENCE_NOISE_FRACTAL_SUM = 0,
    D2D1_TURBULENCE_NOISE_TURBULENCE = 1,
    D2D1_TURBULENCE_NOISE_FORCE_DWORD = 0xffffffff

} D2D1_TURBULENCE_NOISE;


/// <summary>
/// The enumeration of the Displacement Map effect's top level properties.
/// </summary>
typedef enum D2D1_DISPLACEMENTMAP_PROP
{

    /// <summary>
    /// Property Name: "Scale"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISPLACEMENTMAP_PROP_SCALE = 0,

    /// <summary>
    /// Property Name: "XChannelSelect"
    /// Property Type: D2D1_CHANNEL_SELECTOR
    /// </summary>
    D2D1_DISPLACEMENTMAP_PROP_X_CHANNEL_SELECT = 1,

    /// <summary>
    /// Property Name: "YChannelSelect"
    /// Property Type: D2D1_CHANNEL_SELECTOR
    /// </summary>
    D2D1_DISPLACEMENTMAP_PROP_Y_CHANNEL_SELECT = 2,
    D2D1_DISPLACEMENTMAP_PROP_FORCE_DWORD = 0xffffffff

} D2D1_DISPLACEMENTMAP_PROP;


/// <summary>
/// The enumeration of the Color Management effect's top level properties.
/// </summary>
typedef enum D2D1_COLORMANAGEMENT_PROP
{

    /// <summary>
    /// Property Name: "SourceColorContext"
    /// Property Type: ID2D1ColorContext *
    /// </summary>
    D2D1_COLORMANAGEMENT_PROP_SOURCE_COLOR_CONTEXT = 0,

    /// <summary>
    /// Property Name: "SourceRenderingIntent"
    /// Property Type: D2D1_RENDERING_INTENT
    /// </summary>
    D2D1_COLORMANAGEMENT_PROP_SOURCE_RENDERING_INTENT = 1,

    /// <summary>
    /// Property Name: "DestinationColorContext"
    /// Property Type: ID2D1ColorContext *
    /// </summary>
    D2D1_COLORMANAGEMENT_PROP_DESTINATION_COLOR_CONTEXT = 2,

    /// <summary>
    /// Property Name: "DestinationRenderingIntent"
    /// Property Type: D2D1_RENDERING_INTENT
    /// </summary>
    D2D1_COLORMANAGEMENT_PROP_DESTINATION_RENDERING_INTENT = 3,

    /// <summary>
    /// Property Name: "AlphaMode"
    /// Property Type: D2D1_COLORMANAGEMENT_ALPHA_MODE
    /// </summary>
    D2D1_COLORMANAGEMENT_PROP_ALPHA_MODE = 4,

    /// <summary>
    /// Property Name: "Quality"
    /// Property Type: D2D1_COLORMANAGEMENT_QUALITY
    /// </summary>
    D2D1_COLORMANAGEMENT_PROP_QUALITY = 5,
    D2D1_COLORMANAGEMENT_PROP_FORCE_DWORD = 0xffffffff

} D2D1_COLORMANAGEMENT_PROP;

typedef enum D2D1_COLORMANAGEMENT_ALPHA_MODE
{
    D2D1_COLORMANAGEMENT_ALPHA_MODE_PREMULTIPLIED = 1,
    D2D1_COLORMANAGEMENT_ALPHA_MODE_STRAIGHT = 2,
    D2D1_COLORMANAGEMENT_ALPHA_MODE_FORCE_DWORD = 0xffffffff

} D2D1_COLORMANAGEMENT_ALPHA_MODE;

typedef enum D2D1_COLORMANAGEMENT_QUALITY
{
    D2D1_COLORMANAGEMENT_QUALITY_PROOF = 0,
    D2D1_COLORMANAGEMENT_QUALITY_NORMAL = 1,
    D2D1_COLORMANAGEMENT_QUALITY_BEST = 2,
    D2D1_COLORMANAGEMENT_QUALITY_FORCE_DWORD = 0xffffffff

} D2D1_COLORMANAGEMENT_QUALITY;


/// <summary>
/// Specifies which ICC rendering intent the Color management effect should use.
/// </summary>
typedef enum D2D1_COLORMANAGEMENT_RENDERING_INTENT
{
    D2D1_COLORMANAGEMENT_RENDERING_INTENT_PERCEPTUAL = 0,
    D2D1_COLORMANAGEMENT_RENDERING_INTENT_RELATIVE_COLORIMETRIC = 1,
    D2D1_COLORMANAGEMENT_RENDERING_INTENT_SATURATION = 2,
    D2D1_COLORMANAGEMENT_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 3,
    D2D1_COLORMANAGEMENT_RENDERING_INTENT_FORCE_DWORD = 0xffffffff

} D2D1_COLORMANAGEMENT_RENDERING_INTENT;


/// <summary>
/// The enumeration of the Histogram effect's top level properties.
/// </summary>
typedef enum D2D1_HISTOGRAM_PROP
{

    /// <summary>
    /// Property Name: "NumBins"
    /// Property Type: UINT32
    /// </summary>
    D2D1_HISTOGRAM_PROP_NUM_BINS = 0,

    /// <summary>
    /// Property Name: "ChannelSelect"
    /// Property Type: D2D1_CHANNEL_SELECTOR
    /// </summary>
    D2D1_HISTOGRAM_PROP_CHANNEL_SELECT = 1,

    /// <summary>
    /// Property Name: "HistogramOutput"
    /// Property Type: (blob)
    /// </summary>
    D2D1_HISTOGRAM_PROP_HISTOGRAM_OUTPUT = 2,
    D2D1_HISTOGRAM_PROP_FORCE_DWORD = 0xffffffff

} D2D1_HISTOGRAM_PROP;


/// <summary>
/// The enumeration of the Point-Specular effect's top level properties.
/// </summary>
typedef enum D2D1_POINTSPECULAR_PROP
{

    /// <summary>
    /// Property Name: "LightPosition"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_POINTSPECULAR_PROP_LIGHT_POSITION = 0,

    /// <summary>
    /// Property Name: "SpecularExponent"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_POINTSPECULAR_PROP_SPECULAR_EXPONENT = 1,

    /// <summary>
    /// Property Name: "SpecularConstant"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_POINTSPECULAR_PROP_SPECULAR_CONSTANT = 2,

    /// <summary>
    /// Property Name: "SurfaceScale"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_POINTSPECULAR_PROP_SURFACE_SCALE = 3,

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_POINTSPECULAR_PROP_COLOR = 4,

    /// <summary>
    /// Property Name: "KernelUnitLength"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_POINTSPECULAR_PROP_KERNEL_UNIT_LENGTH = 5,

    /// <summary>
    /// Property Name: "ScaleMode"
    /// Property Type: D2D1_POINTSPECULAR_SCALE_MODE
    /// </summary>
    D2D1_POINTSPECULAR_PROP_SCALE_MODE = 6,
    D2D1_POINTSPECULAR_PROP_FORCE_DWORD = 0xffffffff

} D2D1_POINTSPECULAR_PROP;

typedef enum D2D1_POINTSPECULAR_SCALE_MODE
{
    D2D1_POINTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_POINTSPECULAR_SCALE_MODE_LINEAR = 1,
    D2D1_POINTSPECULAR_SCALE_MODE_CUBIC = 2,
    D2D1_POINTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_POINTSPECULAR_SCALE_MODE_ANISOTROPIC = 4,
    D2D1_POINTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_POINTSPECULAR_SCALE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_POINTSPECULAR_SCALE_MODE;


/// <summary>
/// The enumeration of the Spot-Specular effect's top level properties.
/// </summary>
typedef enum D2D1_SPOTSPECULAR_PROP
{

    /// <summary>
    /// Property Name: "LightPosition"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_LIGHT_POSITION = 0,

    /// <summary>
    /// Property Name: "PointsAt"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_POINTS_AT = 1,

    /// <summary>
    /// Property Name: "Focus"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_FOCUS = 2,

    /// <summary>
    /// Property Name: "LimitingConeAngle"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_LIMITING_CONE_ANGLE = 3,

    /// <summary>
    /// Property Name: "SpecularExponent"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_SPECULAR_EXPONENT = 4,

    /// <summary>
    /// Property Name: "SpecularConstant"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_SPECULAR_CONSTANT = 5,

    /// <summary>
    /// Property Name: "SurfaceScale"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_SURFACE_SCALE = 6,

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_COLOR = 7,

    /// <summary>
    /// Property Name: "KernelUnitLength"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_KERNEL_UNIT_LENGTH = 8,

    /// <summary>
    /// Property Name: "ScaleMode"
    /// Property Type: D2D1_SPOTSPECULAR_SCALE_MODE
    /// </summary>
    D2D1_SPOTSPECULAR_PROP_SCALE_MODE = 9,
    D2D1_SPOTSPECULAR_PROP_FORCE_DWORD = 0xffffffff

} D2D1_SPOTSPECULAR_PROP;

typedef enum D2D1_SPOTSPECULAR_SCALE_MODE
{
    D2D1_SPOTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_SPOTSPECULAR_SCALE_MODE_LINEAR = 1,
    D2D1_SPOTSPECULAR_SCALE_MODE_CUBIC = 2,
    D2D1_SPOTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_SPOTSPECULAR_SCALE_MODE_ANISOTROPIC = 4,
    D2D1_SPOTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_SPOTSPECULAR_SCALE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_SPOTSPECULAR_SCALE_MODE;


/// <summary>
/// The enumeration of the Distant-Specular effect's top level properties.
/// </summary>
typedef enum D2D1_DISTANTSPECULAR_PROP
{

    /// <summary>
    /// Property Name: "Azimuth"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTSPECULAR_PROP_AZIMUTH = 0,

    /// <summary>
    /// Property Name: "Elevation"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTSPECULAR_PROP_ELEVATION = 1,

    /// <summary>
    /// Property Name: "SpecularExponent"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTSPECULAR_PROP_SPECULAR_EXPONENT = 2,

    /// <summary>
    /// Property Name: "SpecularConstant"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTSPECULAR_PROP_SPECULAR_CONSTANT = 3,

    /// <summary>
    /// Property Name: "SurfaceScale"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTSPECULAR_PROP_SURFACE_SCALE = 4,

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_DISTANTSPECULAR_PROP_COLOR = 5,

    /// <summary>
    /// Property Name: "KernelUnitLength"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_DISTANTSPECULAR_PROP_KERNEL_UNIT_LENGTH = 6,

    /// <summary>
    /// Property Name: "ScaleMode"
    /// Property Type: D2D1_DISTANTSPECULAR_SCALE_MODE
    /// </summary>
    D2D1_DISTANTSPECULAR_PROP_SCALE_MODE = 7,
    D2D1_DISTANTSPECULAR_PROP_FORCE_DWORD = 0xffffffff

} D2D1_DISTANTSPECULAR_PROP;

typedef enum D2D1_DISTANTSPECULAR_SCALE_MODE
{
    D2D1_DISTANTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_DISTANTSPECULAR_SCALE_MODE_LINEAR = 1,
    D2D1_DISTANTSPECULAR_SCALE_MODE_CUBIC = 2,
    D2D1_DISTANTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_DISTANTSPECULAR_SCALE_MODE_ANISOTROPIC = 4,
    D2D1_DISTANTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_DISTANTSPECULAR_SCALE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_DISTANTSPECULAR_SCALE_MODE;


/// <summary>
/// The enumeration of the Point-Diffuse effect's top level properties.
/// </summary>
typedef enum D2D1_POINTDIFFUSE_PROP
{

    /// <summary>
    /// Property Name: "LightPosition"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_POINTDIFFUSE_PROP_LIGHT_POSITION = 0,

    /// <summary>
    /// Property Name: "DiffuseConstant"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_POINTDIFFUSE_PROP_DIFFUSE_CONSTANT = 1,

    /// <summary>
    /// Property Name: "SurfaceScale"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_POINTDIFFUSE_PROP_SURFACE_SCALE = 2,

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_POINTDIFFUSE_PROP_COLOR = 3,

    /// <summary>
    /// Property Name: "KernelUnitLength"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_POINTDIFFUSE_PROP_KERNEL_UNIT_LENGTH = 4,

    /// <summary>
    /// Property Name: "ScaleMode"
    /// Property Type: D2D1_POINTDIFFUSE_SCALE_MODE
    /// </summary>
    D2D1_POINTDIFFUSE_PROP_SCALE_MODE = 5,
    D2D1_POINTDIFFUSE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_POINTDIFFUSE_PROP;

typedef enum D2D1_POINTDIFFUSE_SCALE_MODE
{
    D2D1_POINTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_POINTDIFFUSE_SCALE_MODE_LINEAR = 1,
    D2D1_POINTDIFFUSE_SCALE_MODE_CUBIC = 2,
    D2D1_POINTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_POINTDIFFUSE_SCALE_MODE_ANISOTROPIC = 4,
    D2D1_POINTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_POINTDIFFUSE_SCALE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_POINTDIFFUSE_SCALE_MODE;


/// <summary>
/// The enumeration of the Spot-Diffuse effect's top level properties.
/// </summary>
typedef enum D2D1_SPOTDIFFUSE_PROP
{

    /// <summary>
    /// Property Name: "LightPosition"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_LIGHT_POSITION = 0,

    /// <summary>
    /// Property Name: "PointsAt"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_POINTS_AT = 1,

    /// <summary>
    /// Property Name: "Focus"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_FOCUS = 2,

    /// <summary>
    /// Property Name: "LimitingConeAngle"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_LIMITING_CONE_ANGLE = 3,

    /// <summary>
    /// Property Name: "DiffuseConstant"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_DIFFUSE_CONSTANT = 4,

    /// <summary>
    /// Property Name: "SurfaceScale"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_SURFACE_SCALE = 5,

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_COLOR = 6,

    /// <summary>
    /// Property Name: "KernelUnitLength"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_KERNEL_UNIT_LENGTH = 7,

    /// <summary>
    /// Property Name: "ScaleMode"
    /// Property Type: D2D1_SPOTDIFFUSE_SCALE_MODE
    /// </summary>
    D2D1_SPOTDIFFUSE_PROP_SCALE_MODE = 8,
    D2D1_SPOTDIFFUSE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_SPOTDIFFUSE_PROP;

typedef enum D2D1_SPOTDIFFUSE_SCALE_MODE
{
    D2D1_SPOTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_SPOTDIFFUSE_SCALE_MODE_LINEAR = 1,
    D2D1_SPOTDIFFUSE_SCALE_MODE_CUBIC = 2,
    D2D1_SPOTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_SPOTDIFFUSE_SCALE_MODE_ANISOTROPIC = 4,
    D2D1_SPOTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_SPOTDIFFUSE_SCALE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_SPOTDIFFUSE_SCALE_MODE;


/// <summary>
/// The enumeration of the Distant-Diffuse effect's top level properties.
/// </summary>
typedef enum D2D1_DISTANTDIFFUSE_PROP
{

    /// <summary>
    /// Property Name: "Azimuth"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTDIFFUSE_PROP_AZIMUTH = 0,

    /// <summary>
    /// Property Name: "Elevation"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTDIFFUSE_PROP_ELEVATION = 1,

    /// <summary>
    /// Property Name: "DiffuseConstant"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTDIFFUSE_PROP_DIFFUSE_CONSTANT = 2,

    /// <summary>
    /// Property Name: "SurfaceScale"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_DISTANTDIFFUSE_PROP_SURFACE_SCALE = 3,

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_DISTANTDIFFUSE_PROP_COLOR = 4,

    /// <summary>
    /// Property Name: "KernelUnitLength"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_DISTANTDIFFUSE_PROP_KERNEL_UNIT_LENGTH = 5,

    /// <summary>
    /// Property Name: "ScaleMode"
    /// Property Type: D2D1_DISTANTDIFFUSE_SCALE_MODE
    /// </summary>
    D2D1_DISTANTDIFFUSE_PROP_SCALE_MODE = 6,
    D2D1_DISTANTDIFFUSE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_DISTANTDIFFUSE_PROP;

typedef enum D2D1_DISTANTDIFFUSE_SCALE_MODE
{
    D2D1_DISTANTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_DISTANTDIFFUSE_SCALE_MODE_LINEAR = 1,
    D2D1_DISTANTDIFFUSE_SCALE_MODE_CUBIC = 2,
    D2D1_DISTANTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_DISTANTDIFFUSE_SCALE_MODE_ANISOTROPIC = 4,
    D2D1_DISTANTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_DISTANTDIFFUSE_SCALE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_DISTANTDIFFUSE_SCALE_MODE;


/// <summary>
/// The enumeration of the Flood effect's top level properties.
/// </summary>
typedef enum D2D1_FLOOD_PROP
{

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_FLOOD_PROP_COLOR = 0,
    D2D1_FLOOD_PROP_FORCE_DWORD = 0xffffffff

} D2D1_FLOOD_PROP;


/// <summary>
/// The enumeration of the Linear Transfer effect's top level properties.
/// </summary>
typedef enum D2D1_LINEARTRANSFER_PROP
{

    /// <summary>
    /// Property Name: "RedYIntercept"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_RED_Y_INTERCEPT = 0,

    /// <summary>
    /// Property Name: "RedSlope"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_RED_SLOPE = 1,

    /// <summary>
    /// Property Name: "RedDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_RED_DISABLE = 2,

    /// <summary>
    /// Property Name: "GreenYIntercept"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_GREEN_Y_INTERCEPT = 3,

    /// <summary>
    /// Property Name: "GreenSlope"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_GREEN_SLOPE = 4,

    /// <summary>
    /// Property Name: "GreenDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_GREEN_DISABLE = 5,

    /// <summary>
    /// Property Name: "BlueYIntercept"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_BLUE_Y_INTERCEPT = 6,

    /// <summary>
    /// Property Name: "BlueSlope"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_BLUE_SLOPE = 7,

    /// <summary>
    /// Property Name: "BlueDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_BLUE_DISABLE = 8,

    /// <summary>
    /// Property Name: "AlphaYIntercept"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_ALPHA_Y_INTERCEPT = 9,

    /// <summary>
    /// Property Name: "AlphaSlope"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_ALPHA_SLOPE = 10,

    /// <summary>
    /// Property Name: "AlphaDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_ALPHA_DISABLE = 11,

    /// <summary>
    /// Property Name: "ClampOutput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_LINEARTRANSFER_PROP_CLAMP_OUTPUT = 12,
    D2D1_LINEARTRANSFER_PROP_FORCE_DWORD = 0xffffffff

} D2D1_LINEARTRANSFER_PROP;


/// <summary>
/// The enumeration of the Gamma Transfer effect's top level properties.
/// </summary>
typedef enum D2D1_GAMMATRANSFER_PROP
{

    /// <summary>
    /// Property Name: "RedAmplitude"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_RED_AMPLITUDE = 0,

    /// <summary>
    /// Property Name: "RedExponent"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_RED_EXPONENT = 1,

    /// <summary>
    /// Property Name: "RedOffset"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_RED_OFFSET = 2,

    /// <summary>
    /// Property Name: "RedDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_RED_DISABLE = 3,

    /// <summary>
    /// Property Name: "GreenAmplitude"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_GREEN_AMPLITUDE = 4,

    /// <summary>
    /// Property Name: "GreenExponent"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_GREEN_EXPONENT = 5,

    /// <summary>
    /// Property Name: "GreenOffset"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_GREEN_OFFSET = 6,

    /// <summary>
    /// Property Name: "GreenDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_GREEN_DISABLE = 7,

    /// <summary>
    /// Property Name: "BlueAmplitude"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_BLUE_AMPLITUDE = 8,

    /// <summary>
    /// Property Name: "BlueExponent"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_BLUE_EXPONENT = 9,

    /// <summary>
    /// Property Name: "BlueOffset"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_BLUE_OFFSET = 10,

    /// <summary>
    /// Property Name: "BlueDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_BLUE_DISABLE = 11,

    /// <summary>
    /// Property Name: "AlphaAmplitude"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_ALPHA_AMPLITUDE = 12,

    /// <summary>
    /// Property Name: "AlphaExponent"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_ALPHA_EXPONENT = 13,

    /// <summary>
    /// Property Name: "AlphaOffset"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_ALPHA_OFFSET = 14,

    /// <summary>
    /// Property Name: "AlphaDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_ALPHA_DISABLE = 15,

    /// <summary>
    /// Property Name: "ClampOutput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_GAMMATRANSFER_PROP_CLAMP_OUTPUT = 16,
    D2D1_GAMMATRANSFER_PROP_FORCE_DWORD = 0xffffffff

} D2D1_GAMMATRANSFER_PROP;


/// <summary>
/// The enumeration of the Table Transfer effect's top level properties.
/// </summary>
typedef enum D2D1_TABLETRANSFER_PROP
{

    /// <summary>
    /// Property Name: "RedTable"
    /// Property Type: (blob)
    /// </summary>
    D2D1_TABLETRANSFER_PROP_RED_TABLE = 0,

    /// <summary>
    /// Property Name: "RedDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_TABLETRANSFER_PROP_RED_DISABLE = 1,

    /// <summary>
    /// Property Name: "GreenTable"
    /// Property Type: (blob)
    /// </summary>
    D2D1_TABLETRANSFER_PROP_GREEN_TABLE = 2,

    /// <summary>
    /// Property Name: "GreenDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_TABLETRANSFER_PROP_GREEN_DISABLE = 3,

    /// <summary>
    /// Property Name: "BlueTable"
    /// Property Type: (blob)
    /// </summary>
    D2D1_TABLETRANSFER_PROP_BLUE_TABLE = 4,

    /// <summary>
    /// Property Name: "BlueDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_TABLETRANSFER_PROP_BLUE_DISABLE = 5,

    /// <summary>
    /// Property Name: "AlphaTable"
    /// Property Type: (blob)
    /// </summary>
    D2D1_TABLETRANSFER_PROP_ALPHA_TABLE = 6,

    /// <summary>
    /// Property Name: "AlphaDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_TABLETRANSFER_PROP_ALPHA_DISABLE = 7,

    /// <summary>
    /// Property Name: "ClampOutput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_TABLETRANSFER_PROP_CLAMP_OUTPUT = 8,
    D2D1_TABLETRANSFER_PROP_FORCE_DWORD = 0xffffffff

} D2D1_TABLETRANSFER_PROP;


/// <summary>
/// The enumeration of the Discrete Transfer effect's top level properties.
/// </summary>
typedef enum D2D1_DISCRETETRANSFER_PROP
{

    /// <summary>
    /// Property Name: "RedTable"
    /// Property Type: (blob)
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_RED_TABLE = 0,

    /// <summary>
    /// Property Name: "RedDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_RED_DISABLE = 1,

    /// <summary>
    /// Property Name: "GreenTable"
    /// Property Type: (blob)
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_GREEN_TABLE = 2,

    /// <summary>
    /// Property Name: "GreenDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_GREEN_DISABLE = 3,

    /// <summary>
    /// Property Name: "BlueTable"
    /// Property Type: (blob)
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_BLUE_TABLE = 4,

    /// <summary>
    /// Property Name: "BlueDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_BLUE_DISABLE = 5,

    /// <summary>
    /// Property Name: "AlphaTable"
    /// Property Type: (blob)
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_ALPHA_TABLE = 6,

    /// <summary>
    /// Property Name: "AlphaDisable"
    /// Property Type: BOOL
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_ALPHA_DISABLE = 7,

    /// <summary>
    /// Property Name: "ClampOutput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_DISCRETETRANSFER_PROP_CLAMP_OUTPUT = 8,
    D2D1_DISCRETETRANSFER_PROP_FORCE_DWORD = 0xffffffff

} D2D1_DISCRETETRANSFER_PROP;


/// <summary>
/// The enumeration of the Convolve Matrix effect's top level properties.
/// </summary>
typedef enum D2D1_CONVOLVEMATRIX_PROP
{

    /// <summary>
    /// Property Name: "KernelUnitLength"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_KERNEL_UNIT_LENGTH = 0,

    /// <summary>
    /// Property Name: "ScaleMode"
    /// Property Type: D2D1_CONVOLVEMATRIX_SCALE_MODE
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_SCALE_MODE = 1,

    /// <summary>
    /// Property Name: "KernelSizeX"
    /// Property Type: UINT32
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_KERNEL_SIZE_X = 2,

    /// <summary>
    /// Property Name: "KernelSizeY"
    /// Property Type: UINT32
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_KERNEL_SIZE_Y = 3,

    /// <summary>
    /// Property Name: "KernelMatrix"
    /// Property Type: (blob)
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_KERNEL_MATRIX = 4,

    /// <summary>
    /// Property Name: "Divisor"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_DIVISOR = 5,

    /// <summary>
    /// Property Name: "Bias"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_BIAS = 6,

    /// <summary>
    /// Property Name: "KernelOffset"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_KERNEL_OFFSET = 7,

    /// <summary>
    /// Property Name: "PreserveAlpha"
    /// Property Type: BOOL
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_PRESERVE_ALPHA = 8,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_BORDER_MODE = 9,

    /// <summary>
    /// Property Name: "ClampOutput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_CONVOLVEMATRIX_PROP_CLAMP_OUTPUT = 10,
    D2D1_CONVOLVEMATRIX_PROP_FORCE_DWORD = 0xffffffff

} D2D1_CONVOLVEMATRIX_PROP;

typedef enum D2D1_CONVOLVEMATRIX_SCALE_MODE
{
    D2D1_CONVOLVEMATRIX_SCALE_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_CONVOLVEMATRIX_SCALE_MODE_LINEAR = 1,
    D2D1_CONVOLVEMATRIX_SCALE_MODE_CUBIC = 2,
    D2D1_CONVOLVEMATRIX_SCALE_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_CONVOLVEMATRIX_SCALE_MODE_ANISOTROPIC = 4,
    D2D1_CONVOLVEMATRIX_SCALE_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_CONVOLVEMATRIX_SCALE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_CONVOLVEMATRIX_SCALE_MODE;


/// <summary>
/// The enumeration of the Brightness effect's top level properties.
/// </summary>
typedef enum D2D1_BRIGHTNESS_PROP
{

    /// <summary>
    /// Property Name: "WhitePoint"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_BRIGHTNESS_PROP_WHITE_POINT = 0,

    /// <summary>
    /// Property Name: "BlackPoint"
    /// Property Type: D2D1_VECTOR_2F
    /// </summary>
    D2D1_BRIGHTNESS_PROP_BLACK_POINT = 1,
    D2D1_BRIGHTNESS_PROP_FORCE_DWORD = 0xffffffff

} D2D1_BRIGHTNESS_PROP;


/// <summary>
/// The enumeration of the Arithmetic Composite effect's top level properties.
/// </summary>
typedef enum D2D1_ARITHMETICCOMPOSITE_PROP
{

    /// <summary>
    /// Property Name: "Coefficients"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_ARITHMETICCOMPOSITE_PROP_COEFFICIENTS = 0,

    /// <summary>
    /// Property Name: "ClampOutput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_ARITHMETICCOMPOSITE_PROP_CLAMP_OUTPUT = 1,
    D2D1_ARITHMETICCOMPOSITE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_ARITHMETICCOMPOSITE_PROP;


/// <summary>
/// The enumeration of the Crop effect's top level properties.
/// </summary>
typedef enum D2D1_CROP_PROP
{

    /// <summary>
    /// Property Name: "Rect"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_CROP_PROP_RECT = 0,

    /// <summary>
    /// Property Name: "BorderMode"
    /// Property Type: D2D1_BORDER_MODE
    /// </summary>
    D2D1_CROP_PROP_BORDER_MODE = 1,
    D2D1_CROP_PROP_FORCE_DWORD = 0xffffffff

} D2D1_CROP_PROP;


/// <summary>
/// The enumeration of the Border effect's top level properties.
/// </summary>
typedef enum D2D1_BORDER_PROP
{

    /// <summary>
    /// Property Name: "EdgeModeX"
    /// Property Type: D2D1_BORDER_EDGE_MODE
    /// </summary>
    D2D1_BORDER_PROP_EDGE_MODE_X = 0,

    /// <summary>
    /// Property Name: "EdgeModeY"
    /// Property Type: D2D1_BORDER_EDGE_MODE
    /// </summary>
    D2D1_BORDER_PROP_EDGE_MODE_Y = 1,
    D2D1_BORDER_PROP_FORCE_DWORD = 0xffffffff

} D2D1_BORDER_PROP;


/// <summary>
/// The edge mode for the Border effect.
/// </summary>
typedef enum D2D1_BORDER_EDGE_MODE
{
    D2D1_BORDER_EDGE_MODE_CLAMP = 0,
    D2D1_BORDER_EDGE_MODE_WRAP = 1,
    D2D1_BORDER_EDGE_MODE_MIRROR = 2,
    D2D1_BORDER_EDGE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_BORDER_EDGE_MODE;


/// <summary>
/// The enumeration of the Morphology effect's top level properties.
/// </summary>
typedef enum D2D1_MORPHOLOGY_PROP
{

    /// <summary>
    /// Property Name: "Mode"
    /// Property Type: D2D1_MORPHOLOGY_MODE
    /// </summary>
    D2D1_MORPHOLOGY_PROP_MODE = 0,

    /// <summary>
    /// Property Name: "Width"
    /// Property Type: UINT32
    /// </summary>
    D2D1_MORPHOLOGY_PROP_WIDTH = 1,

    /// <summary>
    /// Property Name: "Height"
    /// Property Type: UINT32
    /// </summary>
    D2D1_MORPHOLOGY_PROP_HEIGHT = 2,
    D2D1_MORPHOLOGY_PROP_FORCE_DWORD = 0xffffffff

} D2D1_MORPHOLOGY_PROP;

typedef enum D2D1_MORPHOLOGY_MODE
{
    D2D1_MORPHOLOGY_MODE_ERODE = 0,
    D2D1_MORPHOLOGY_MODE_DILATE = 1,
    D2D1_MORPHOLOGY_MODE_FORCE_DWORD = 0xffffffff

} D2D1_MORPHOLOGY_MODE;


/// <summary>
/// The enumeration of the Tile effect's top level properties.
/// </summary>
typedef enum D2D1_TILE_PROP
{

    /// <summary>
    /// Property Name: "Rect"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_TILE_PROP_RECT = 0,
    D2D1_TILE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_TILE_PROP;


/// <summary>
/// The enumeration of the Atlas effect's top level properties.
/// </summary>
typedef enum D2D1_ATLAS_PROP
{

    /// <summary>
    /// Property Name: "InputRect"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_ATLAS_PROP_INPUT_RECT = 0,

    /// <summary>
    /// Property Name: "InputPaddingRect"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_ATLAS_PROP_INPUT_PADDING_RECT = 1,
    D2D1_ATLAS_PROP_FORCE_DWORD = 0xffffffff

} D2D1_ATLAS_PROP;


/// <summary>
/// The enumeration of the Opacity Metadata effect's top level properties.
/// </summary>
typedef enum D2D1_OPACITYMETADATA_PROP
{

    /// <summary>
    /// Property Name: "InputOpaqueRect"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_OPACITYMETADATA_PROP_INPUT_OPAQUE_RECT = 0,
    D2D1_OPACITYMETADATA_PROP_FORCE_DWORD = 0xffffffff

} D2D1_OPACITYMETADATA_PROP;


/// <summary>
/// The enumeration of the YCbCr effect's top level properties.
/// </summary>
typedef enum D2D1_YCBCR_PROP
{

    /// <summary>
    /// Property Name: "ChromaSubsampling"
    /// Property Type: D2D1_YCBCR_CHROMA_SUBSAMPLING
    /// </summary>
    D2D1_YCBCR_PROP_CHROMA_SUBSAMPLING = 0,

    /// <summary>
    /// Property Name: "TransformMatrix"
    /// Property Type: D2D1_MATRIX_3X2_F
    /// </summary>
    D2D1_YCBCR_PROP_TRANSFORM_MATRIX = 1,

    /// <summary>
    /// Property Name: "InterpolationMode"
    /// Property Type: D2D1_YCBCR_INTERPOLATION_MODE
    /// </summary>
    D2D1_YCBCR_PROP_INTERPOLATION_MODE = 2,
    D2D1_YCBCR_PROP_FORCE_DWORD = 0xffffffff

} D2D1_YCBCR_PROP;

typedef enum D2D1_YCBCR_CHROMA_SUBSAMPLING
{
    D2D1_YCBCR_CHROMA_SUBSAMPLING_AUTO = 0,
    D2D1_YCBCR_CHROMA_SUBSAMPLING_420 = 1,
    D2D1_YCBCR_CHROMA_SUBSAMPLING_422 = 2,
    D2D1_YCBCR_CHROMA_SUBSAMPLING_444 = 3,
    D2D1_YCBCR_CHROMA_SUBSAMPLING_440 = 4,
    D2D1_YCBCR_CHROMA_SUBSAMPLING_FORCE_DWORD = 0xffffffff

} D2D1_YCBCR_CHROMA_SUBSAMPLING;

typedef enum D2D1_YCBCR_INTERPOLATION_MODE
{
    D2D1_YCBCR_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_YCBCR_INTERPOLATION_MODE_LINEAR = 1,
    D2D1_YCBCR_INTERPOLATION_MODE_CUBIC = 2,
    D2D1_YCBCR_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_YCBCR_INTERPOLATION_MODE_ANISOTROPIC = 4,
    D2D1_YCBCR_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = 5,
    D2D1_YCBCR_INTERPOLATION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_YCBCR_INTERPOLATION_MODE;


/// <summary>
/// The enumeration of the Contrast effect's top level properties.
/// </summary>
typedef enum D2D1_CONTRAST_PROP
{

    /// <summary>
    /// Property Name: "Contrast"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_CONTRAST_PROP_CONTRAST = 0,

    /// <summary>
    /// Property Name: "ClampInput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_CONTRAST_PROP_CLAMP_INPUT = 1,
    D2D1_CONTRAST_PROP_FORCE_DWORD = 0xffffffff

} D2D1_CONTRAST_PROP;


/// <summary>
/// The enumeration of the RgbToHue effect's top level properties.
/// </summary>
typedef enum D2D1_RGBTOHUE_PROP
{

    /// <summary>
    /// Property Name: "OutputColorSpace"
    /// Property Type: D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE
    /// </summary>
    D2D1_RGBTOHUE_PROP_OUTPUT_COLOR_SPACE = 0,
    D2D1_RGBTOHUE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_RGBTOHUE_PROP;

typedef enum D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE
{
    D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_HUE_SATURATION_VALUE = 0,
    D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_HUE_SATURATION_LIGHTNESS = 1,
    D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_FORCE_DWORD = 0xffffffff

} D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE;


/// <summary>
/// The enumeration of the HueToRgb effect's top level properties.
/// </summary>
typedef enum D2D1_HUETORGB_PROP
{

    /// <summary>
    /// Property Name: "InputColorSpace"
    /// Property Type: D2D1_HUETORGB_INPUT_COLOR_SPACE
    /// </summary>
    D2D1_HUETORGB_PROP_INPUT_COLOR_SPACE = 0,
    D2D1_HUETORGB_PROP_FORCE_DWORD = 0xffffffff

} D2D1_HUETORGB_PROP;

typedef enum D2D1_HUETORGB_INPUT_COLOR_SPACE
{
    D2D1_HUETORGB_INPUT_COLOR_SPACE_HUE_SATURATION_VALUE = 0,
    D2D1_HUETORGB_INPUT_COLOR_SPACE_HUE_SATURATION_LIGHTNESS = 1,
    D2D1_HUETORGB_INPUT_COLOR_SPACE_FORCE_DWORD = 0xffffffff

} D2D1_HUETORGB_INPUT_COLOR_SPACE;


/// <summary>
/// The enumeration of the Chroma Key effect's top level properties.
/// </summary>
typedef enum D2D1_CHROMAKEY_PROP
{

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_3F
    /// </summary>
    D2D1_CHROMAKEY_PROP_COLOR = 0,

    /// <summary>
    /// Property Name: "Tolerance"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_CHROMAKEY_PROP_TOLERANCE = 1,

    /// <summary>
    /// Property Name: "InvertAlpha"
    /// Property Type: BOOL
    /// </summary>
    D2D1_CHROMAKEY_PROP_INVERT_ALPHA = 2,

    /// <summary>
    /// Property Name: "Feather"
    /// Property Type: BOOL
    /// </summary>
    D2D1_CHROMAKEY_PROP_FEATHER = 3,
    D2D1_CHROMAKEY_PROP_FORCE_DWORD = 0xffffffff

} D2D1_CHROMAKEY_PROP;


/// <summary>
/// The enumeration of the Emboss effect's top level properties.
/// </summary>
typedef enum D2D1_EMBOSS_PROP
{

    /// <summary>
    /// Property Name: "Height"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_EMBOSS_PROP_HEIGHT = 0,

    /// <summary>
    /// Property Name: "Direction"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_EMBOSS_PROP_DIRECTION = 1,
    D2D1_EMBOSS_PROP_FORCE_DWORD = 0xffffffff

} D2D1_EMBOSS_PROP;


/// <summary>
/// The enumeration of the Exposure effect's top level properties.
/// </summary>
typedef enum D2D1_EXPOSURE_PROP
{

    /// <summary>
    /// Property Name: "ExposureValue"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_EXPOSURE_PROP_EXPOSURE_VALUE = 0,
    D2D1_EXPOSURE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_EXPOSURE_PROP;


/// <summary>
/// The enumeration of the Posterize effect's top level properties.
/// </summary>
typedef enum D2D1_POSTERIZE_PROP
{

    /// <summary>
    /// Property Name: "RedValueCount"
    /// Property Type: UINT32
    /// </summary>
    D2D1_POSTERIZE_PROP_RED_VALUE_COUNT = 0,

    /// <summary>
    /// Property Name: "GreenValueCount"
    /// Property Type: UINT32
    /// </summary>
    D2D1_POSTERIZE_PROP_GREEN_VALUE_COUNT = 1,

    /// <summary>
    /// Property Name: "BlueValueCount"
    /// Property Type: UINT32
    /// </summary>
    D2D1_POSTERIZE_PROP_BLUE_VALUE_COUNT = 2,
    D2D1_POSTERIZE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_POSTERIZE_PROP;


/// <summary>
/// The enumeration of the Sepia effect's top level properties.
/// </summary>
typedef enum D2D1_SEPIA_PROP
{

    /// <summary>
    /// Property Name: "Intensity"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SEPIA_PROP_INTENSITY = 0,

    /// <summary>
    /// Property Name: "AlphaMode"
    /// Property Type: D2D1_ALPHA_MODE
    /// </summary>
    D2D1_SEPIA_PROP_ALPHA_MODE = 1,
    D2D1_SEPIA_PROP_FORCE_DWORD = 0xffffffff

} D2D1_SEPIA_PROP;


/// <summary>
/// The enumeration of the Sharpen effect's top level properties.
/// </summary>
typedef enum D2D1_SHARPEN_PROP
{

    /// <summary>
    /// Property Name: "Sharpness"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SHARPEN_PROP_SHARPNESS = 0,

    /// <summary>
    /// Property Name: "Threshold"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_SHARPEN_PROP_THRESHOLD = 1,
    D2D1_SHARPEN_PROP_FORCE_DWORD = 0xffffffff

} D2D1_SHARPEN_PROP;


/// <summary>
/// The enumeration of the Straighten effect's top level properties.
/// </summary>
typedef enum D2D1_STRAIGHTEN_PROP
{

    /// <summary>
    /// Property Name: "Angle"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_STRAIGHTEN_PROP_ANGLE = 0,

    /// <summary>
    /// Property Name: "MaintainSize"
    /// Property Type: BOOL
    /// </summary>
    D2D1_STRAIGHTEN_PROP_MAINTAIN_SIZE = 1,

    /// <summary>
    /// Property Name: "ScaleMode"
    /// Property Type: D2D1_STRAIGHTEN_SCALE_MODE
    /// </summary>
    D2D1_STRAIGHTEN_PROP_SCALE_MODE = 2,
    D2D1_STRAIGHTEN_PROP_FORCE_DWORD = 0xffffffff

} D2D1_STRAIGHTEN_PROP;

typedef enum D2D1_STRAIGHTEN_SCALE_MODE
{
    D2D1_STRAIGHTEN_SCALE_MODE_NEAREST_NEIGHBOR = 0,
    D2D1_STRAIGHTEN_SCALE_MODE_LINEAR = 1,
    D2D1_STRAIGHTEN_SCALE_MODE_CUBIC = 2,
    D2D1_STRAIGHTEN_SCALE_MODE_MULTI_SAMPLE_LINEAR = 3,
    D2D1_STRAIGHTEN_SCALE_MODE_ANISOTROPIC = 4,
    D2D1_STRAIGHTEN_SCALE_MODE_FORCE_DWORD = 0xffffffff

} D2D1_STRAIGHTEN_SCALE_MODE;


/// <summary>
/// The enumeration of the Temperature And Tint effect's top level properties.
/// </summary>
typedef enum D2D1_TEMPERATUREANDTINT_PROP
{

    /// <summary>
    /// Property Name: "Temperature"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_TEMPERATUREANDTINT_PROP_TEMPERATURE = 0,

    /// <summary>
    /// Property Name: "Tint"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_TEMPERATUREANDTINT_PROP_TINT = 1,
    D2D1_TEMPERATUREANDTINT_PROP_FORCE_DWORD = 0xffffffff

} D2D1_TEMPERATUREANDTINT_PROP;


/// <summary>
/// The enumeration of the Vignette effect's top level properties.
/// </summary>
typedef enum D2D1_VIGNETTE_PROP
{

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_VIGNETTE_PROP_COLOR = 0,

    /// <summary>
    /// Property Name: "TransitionSize"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_VIGNETTE_PROP_TRANSITION_SIZE = 1,

    /// <summary>
    /// Property Name: "Strength"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_VIGNETTE_PROP_STRENGTH = 2,
    D2D1_VIGNETTE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_VIGNETTE_PROP;


/// <summary>
/// The enumeration of the Edge Detection effect's top level properties.
/// </summary>
typedef enum D2D1_EDGEDETECTION_PROP
{

    /// <summary>
    /// Property Name: "Strength"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_EDGEDETECTION_PROP_STRENGTH = 0,

    /// <summary>
    /// Property Name: "BlurRadius"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_EDGEDETECTION_PROP_BLUR_RADIUS = 1,

    /// <summary>
    /// Property Name: "Mode"
    /// Property Type: D2D1_EDGEDETECTION_MODE
    /// </summary>
    D2D1_EDGEDETECTION_PROP_MODE = 2,

    /// <summary>
    /// Property Name: "OverlayEdges"
    /// Property Type: BOOL
    /// </summary>
    D2D1_EDGEDETECTION_PROP_OVERLAY_EDGES = 3,

    /// <summary>
    /// Property Name: "AlphaMode"
    /// Property Type: D2D1_ALPHA_MODE
    /// </summary>
    D2D1_EDGEDETECTION_PROP_ALPHA_MODE = 4,
    D2D1_EDGEDETECTION_PROP_FORCE_DWORD = 0xffffffff

} D2D1_EDGEDETECTION_PROP;

typedef enum D2D1_EDGEDETECTION_MODE
{
    D2D1_EDGEDETECTION_MODE_SOBEL = 0,
    D2D1_EDGEDETECTION_MODE_PREWITT = 1,
    D2D1_EDGEDETECTION_MODE_FORCE_DWORD = 0xffffffff

} D2D1_EDGEDETECTION_MODE;


/// <summary>
/// The enumeration of the Highlights and Shadows effect's top level properties.
/// </summary>
typedef enum D2D1_HIGHLIGHTSANDSHADOWS_PROP
{

    /// <summary>
    /// Property Name: "Highlights"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_HIGHLIGHTSANDSHADOWS_PROP_HIGHLIGHTS = 0,

    /// <summary>
    /// Property Name: "Shadows"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_HIGHLIGHTSANDSHADOWS_PROP_SHADOWS = 1,

    /// <summary>
    /// Property Name: "Clarity"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_HIGHLIGHTSANDSHADOWS_PROP_CLARITY = 2,

    /// <summary>
    /// Property Name: "InputGamma"
    /// Property Type: D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA
    /// </summary>
    D2D1_HIGHLIGHTSANDSHADOWS_PROP_INPUT_GAMMA = 3,

    /// <summary>
    /// Property Name: "MaskBlurRadius"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_HIGHLIGHTSANDSHADOWS_PROP_MASK_BLUR_RADIUS = 4,
    D2D1_HIGHLIGHTSANDSHADOWS_PROP_FORCE_DWORD = 0xffffffff

} D2D1_HIGHLIGHTSANDSHADOWS_PROP;

typedef enum D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA
{
    D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_LINEAR = 0,
    D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_SRGB = 1,
    D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_FORCE_DWORD = 0xffffffff

} D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA;


/// <summary>
/// The enumeration of the Lookup Table 3D effect's top level properties.
/// </summary>
typedef enum D2D1_LOOKUPTABLE3D_PROP
{

    /// <summary>
    /// Property Name: "Lut"
    /// Property Type: IUnknown *
    /// </summary>
    D2D1_LOOKUPTABLE3D_PROP_LUT = 0,

    /// <summary>
    /// Property Name: "AlphaMode"
    /// Property Type: D2D1_ALPHA_MODE
    /// </summary>
    D2D1_LOOKUPTABLE3D_PROP_ALPHA_MODE = 1,
    D2D1_LOOKUPTABLE3D_PROP_FORCE_DWORD = 0xffffffff

} D2D1_LOOKUPTABLE3D_PROP;

/// <summary>
/// The enumeration of the Opacity effect's top level properties.
/// </summary>
typedef enum D2D1_OPACITY_PROP
{

    /// <summary>
    /// Property Name: "Opacity"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_OPACITY_PROP_OPACITY = 0,
    D2D1_OPACITY_PROP_FORCE_DWORD = 0xffffffff

} D2D1_OPACITY_PROP;


/// <summary>
/// The enumeration of the Cross Fade effect's top level properties.
/// </summary>
typedef enum D2D1_CROSSFADE_PROP
{

    /// <summary>
    /// Property Name: "Weight"
    /// Property Type: FLOAT
    /// </summary>
    D2D1_CROSSFADE_PROP_WEIGHT = 0,
    D2D1_CROSSFADE_PROP_FORCE_DWORD = 0xffffffff

} D2D1_CROSSFADE_PROP;


/// <summary>
/// The enumeration of the Tint effect's top level properties.
/// </summary>
typedef enum D2D1_TINT_PROP
{

    /// <summary>
    /// Property Name: "Color"
    /// Property Type: D2D1_VECTOR_4F
    /// </summary>
    D2D1_TINT_PROP_COLOR = 0,

    /// <summary>
    /// Property Name: "ClampOutput"
    /// Property Type: BOOL
    /// </summary>
    D2D1_TINT_PROP_CLAMP_OUTPUT = 1,
    D2D1_TINT_PROP_FORCE_DWORD = 0xffffffff

} D2D1_TINT_PROP;



typedef enum {
    AliceBlue = 0x00f0f8ff,
    AntiqueWhite = 0x00faebd7,
    Aqua = 65535,
    Aquamarine = 0x007fffd4,
    Azure = 0x00f0ffff,
    Beige = 0x00f5f5dc,
    Bisque = 0x00ffe4c4,
    Black = 0,
    BlanchedAlmond = 0x00ffebcd,
    Blue = 255,
    BlueViolet = 0x008a2be2,
    Brown = 0x00a52a2a,
    BurlyWood = 0x00deb887,
    CadetBlue = 0x005f9ea0,
    Chartreuse = 0x007fff00,
    Chocolate = 0x00d2691e,
    Coral = 0x00ff7f50,
    CornflowerBlue = 0x006495ed,
    Cornsilk = 0x00fff8dc,
    Crimson = 0x00dc143c,
    Cyan = 65535,
    DarkBlue = 139,
    DarkCyan = 35723,
    DarkGoldenrod = 0x00b8860b,
    DarkGray = 0x00a9a9a9,
    DarkGreen = 25600,
    DarkKhaki = 0x00bdb76b,
    DarkMagenta = 0x008b008b,
    DarkOliveGreen = 0x00556b2f,
    DarkOrange = 0x00ff8c00,
    DarkOrchid = 0x009932cc,
    DarkRed = 0x008b0000,
    DarkSalmon = 0x00e9967a,
    DarkSeaGreen = 0x008fbc8f,
    DarkSlateBlue = 0x00483d8b,
    DarkSlateGray = 0x002f4f4f,
    DarkTurquoise = 52945,
    DarkViolet = 0x009400d3,
    DeepPink = 0x00ff1493,
    DeepSkyBlue = 49151,
    DimGray = 0x00696969,
    DodgerBlue = 0x001e90ff,
    Firebrick = 0x00b22222,
    FloralWhite = 0x00fffaf0,
    ForestGreen = 0x00228b22,
    Fuchsia = 0x00ff00ff,
    Gainsboro = 0x00dcdcdc,
    GhostWhite = 0x00f8f8ff,
    Gold = 0x00ffd700,
    Goldenrod = 0x00daa520,
    Gray = 0x00808080,
    Green = 32768,
    GreenYellow = 0x00adff2f,
    Honeydew = 0x00f0fff0,
    HotPink = 0x00ff69b4,
    IndianRed = 0x00cd5c5c,
    Indigo = 0x004b0082,
    Ivory = 0x00fffff0,
    Khaki = 0x00f0e68c,
    Lavender = 0x00e6e6fa,
    LavenderBlush = 0x00fff0f5,
    LawnGreen = 0x007cfc00,
    LemonChiffon = 0x00fffacd,
    LightBlue = 0x00add8e6,
    LightCoral = 0x00f08080,
    LightCyan = 0x00e0ffff,
    LightGoldenrodYellow = 0x00fafad2,
    LightGreen = 0x0090ee90,
    LightGray = 0x00d3d3d3,
    LightPink = 0x00ffb6c1,
    LightSalmon = 0x00ffa07a,
    LightSeaGreen = 0x0020b2aa,
    LightSkyBlue = 0x0087cefa,
    LightSlateGray = 0x00778899,
    LightSteelBlue = 0x00b0c4de,
    LightYellow = 0x00ffffe0,
    Lime = 65280,
    LimeGreen = 0x0032cd32,
    Linen = 0x00faf0e6,
    Magenta = 0x00ff00ff,
    Maroon = 0x00800000,
    MediumAquamarine = 0x0066cdaa,
    MediumBlue = 205,
    MediumOrchid = 0x00ba55d3,
    MediumPurple = 0x009370db,
    MediumSeaGreen = 0x003cb371,
    MediumSlateBlue = 0x007b68ee,
    MediumSpringGreen = 64154,
    MediumTurquoise = 0x0048d1cc,
    MediumVioletRed = 0x00c71585,
    MidnightBlue = 0x00191970,
    MintCream = 0x00f5fffa,
    MistyRose = 0x00ffe4e1,
    Moccasin = 0x00ffe4b5,
    NavajoWhite = 0x00ffdead,
    Navy = 128,
    OldLace = 0x00fdf5e6,
    Olive = 0x00808000,
    OliveDrab = 0x006b8e23,
    Orange = 0x00ffa500,
    OrangeRed = 0x00ff4500,
    Orchid = 0x00da70d6,
    PaleGoldenrod = 0x00eee8aa,
    PaleGreen = 0x0098fb98,
    PaleTurquoise = 0x00afeeee,
    PaleVioletRed = 0x00db7093,
    PapayaWhip = 0x00ffefd5,
    PeachPuff = 0x00ffdab9,
    Peru = 0x00cd853f,
    Pink = 0x00ffc0cb,
    Plum = 0x00dda0dd,
    PowderBlue = 0x00b0e0e6,
    Purple = 0x00800080,
    Red = 0x00ff0000,
    RosyBrown = 0x00bc8f8f,
    RoyalBlue = 0x004169e1,
    SaddleBrown = 0x008b4513,
    Salmon = 0x00fa8072,
    SandyBrown = 0x00f4a460,
    SeaGreen = 0x002e8b57,
    SeaShell = 0x00fff5ee,
    Sienna = 0x00a0522d,
    Silver = 0x00c0c0c0,
    SkyBlue = 0x0087ceeb,
    SlateBlue = 0x006a5acd,
    SlateGray = 0x00708090,
    Snow = 0x00fffafa,
    SpringGreen = 65407,
    SteelBlue = 0x004682b4,
    Tan = 0x00d2b48c,
    Teal = 32896,
    Thistle = 0x00d8bfd8,
    Tomato = 0x00ff6347,
    Turquoise = 0x0040e0d0,
    Violet = 0x00ee82ee,
    Wheat = 0x00f5deb3,
    White = 0x00ffffff,
    WhiteSmoke = 0x00f5f5f5,
    Yellow = 0x00ffff00,
    YellowGreen = 0x009acd32
} D2D1_COLORS;




[
    dllname("D2d1.dll")
]
module D2D1{
    [entry("D2D1CreateFactory"), helpstring("Creates a factory object that can be used to create Direct2D resources.")]
    HRESULT _stdcall D2D1CreateFactory(
                    [in] D2D1_FACTORY_TYPE factoryType,
                    [in] void* riid,
                    [in] void* pFactoryOptions,
                    [out, retval] IUnknown * *ppIFactory);
    [entry("D2D1MakeRotateMatrix"), helpstring("Creates a rotation transformation that rotates by the specified angle about the specified point.")]
    void _stdcall D2D1MakeRotateMatrix(
                    [in] single angle,
                    [in] single centerX,
                    [in] single centerY,
                    [in, out] D2D1_MATRIX_3X2_F* matrix);
    [entry("D2D1MakeSkewMatrix"), helpstring("Creates a skew transformation that has the specified x-axis angle, y-axis angle, and center point.")]
    void _stdcall D2D1MakeSkewMatrix(
                    [in] single angleX,
                    [in] single angleY,
                    [in] single centerX,
                    [in] single centerY,
                    [in, out] D2D1_MATRIX_3X2_F* matrix);
    [entry("D2D1IsMatrixInvertible"), helpstring("Indicates whether the specified matrix is invertible.")]
    long _stdcall D2D1IsMatrixInvertible([in] D2D1_MATRIX_3X2_F* matrix);
    [entry("D2D1InvertMatrix"), helpstring("Tries to invert the specified matrix.")]
    long _stdcall D2D1InvertMatrix([in, out] D2D1_MATRIX_3X2_F* matrix);

    [entry("D2D1CreateDevice")]
    long D2D1CreateDevice([in] IDXGIDevice* dxgiDevice,[in] void* creationProperties,[out] ID2D1Device** d2dDevice);

    [entry("D2D1CreateDeviceContext")]
    long D2D1CreateDeviceContext([in] IDXGISurface* dxgiSurface,[in] void* creationProperties,[out] ID2D1DeviceContext** d2dDeviceContext);

    [entry("D2D1ConvertColorSpace")]
    D2D1_COLOR_F D2D1ConvertColorSpace([in] D2D1_COLOR_SPACE sourceColorSpace,[in] D2D1_COLOR_SPACE destinationColorSpace,[in] D2D1_COLOR_F* color);

    [entry("D2D1SinCos")]
    void D2D1SinCos([in] float angle,[out] float* s,[out] float* c);

    [entry("D2D1Tan")]
    float D2D1Tan([in] float angle);

    [entry("D2D1Vec3Length")]
    float D2D1Vec3Length([in] float x,[in] float y,[in] float z);

    [entry("D2D1ComputeMaximumScaleFactor")]
    float D2D1ComputeMaximumScaleFactor([in] D2D1_MATRIX_3X2_F* matrix);
};

