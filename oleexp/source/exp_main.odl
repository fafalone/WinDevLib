//oleexp main definition file



	typedef enum DROPIMAGETYPE
	{
	  DROPIMAGE_INVALID = -1,
	  DROPIMAGE_NONE = 0,
	  DROPIMAGE_COPY = 1,
	  DROPIMAGE_MOVE = 2,
	  DROPIMAGE_LINK = 4,
	  DROPIMAGE_LABEL = 6,
	  DROPIMAGE_WARNING = 7,
	  DROPIMAGE_NOIMAGE = 8
	} DROPIMAGETYPE;
	typedef struct DROPDESCRIPTION
	{
		DROPIMAGETYPE type;
		WCHAR szMessage[260];
		WCHAR szInsert[260];
	} DROPDESCRIPTION;


typedef enum REPARSE_POINT_TAGS {
	IO_REPARSE_TAG_CSV          = 0x80000009,
	IO_REPARSE_TAG_DEDUP        = 0x80000013,
	IO_REPARSE_TAG_DFS          = 0x8000000A,
	IO_REPARSE_TAG_DFSR         = 0x80000012,
	IO_REPARSE_TAG_HSM          = 0xC0000004,
	IO_REPARSE_TAG_HSM2         = 0x80000006,
	IO_REPARSE_TAG_MOUNT_POINT  = 0xA0000003,
	IO_REPARSE_TAG_NFS          = 0x80000014, //Win8+
	IO_REPARSE_TAG_SIS          = 0x80000007,
	IO_REPARSE_TAG_SYMLINK      = 0xA000000C,
	IO_REPARSE_TAG_WIM          = 0x80000008
} REPARSE_POINT_TAGS;

typedef enum VirtualKeyCodes {
   VK_LBUTTON = 0x1,
   VK_RBUTTON = 0x2,
   VK_CANCEL = 0x3,
   VK_MBUTTON = 0x4,
   VK_BACK = 0x8,
   VK_TAB = 0x9,
   VK_CLEAR = 0xC,
   VK_RETURN = 0xD,
   VK_SHIFT = 0x10,
   VK_CONTROL = 0x11,
   VK_MENU = 0x12,
   VK_PAUSE = 0x13,
   VK_CAPITAL = 0x14,
   VK_ESCAPE = 0x1B,
   VK_SPACE = 0x20,
   VK_PRIOR = 0x21,
   VK_NEXT = 0x22,
   VK_END = 0x23,
   VK_HOME = 0x24,
   VK_LEFT = 0x25,
   VK_UP = 0x26,
   VK_RIGHT = 0x27,
   VK_DOWN = 0x28,
   VK_SELECT = 0x29,
   VK_PRINT = 0x2A,
   VK_EXECUTE = 0x2B,
   VK_SNAPSHOT = 0x2C,
   VK_INSERT = 0x2D,
   VK_DELETE = 0x2E,
   VK_HELP = 0x2F,
   VK_0 = 0x30,
   VK_1 = 0x31,
   VK_2 = 0x32,
   VK_3 = 0x33,
   VK_4 = 0x34,
   VK_5 = 0x35,
   VK_6 = 0x36,
   VK_7 = 0x37,
   VK_8 = 0x38,
   VK_9 = 0x39,
   VK_A = 0x41,
   VK_B = 0x42,
   VK_C = 0x43,
   VK_D = 0x44,
   VK_E = 0x45,
   VK_F = 0x46,
   VK_G = 0x47,
   VK_H = 0x48,
   VK_I = 0x49,
   VK_J = 0x4A,
   VK_K = 0x4B,
   VK_L = 0x4C,
   VK_M = 0x4D,
   VK_N = 0x4E,
   VK_O = 0x4F,
   VK_P = 0x50,
   VK_Q = 0x51,
   VK_R = 0x52,
   VK_S = 0x53,
   VK_T = 0x54,
   VK_U = 0x55,
   VK_V = 0x56,
   VK_W = 0x57,
   VK_X = 0x58,
   VK_Y = 0x59,
   VK_Z = 0x5A,
   VK_STARTKEY = 0x5B,
   VK_CONTEXTKEY = 0x5D,
   VK_NUMPAD0 = 0x60,
   VK_NUMPAD1 = 0x61,
   VK_NUMPAD2 = 0x62,
   VK_NUMPAD3 = 0x63,
   VK_NUMPAD4 = 0x64,
   VK_NUMPAD5 = 0x65,
   VK_NUMPAD6 = 0x66,
   VK_NUMPAD7 = 0x67,
   VK_NUMPAD8 = 0x68,
   VK_NUMPAD9 = 0x69,
   VK_MULTIPLY = 0x6A,
   VK_ADD = 0x6B,
   VK_SEPARATOR = 0x6C,
   VK_SUBTRACT = 0x6D,
   VK_DECIMAL = 0x6E,
   VK_DIVIDE = 0x6F,
   VK_F1 = 0x70,
   VK_F2 = 0x71,
   VK_F3 = 0x72,
   VK_F4 = 0x73,
   VK_F5 = 0x74,
   VK_F6 = 0x75,
   VK_F7 = 0x76,
   VK_F8 = 0x77,
   VK_F9 = 0x78,
   VK_F10 = 0x79,
   VK_F11 = 0x7A,
   VK_F12 = 0x7B,
   VK_F13 = 0x7C,
   VK_F14 = 0x7D,
   VK_F15 = 0x7E,
   VK_F16 = 0x7F,
   VK_F17 = 0x80,
   VK_F18 = 0x81,
   VK_F19 = 0x82,
   VK_F20 = 0x83,
   VK_F21 = 0x84,
   VK_F22 = 0x85,
   VK_F23 = 0x86,
   VK_F24 = 0x87,
   VK_NUMLOCK = 0x90,
   VK_OEM_SCROLL = 0x91,
   VK_OEM_1 = 0xBA,
   VK_OEM_PLUS = 0xBB,
   VK_OEM_COMMA = 0xBC,
   VK_OEM_MINUS = 0xBD,
   VK_OEM_PERIOD = 0xBE,
   VK_OEM_2 = 0xBF,
   VK_OEM_3 = 0xC0,
   VK_OEM_4 = 0xDB,
   VK_OEM_5 = 0xDC,
   VK_OEM_6 = 0xDD,
   VK_OEM_7 = 0xDE,
   VK_OEM_8 = 0xDF,
   VK_ICO_F17 = 0xE0,
   VK_ICO_F18 = 0xE1,
   VK_OEM102 = 0xE2,
   VK_ICO_HELP = 0xE3,
   VK_ICO_00 = 0xE4,
   VK_ICO_CLEAR = 0xE6,
   VK_OEM_RESET = 0xE9,
   VK_OEM_JUMP = 0xEA,
   VK_OEM_PA1 = 0xEB,
   VK_OEM_PA2 = 0xEC,
   VK_OEM_PA3 = 0xED,
   VK_OEM_WSCTRL = 0xEE,
   VK_OEM_CUSEL = 0xEF,
   VK_OEM_ATTN = 0xF0,
   VK_OEM_FINNISH = 0xF1,
   VK_OEM_COPY = 0xF2,
   VK_OEM_AUTO = 0xF3,
   VK_OEM_ENLW = 0xF4,
   VK_OEM_BACKTAB = 0xF5,
   VK_ATTN = 0xF6,
   VK_CRSEL = 0xF7,
   VK_EXSEL = 0xF8,
   VK_EREOF = 0xF9,
   VK_PLAY = 0xFA,
   VK_ZOOM = 0xFB,
   VK_NONAME = 0xFC,
   VK_PA1 = 0xFD,
   VK_OEM_CLEAR = 0xFE
} VirtualKeyCodes;







[
    odl,
    uuid(fe0b6665-e0ca-49b9-a178-2b5cb48d92a5)
]
interface IStreamAsync : IStream
{
    HRESULT ReadAsync(
		[out] void *pv, 
		[in] DWORD cb, 
		[out] LONG *pcbRead,
		[in] LONG lpOverlapped);
		//[in] LPOVERLAPPED lpOverlapped);

    HRESULT WriteAsync(
		[in] void *lpBuffer, 
		[in] DWORD cb, 
		[out] LONG *pcbWritten, 
		[in] LONG lpOverlapped);
		/*[in] LPOVERLAPPED lpOverlapped);*/

    HRESULT OverlappedResult(
		[in] LONG lpOverlapped, //LPOVERLAPPED
		[out] LONG *lpNumberOfBytesTransferred, 
		[in] BOOL bWait);

    HRESULT CancelIo();
};


[
	odl,
    uuid(d0191542-7954-4908-bc06-b2360bbe45ba)
]
interface IEnumFullIDList : stdole.IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out] PIDLIST_ABSOLUTE *rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumFullIDList **ppenum);
};


typedef enum SV3CVW3_FLAGS
    {
        SV3CVW3_DEFAULT             = 0x00000000,
        SV3CVW3_NONINTERACTIVE      = 0x00000001,    // Instead of bringing up UI, fail silently.
        SV3CVW3_FORCEVIEWMODE       = 0x00000002,    // Prefer view mode set by CreateViewWindow3 over saved view state
        SV3CVW3_FORCEFOLDERFLAGS    = 0x00000004,    // Prefer folder flags set by CreateViewWindow3 over saved view state
    } SV3CVW3_FLAGS;
[
	odl,
    uuid(ec39fa88-f8af-41c5-8421-38bed28f4673)
]
interface IShellView3 :  IShellView2
{

    HRESULT CreateViewWindow3(
        [in] IShellBrowser *psbOwner,
        [in] IShellView *psvPrev,
        [in] SV3CVW3_FLAGS dwViewFlags,
        [in] FOLDERFLAGS dwMask,
        [in] FOLDERFLAGS dwFlags,
        [in] FOLDERVIEWMODE fvMode,
        [in] UUID *pvid,
        [in] RECT *prcView,
        [out] HWND *phwndView);
}

typedef enum CDBOSC_FLAGS {
	CDBOSC_SETFOCUS    = 0x00000000,
	CDBOSC_KILLFOCUS   = 0x00000001,
	CDBOSC_SELCHANGE   = 0x00000002,
	CDBOSC_RENAME      = 0x00000003,
	CDBOSC_STATECHANGE = 0x00000004
} CBDOSC_FLAGS;

[
	odl,
    uuid(000214F1-0000-0000-C000-000000000046)
]
interface ICommDlgBrowser : stdole.IUnknown
{
    HRESULT OnDefaultCommand([in] IShellView *ppshv);

    HRESULT OnStateChange(
        [in] IShellView *ppshv,
        [in] ULONG uChange);

    HRESULT IncludeObject(
        [in] IShellView *ppshv,
        [in] PCUITEMID_CHILD pidl);
};

typedef enum CDB2N_TYPES {
	CDB2N_CONTEXTMENU_DONE  =0x00000001,
	CDB2N_CONTEXTMENU_START =0x00000002
} CB2DN_TYPES;

//GetViewFlags
typedef enum CDB2GVF_FLAGS {
	CDB2GVF_SHOWALLFILES       = 0x00000001,
	CDB2GVF_ISFILESAVE         = 0x00000002, // is file save, else file open")
	CDB2GVF_ALLOWPREVIEWPANE   = 0x00000004,
	CDB2GVF_NOSELECTVERB       = 0x00000008,
	CDB2GVF_NOINCLUDEITEM      = 0x00000010,
	CDB2GVF_ISFOLDERPICKER     = 0x00000020,
	CDB2GVF_ADDSHIELD          = 0x00000040   // when CDB2GVF_NOSELECTVERB is not specified this flag controls the display of a LUA shield on the Select menu item") 
} CDB2GVF_FLAGS;

[
	odl,
    uuid(10339516-2894-11d2-9039-00C04F8EEB3E)
]
interface ICommDlgBrowser2 : ICommDlgBrowser
{
    HRESULT Notify(
        [in] IShellView *ppshv,
        [in] DWORD dwNotifyType);

    HRESULT GetDefaultMenuText(
        [in] IShellView *ppshv,
        [in] LONG pszText,
        [in] int cchMax);

    // returns CDB2GVF_XXX values to control the behavior of the view when in common dialog mode
    HRESULT GetViewFlags([out] CDB2GVF_FLAGS *pdwFlags);
};
[
	odl,
    uuid(c8ad25a1-3294-41ee-8165-71174bd01c57)
]
interface ICommDlgBrowser3 : ICommDlgBrowser2
{
    HRESULT OnColumnClicked(
        [in] IShellView *ppshv,
        [in] int iColumn);

    HRESULT GetCurrentFilter(
        [in] LONG pszFileSpec,
        [in] int cchFileSpec);

    HRESULT OnPreViewCreated([in] IShellView *ppshv);
};

typedef enum CM_MASK
{
    CM_MASK_WIDTH           = 0x00000001,
    CM_MASK_DEFAULTWIDTH    = 0x00000002,
    CM_MASK_IDEALWIDTH      = 0x00000004,
    CM_MASK_NAME            = 0x00000008,
    CM_MASK_STATE           = 0x00000010,
} CM_MASK;

typedef enum CM_STATE
{
    CM_STATE_NONE               = 0x00000000,
    CM_STATE_VISIBLE            = 0x00000001,  // The column is visible
    CM_STATE_FIXEDWIDTH         = 0x00000002,  // Can't resize the column
    CM_STATE_NOSORTBYFOLDERNESS = 0x00000004,  // Do not sort folders seperately
    CM_STATE_ALWAYSVISIBLE      = 0x00000008,  // readonly. column cannot be hidden
} CM_STATE;

typedef enum CM_ENUM_FLAGS
{
    CM_ENUM_ALL          = 0x00000001,
    CM_ENUM_VISIBLE      = 0x00000002,
} CM_ENUM_FLAGS;

typedef enum CM_SET_WIDTH_VALUE
{
    CM_WIDTH_USEDEFAULT  = -1,
    CM_WIDTH_AUTOSIZE    = -2,
} CM_SET_WIDTH_VALUE;

#define MAX_COLUMN_NAME_LEN 80

typedef struct CM_COLUMNINFO
{
    DWORD cbSize;  // size in bytes of struct
    CM_MASK dwMask;  // CM_MASK
    CM_STATE dwState; // CM_STATE
    UINT uWidth;   // CM_MASK_WIDTH, for SetColumnInfo it can be a CM_SET_WIDTH_VALUE
    UINT uDefaultWidth; // CM_MASK_DEFAULTWIDTH
    UINT uIdealWidth; // CM_MASK_IDEALWIDTH
    WCHAR wszName[MAX_COLUMN_NAME_LEN];
} CM_COLUMNINFO;

[
	odl,
    uuid(d8ec27bb-3f3b-4042-b10a-4acfd924d453)
]
interface IColumnManager : stdole.IUnknown
{
    HRESULT SetColumnInfo(
        [in] REFPROPERTYKEY propkey,
        [in] CM_COLUMNINFO *pcmci);

    HRESULT GetColumnInfo(
        [in] REFPROPERTYKEY propkey,
        [out] CM_COLUMNINFO *pcmci);

    HRESULT GetColumnCount(
        [in] CM_ENUM_FLAGS dwFlags,
        [out] UINT *puCount);

    HRESULT GetColumns(
        [in] CM_ENUM_FLAGS dwFlags,
        [out] PROPERTYKEY *rgkeyOrder,
        [in] UINT cColumns);

    HRESULT SetColumns(
        [in] PROPERTYKEY *rgkeyOrder,
        [in] UINT cVisible);
}
typedef enum THUMBBUTTONFLAGS
{
    THBF_ENABLED        =   0x00000000,
    THBF_DISABLED       =   0x00000001,
    THBF_DISMISSONCLICK =   0x00000002,
    THBF_NOBACKGROUND   =   0x00000004,
    THBF_HIDDEN         =   0x00000008,
    THBF_NONINTERACTIVE =   0x00000010,
} THUMBBUTTONFLAGS;

typedef enum THUMBBUTTONMASK
{
    THB_BITMAP          =   0x00000001,
    THB_ICON            =   0x00000002,
    THB_TOOLTIP         =   0x00000004,
    THB_FLAGS           =   0x00000008,
} THUMBBUTTONMASK;
//cpp_quote("#include <pshpack8.h>")

typedef struct THUMBBUTTON
{
    THUMBBUTTONMASK  dwMask;
    UINT    iId;
    UINT    iBitmap;
    LONG    hIcon;
    WCHAR   szTip[260];
    THUMBBUTTONFLAGS  dwFlags;
} THUMBBUTTON;

// Flags for Setting Taskbar Progress state
typedef enum TBPFLAG
{
    TBPF_NOPROGRESS     = 0x00000000,
    TBPF_INDETERMINATE  = 0x00000001,
    TBPF_NORMAL         = 0x00000002,
    TBPF_ERROR          = 0x00000004,
    TBPF_PAUSED         = 0x00000008,
} TBPFLAG;


[
	odl,
    uuid(ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf)
]
interface ITaskbarList3 : ITaskbarList2
{
    HRESULT SetProgressValue(
        [in] LONG hwnd,
        [in] CURRENCY ullCompleted,
        [in] CURRENCY ullTotal);

    HRESULT SetProgressState(
        [in] LONG hwnd,
        [in] TBPFLAG tbpFlags);

    HRESULT RegisterTab(
        [in] LONG hwndTab,
        [in] LONG hwndMDI);

    HRESULT UnregisterTab(
        [in] LONG hwndTab);

    HRESULT SetTabOrder(
        [in] LONG hwndTab,
        [in] LONG hwndInsertBefore);

    HRESULT SetTabActive(
        [in] LONG hwndTab,
        [in] LONG hwndMDI,
        [in] LONG dwReserved);

	[helpstring("pButton = VarPtr(buttonarray(0)")]
    HRESULT ThumbBarAddButtons(
        [in] LONG hwnd,
        [in] UINT cButtons,
        [in] LONG pButton);

	[helpstring("pButton = VarPtr(buttonarray(0)")]
    HRESULT ThumbBarUpdateButtons(
        [in] LONG hwnd,
        [in] UINT cButtons,
        [in] LONG pButton);

    HRESULT ThumbBarSetImageList(
        [in] LONG hwnd,
        [in] LONG himl);

    HRESULT SetOverlayIcon(
        [in] LONG hwnd, 
        [in] LONG hIcon,
        [in] LPCWSTR pszDescription);

    HRESULT SetThumbnailTooltip(
        [in] LONG hwnd, 
        [in] LPCWSTR pszTip);

    HRESULT SetThumbnailClip(
        [in] LONG hwnd, 
        [in] RECT *prcClip);
}

    // Flags for Setting Tab Properties 
typedef enum STPFLAG
{
    STPF_NONE                       = 0x00000000,
    STPF_USEAPPTHUMBNAILALWAYS      = 0x00000001,
    STPF_USEAPPTHUMBNAILWHENACTIVE  = 0x00000002,
    STPF_USEAPPPEEKALWAYS           = 0x00000004,
    STPF_USEAPPPEEKWHENACTIVE       = 0x00000008,
} STPFLAG;
[
	odl,
    uuid(c43dc798-95d1-4bea-9030-bb99e2983a1a)
]
interface ITaskbarList4 : ITaskbarList3
{

    HRESULT SetTabProperties(
        [in] LONG hwndTab,
        [in] STPFLAG stpFlags);
}

typedef enum SIIGBF {
    SIIGBF_RESIZETOFIT = 0x00,
    SIIGBF_BIGGERSIZEOK = 0x01,
    SIIGBF_MEMORYONLY = 0x02,
    SIIGBF_ICONONLY = 0x04,
    SIIGBF_THUMBNAILONLY = 0x08,
    SIIGBF_INCACHEONLY = 0x10,
	//Windows 8+
	SIIGBF_CROPTOSQUARE = 0x20,
	SIIGBF_WIDETHUMBNAILS = 0x40,
	SIIGBF_ICONBACKGROUND = 0x80,
	SIIGBF_SCALEUP = 0x100,
} SIIGBF;

typedef enum SICHINTF { 
  SICHINT_DISPLAY                        = 0x00000000,
  SICHINT_ALLFIELDS                      = 0x80000000,
  SICHINT_CANONICAL                      = 0x10000000,
  SICHINT_TEST_FILESYSPATH_IF_NOT_EQUAL  = 0x20000000
} SICHINTF;


[
	odl,
	uuid(43826D1E-E718-42EE-BC55-A1E261C37BFE)
]
interface IShellItem : stdole.IUnknown {
	long BindToHandler(
		[in] LONG pbc, //IBindCtx *pbc, --rare; can accept ObtPtr(bindctx) instead
		[in] UUID* rbhid,
		[in] UUID* riid,
		[in, out] LPVOID ppvOut);

	long GetParent(
		[in, out] IShellItem** ppsi);

	long GetDisplayName(
		[in] SIGDN sigdnName,
		[out] LONG* ppszName);
		
	long GetAttributes(
		[in] SFGAO_Flags sfgaoMask,
		[in, out] SFGAO_Flags* psfgaoAttribs);
		
	long Compare(
		[in] IShellItem* psi,
		[in] SICHINTF hint,
		[in, out] LONG* piOrder);

};


[
	odl,
    uuid(7e9fb0d3-919f-4307-ab2e-9b1860310c93)
]
interface IShellItem2 : IShellItem
{
    long GetPropertyStore(
        [in] GETPROPERTYSTOREFLAGS flags,
        [in] UUID* riid,
        [in, out] LPVOID ppv);

    long GetPropertyStoreWithCreateObject(
        [in] GETPROPERTYSTOREFLAGS flags,
        [in] IUnknown *punkCreateObject,   // factory for low-rights creation of type ICreateObject
        [in] UUID* riid,
        [in, out] LPVOID ppv);

    long GetPropertyStoreForKeys(
        [in] PROPERTYKEY *rgKeys,
        [in] LONG cKeys,
        [in] GETPROPERTYSTOREFLAGS flags,
        [in] UUID* riid,
        [in, out] LPVOID ppv);

    long GetPropertyDescriptionList(
        [in] PROPERTYKEY *keyType,
        [in] UUID* riid,
        [in, out] LPVOID ppv);

    // Ensures any cached information in this item is up to date, or returns __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if the item does not exist.
    long Update([in] IBindCtx *pbc);

    long GetProperty(
        [in] PROPERTYKEY *key,
        [out] VARIANT *ppropvar);

    long GetCLSID(
        [in] PROPERTYKEY *key,
        [out] CLSID *pclsid);

    long GetFileTime(
        [in] PROPERTYKEY *key,
        [out] FILETIME *pft);

    long GetInt32(
        [in] PROPERTYKEY *key,
        [out] int *pi);

    long GetString(
        [in] PROPERTYKEY *key,
        [out] LONG *ppsz); // LPWSTR *ppsz

    long GetUInt32(
        [in] PROPERTYKEY *key,
        [out] ULONG *pui);

    long GetUInt64(
        [in] PROPERTYKEY *key,
        [out] CURRENCY *pull);

    long GetBool(
        [in] PROPERTYKEY *key,
        [out] BOOL *pf);
};
[
	odl,
	uuid(bcc18b79-ba16-442f-80c4-8a59c30c463b)
]
interface IShellItemImageFactory : stdole.IUnknown {
	long GetImage(
		//[in] SIZE* size,
		[in] LONG cx,
		[in] LONG cy,
		[in] SIIGBF flags,
		[out] HBITMAP *phbm);
};

typedef enum FILE_USAGE_TYPE
{
    FUT_PLAYING,
    FUT_EDITING,
    FUT_GENERIC
} FILE_USAGE_TYPE;

typedef enum FileInUseCapabilities
{
    OF_CAP_CANSWITCHTO    = 0x0001,
    OF_CAP_CANCLOSE       = 0x0002
} FileInUseCapabilities;
[
	odl,
    uuid(64a1cbf0-3a1a-4461-9158-376969693950)
]
interface IFileIsInUse : stdole.IUnknown
{
    HRESULT GetAppName([in, out] LONG *ppszName);

    HRESULT GetUsage([in, out] FILE_USAGE_TYPE *pfut);

    HRESULT GetCapabilities([in, out] FileInUseCapabilities *pdwCapFlags);

    HRESULT GetSwitchToHWND([in, out] HWND *phwnd);

    HRESULT CloseFile();
}

typedef enum MENUPOPUPPOPUPFLAGS
    {
        MPPF_SETFOCUS        = 0x00000001,    // Menu can take the focus
        MPPF_INITIALSELECT   = 0x00000002,    // Select the first item
        MPPF_NOANIMATE       = 0x00000004,    // Do not animate this show
        MPPF_KEYBOARD        = 0x00000010,    // The menu is activated by keyboard
        MPPF_REPOSITION      = 0x00000020,    // Resposition the displayed bar.
        MPPF_FORCEZORDER     = 0x00000040,    // internal: Tells menubar to ignore Submenu positions
        MPPF_FINALSELECT     = 0x00000080,    // Select the last item
        MPPF_TOP             = 0x20000000,    // Popup menu up from point
        MPPF_LEFT            = 0x40000000,    // Popup menu left from point
        MPPF_RIGHT           = 0x60000000,    // Popup menu right from point
        MPPF_BOTTOM          = 0x80000000, // Popup menu below point
        MPPF_POS_MASK        = 0xE0000000, // Menu Position Mask
        MPPF_ALIGN_LEFT      = 0x02000000,    // Default alignment
        MPPF_ALIGN_RIGHT     = 0x04000000     // Popup menu aligned to right of exclude rect
    } MENUPOPUPPOPUPFLAGS;
typedef enum MENUPOPUPSELECT
    {
        MPOS_EXECUTE = 0,           // Execute the selected menu item
        MPOS_FULLCANCEL,            // Cancel the entire menu
        MPOS_CANCELLEVEL,           // Cancel the current cascaded menu
        MPOS_SELECTLEFT,            // select one to the left of the cur selection
        MPOS_SELECTRIGHT,           // select one to the right of the cur selection
        MPOS_CHILDTRACKING          // the child got a tracking select (mouse moved over)
    } MENUPOPUPSELECT;

[
    odl,
        uuid(EB0FE173-1A3A-11D0-89B3-00A0C90A90AC)
]
interface IDeskBar : IOleWindow
{ 
    HRESULT   SetClient(
        /* [annotation][unique][in] */
        [in]  IUnknown* punkClient);

      HRESULT   GetClient(
        /* [annotation][out] */
       [in,out]  IUnknown** ppunkClient);

      HRESULT   OnPosRectChangeDB(
        /* [annotation][in] */
        [in]  RECT* prc);

};

typedef enum MP_POPUPFLAGS
{
    MPPF_SETFOCUS = 0x1,
    MPPF_INITIALSELECT = 0x2,
    MPPF_NOANIMATE = 0x4,
    MPPF_KEYBOARD = 0x10,
    MPPF_REPOSITION = 0x20,
    MPPF_FORCEZORDER = 0x40,
    MPPF_FINALSELECT = 0x80,
    MPPF_TOP = 0x20000000,
    MPPF_LEFT = 0x40000000,
    MPPF_RIGHT = 0x60000000,
    MPPF_BOTTOM = 0x80000000,
    MPPF_POS_MASK = 0xe0000000,
    MPPF_ALIGN_LEFT = 0x2000000,
    MPPF_ALIGN_RIGHT = 0x4000000
} MP_POPUPFLAGS;

[
    odl,
    uuid(D1E7AFEB-6A2E-11d0-8C78-00C04FD918B4) 
]
interface IMenuPopup : IDeskBar
{
    // Type values for IMenuPopup::OnSelect

 
    HRESULT Popup(
        [in] POINT* ppt,
        [in] RECT* prcExclude,
        [in] MP_POPUPFLAGS dwFlags);

    HRESULT OnSelect([in] MENUPOPUPSELECT dwSelectType);

    HRESULT SetSubMenu(
        [in] IMenuPopup* pmp,
        [in] BOOL fSet);
}



    typedef enum LIBRARYFOLDERFILTER
    {
        LFF_FORCEFILESYSTEM       = 1,  // Return only file system items.
        LFF_STORAGEITEMS          = 2,  // Return any items that can be bound to an IStorage. (default)
        LFF_ALLITEMS              = 3,  // Return all items.
    } LIBRARYFOLDERFILTER;

    typedef enum LIBRARYOPTIONFLAGS
    {
        LOF_DEFAULT          = 0x00000000,
        LOF_PINNEDTONAVPANE  = 0x00000001,  // Specifies that this library is pinned to the navigation pane.
        LOF_MASK_ALL         = 0x00000001,
    } LIBRARYOPTIONFLAGS;

    typedef enum DEFAULTSAVEFOLDERTYPE
    {
        DSFT_DETECT = 1,  // Specifies the save folder for the current user depending on whether or not they are the owner of the library
        DSFT_PRIVATE,     // Specifies the private save folder for the owner of the library
        DSFT_PUBLIC,      // Specifies the public save folder for non-owners of the library
    } DEFAULTSAVEFOLDERTYPE;

    typedef enum LIBRARYSAVEFLAGS
    {
        LSF_FAILIFTHERE         = 0x00000000,   // if a library with the same name exists fail to save
        LSF_OVERRIDEEXISTING    = 0x00000001,   // will override existing library with the same name if there or create a new one if not
        LSF_MAKEUNIQUENAME      = 0x00000002,   // if a library with the same name exists create a unique name by adding a number in parenthesis
    } LIBRARYSAVEFLAGS;

    typedef enum SIATTRIBFLAGS
    {
        SIATTRIBFLAGS_AND               = 0x00000001, // if multiple items and the attirbutes together.
        SIATTRIBFLAGS_OR                = 0x00000002, // if multiple items or the attributes together.
        SIATTRIBFLAGS_APPCOMPAT         = 0x00000003, // Call GetAttributes directly on the ShellFolder for multiple attributes
        SIATTRIBFLAGS_MASK              = 0x00000003, // for the AND/OR/APPCOMPAT value
        SIATTRIBFLAGS_ALLITEMS          = 0x00004000, // normally only the first few items are used to compute the attributes, pass this to force all of them
                                                      // doing all will result in poor performance for large arrays so use this carefuly
    } SIATTRIBFLAGS;
    

     


// Shell Namespace enumerator
[
	odl,
    uuid(70629033-e363-4a28-a567-0db78006e6d7),
]
interface IEnumShellItems : stdole.IUnknown
{
    //[local]
    long Next(
        [in] LONG celt,
        [out] IShellItem **rgelt,
        [out] LONG *pceltFetched);

    //[call_as(Next)]
    //long RemoteNext(
    //    [in] LONG celt,
    //    [out] IShellItem **rgelt,
    //    [out] LONG *pceltFetched);

    HRESULT Skip([in] LONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumShellItems **ppenum);
    //use same as IEnumIDList
};		    


[
	odl,
    uuid(b63ea76d-1f85-456f-a19c-48159efa858b),
]
interface IShellItemArray : stdole.IUnknown
{

    //cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(SIATTRIBFLAGS)")  // some bits are flags, others are not

    // bhid values supported for the handler type are defined in shlguid.h
    // BHID_DataObject - IDataObject, only works for flat data objects or item arrays produced directly using SHCreateShellItemArrayFromDataObject()
    // BHID_AssociationArray - IQueryAssociations from the first item in the array
    // BHID_SFUIObject - only works for flat (items in the same folder) item array
    HRESULT BindToHandler(
						[in] LONG pbc, 
						[in] UUID* bhid, 
						[in] UUID* riid,
						[in, out] LPVOID ppvOut);
						//[out, iid_is(riid)] void **ppvOut);

    HRESULT GetPropertyStore(
							[in] GETPROPERTYSTOREFLAGS flags, 
							[in] UUID* riid, 
							[in, out] LPVOID ppv);
							//[out, iid_is(riid)] void **ppv);

    HRESULT GetPropertyDescriptionList(
							[in] REFPROPERTYKEY keyType, 
							[in] UUID* riid, 
							[in, out] LPVOID ppv);
							//[out, iid_is(riid)] void **ppv);

    // get the attributes for the items using different methods defined by SIATTRIBFLAGS
    HRESULT GetAttributes(
							[in] SIATTRIBFLAGS AttribFlags, 
							[in] SFGAO_Flags sfgaoMask, 
							[out] SFGAO_Flags *psfgaoAttribs);

    HRESULT GetCount([out] LONG *pdwNumItems);

    HRESULT GetItemAt([in] LONG dwIndex, [out] IShellItem **ppsi);

    HRESULT EnumItems([out] IEnumShellItems **ppenumShellItems);
};    
[
	odl,
    uuid(11a66efa-382e-451a-9234-1e0e12ef3085)
]
interface IShellLibrary : stdole.IUnknown
{
    
    long LoadLibraryFromItem([in] IShellItem *psiLibrary, [in] LONG grfMode);
	long LoadLibraryFromKnownFolder([in] UUID* kfidLibrary, [in] LONG grfMode);

	long AddFolder([in] IShellItem *psiLocation);
	long RemoveFolder([in] IShellItem *psiLocation);

    // may return S_FALSE if some folders were omitted due to errors during enumeration
	long GetFolders(
        [in] LIBRARYFOLDERFILTER lff,
        [in] UUID* riid,
        [in, out] LPVOID ppv);
        //[out] LPVOID **ppv); // returns IShellItemArray

    // returns S_FALSE if no resolution was necessary; resolved folder will not be saved until Save[InKnownFolder] or Commit is called
	long ResolveFolder(
        [in] IShellItem *psiFolderToResolve,
        [in] LONG dwTimeout,
        [in] UUID* riid,
        [in, out] LPVOID ppv); // returns IShellItem

	long GetDefaultSaveFolder(
        [in] DEFAULTSAVEFOLDERTYPE dsft,
        [in] UUID* riid,
        [in, out] IShellItem **ppv);
        //[in, out] void **ppv); // returns IShellItem

	long SetDefaultSaveFolder([in] DEFAULTSAVEFOLDERTYPE dsft, [in] IShellItem *psi);

	long GetOptions([out] LIBRARYOPTIONFLAGS *plofOptions);
	long SetOptions([in] LIBRARYOPTIONFLAGS lofMask, [in] LIBRARYOPTIONFLAGS lofOptions);

	long GetFolderType([out] UUID *pftid); //FOLDERTYPEID
	long SetFolderType([in] UUID* ftid); //REFFOLDERTYPEID

    //HRESULT GetIcon([out] LPWSTR *ppszIcon);
	long GetIcon([out] long *ppszIcon);
	long SetIcon([in] long pszIcon);

	long Commit();

	long Save(
        [in] IShellItem *psiFolderToSaveIn, 
        [in] long pszLibraryName,    // name without an extension LPCWSTR
        [in] LIBRARYSAVEFLAGS lsf, 
        [out] IShellItem **ppsiSavedTo);

	long SaveInKnownFolder(
        [in] UUID* kfidToSaveIn, //REFKNOWNFOLDERID
        [in] long pszLibraryName,    // name without an extension LPCWSTR
        [in] LIBRARYSAVEFLAGS lsf, 
        [out] IShellItem **ppsiSavedTo);
};





typedef enum TRANSFER_SOURCE_FLAGS
{
    TSF_NORMAL                      = 0x0000,
    TSF_FAIL_EXIST                  = 0x0000,   // Fail if destination already exists
    TSF_RENAME_EXIST                = 0x0001,   // Rename with auto-name generation if destination already exists
    TSF_OVERWRITE_EXIST             = 0x0002,   // Overwrite/Merge with destination
    TSF_ALLOW_DECRYPTION            = 0x0004,   // Allow creation of decrypted destination
    TSF_NO_SECURITY                 = 0x0008,   // Without DACL/SACL/Owner
    TSF_COPY_CREATION_TIME          = 0x0010,   // Copy the creation time as part of the copy (useful for move as copy/delete)
    TSF_COPY_WRITE_TIME             = 0x0020,   // Copy the last write time as part of the copy
    TSF_USE_FULL_ACCESS             = 0x0040,   // Open a file with write, read, or delete as share mode
    TSF_DELETE_RECYCLE_IF_POSSIBLE  = 0x0080,   // Recycle if possible
    TSF_COPY_HARD_LINK              = 0x0100,   // Hard link desired (not required)
    TSF_COPY_LOCALIZED_NAME         = 0x0200,   // Copy localized name
    TSF_MOVE_AS_COPY_DELETE         = 0x0400,   // We are doing a move operation, but we are doing it as a copy/delete
    TSF_SUSPEND_SHELLEVENTS         = 0x0800,   // suspend shell events
} TRANSFER_SOURCE_FLAGS;




//typedef enum SNCF {
//	SNCF_REFRESHLIST = 0x00000001  // refresh the list (eg. from F5 or opening a folder)")
//} SNCF;

typedef enum PDMODE
    {
        PDM_DEFAULT        = 0x00000000,
        PDM_RUN            = 0x00000001,       // Operation is running
        PDM_PREFLIGHT      = 0x00000002,       // Pre-flight mode, calculating operation time, etc
        PDM_UNDOING        = 0x00000004,       // Operation is rolling back, undo has been selected
        PDM_ERRORSBLOCKING = 0x00000008,       // Only errors remain, error dialogs are blocking progress from completing
        PDM_INDETERMINATE  = 0x00000010,       // The length of the operation is indeterminate, don't show a timer, progressbar is in marquee mode
    } PDMODE;
//typedef DWORD PDMODE;

typedef enum PDOPSTATUS
    {
        PDOPS_RUNNING   = 1,       // Operation is running, no user intervention
        PDOPS_PAUSED    = 2,       // Operation has been paused by the user
        PDOPS_CANCELLED = 3,       // Operation has been cancelled by the user - now go undo
        PDOPS_STOPPED   = 4,       // Operation has been stopped by the user - terminate completely
        PDOPS_ERRORS    = 5,       // Operation has gone as far as it can without throwing error dialogs
    } PDOPSTATUS;
    
typedef enum OPPROGDLGF
{
    // The flag space includes OPPROGDLG_ and PROGDLG_ values
    // please guarantee they don't conflict. See shlobj.w for PROGDLG_*
    OPPROGDLG_DEFAULT               = 0x00000000,
	OPPROGDLG_NORMAL = 0x00000000,      // default normal progress dlg behavior
	OPPROGDLG_MODAL = 0x00000001,      // the dialog is modal to its hwndParent (default is modeless)
	OPPROGDLG_AUTOTIME = 0x00000002,      // automatically updates the "Line3" text with the "time remaining" (you cant call SetLine3 if you passs this!)
	OPPROGDLG_NOTIME = 0x00000004,      // we dont show the "time remaining" if this is set. We need this if dwTotal < dwCompleted for sparse files
	OPPROGDLG_NOMINIMIZE = 0x00000008,      // Do not have a minimize button in the caption bar.
	OPPROGDLG_NOPROGRESSBAR = 0x00000010,      // Don't display the progress bar
	OPPROGDLG_MARQUEEPROGRESS = 0x00000020,      // Use marquee progress (comctl32 v6 required)
	OPPROGDLG_NOCANCEL = 0x00000040,      // No cancel button (operation cannot be canceled) (use sparingly)
	OPPROGDLG_ENABLEPAUSE = 0x00000080,   // Add a pause button (operation can be paused)
    OPPROGDLG_ALLOWUNDO             = 0x00000100,   // The operation can be undone in the dialog.  (The Stop button becomes Undo)
    OPPROGDLG_DONTDISPLAYSOURCEPATH = 0x00000200,   // Don't display the path of source file in progress dialog
    OPPROGDLG_DONTDISPLAYDESTPATH   = 0x00000400,   // Don't display the path of destination file in progress dialog
    OPPROGDLG_NOMULTIDAYESTIMATES   = 0x00000800,   // deprecated - progress dialog no longer displays > 1 day estimates
    OPPROGDLG_DONTDISPLAYLOCATIONS  = 0x00001000,   // Don't display the location line in the progress dialog
} OPPROGDLGF;

//typedef DWORD OPPROGDLGF;
// Shell Operations Engine Progress Dialog
[
	odl,
    uuid(0C9FB851-E5C9-43EB-A370-F0677B13874C),
]
interface IOperationsProgressDialog : stdole.IUnknown
{

    HRESULT StartProgressDialog([in] LONG hwndOwner, [in] OPPROGDLGF flags);

    HRESULT StopProgressDialog();

    // Sets which operation is occuring, and whether we are in pre-flight or undo mode - sets animations, text, etc.
    HRESULT SetOperation([in] SPACTION action);

    HRESULT SetMode([in] PDMODE mode);

    HRESULT UpdateProgress(
       [in] CURRENCY ullPointsCurrent,     // Progress (in points) we are currently at
       [in] CURRENCY ullPointsTotal,       // Progress (in points) to go to timer
       [in] CURRENCY ullSizeCurrent,       // Progress (in bytes) we are currently at
       [in] CURRENCY ullSizeTotal,         // Progress (in bytes) total
       [in] CURRENCY ullItemsCurrent,      // Progress (in # of items) we are currently at
       [in] CURRENCY ullItemsTotal);       // Progress (in # of items) total

    // Used to generate display for "from <item (path)> to <item (path)>", etc.
    HRESULT UpdateLocations(
        [in] IShellItem *psiSource,
        [in] IShellItem *psiTarget,
        [in] IShellItem *psiItem);

    HRESULT ResetTimer();

    HRESULT PauseTimer();

    HRESULT ResumeTimer();

    HRESULT GetMilliseconds([out] CURRENCY *pullElapsed, [out] CURRENCY *pullRemaining);

    // Returns running/paused/cancelled, etc.
    HRESULT GetOperationStatus([out] PDOPSTATUS *popstatus);
}
[
    odl,
    uuid(04b0f1a7-9490-44bc-96e1-4296a31252e2)
]
interface IFileOperationProgressSink : stdole.IUnknown
{
    HRESULT StartOperations();

    HRESULT FinishOperations(
        [in] LONG hrResult);

    HRESULT PreRenameItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        //[in] LPWSTR pszNewName);
		[in] LONG pszNewName);
    HRESULT PostRenameItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        //[in] LPCWSTR pszNewName,
		[in] LONG pszNewName,
        [in] LONG hrRename,
        [in] IShellItem *psiNewlyCreated);

    HRESULT PreMoveItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        //[in] LPCWSTR pszNewName);
		[in] LONG pszNewName);

    HRESULT PostMoveItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        //[in] LPCWSTR pszNewName,
		[in] LONG pszNewName,
        [in] LONG hrMove,
        [in] IShellItem *psiNewlyCreated);

    HRESULT PreCopyItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        //[in] LPCWSTR pszNewName);
		[in] LONG pszNewName);

    HRESULT PostCopyItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        //[in] LPCWSTR pszNewName,
		[in] LONG pszNewName,
        [in] LONG hrCopy,
        [in] IShellItem *psiNewlyCreated);

    HRESULT PreDeleteItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem);

    HRESULT PostDeleteItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiItem,
        [in] LONG hrDelete,
        [in] IShellItem *psiNewlyCreated);

    HRESULT PreNewItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiDestinationFolder,
        //[in] LPCWSTR pszNewName);
		[in] LONG pszNewName);

    HRESULT PostNewItem(
        [in] DWORD dwFlags,
        [in] IShellItem *psiDestinationFolder, 
		[in] LONG pszNewName, 
		[in] LONG pszTemplateName,
        [in] DWORD dwFileAttributes,
        [in] LONG hrNew,
        [in] IShellItem *psiNewItem);

    HRESULT UpdateProgress(
        [in] UINT iWorkTotal,
        [in] UINT iWorkSoFar);

    HRESULT ResetTimer();

    HRESULT PauseTimer();

    HRESULT ResumeTimer();
}

typedef enum IFO_Flags {
	IFO_ALLOWUNDO              = 0x00000040,
	IFO_FILESONLY              = 0x00000080,
	IFO_NOCONFIRMATION         = 0x00000010,
	IFO_NOCONFIRMMKDIR         = 0x00000200,
	IFO_NO_CONNECTED_ELEMENTS  = 0x00002000,
	IFO_NOCOPYSECURITYATTRIBS  = 0x00000800,
	IFO_NOERRORUI			   = 0x00000400,
	IFO_NORECURSION            = 0x00001000,
	IFO_RENAMEONCOLLISION      = 0x00000008,
	IFO_SILENT				   = 0x00000004,
	IFO_WANTNUKEWARNING        = 0x00004000,
	IFOX_ADDUNDORECORD         = 0x20000000, //WINDOWS 8+
	IFOX_NOSKIPJUNCTIONS       = 0x00010000,
	IFOX_PREFERHARDLINK        = 0x00020000,
	IFOX_SHOWELEVATIONPROMPT   = 0x00040000,
	IFOX_EARLYFAILURE          = 0x00100000,
	IFOX_PRESERVEFILEEXTENSIONS= 0x00200000,
	IFOX_KEEPNEWERFILE         = 0x00400000,
	IFOX_NOCOPYHOOKS           = 0x00800000,
	IFOX_NOMINIMIZEBOX         = 0x01000000,
	IFOX_MOVEACLSACROSSVOLUMES = 0x02000000,
	IFOX_DONTDISPLAYSOURCEPATH = 0x04000000,
	IFOX_DONTDISPLAYDESTPATH   = 0x08000000,
	IFOX_RECYCLEONDELETE       = 0x00080000, //WINDOWS 8+
	IFOX_REQUIREELEVATION      = 0x10000000, //VISTA SP1+
	IFOX_COPYASDOWNLOAD        = 0x40000000, //WINDOWS 7+
	IFOX_DONTDISPLAYLOCATIONS  = 0x80000000,
} IFO_Flags;

typedef enum FILEOP_FLAGSEX
{
    FOFX_ADDUNDORECORD = 0x20000000, //WINDOWS 8+
    FOFX_NOSKIPJUNCTIONS = 0x00010000,
    FOFX_PREFERHARDLINK = 0x00020000,
    FOFX_SHOWELEVATIONPROMPT = 0x00040000,
    FOFX_EARLYFAILURE = 0x00100000,
    FOFX_PRESERVEFILEEXTENSIONS = 0x00200000,
    FOFX_KEEPNEWERFILE = 0x00400000,
    FOFX_NOCOPYHOOKS = 0x00800000,
    FOFX_NOMINIMIZEBOX = 0x01000000,
    FOFX_MOVEACLSACROSSVOLUMES = 0x02000000,
    FOFX_DONTDISPLAYSOURCEPATH = 0x04000000,
    FOFX_DONTDISPLAYDESTPATH = 0x08000000,
    FOFX_RECYCLEONDELETE = 0x00080000, //WINDOWS 8+
    FOFX_REQUIREELEVATION = 0x10000000, //VISTA SP1+
    FOFX_COPYASDOWNLOAD = 0x40000000, //WINDOWS 7+
    FOFX_DONTDISPLAYLOCATIONS = 0x80000000,
} FILEOP_FLAGSEX;
[
	odl,
    uuid(947aab5f-0a5c-4c13-b4d6-4bf7836fc9f8),
]
interface IFileOperation : stdole.IUnknown
{
    // 1) (Optional) Set up your event sink.
    [helpstring("IFileOperationProgressSink must be implemented by a class in your program.")]
    //HRESULT Advise([in] void *pfops, [out] LONG *pdwCookie);
    long Advise([in] IFileOperationProgressSink *pfops, [out] LONG *pdwCookie);

	long Unadvise([in] LONG dwCookie);

    // 2) Set operation state
    // FOF_ flags (defined in shellapi.h) and FOFX_ flags are passed here
    // if not specified the default flags are FOF_ALLOWUNDO | FOF_NOCONFIRMMKDIR
	long SetOperationFlags([in] IFO_Flags dwOperationFlags);

	long SetProgressMessage([in] LPCWSTR pszMessage);

	long SetProgressDialog([in] IOperationsProgressDialog *popd);

	long SetProperties([in] IPropertyChangeArray  *pproparray);

	long SetOwnerWindow([in] LONG hwndOwner);

    // 3) Specify operations to take on given items.
    // FooItem takes an IShellItem*.
    // FooItems takes an IShellItem*, an IEnumShellItems* or an IDataObject*.
	long ApplyPropertiesToItem([in] IShellItem *psiItem);

	long ApplyPropertiesToItems([in] IUnknown *punkItems);

	long RenameItem(
        [in] IShellItem *psiItem,
        [in] long pszNewName,
        [in] void *pfopsItem); //IFileOperationProgressSink
    
    [helpstring("punkItems is either IShellItemArray, IEnumShellItems, or IDataObject")]
	long RenameItems(
        [in] IUnknown *pUnkItems,
        [in] LPCWSTR pszNewName);

	long MoveItem(
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        [in] LPCWSTR pszNewName,
        [in] void *pfopsItem); //IFileOperationProgressSink

    [helpstring("punkItems is either IShellItemArray, IEnumShellItems, or IDataObject")]
	long MoveItems(
        [in] IUnknown *punkItems,
        [in] IShellItem *psiDestinationFolder);

	long CopyItem(
        [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder,
        [in] LPCWSTR pszCopyName,
        [in] void *pfopsItem);
    
    [helpstring("punkItems is either IShellItemArray, IEnumShellItems, or IDataObject")]
	long CopyItems(
        [in] IUnknown *punkItems,
        [in] IShellItem *psiDestinationFolder);

	long DeleteItem(
        [in] IShellItem *psiItem,
        [in] void *pfopsItem);
    
    [helpstring("punkItems is either IShellItemArray, IEnumShellItems, or IDataObject")]
	long DeleteItems([in] IUnknown *punkItems);

	long NewItem(
        [in] IShellItem *psiDestinationFolder,
        [in] LONG dwFileAttributes,
        [in] LPCWSTR pszName,
        [in] LPCWSTR pszTemplateName,
        [in] void *pfopsItem);

    // 4) Perform operations.
	long PerformOperations();

    // 5) Were any operations aborted?
	long GetAnyOperationsAborted([out] LONG *pfAnyOperationsAborted);
}

typedef /* [v1_enum] */
enum FILE_OPERATION_FLAGS2
{
    FOF2_NONE = 0,
    FOF2_MERGEFOLDERSONCOLLISION = 0x1
} 	FILE_OPERATION_FLAGS2;

[
    odl,
        uuid(cd8f23c1-8f61-4916-909d-55bdd0918753)
]
interface IFileOperation2 : IFileOperation
{
 
      HRESULT   SetOperationFlags2(
        [in] FILE_OPERATION_FLAGS2 operationFlags2);

};

[
    odl,
    uuid(BCFCE0A0-EC17-11d0-8D10-00A0C90F2719) // IID_IContextMenu3
]

interface IContextMenu3 : IContextMenu2
{
    HRESULT HandleMenuMsg2(
        [in] LONG uMsg,
        [in] LONG wParam,
        [in] LONG lParam,
        [out] LONG *plResult);
};
    typedef enum KNOWNDESTCATEGORY
    {
        KDC_FREQUENT = 1,
        KDC_RECENT,
    } KNOWNDESTCATEGORY;


[
	odl,
    helpstring("Unknown Object Array"),
    uuid(92CA9DCD-5622-4bba-A805-5E9F541BD8C9)

]
interface IObjectArray : stdole.IUnknown
{
    long GetCount([out] LONG *pcObjects);
    long GetAt([in] LONG uiIndex, [in] UUID* riid, [in, out] LPVOID ppv);
};

[
	odl,
    uuid(5632b1a4-e38a-400a-928a-d4cd63230295)

]
interface IObjectCollection : IObjectArray
{
    HRESULT AddObject([in] LONG punk);
    HRESULT AddFromArray([in] LONG poaSource);//IObjectArray *
    HRESULT RemoveObjectAt([in] UINT uiIndex);
    HRESULT Clear();
};
[
	odl,
    uuid(12337d35-94c6-48a0-bce7-6a9c69d4d600)
]
interface IApplicationDestinations : stdole.IUnknown
{
    // Set the App User Model ID for the application removing destinations from its list.  If an AppID is not provided 
    // via this method, the system will use a heuristically determined ID.  This method must be called before
    // RemoveDestination or RemoveAllDestinations.
    HRESULT SetAppID([in] LPCWSTR pszAppID);
    // Remove an IShellItem or an IShellLink from the automatic destination list
    HRESULT RemoveDestination([in] IUnknown *punk);
    // Clear the frequent and recent destination lists for this application.
    HRESULT RemoveAllDestinations();
};
[
	odl,
    uuid(6332debf-87b5-4670-90c0-5e57b408a49e)
]
interface ICustomDestinationList : stdole.IUnknown
{

    //long SetAppID([in] LPCWSTR pszAppID);
	long SetAppID([in] LONG pszAppID);
    // Retrieve IObjectArray of IShellItems or IShellLinks that represent removed destinations
    long BeginList(
        [out] UINT *pcMinSlots,
        [in] UUID *riid,
		//[in] LONG ptrIOA);
        [in,out] LPVOID ppv);
    long AppendCategory(
        [in] LONG pszCategory, 
		[in] LONG poa);
        //[in] IObjectArray *poa);
    long AppendKnownCategory([in] KNOWNDESTCATEGORY category);
    //long AddUserTasks([in] IObjectArray *poa); //IObjectArray *poa);
	long AddUserTasks([in] LONG poa);
    long CommitList();
    // Retrieve IObjectCollection of IShellItems
    long GetRemovedDestinations(
        [in] UUID *riid,
        [in, out] LPVOID ppv);
    long DeleteList([in] LPCWSTR pszAppID);
    long AbortList();
};

[
	odl,
    uuid(b4db1657-70d7-485e-8e3e-6fcb5a5c1802)
]
interface IModalWindow : stdole.IUnknown
{
    HRESULT Show([in] HWND hwndOwner);

}
typedef enum FDE_OVERWRITE_RESPONSE
{
    FDEOR_DEFAULT            = 0, // The application has not handled the event, and the dialog should put up UI asking the user
                                  // whether or not the file should be overwritten and be returned from the dialog
    FDEOR_ACCEPT             = 1, // The application has decided that the file should be returned from the dialog
    FDEOR_REFUSE             = 2, // The application has decided that the file should not be returned from the dialog
} FDE_OVERWRITE_RESPONSE;

typedef enum FDE_SHAREVIOLATION_RESPONSE
{
    FDESVR_DEFAULT           = 0, // The application has not handled the event.  The dialog will put up UI indicating the file
                                  // is in use, and a different file must be chosen.
    FDESVR_ACCEPT            = 1, // The application has decided that the file should be returned from the dialog
    FDESVR_REFUSE            = 2, // The application has decided that the file should not be returned from the dialog
} FDE_SHAREVIOLATION_RESPONSE;

typedef enum FDAP
{
    FDAP_BOTTOM              = 0, // The place is added to the bottom of the default list.
    FDAP_TOP                 = 1, // The place is added to the top of the default list.
} FDAP;

[
	odl,
    uuid(973510db-7d7f-452b-8975-74a85828d354),
]
interface IFileDialogEvents : stdole.IUnknown
{
    HRESULT OnFileOk([in] IFileDialog *pfd);

    HRESULT OnFolderChanging(
        [in] IFileDialog *pfd,
        [in] IShellItem *psiFolder);

    HRESULT OnFolderChange([in] IFileDialog *pfd);

    HRESULT OnSelectionChange([in] IFileDialog *pfd);

    // Note: FOS_SHAREAWARE must be set in IFileDialog::SetOptions in order for this method to be called.
    HRESULT OnShareViolation(
        [in] IFileDialog *pfd,
        [in] IShellItem *psi,
        [in,out] FDE_SHAREVIOLATION_RESPONSE *pResponse);

    HRESULT OnTypeChange([in] IFileDialog *pfd);

    // Note: FOS_OVERWRITEPROMPT must be set in IFileDialog::SetOptions in order for this method to be called.
    HRESULT OnOverwrite(
        [in] IFileDialog *pfd,
        [in] IShellItem *psi,
        [in,out] FDE_OVERWRITE_RESPONSE *pResponse);
}
    typedef enum FILEOPENDIALOGOPTIONS
    {
        FOS_OVERWRITEPROMPT          = 0x00000002, // (on by default in the save dialog)
        FOS_STRICTFILETYPES          = 0x00000004, // In the save dialog, only allow the user to choose a file that has
                                                   // one of the file extensions provided in SetFileTypes.
        FOS_NOCHANGEDIR              = 0x00000008, // Don't change the current working directory
        FOS_PICKFOLDERS              = 0x00000020, // Invoke the open dialog in folder picking mode.
        FOS_FORCEFILESYSTEM          = 0x00000040, // Ensure that items returned are filesystem items.
        FOS_ALLNONSTORAGEITEMS       = 0x00000080, // Allow choosing items that have no storage.
        FOS_NOVALIDATE               = 0x00000100,
        FOS_ALLOWMULTISELECT         = 0x00000200,
        FOS_PATHMUSTEXIST            = 0x00000800, // (on by default)
        FOS_FILEMUSTEXIST            = 0x00001000, // (on by default in the open dialog and folder picker)
        FOS_CREATEPROMPT             = 0x00002000,
        FOS_SHAREAWARE               = 0x00004000,
        FOS_NOREADONLYRETURN         = 0x00008000, // (on by default in the save dialog)
        FOS_NOTESTFILECREATE         = 0x00010000, // Avoid testing the creation of the chosen file in the save dialog
                                                   // (specifying this flag will circumvent some useful error handling, such as access denied)
        FOS_HIDEMRUPLACES            = 0x00020000, // (not used in Win7)
        FOS_HIDEPINNEDPLACES         = 0x00040000, // Don't display the standard namespace locations in the navigation pane.
                                                   // (generally used along with AddPlace)
        FOS_NODEREFERENCELINKS       = 0x00100000, // Don't treat shortcuts as their target files.
        FOS_DONTADDTORECENT          = 0x02000000, // Don't add the chosen file to the recent documents list (SHAddToRecentDocs)
        FOS_FORCESHOWHIDDEN          = 0x10000000, // Show all files including system and hidden files.
        FOS_DEFAULTNOMINIMODE        = 0x20000000, // (not used in Win7)
        FOS_FORCEPREVIEWPANEON       = 0x40000000, 
		FOS_SUPPORTSTREAMABLEITEMS   = 0x80000000, // Indicates the caller will use BHID_Stream to open contents, no need to download the file

    } FILEOPENDIALOGOPTIONS;
//typedef struct COMDLG_FILTERSPEC {
//  LPCWSTR pszName;
//  LPCWSTR pszSpec;
//} COMDLG_FILTERSPEC;
[
    odl,
    uuid(2659B475-EEB8-48b7-8F07-B378810F48CF)
]
interface IShellItemFilter : stdole.IUnknown
{
    HRESULT IncludeItem([in] IShellItem *psi);

    HRESULT GetEnumFlagsForItem(
        [in] IShellItem *psi,
        [in, out] SHCONTF *pgrfFlags);
}
[
	odl,
    uuid(42f85136-db7e-439c-85f1-e4075d135fc8)
]
interface IFileDialog : IModalWindow
{


    HRESULT SetFileTypes(
        [in] LONG cFileTypes,
		[in] LONG rgFilterSpec);
        //[in] COMDLG_FILTERSPEC *rgFilterSpec);

    HRESULT SetFileTypeIndex([in] UINT iFileType);

    HRESULT GetFileTypeIndex([out] UINT *piFileType);

    HRESULT Advise(
        [in] IFileDialogEvents *pfde,
        [in,out] LONG *pdwCookie);

    HRESULT Unadvise([in] LONG dwCookie);

    HRESULT SetOptions([in] FILEOPENDIALOGOPTIONS fos);

    HRESULT GetOptions([in,out] FILEOPENDIALOGOPTIONS *pfos);

    HRESULT SetDefaultFolder([in] IShellItem *psi);

    HRESULT SetFolder([in] IShellItem *psi);

    HRESULT GetFolder([out] IShellItem **ppsi);

    HRESULT GetCurrentSelection([out] IShellItem **ppsi);

    HRESULT SetFileName([in] LPCWSTR pszName);

    HRESULT GetFileName([out] LONG *pszName);

    HRESULT SetTitle([in] LPCWSTR pszTitle);

    HRESULT SetOkButtonLabel([in] LPCWSTR pszText);

    HRESULT SetFileNameLabel([in] LPCWSTR pszLabel);

    HRESULT GetResult([out] IShellItem **ppsi);

    HRESULT AddPlace(
        [in] IShellItem *psi,
        [in] FDAP fdap);

    HRESULT SetDefaultExtension([in] LPCWSTR pszDefaultExtension);

    HRESULT Close([in] LONG hr);

    HRESULT SetClientGuid([in] UUID *guid);

    HRESULT ClearClientData();

    HRESULT SetFilter([in] IShellItemFilter *pFilter);
}

[
	odl,
    uuid(84bccd23-5fde-4cdb-aea4-af64b83d78ab)
]
interface IFileSaveDialog : IFileDialog
{
    HRESULT SetSaveAsItem([in] IShellItem *psi);

    HRESULT SetProperties([in] IPropertyStore *pStore);

    HRESULT SetCollectedProperties(
        [in] IPropertyDescriptionList *pList,
        [in] BOOL fAppendDefault);

    HRESULT GetProperties([out] IPropertyStore **ppStore);

    HRESULT ApplyProperties(
        [in] IShellItem *psi,
        [in] IPropertyStore *pStore,
        [in] HWND hwnd,
        [in] IFileOperationProgressSink *pSink);
}

//
// Additional methods specific to the file open dialog
// (adding multiselect capability)
//
[
	odl,
    uuid(d57c7288-d4ad-4768-be02-9d969532d960)
]
interface IFileOpenDialog : IFileDialog
{
    HRESULT GetResults([out] IShellItemArray **ppenum);

    HRESULT GetSelectedItems([out] IShellItemArray **ppsai);
}
typedef enum CDCONTROLSTATEF
{
    CDCS_INACTIVE       = 0x00000000,
    CDCS_ENABLED        = 0x00000001,
    CDCS_VISIBLE        = 0x00000002,
    CDCS_ENABLEDVISIBLE = 0x00000003,
} CDCONTROLSTATEF;

[
	odl,
    uuid(e6fdd21a-163f-4975-9c8c-a69f1ba37034)
]
interface IFileDialogCustomize : stdole.IUnknown
{
    // Methods for adding or enabling controls. All of these can have their
    // enabled/visible state set, however the default is for them to be enabled and visible,
    // so this parameter has been left off these methods.
    HRESULT EnableOpenDropDown([in] DWORD dwIDCtl);

    HRESULT AddMenu(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszLabel);

    HRESULT AddPushButton(
        [in] DWORD dwIDCtl,
        [in, string] LPCWSTR pszLabel);

    HRESULT AddComboBox([in] DWORD dwIDCtl);

    HRESULT AddRadioButtonList([in] DWORD dwIDCtl);

    HRESULT AddCheckButton(
        [in] DWORD dwIDCtl,
        [in] LPCWSTR pszLabel,
        [in] BOOL bChecked);

    HRESULT AddEditBox(
        [in] DWORD dwIDCtl,
        [in] LPCWSTR pszText);

    HRESULT AddSeparator([in] DWORD dwIDCtl);

    HRESULT AddText(
        [in] DWORD dwIDCtl,
        [in] LPCWSTR pszText);

    // Getting/setting attributes on controls on the fly
    HRESULT SetControlLabel(
        [in] DWORD dwIDCtl,
        [in] LPCWSTR pszLabel);

    HRESULT GetControlState(
        [in] DWORD dwIDCtl,
        [out] CDCONTROLSTATEF *pdwState);

    HRESULT SetControlState(
        [in] DWORD dwIDCtl,
        [in] CDCONTROLSTATEF dwState);

    HRESULT GetEditBoxText(
        [in] DWORD dwIDCtl,
        [in,out] LONG *ppszText); // was [out] WCHAR **ppszText); but that's not supported in VB; this change
								 // will result in VB getting a pointer for SysReAllocString

    HRESULT SetEditBoxText(
        [in] DWORD dwIDCtl,
        [in] LPCWSTR pszText);

    HRESULT GetCheckButtonState(
        [in] DWORD dwIDCtl,
        [out] BOOL *pbChecked);

    HRESULT SetCheckButtonState(
        [in] DWORD dwIDCtl,
        [in] BOOL bChecked);

    // Method for adding items to "container controls" (radiogroup, combobox, opendropdown, toolsmenu)
    HRESULT AddControlItem(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem,
        [in] LPCWSTR pszLabel);

    // Methods for removing items in the "container controls"
    HRESULT RemoveControlItem(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem);

    HRESULT RemoveAllControlItems([in] DWORD dwIDCtl);

    // Getting/setting attributes on control items on the fly
    // Items are considered immutable once created, except for their state:
    HRESULT GetControlItemState(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem,
        [out] CDCONTROLSTATEF *pdwState);

    HRESULT SetControlItemState(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem,
        [in] CDCONTROLSTATEF dwState);

    // Methods for some "container controls": OpenDropDown, combobox, radiobuttongroup.
    // These methods don't apply to the tools menu.
    // These methods can be called after the dialog has closed, to determine the users final choice.
    // For comboboxes and radiobuttongroups, these methods may also be called while the
    // dialog is showing (which makes no sense for the OpenDropDown).
    HRESULT GetSelectedControlItem(
        [in] DWORD dwIDCtl,
        [out] DWORD *pdwIDItem);

    HRESULT SetSelectedControlItem(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem); // Not valid for OpenDropDown

    // Controls can be grouped by wrapping their adds in StartVisualGroup/EndVisualGroup
    // Groups have control IDs, and can be disabled/hidden, just like other controls.
    HRESULT StartVisualGroup(
        [in] DWORD dwIDCtl,
        [in] LPCWSTR pszLabel);

    HRESULT EndVisualGroup();

    // One control may be marked as appearing prominently in the UI
    HRESULT MakeProminent([in] DWORD dwIDCtl);

    // Set the text of a control item (RadioButton, or item in an OpenDropDown or Menu)
    HRESULT SetControlItemText(
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem,
        [in] LPCWSTR pszLabel);
}

// Event notifications from the controls, handled by an interface
// optionally implemented by the same IFileDialogEvents object supplied by the app.
[
	odl,
    uuid(36116642-D713-4b97-9B83-7484A9D00433)
]
interface IFileDialogControlEvents : stdole.IUnknown
{
    // An item in a combobox, toolsmenu, or radiobutton group was selected.
    // (this notification is *not* sent when an item is chosen from the open dropdown,
    //  as the action here is always the same: close the dialog as if the user clicked open.
    //  At that point, the app will then be able to call GetSelectedItem() for the open dropdown, to
    //  obtain the item that was chosen).
    HRESULT OnItemSelected(
        [in] IFileDialogCustomize *pfdc,
        [in] DWORD dwIDCtl,
        [in] DWORD dwIDItem);

    // A pushbutton was clicked.
    HRESULT OnButtonClicked(
        [in] IFileDialogCustomize *pfdc,
        [in] DWORD dwIDCtl);

    // A checkbutton was toggled.
    HRESULT OnCheckButtonToggled(
        [in] IFileDialogCustomize *pfdc,
        [in] DWORD dwIDCtl,
        [in] BOOL bChecked);

    // A combobox, toolsmenu or open dropdown is about to be "dropped down".  At this point,
    // the application may want to update the contents based on the current state of the dialog.
    HRESULT OnControlActivating(
        [in] IFileDialogCustomize *pfdc,
        [in] DWORD dwIDCtl);
}

[
	odl,
    uuid(61744fc7-85b5-4791-a9b0-272276309b13)
]
interface IFileDialog2 : IFileDialog
{
    // Changing the text on the Cancel button can be useful for a "basket mode" where IFileDialogEvents::OnFileOk
    // is used to accumulate items, and Open/Cancel would be changed to Add/Done for example.
    HRESULT SetCancelButtonLabel([in] LPCWSTR pszLabel);

    // Replaces any items in the navigation pane with this item instead, to guide the user from navigating outside of 
    // this part of the namespace.
    HRESULT SetNavigationRoot([in] IShellItem *psi);
};


typedef struct SMDATA
{
    DWORD   dwMask;             // SMDM_* values
    DWORD   dwFlags;            // Not used
    long    hmenu;              // Static HMENU portion.
    HWND    hwnd;               // HWND owning the HMENU
    UINT    uId;                // Id of the item in the menu (-1 for menu itself)
    UINT    uIdParent;          // Id of the item spawning this menu
    UINT    uIdAncestor;        // Id of the very top item in the chain of ShellFolders
    //IUnknown*    punk;          // IUnkown of the menuband
	long punk; //use pointer??
    long pidlFolder;// pidl of the ShellFolder portion
    long   pidlItem;  // pidl of the item in the ShellFolder portion
    //IShellFolder*   psf;        // IShellFolder for the shell folder portion
    long  psf; //use pointer??
	long   pvUserData;         // User defined Data associated with a pane.
} SMDATA;

[
	odl,
    uuid(4CA300A1-9B8D-11d1-8B22-00C04FD918D0)
]

interface IShellMenuCallback : stdole.IUnknown
{
    // psmd is [in,out] because SMC_MAPACCELERATOR returns a value in uId
    HRESULT CallbackSM(
        [in, out] SMDATA *psmd,
        [in] UINT uMsg,
        [in] LONG wParam,
        [in] LONG lParam);
};

[
	odl,
    uuid(EE1F7637-E138-11d1-8379-00C04FD918D0),
]
interface IShellMenu : stdole.IUnknown
{
    long Initialize(
        [in] IShellMenuCallback* psmc,
        [in] UINT uId,
        [in] UINT uIdAncestor,
        [in] DWORD dwFlags);

    long GetMenuInfo(
        [out] IShellMenuCallback** ppsmc,
        [out] UINT* puId,
        [out] UINT* puIdAncestor,
        [out] DWORD* pdwFlags);

    long SetShellFolder(
        [in] IShellFolder* psf,
        [in] LONG pidlFolder,
        [in] HKEY hKey,
        [in] DWORD dwFlags);

    long GetShellFolder(
        [out] DWORD* pdwFlags,
        [out] LONG* ppidl,
        [in] UUID* riid,
        [in,out] LPVOID ppv);

    long SetMenu(
        [in] LONG hmenu,
        [in] HWND hwnd,
        [in] DWORD dwFlags);

    long GetMenu(
        [out] HMENU* phmenu,
        [out] HWND* phwnd,
        [out] DWORD* pdwFlags);

    long InvalidateItem(
        [in] SMDATA *psmd,
        [in] DWORD dwFlags);

    long GetState([out] SMDATA *psmd);

    long SetMenuToolbar(
        [in] IUnknown* punk,
        [in] DWORD dwFlags);
};

[
    odl,
    uuid(6f51c646-0efe-4370-882a-c1f61cb27c3b)
]
interface IShellMenu2 : IShellMenu
{
    // Retrieves an interface on a submenu.
    HRESULT GetSubMenu([in] UINT idCmd, [in] REFIID riid, [out] void** ppvObj);
    HRESULT SetToolbar([in] HWND hwnd, [in] DWORD dwFlags);
    HRESULT SetMinWidth([in] int cxMenu);
    HRESULT SetNoBorder([in] BOOL fNoBorder);
    HRESULT SetTheme([in] LPCWSTR pszTheme);
};


[
    odl,
        uuid(8278F932-2A3E-11d2-838F-00C04FD918D0)
]
interface ITrackShellMenu : IShellMenu
{
    HRESULT SetObscured(
        [in] HWND hwndTB,
        [in] IUnknown* punkBand,
        [in] DWORD dwSMSetFlags);

    HRESULT Popup(
        [in] HWND hwnd,
        [in] POINT* ppt,
        [in] RECT* prcExclude,
        [in] MENUPOPUPPOPUPFLAGS dwFlags);

};

// Invoke an associated app handler
[
	odl,
    uuid(92218CAB-ECAA-4335-8133-807FD234C2EE)
]
interface IAssocHandlerInvoker : stdole.IUnknown
{
    // Returns S_OK if selection is supported, S_FALSE if not.
    long SupportsSelection();

    long Invoke();
};

[
	odl,
    uuid(F04061AC-1659-4a3f-A954-775AA57FC083)
]
interface IAssocHandler : stdole.IUnknown
{
    long GetName([out] LONG* ppsz);

    long GetUIName([out] LONG* ppsz);

    long GetIconLocation(
        [out] LONG* ppszPath,
        [out] int *pIndex);

    long IsRecommended();

    long MakeDefault([in] LPCWSTR pszDescription);

    long Invoke([in] IDataObject *pdo);

    long CreateInvoker(
        [in] IDataObject *pdo,
        [out] IAssocHandlerInvoker **ppInvoker);
};


// Enumerate handlers
[
	odl,
    uuid(973810ae-9599-4b88-9e4d-6ee98c9552da)
]
interface IEnumAssocHandlers : stdole.IUnknown
{
    long Next(
        [in] ULONG celt,
        [out] IAssocHandler **rgelt,
        [out] LONG *pceltFetched);
};

typedef enum NAMESPACEWALKFLAG
{
    NSWF_DEFAULT                        = 0x00000000,
    NSWF_NONE_IMPLIES_ALL               = 0x00000001,
    NSWF_ONE_IMPLIES_ALL                = 0x00000002,
    NSWF_DONT_TRAVERSE_LINKS            = 0x00000004,   // don't traverse the targets of link items (items with SFGAO_LINK)
    NSWF_DONT_ACCUMULATE_RESULT         = 0x00000008,   // don't store the results of the walk, GetIDArrayResult() will fail if called

    // for items with both SFGAO_FOLDER and SFGAO_STREAM discovered via the walk 
    // (as opposed to those passed as the input) for example .zip, .search-ms and .library-ms files
    // traverse through them and find the items they reference. this will result in
    // EnterFolder()/LeaveFolder() callbacks instead of FoundItem()
    NSWF_TRAVERSE_STREAM_JUNCTIONS      = 0x00000010,

    NSWF_FILESYSTEM_ONLY                = 0x00000020,   // only return file system items (SFGAO_FILESYSTEM)
    NSWF_SHOW_PROGRESS                  = 0x00000040,   // display the progress dialog while walking
    NSWF_FLAG_VIEWORDER                 = 0x00000080,   // order the items based on the view order that might be different from the default sort
    NSWF_IGNORE_AUTOPLAY_HIDA           = 0x00000100,
    NSWF_ASYNC                          = 0x00000200,   // run the walk on a background thread
    NSWF_DONT_RESOLVE_LINKS             = 0x00000400,   // avoid the expense of resolving links, means link targets might not be up to date
    NSWF_ACCUMULATE_FOLDERS             = 0x00000800,
    NSWF_DONT_SORT                      = 0x00001000,   // Don't maintain sort order of items
    NSWF_USE_TRANSFER_MEDIUM            = 0x00002000,   // Use SHCONTF_STORAGE in enumerations

    // for items with both SFGAO_FOLDER and SFGAO_STREAM passed to the walk
    // (as opposed to those discovered by walking), for example .zip, .search-ms and .library-ms files
    // do not traverse them, instead treat them as items. this will result in
    // FoundItem() callbacks instead of EnterFolder()/LeaveFolder()
    NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS = 0x00004000,

	NSWF_ANY_IMPLIES_ALL                = 0x00008000 //Windows 8+ only
}  NAMESPACEWALKFLAG;

[
	odl,
    uuid(d92995f8-cf5e-4a76-bf59-ead39ea2b97e)
]
interface INamespaceWalkCB : stdole.IUnknown
{
    // called for every non folder item found in the folder. these items are reported
    // before any of the folders are returned via EnterFolder(). this is a bredth first
    // walk of the name space
    HRESULT FoundItem([in] IShellFolder *psf, [in] LONG pidl);

    // this is called for ever sub folder found below the punkToWalk input
    // it is not called for any folders specified directly in the input
    //
    // for every folder this is called after all of the items in the folder have
    // been reported via FoundItem()
    //
    // return:
    //      S_OK to continue recursing
    //      S_FALSE to skip this folder but continue
    //      FAILED() (HRESULT_FROM_WIN32(ERROR_CANCELLED)) to stop the whole walk
    HRESULT EnterFolder([in] IShellFolder *psf, [in] LONG pidl);

    // matches the EnterFolder() calls, but since folders can nest this
    // other folders may be entered and left before the matching call is made
    HRESULT LeaveFolder([in] IShellFolder *psf, [in] LONG pidl);

    HRESULT InitializeProgressDialog([in, out] LONG *ppszTitle, [in, out] LONG *ppszCancel);
};
[
	odl,
    uuid(7ac7492b-c38e-438a-87db-68737844ff70)
]
interface INamespaceWalkCB2 : stdole.IUnknown
{
	//INamespaceWalkCB Methods (VB cannot implment an interface derived from another besides IUnknown)

    // called for every non folder item found in the folder. these items are reported
    // before any of the folders are returned via EnterFolder(). this is a bredth first
    // walk of the name space
    HRESULT FoundItem([in] IShellFolder *psf, [in] LONG pidl);

    // this is called for ever sub folder found below the punkToWalk input
    // it is not called for any folders specified directly in the input
    //
    // for every folder this is called after all of the items in the folder have
    // been reported via FoundItem()
    //
    // return:
    //      S_OK to continue recursing
    //      S_FALSE to skip this folder but continue
    //      FAILED() (HRESULT_FROM_WIN32(ERROR_CANCELLED)) to stop the whole walk
    HRESULT EnterFolder([in] IShellFolder *psf, [in] LONG pidl);

    // matches the EnterFolder() calls, but since folders can nest this
    // other folders may be entered and left before the matching call is made
    HRESULT LeaveFolder([in] IShellFolder *psf, [in] LONG pidl);

    HRESULT InitializeProgressDialog([in, out] LONG *ppszTitle, [in, out] LONG *ppszCancel);

	//INamespaceWalkCB2
    HRESULT WalkComplete([in] LONG hr);
};
[
	odl,
    uuid(57ced8a7-3f4a-432c-9350-30f24483f74f)
]
interface INamespaceWalk : stdole.IUnknown
{

    // punkToWalk can be
    //      a punkSite that QueryService(SID_SFolderView, IFolderView) can discover
    //      IShellFolder
    //      IDataObject
    //      IParentAndItem (thus supports CLSID_ShellItem/IShellItem)
    //      IEnumFullIDList
    //      IShellItem
    //      IShellItemArray
    HRESULT Walk(
        [in] IUnknown *punkToWalk,
        [in] DWORD /* NAMESPACEWALKFLAG */ dwFlags,
        [in] int cDepth,
        [in] INamespaceWalkCB *pnswcb);

    HRESULT GetIDArrayResult(
        [out] UINT *pcItems,
        [out] LONG *prgpidl); //was **prgpidl; unsupported, will now return a pointer to use with CopyMemory
};



[
	odl,
    uuid(19108294-0441-4AFF-8013-FA0A730B0BEA)
]
interface IUserNotificationCallback : stdole.IUnknown
{
    // All of these return S_OK to continue, S_FALSE or other error codes to stop
    // These are all "fire and forget" callbacks. Dont pump messages during these
    // callbacks...
    HRESULT OnBalloonUserClick([in] POINT * pt);
    HRESULT OnLeftClick([in] POINT * pt);
    HRESULT OnContextMenu([in] POINT * pt);
}

[
	odl,
    uuid(215913CC-57EB-4FAB-AB5A-E5FA7BEA2A6C)
]
interface IUserNotification2 : stdole.IUnknown
{
    HRESULT SetBalloonInfo(
        [in] LPCWSTR pszTitle,
        [in] LPCWSTR pszText,
        [in] NII_Flags dwInfoFlags);

    HRESULT SetBalloonRetry(
        [in] DWORD dwShowTime,  // times in msec
        [in] DWORD dwInterval,
        [in] INT cRetryCount);

    HRESULT SetIconInfo(
        [in] HICON hIcon,
        [in] LPCWSTR pszToolTip);

    HRESULT Show(
        [in] IQueryContinue *pqc,
        [in] DWORD dwContinuePollInterval,
        [in] IUserNotificationCallback *pSink);

    HRESULT PlaySound([in] LPCWSTR pszSoundName);
};


typedef struct SHDRAGIMAGE {
	SIZE sizeDragImage;
	POINT ptOffset;
	LONG hbmpDragImage;
	LONG crColorKey;
} SHDRAGIMAGE;

[
	odl,
    uuid(4657278B-411B-11D2-839A-00C04FD918D0),
	helpstring("Create with CoCreateInstance CLSID_DragDropHelper")
]
interface IDropTargetHelper : stdole.IUnknown
{
    HRESULT DragEnter(
        [in] HWND hwndTarget,
        [in] IDataObject* pDataObject,
        [in] POINT* ppt,
        [in] DWORD dwEffect);

    HRESULT DragLeave();

    HRESULT DragOver(
        [in] POINT* ppt,
        [in] DWORD dwEffect);

    HRESULT Drop(
        [in] IDataObject* pDataObject,
        [in] POINT* ppt,
        [in] DWORD dwEffect);

    HRESULT Show([in] BOOL fShow);
}

[
	odl,
    uuid(DE5BF786-477A-11D2-839D-00C04FD918D0),
	helpstring("Create with CoCreateInstance CLSID_DragDropHelper")
]
interface IDragSourceHelper : stdole.IUnknown
{
    // IDragSourceHelper
    HRESULT InitializeFromBitmap(
        [in] SHDRAGIMAGE *pshdi,
        [in] IDataObject* pDataObject);

    HRESULT InitializeFromWindow(
        [in] HWND hwnd,
        [in] POINT* ppt,
        [in] IDataObject* pDataObject);
};
typedef enum DSH_FLAGS
{
    DSH_ALLOWDROPDESCRIPTIONTEXT    = 0x0001,   // Allow text specified in DropDescription to be displayed on drag image
} DSH_FLAGS;

[
	odl,
    uuid(83E07D0D-0C5F-4163-BF1A-60B274051E40),
	helpstring("Create with CoCreateInstance CLSID_DragDropHelper")
]
interface IDragSourceHelper2 : IDragSourceHelper
{
    HRESULT SetFlags(
        [in] DSH_FLAGS dwFlags);
};


//typedef GUID STGTRANSCONFIRMATION, *LPSTGTRANSCONFIRMATION;

// Storage operations

typedef enum STGOP
{
    STGOP_MOVE               = 1,
    STGOP_COPY               = 2,
    STGOP_SYNC               = 3,
    STGOP_REMOVE             = 5,
    STGOP_RENAME             = 6,
    STGOP_APPLYPROPERTIES    = 8,   // _WIN32_WINNT >= 0x0600
    STGOP_NEW                = 10,  // _WIN32_WINNT >= 0x0600
} STGOP;


// ITransferSource/ITransferDestination flag values use for OpenItem/MoveItem/RecycleItem/RemoveItem/etc



typedef enum TRANSFER_ADVISE_STATE
{
    TS_NONE            = 0x00000000,
    TS_PERFORMING      = 0x00000001,       // Transfer is being performed
    TS_PREPARING       = 0x00000002,       // Preparing to perform transfer - calculating space needed, etc.
    TS_INDETERMINATE   = 0x00000004,       // The length of the transfer is indeterminate
} TRANSFER_ADVISE_STATE;
[
	odl,
    uuid(d594d0d8-8da7-457b-b3b4-ce5dbaac0b88),
	helpstring("Implement in class module, must do vtable swap if you want to be able to cancel")
]
interface ITransferAdviseSink : stdole.IUnknown
{

    //  Return values:
    //      COPYENGINE_E_USER_CANCELLED
    //          The user has cancelled the operation and the caller should halt execution of the operation as soon as possible.
    //
    //      Any other error:
    //          The caller should halt execution of the operation as soon as possible.
    HRESULT UpdateProgress(
        [in] ULONGLONG ullSizeCurrent,
        [in] ULONGLONG ullSizeTotal,
        [in] int nFilesCurrent,
        [in] int nFilesTotal,
        [in] int nFoldersCurrent,
        [in] int nFoldersTotal);

    HRESULT UpdateTransferState([in] TRANSFER_ADVISE_STATE ts);

    //
    //  Return Values from Confirmations
    //      COPYENGINE_S_USER_IGNORED
    //          Continue operation
    //      COPYENGINE_E_USER_CANCELLED
    //          is a user-interaction cancel. The user clicked "Cancel" somewhere.
    //
    //      Any other HRESULT should be passed up.

    // Confirm that the operation is ok to actually overwrite an existing item
    HRESULT ConfirmOverwrite(
        [in] IShellItem *psiSource,
        [in] IShellItem *psiDestParent,
        [in] LONG pszName);

    // Confirm that the operation is ok to lose encryption (disclosure)
    HRESULT ConfirmEncryptionLoss([in] IShellItem *psiSource);

    //  Parameters:
    //      psi
    //          The IShellItem that is reporting the failure.
    //      pszItem
    //          If NULL, the "psi"'s display name will be used.
    //          If not NULL, this should be a pointer to a string that is the
    //          name of the item.
    //      hrError
    //          The error that is being reported.
    //      pszRename
    //          A buffer that the caller passes if it wants to be able to
    //          retry the operation with a new destination name. If this
    //          parameter is NULL, no option to rename will be available.
    //      cchRename
    //          Size of the buffer pointed to be pszRename.
    //
    //  Return Values:
    //      COPYENGINE_S_USER_RETRY
    //          The handler should retry the file operation.
    //      COPYENGINE_S_USER_IGNORED
    //          The handler should skip creating the item and return this code
    //          back to the copy engine.
    //      COPYENGINE_E_USERCANCELLED
    //          The user clicked "Cancel" somewhere. The entire copy job is
    //          being aborted. The handler should return this code back to the
    //          copy engine.
    //
    //      Any other HRESULT should be passed up. If failure not handled,
    //      the return value should be the same as hrError.
    HRESULT FileFailure(
        [in] IShellItem *psi,
        [in] LONG pszItem,
        [in] LONG hrError,
        [in] LONG pszRename,
        [in] LONG cchRename);

    HRESULT SubStreamFailure(
        [in] IShellItem *psi,
        [in] LONG pszStreamName,
        [in] LONG hrError);

    HRESULT PropertyFailure(
        [in] IShellItem *psi,
        [in] PROPERTYKEY* pkey,   // (pkey == NULL) indicates loss of all properties
        [in] LONG hrError);
}

[
    odl,
    uuid(00adb003-bde9-45c6-8e29-d09f9353e108)
]
interface ITransferSource : stdole.IUnknown
{
    //  Description:
    //      Do an advise before calling anything so the handler can callback for
    //      any errors that might occur. If not set, the handler should consider
    //      it an indication that no feedback is available and to do the "default"
    //      operation.
    //
    //  Parameters:
    //      psink
    //          ITransferAdviseSink interface to be used for status and
    //          failures.
    //      pdwCookie
    //          Pointer to a returned token that uniquely identifies this
    //          connection. The caller uses this token later to delete the
    //          connection by passing it to the Unadvise method. If the
    //          connection was not successfully established, this value is zero.
    //
    //  Return Values:
    //      S_OK
    //          Interface successfully associated.
    //      E_UNEXPECTED
    //          The handler can only handle one sink interface.
    //
    //      other HRESULTs indicate a failure.
    HRESULT Advise(
        [in] ITransferAdviseSink *psink,
        [in, out] DWORD *pdwCookie);

    //  Description:
    //      Terminates an advisory connection previously established through
    //      Advise method. The dwCookie parameter identifies the connection
    //      to terminate
    //
    //  Parameters:
    //      dwCookie
    //          Connection token previously returned from Advise.
    //
    //  Return Values:
    //      S_OK
    //          The connection was successfully terminated.
    //      CONNECT_E_NOCONNECTION
    //          The value in dwCookie does not represent a valid connection.
    //
    //      other HRESULTs indicate a failure.
    HRESULT Unadvise([in] DWORD dwCookie);

    //  Description:
    //      Set properties that should be applied to an item
    //
    //  Parameters:
    //      pproparray
    //          Contains a list of changes
    //
    //  Return Values:
    //      S_OK
    //          Properties set successfully
    //      other HRESULTs indicate a failure.
    HRESULT SetProperties([in] IPropertyChangeArray *pproparray);

    // Open the item for copying, returning an object that can be enumerated
    // for resources (IShellItemResources).
    HRESULT OpenItem(
        [in] IShellItem *psi,
        [in] TRANSFER_SOURCE_FLAGS flags,
        [in] UUID *riid,
        [in, out] LPVOID ppv);

    // Move the item within the volume/namespace, returning the shell item
    // in its new location.
    // returns:
    //      FAILED() codes with special meaning for
    //          HRESULT_FROM_WIN32(ERROR_NOT_SAME_DEVICE) -> caller should convert move into a copy/delete
    //          E_NOINTERFACE -> caller should convert move into a copy/delete
    //          in the case of moving a folder
    //              HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) or HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)
    //              indicates 
    //          to convert to a copy/delete the destination item must support ITransferDestination
    //
    //      SUCCEEDED() code with special meaning for
    //          S_OK - move succeeded, *ppsiNew contains the new item that is the target of the move
    //          COPYENGINE_S_USER_IGNORED -> *ppsiNew is NULL, the destination item already exists and
    //              has not been overwritten. caller should complete the "move" by deleting the
    ///             source item
    //          COPYENGINE_S_MERGE -> *ppsiNew is NULL, the destination folder already exists
    //              and the user has chosen to proceed merging the folder, the caller should complete
    //              the "move" of the folder by deleting the source

    HRESULT MoveItem(
        [in] IShellItem *psi,
        [in] IShellItem *psiParentDst,
        [in] LPCWSTR pszNameDst,
        [in] TRANSFER_SOURCE_FLAGS flags,
        [in, out] IShellItem **ppsiNew);

    // Recycle the item into the provided recycle location, returning the new
    // recycled item in that location.
    HRESULT RecycleItem(
        [in] IShellItem *psiSource,
        [in] IShellItem *psiParentDest,
        [in] TRANSFER_SOURCE_FLAGS flags,
        [in, out] IShellItem **ppsiNewDest);

    // Removed the item (without recycle support)
    HRESULT RemoveItem(
        [in] IShellItem *psiSource,
        [in] TRANSFER_SOURCE_FLAGS flags);

    // Change the name of an item, returing the shell item in its new location
    HRESULT RenameItem(
        [in] IShellItem *psiSource,
        [in] LPCWSTR pszNewName,
        [in] TRANSFER_SOURCE_FLAGS flags,
        [in, out] IShellItem **ppsiNewDest);

    // not used or supported, return E_NOTIMPL
    HRESULT LinkItem(
        [in] IShellItem *psiSource,
        [in] IShellItem *psiParentDest,
        [in] LPCWSTR pszNewName,
        [in] TRANSFER_SOURCE_FLAGS flags,
        [in, out] IShellItem **ppsiNewDest);

    // Apply a set of property changes to an item, return the modified shell item.
    HRESULT ApplyPropertiesToItem(
        [in] IShellItem *psiSource,
        [in, out] IShellItem **ppsiNew);

    // Return the default name, if different from the items parsing name.
    HRESULT GetDefaultDestinationName(
        [in] IShellItem *psiSource,
        [in] IShellItem *psiParentDest,
        [in, out] LONG *ppszDestinationName);

	HRESULT EnterFolder([in] IShellItem *psiChildFolderDest);

	HRESULT LeaveFolder([in] IShellItem *psiChildFolderDest);

}

[
	odl,
	uuid(D82BE2B1-5764-11D0-A96E-00C04FD705A2)
]
interface IShellChangeNotify : stdole.IUnknown
{
	HRESULT OnChange([in] SHCN_Events lEvent,
					 [in] LONG pidl1,
					 [in] LONG pidl2);
}



typedef struct SHELL_ITEM_RESOURCE {
  UUID  guidType;
  WCHAR szName[260];
} SHELL_ITEM_RESOURCE;

[
    odl,
    uuid(2dd81fe3-a83c-4da9-a330-47249d345ba1)
]
interface IEnumResources : stdole.IUnknown
{
    long Next(
        [in] ULONG celt,
        [out] SHELL_ITEM_RESOURCE *psir,
        [out] ULONG *pceltFetched);

    long Skip([in] ULONG celt);

    long Reset();

    long Clone([out] IEnumResources **ppenumr);
}

[
    odl,
    uuid(ff5693be-2ce0-4d48-b5c5-40817d1acdb9)
]
interface IShellItemResources : stdole.IUnknown
{
    long GetAttributes([out] DWORD *pdwAttributes);

    long GetSize([out] ULONGLONG *pullSize);

    long GetTimes(
        [out] FILETIME *pftCreation,
        [out] FILETIME *pftWrite,
        [out] FILETIME *pftAccess);

    long SetTimes(
        [in] FILETIME *pftCreation,
        [in] FILETIME *pftWrite,
        [in] FILETIME *pftAccess);

    long GetResourceDescription(
        [in] SHELL_ITEM_RESOURCE *pcsir,
        [out] LONG *ppszDescription);

    long EnumResources([out] IEnumResources **ppenumr);

    long SupportsResource([in] SHELL_ITEM_RESOURCE *pcsir);

    long OpenResource(
        [in] SHELL_ITEM_RESOURCE *pcsir,
        [in] UUID *riid,
        [in, out]  LPVOID ppv);

    long CreateResource(
        [in] SHELL_ITEM_RESOURCE *pcsir,
        [in] UUID *riid,
        [in, out] LPVOID ppv);

    long MarkForDelete();
}
[
    odl,
    uuid(48addd32-3ca5-4124-abe3-b5a72531b207)
]
interface ITransferDestination : stdole.IUnknown
{
    //  *** 1: advise ***

    //  Do an advise before calling anything so the object can callback for
    //  any errors that might occur. If not set, the object should consider
    //  it an indication that no feedback is available and to do the "default"
    //  for the operation.
    HRESULT Advise(
        [in] ITransferAdviseSink * psink,
        [out] DWORD *pdwCookie);

    HRESULT Unadvise([in] DWORD dwCookie);

    // returns:
    //      SUCCEEDED() code with special meaning for
    //          S_OK - move succeeded, *ppvItem and *ppvResources contains the new item and resources object
    //          that should be copied to
    //          COPYENGINE_S_USER_IGNORED ->  *ppvItem and *ppvResources are NULL, the destination item already exists and
    //              has not been overwritten. if the caller is implemeting "move" as copy/delete it should complete 
    //              the "move" by deleting the source item

    long CreateItem(
        [in] LPCWSTR pszName,
        // FILE_ATTRIBUTE_XXX values, most important being FILE_ATTRIBUTE_DIRECTORY indicating that
        // a folder should be created
        [in] DWORD dwAttributes,
        // the size of the item being copied or zero if unknow
        [in] ULONGLONG ullSize,
        [in] TRANSFER_SOURCE_FLAGS flags, 
        // ppvItem should be an IShellItem or derived interface
        [in] UUID *riidItem,
        [in, out] LPVOID ppvItem,
        // ppvResources should be an IShellItemResources or derived interface
        [in] UUID *riidResources,
        [in, out] LPVOID ppvResources);
}



typedef enum KF_CATEGORY
{
    KF_CATEGORY_VIRTUAL     = 1,       // virtual folders, have not file system path
    KF_CATEGORY_FIXED       = 2,       // fixed, predefined OS folders, might be different for different users
    KF_CATEGORY_COMMON      = 3,       // Public folders shared by all users, can be redirected
    KF_CATEGORY_PERUSER     = 4,       // User folders, can be redirected
} KF_CATEGORY;

typedef enum KF_DEFINITION_FLAGS
{
    KFDF_LOCAL_REDIRECT_ONLY    = 0x00000002,    // Can only be redirected to a local disk
    KFDF_ROAMABLE               = 0x00000004,    // Can be roamed via PC to PC sync
    KFDF_PRECREATE              = 0x00000008,    // Pre create folder
    KFDF_STREAM                 = 0x00000010,    // folder is actually a file
    KFDF_PUBLISHEXPANDEDPATH    = 0x00000020,    // Expanded path is published in the registry under HKCU
	KFDF_NO_REDIRECT_UI         = 0x00000040,
} KF_DEFINITION_FLAGS;

typedef enum KF_REDIRECT_FLAGS
{
    KF_REDIRECT_USER_EXCLUSIVE      = 0x00000001, // Give user exclusive permission
    KF_REDIRECT_COPY_SOURCE_DACL    = 0x00000002, // Copy the DACL of the source directory to target

    // Ownership checks for the target folder if the folder exists, by default, the API does not do any ownership checks
    KF_REDIRECT_OWNER_USER          = 0x00000004, // The owner of the folder must be the user itself
    KF_REDIRECT_SET_OWNER_EXPLICIT  = 0x00000008, // The owner of any newly created folder will be set explicitly
                                                    // by default if user belongs to Administrators group Administrators will be the owner

    // Check if the redirection is already done, S_OK if yes, S_FALSE if some actions need to be done.
    KF_REDIRECT_CHECK_ONLY          = 0x00000010,

    // Enable user interaction when redirecting
    KF_REDIRECT_WITH_UI             = 0x00000020,

    // CSC related settings
    KF_REDIRECT_UNPIN               = 0x00000040, // Unpin the source folder
    KF_REDIRECT_PIN                 = 0x00000080, // Pin the target folder

    KF_REDIRECT_COPY_CONTENTS       = 0x00000200, // Copy the contents (both files and subfolders) under the known folder
    KF_REDIRECT_DEL_SOURCE_CONTENTS = 0x00000400, // Delete source, valid only if KF_REDIRECT_COPY_CONTENTS set

    KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS
                                    = 0x00000800, // Exclude all known subfolders from redirection
} KF_REDIRECT_FLAGS;

typedef enum KF_REDIRECTION_CAPABILITIES
{
    KF_REDIRECTION_CAPABILITIES_ALLOW_ALL               = 0x000000FF, // if any of these flags set this means that
                                                                      // the folder can potentially be redirected unless
                                                                      // any deny flag is set
    KF_REDIRECTION_CAPABILITIES_REDIRECTABLE            = 0x00000001, // the folder can potentially be redirected
                                                                      // currently we only allow redirection for
                                                                      // common and user's folders.
                                                                      // Fixed and virtual can not be redirected

    KF_REDIRECTION_CAPABILITIES_DENY_ALL                = 0x000FFF00, // If any of there flags set then redirection is blocked
    KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED  = 0x00000100, // Folder can not be redirected because it is redirected by group policy
    KF_REDIRECTION_CAPABILITIES_DENY_POLICY             = 0x00000200, // Folder can not be redirected because the policy prohibits redirecting this folder
    KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS        = 0x00000400, // Folder can not be redirected because the caller does not have sufficient permissions
} KF_REDIRECTION_CAPABILITIES;

typedef struct KNOWNFOLDER_DEFINITION
{
    KF_CATEGORY             category;
    LONG                    pszName;
    LONG                    pszDescription;
    KNOWNFOLDERID           fidParent;
    LONG                    pszRelativePath;
    LONG                    pszParsingName;
    LONG                    pszTooltip;
    LONG                    pszLocalizedName;
    LONG                    pszIcon;
    LONG                    pszSecurity;
    DWORD                   dwAttributes;
    KF_DEFINITION_FLAGS     kfdFlags;
    FOLDERTYPEID            ftidType;
} KNOWNFOLDER_DEFINITION;

// Known Folder Interface
[
	odl,
    uuid(3AA7AF7E-9B36-420c-A8E3-F77D4674A488)
]
interface IKnownFolder : stdole.IUnknown
{
    HRESULT GetId([out] KNOWNFOLDERID *pkfid);

    HRESULT GetCategory([out] KF_CATEGORY* pCategory);

    // get the ShellItem (IShellItem or derived interface) for this known folder
    HRESULT GetShellItem(
        [in] KNOWN_FOLDER_FLAG dwFlags,
        [in] UUID *riid,
        [out] LPVOID ppv);

    HRESULT GetPath(
        [in] KNOWN_FOLDER_FLAG dwFlags,
        [out] LONG *ppszPath);

    HRESULT SetPath(
        [in] KNOWN_FOLDER_FLAG dwFlags,
        [in] LPCWSTR pszPath);

    HRESULT GetIDList(
        [in] KNOWN_FOLDER_FLAG dwFlags,
        [out] LONG *ppidl);

    HRESULT GetFolderType([out] FOLDERTYPEID *pftid);

    HRESULT GetRedirectionCapabilities([out] KF_REDIRECTION_CAPABILITIES * pCapabilities);

    HRESULT GetFolderDefinition([out] KNOWNFOLDER_DEFINITION *pKFD);
}
typedef enum FFFP_MODE
{
    FFFP_EXACTMATCH = 0,
    FFFP_NEARESTPARENTMATCH = 1,
} FFFP_MODE;
// Known Folder Manager
[
	odl,
    uuid(8BE2D872-86AA-4d47-B776-32CCA40C7018)
]
interface IKnownFolderManager : stdole.IUnknown
{
	long FolderIdFromCsidl(
        [in] int nCsidl,
        [out] KNOWNFOLDERID *pfid);

	long FolderIdToCsidl(
        [in] REFKNOWNFOLDERID rfid,
        [out] int *pnCsidl);

	long GetFolderIds(
        [out] long* ppKFId,
        [in, out] UINT *pCount);

	long GetFolder(
        [in] REFKNOWNFOLDERID rfid,
        [out] IKnownFolder **ppkf);

	long GetFolderByName(
        [in] LPCWSTR pszCanonicalName,
        [out] IKnownFolder **ppkf);

	long RegisterFolder(
        [in] REFKNOWNFOLDERID rfid,
        [in] KNOWNFOLDER_DEFINITION *pKFD);

	long UnregisterFolder([in] REFKNOWNFOLDERID rfid);

	long FindFolderFromPath(
        [in] LONG pszPath,
        [in] FFFP_MODE mode,
        [out] IKnownFolder **ppkf);

	long FindFolderFromIDList(
        [in] LONG pidl,
        [out] IKnownFolder **ppkf);

    //[local]
	long Redirect(
        [in] REFKNOWNFOLDERID rfid,
        [in] HWND hwnd,
        [in] KF_REDIRECT_FLAGS flags,
        [in] LONG pszTargetPath,
        [in] UINT cFolders,
        [in] KNOWNFOLDERID *pExclusion,
        [out] LONG *ppszError);

    //[call_as(Redirect)]
    //HRESULT RemoteRedirect(
    //    [in] REFKNOWNFOLDERID rfid,
    //    [in] HWND hwnd,
    //    [in] KF_REDIRECT_FLAGS flags,
    //    [in] LPCWSTR pszTargetPath,
    //    [in] UINT cFolders,
    //    [in] UUID *pExclusion,
    //    [out] LONG *ppszError);
};

[
    odl,
    uuid(71c0d2bc-726d-45cc-a6c0-2e31c1db2159)
]
interface IInitializeWithBindCtx : stdole.IUnknown
{
    HRESULT Initialize([in] IBindCtx *pbc);
};

[
	odl,
    uuid(b7d14566-0509-4cce-a71f-0a554233bd9b)
]
interface IInitializeWithFile : stdole.IUnknown
{
    long Initialize(
        [in] LPCWSTR pszFilePath,
        [in] DWORD grfMode);
};

[
	odl,
    uuid(b824b49d-22ac-4161-ac8a-9916e8fa3f7f)
]
interface IInitializeWithStream : stdole.IUnknown
{
    long Initialize(
        [in] IStream *pstream,
        [in] DWORD grfMode);

    ////[call_as(Initialize)] HRESULT RemoteInitialize(
    ////    [in] IStream *pstream,
    ////    [in] DWORD grfMode);
};
[
	odl,
    uuid(7f73be3f-fb79-493c-a6c7-7ee14e245841)
]
interface IInitializeWithItem : stdole.IUnknown
{
    // grfMode is STGM_ values indicating read/readwrite and sharing modes
    long Initialize([in] IShellItem *psi, [in] DWORD grfMode);
}
[
    odl,
    uuid(8895b1c6-b41f-4c1c-a562-0d564250836f)
]
interface IPreviewHandler : stdole.IUnknown
{
    long SetWindow(
        [in] HWND hwnd,
        [in] RECT *prc);

    long SetRect([in] RECT *prc);

    long DoPreview();

    long Unload();

    long SetFocus();

    long QueryFocus([out] HWND* phwnd);

    long TranslateAccelerator([in] MSG* pmsg);
};
[
    odl,
    uuid(196bf9a5-b346-4ef0-aa1e-5dcdb76768b1)
]
interface IPreviewHandlerVisuals : stdole.IUnknown
{
    HRESULT SetBackgroundColor([in] COLORREF color);

    //HRESULT SetFont([in] const LOGFONTW *plf);
    HRESULT SetFont([in] LONG plf);

    HRESULT SetTextColor([in] COLORREF color);
};

typedef struct PREVIEWHANDLERFRAMEINFO
{
    HACCEL haccel;
    UINT   cAccelEntries;
} PREVIEWHANDLERFRAMEINFO;
[
    odl,
    uuid(fec87aaf-35f9-447a-adb7-20234491401a)
]
interface IPreviewHandlerFrame : stdole.IUnknown
{

    HRESULT GetWindowContext([out] PREVIEWHANDLERFRAMEINFO* pinfo);

    HRESULT TranslateAccelerator([in] MSG* pmsg);
};

    typedef enum VPWATERMARKFLAGS
    {
        VPWF_DEFAULT    = 0x00000000,     // Windows XP behavior
        VPWF_ALPHABLEND = 0x00000001,     // alpha blend the bitmap, assumed 24-bit color + 8-bit alpha
    } VPWATERMARKFLAGS;
	typedef enum VPCOLORFLAGS
    {
        VPCF_TEXT           = 1,
        VPCF_BACKGROUND     = 2,
        VPCF_SORTCOLUMN     = 3,
        VPCF_SUBTEXT        = 4,
        VPCF_TEXTBACKGROUND = 5,
    } VPCOLORFLAGS; // misnamed, this is not a flags type
[
	odl,
    uuid(e693cf68-d967-4112-8763-99172aee5e5a)
]
interface IVisualProperties : stdole.IUnknown
{
    HRESULT SetWatermark([in] HBITMAP hbmp, [in] VPWATERMARKFLAGS vpwf);

    HRESULT SetColor(
        [in] VPCOLORFLAGS vpcf,
        [in] COLORREF cr);

    HRESULT GetColor(
        [in] VPCOLORFLAGS vpcf,
        [out] COLORREF *pcr);

    HRESULT SetItemHeight([in] int cyItemInPixels);

    HRESULT GetItemHeight([out] int *cyItemInPixels);

	[helpstring("For plf, pass a VarPtr to a LOGFONT structure.")]
    HRESULT SetFont(
        //[in] const LOGFONTW* plf,
		[in] LONG plf,
        [in] BOOL bRedraw);

    //HRESULT GetFont([out] LOGFONTW* plf);
	[helpstring("Returns a pointer to a LOGFONT structure.")]
	HRESULT GetFont([out] LONG *plf);

    HRESULT SetTheme(
        [in] LONG pszSubAppName,
        [in] LONG pszSubIdList);
};

typedef enum RASTEROPFLAGS {
	SRCAND 			= 0x8800C6,
	SRCCOPY 		= 0xCC0020,
	SRCINVERT 		= 0x660046,
	SRCPAINT 		= 0xEE0086,
	BLACKNESS 		= 0x42,
	CAPTUREBLT 		= 0x40000000,
	DSTINVERT 		= 0x550009,
	MERGECOPY 		= 0xC000CA,
	MERGEPAINT 		= 0xBB0226,
	NOMIRRORBITMAP 	= 0x80000000,
	NOTSRCCOPY 		= 0x330008,
	NOTSRCERASE 	= 0x1100A6,
	PATCOPY 		= 0xF00021,
	PATINVERT 		= 0x5A0049,
	PATPAINT 		= 0xFB0A09,
	SRCERASE 		= 0x440328,
	WHITENESS 		= 0xFF0062
} RASTEROPFLAGS;

typedef enum IMAGELISTDRAWFLAGS {
  ILD_NORMAL        = 0x00000000,
  ILD_TRANSPARENT   = 0x00000001,
  ILD_BLEND25       = 0x00000002,
  ILD_FOCUS         = 0x00000002, //ILD_BLEND25,
  ILD_BLEND50       = 0x00000004,
  ILD_SELECTED      = 0x00000004, //ILD_BLEND50,
  ILD_BLEND         = 0x00000004, //ILD_BLEND50,
  ILD_MASK          = 0x00000010,
  ILD_IMAGE         = 0x00000020,
  ILD_ROP           = 0x00000040, //(WIN32_IE >= &H300)
  ILD_OVERLAYMASK   = 0x00000F00,
  ILD_PRESERVEALPHA = 0x00001000,
  ILD_SCALE         = 0x00002000,
  ILD_DPISCALE      = 0x00004000,
  ILD_ASYNC         = 0x00008000
} IMAGELISTDRAWFLAGS;
typedef enum IMAGELISTSTATEFLAGS {
	ILS_NORMAL      = 0x00000000,
	ILS_GLOW        = 0x00000001, //Not supported
	ILS_SHADOW      = 0x00000002, //Not supported
	ILS_SATURATE    = 0x00000004,
	ILS_ALPHA       = 0x00000008
} IMAGELISTSTATEFLAGS;

typedef struct IMAGELISTDRAWPARAMS
{
    DWORD       cbSize;
    HIMAGELIST  himl;
    int         i;
    HDC         hdcDst;
    int         x;
    int         y;
    int         cx;
    int         cy;
    int         xBitmap;        // x offest from the upperleft of bitmap
    int         yBitmap;        // y offset from the upperleft of bitmap
    COLORREF    rgbBk;
    COLORREF    rgbFg;
    IMAGELISTDRAWFLAGS   fStyle;
    RASTEROPFLAGS        dwRop;
    IMAGELISTSTATEFLAGS  fState;
    DWORD       Frame;
    COLORREF    crEffect;
} IMAGELISTDRAWPARAMS;

typedef struct IMAGEINFO
{
    HBITMAP hbmImage;
    HBITMAP hbmMask;
    int     Unused1;
    int     Unused2;
    RECT    rcImage;
} IMAGEINFO;



typedef enum ILIMAGEQUALITY {
	ILIF_ALPHA               =0x00000001,
	ILIF_LOWQUALITY          =0x00000002
} ILIMAGEQUALITY;

// return values (if SUCCEEDED()) for IImageList::Draw
typedef enum ILDRAWRESULTS {
	ILDRF_IMAGELOWQUALITY    =0x00000001,
	ILDRF_OVERLAYLOWQUALITY  =0x00000010
} ILDRAWRESULTS;



[
	odl,
    uuid(46EB5926-582E-4017-9FDF-E8998DAA0950)
]
interface IImageList : stdole.IUnknown
{
    HRESULT Add([in] HBITMAP hbmImage,
			 [in] HBITMAP hbmMask, 
			 [out] int* pi);
    
	HRESULT ReplaceIcon([in] int i, 
					 [in] HICON hicon, 
					 [out] int* pi);

    HRESULT SetOverlayImage([in] int iImage, 
						 [in] int iOverlay);

    HRESULT Replace([in] int i, 
				 [in] HBITMAP hbmImage, 
				 [in] HBITMAP hbmMask);

    HRESULT AddMasked([in] HBITMAP hbmImage, 
				   [in] COLORREF crMask, 
				   [out] int* pi);

    HRESULT Draw([in] IMAGELISTDRAWPARAMS* pimldp);

    HRESULT Remove([in] int i);

    HRESULT GetIcon([in] int i, 
				 [in] IMAGELISTDRAWFLAGS flags, 
		         [out] HICON* picon);

    HRESULT GetImageInfo([in] int i, 
					  [out] IMAGEINFO* pImageInfo);

    HRESULT Copy([in] int iDst, 
			  [in] IUnknown* punkSrc, 
			  [in] int iSrc, 
			  [in] UINT uFlags);

    HRESULT Merge([in] int i1, 
		       [in] IUnknown* punk2, 
			   [in] int i2, 
			   [in] int dx, 
			   [in] int dy, 
			   [in] UUID *riid, 
			   [out] LPVOID ppv);

    HRESULT Clone([in] UUID *riid, 
		       [out] LPVOID ppv);

    HRESULT GetImageRect([in] int i, 
					  [out] RECT* prc);

    HRESULT GetIconSize([out] int* cx, 
					 [out] int* cy);

    HRESULT SetIconSize([in] int cx, 
					 [in] int cy);

    HRESULT GetImageCount([out] int* pi);

    HRESULT SetImageCount([in] UINT uNewCount);

    HRESULT SetBkColor([in] COLORREF clrBk, 
					[out] COLORREF* pclr);

    HRESULT GetBkColor([out] COLORREF* pclr);

    HRESULT BeginDrag([in] int iTrack, 
		           [in] int dxHotspot, 
				   [in] int dyHotspot);

    HRESULT EndDrag();

    HRESULT DragEnter([in] HWND hwndLock, 
		           [in] int x, 
				   [in] int y);

    HRESULT DragLeave([in] HWND hwndLock);

    HRESULT DragMove([in] int x, [in] int y);

    HRESULT SetDragCursorImage([in] IUnknown* punk, 
							[in] int iDrag, 
							[in] int dxHotspot, 
							[in] int dyHotspot);

    HRESULT DragShowNolock([in] BOOL fShow);

    HRESULT GetDragImage([out] POINT * ppt, 
					  [out] POINT * pptHotspot, 
					  [in] UUID *riid, 
					  [out] LPVOID ppv);

    HRESULT GetItemFlags([in] int i, 
					  [out] DWORD *dwFlags);

    HRESULT GetOverlayImage([in] int iOverlay, 
						 [out] int* piIndex);
};
typedef enum ILRFLAGS {
	ILR_DEFAULT                  =0x0000,   
	ILR_HORIZONTAL_LEFT          =0x0000,
	ILR_HORIZONTAL_CENTER        =0x0001,
	ILR_HORIZONTAL_RIGHT         =0x0002,
	ILR_VERTICAL_TOP             =0x0000,
	ILR_VERTICAL_CENTER          =0x0010,
	ILR_VERTICAL_BOTTOM          =0x0020,
	ILR_SCALE_CLIP               =0x0000,
	ILR_SCALE_ASPECTRATIO        =0x0100
} ILRFLAGS;

//  Flags for GetOriginalSize
typedef enum ILGOSFLAGS {
	ILGOS_ALWAYS         =0x00000000, // always get the original size (can be slow)
	ILGOS_FROMSTANDBY    =0x00000001 // only if present or on standby
} ILGOSFLAGS;
//  Flags for ForceImagePresent
typedef enum ILFIPFLAGS {
	ILFIP_ALWAYS         =0x00000000, // always get the image (can be slow)
	ILFIP_FROMSTANDBY    =0x00000001 // only if on standby
} ILFIPFLAGS;

//  Flags for DiscardImages
//
//  ILDI_STANDBY and ILDI_PURGE are mutually exclusive.
//  ILDI_RESETACCESS can be combined with either.
typedef enum ILDIFLAGS {
	ILDI_PURGE       =0x00000001, // discard and purge
	ILDI_STANDBY     =0x00000002, // discard to standby list
	ILDI_RESETACCESS =0x00000004, // reset "has been accessed" flag
	ILDI_QUERYACCESS =0x00000008 // ask whether access flag is set (but do not reset)
} ILDIFLAGS;

typedef struct IMAGELISTSTATS
{
    DWORD       cbSize;
    int         cAlloc;     // number of images allocated
    int         cUsed;      // number of images in use
    int         cStandby;   // number of standby images
} IMAGELISTSTATS;// New for (_WIN32_IE >= 0x0605)

[
	odl,
    uuid(192b9d83-50fc-457b-90a0-2b82a8b5dae1)
]
interface IImageList2 : IImageList
{
    long Resize([in] int cxNewIconSize, 
				[in] int cyNewIconSize);

    long GetOriginalSize([in] int iImage, 
						 [in] ILGOSFLAGS dwFlags, 
						 [out] int *pcx, 
						 [out] int *pcy);

    long SetOriginalSize([in] int iImage, 
						 [in] int cx, 
						 [in] int cy);

    long SetCallback([in] IUnknown *punk);

    long GetCallback([in] UUID *riid, 
					 [out] LPVOID ppv);

    long ForceImagePresent([in] int iImage, 
						   [in] ILFIPFLAGS dwFlags);

    long DiscardImages([in] int iFirstImage, 
					   [in] int iLastImage, 
					   [in] ILDIFLAGS dwFlags);

    long PreloadImages([in] IMAGELISTDRAWPARAMS* pimldp);

    long GetStatistics([in, out] IMAGELISTSTATS *pils);

    long Initialize([in] int cx, [in] int cy, 
					[in] UINT flags, 
					[in] int cInitial, 
					[in] int cGrow);

    long Replace2([in] int i, 
				  [in] HBITMAP hbmImage, 
				  [in] HBITMAP hbmMask, 
				  [in] IUnknown *punk, 
				  [in] DWORD dwFlags);

    long ReplaceFromImageList([in] int i, 
							  [in] IImageList *pil, 
							  [in] int iSrc, 
							  [in] IUnknown *punk, 
							  [in] DWORD dwFlags);
};


typedef enum FOLDERLOGICALVIEWMODE
{
	FLVM_UNSPECIFIED = -1,
	FLVM_FIRST = 1,
	FLVM_DETAILS = 1,
	FLVM_TILES = 2,
	FLVM_ICONS = 3,
	FLVM_LIST = 4,
	FLVM_CONTENT = 5,
	FLVM_LAST = 5
} 	FOLDERLOGICALVIEWMODE;

typedef enum SORTDIRECTION
{
	SORT_DESCENDING = -1,
	SORT_ASCENDING = 1
} SORTDIRECTION;

typedef struct SORTCOLUMN
{
	PROPERTYKEY propkey;
	SORTDIRECTION direction;
} 	SORTCOLUMN;


[
    odl,
    uuid(a0ffbc28-5482-4366-be27-3e81e78e06c2)
]
interface ISearchFolderItemFactory : stdole.IUnknown
{
    HRESULT SetDisplayName(
        [in] LONG pszDisplayName);

    HRESULT SetFolderTypeID(
        /*[in] FOLDERTYPEID ftid);*/
		[in] UUID* ftid);
    HRESULT SetFolderLogicalViewMode(
        [in] FOLDERLOGICALVIEWMODE flvm);

    HRESULT SetIconSize(
        [in] int iIconSize);

    HRESULT SetVisibleColumns(
        [in] UINT cVisibleColumns,
        [in] PROPERTYKEY *rgKey);

    HRESULT SetSortColumns(
        [in] UINT cSortColumns,
        [in] SORTCOLUMN *rgSortColumns);

    HRESULT SetGroupColumn(
        [in] PROPERTYKEY *keyGroup);

    HRESULT SetStacks(
        [in] UINT cStackKeys,
        [in] PROPERTYKEY *rgStackKeys);

    HRESULT SetScope(
        [in] IShellItemArray *psiaScope);

    HRESULT SetCondition(
        [in] ICondition *pCondition);

    HRESULT GetShellItem(
        [in] UUID* riid,
        [out] LPVOID ppv);    // returns IShellItem, navigate to this

    HRESULT GetIDList(
        [out] PIDLIST_ABSOLUTE *ppidl);
};


[
	odl,
    uuid(505f1513-6b3e-4892-a272-59f8889a4d3e)
]
interface IImageRecompress : stdole.IUnknown
{
    long RecompressImage(
        [in] IShellItem *psi,
        [in] int cx,
        [in] int cy,
        [in] int iQuality,
        [in] IStorage *pstg,
        [in, out] IStream **ppstrmOut);
};
typedef enum TI_FLAGS {
	TI_BITMAP = 1,
	TI_JPEG = 2
} TI_FLAGS;

[
	odl,
	uuid(BAE86DDD-DC11-421c-B7AB-CC55D1D65C44)
]
interface ITranscodeImage : stdole.IUnknown
{
	long TranscodeImage(
		[in] IShellItem *pShellItem,
		[in] UINT uiMaxWidth,
		[in] UINT uiMaxHeight,
		[in] TI_FLAGS flags,
		[in] IStream *pvImage,
		[out] UINT *puiWidth,
		[out] UINT *puiHeight);
}; 

[
	odl,
    uuid(b3a4b685-b685-4805-99d9-5dead2873236)
]
interface IParentAndItem : stdole.IUnknown
{
    // 2 ways to init
    //      pidlParent == NULL
    //      psf is folder, pidlChild is child relative to psf
    HRESULT SetParentAndItem(
        [in] PCIDLIST_ABSOLUTE pidlParent,
        [in] IShellFolder *psf,
        [in] PCUITEMID_CHILD pidlChild);

    // all params optional
    //      ppidlParent gets full pidl to parent of item
    //      ppsf gets parent folder for item
    //      ppidlChild gets item relitve to psf

    HRESULT GetParentAndItem(
        [out] PIDLIST_ABSOLUTE *ppidlParent,
        [out] IShellFolder **ppsf,
        [out] PITEMID_CHILD *ppidlChild);
};

// to discover the search box, use IServiceProvider::QueryService() using SID_SSearchBoxInfo on a site pointer within the explorer window
[
	odl,
    uuid(6af6e03f-d664-4ef4-9626-f7e0ed36755e)
]
interface ISearchBoxInfo : stdole.IUnknown
{
    HRESULT GetCondition(
        [in] UUID *riid,
		[out] LPVOID ppv);    
        
    HRESULT GetText([out] LONG *ppsz);
};

//[
//    odl,
//    uuid(37A378C0-F82D-11CE-AE65-08002B2E1262)
//]
//interface IShellFolderView : stdole.IUnknown 
//{
//    STDMETHOD(Rearrange) (THIS_ LPARAM lParamSort) PURE; // use IFolderView2::SetSortColumns
//    STDMETHOD(GetArrangeParam) (THIS_ _Out_ LPARAM * plParamSort) PURE; // use IFolderView2::GetSortColumns
//    STDMETHOD(ArrangeGrid) (THIS) PURE; // select Arrange by Grid
//    STDMETHOD(AutoArrange) (THIS) PURE; // select Auto Arrange
//    STDMETHOD(GetAutoArrange) (THIS) PURE; // use IFolderView::GetAutoArrange
//    STDMETHOD(AddObject) (THIS_ _In_ PUITEMID_CHILD pidl, _Out_ UINT * puItem) PURE; // items added here may disappear (the data source is the final arbiter of which items are available to the view)
//    STDMETHOD(GetObject) (THIS_ _Outptr_ PITEMID_CHILD * ppidl, UINT uItem) PURE; // use IFolderView::Item
//    STDMETHOD(RemoveObject) (THIS_ _In_opt_ PUITEMID_CHILD pidl, _Out_ UINT * puItem) PURE; // items removed here may reappear (the data source is the final arbiter of which items are available to the view)
//    STDMETHOD(GetObjectCount) (THIS_ _Out_ UINT * puCount) PURE; // use IFolderView::ItemCount
//    STDMETHOD(SetObjectCount) (THIS_ UINT uCount, UINT dwFlags) PURE; // not implemented on Vista.  Sends LVM_SETITEMCOUNT with WPARAM=uCount and LPARAM=dwFlags to listview on XP.
//    STDMETHOD(UpdateObject) (THIS_ _In_ PUITEMID_CHILD pidlOld, _In_ PUITEMID_CHILD pidlNew, _Out_ UINT * puItem) PURE; // swaps ITEMID_CHILDs, returning new index.  Changes may be discarded (the data source is the final arbiter of which items are available to the view)
//    STDMETHOD(RefreshObject) (THIS_ _In_ PUITEMID_CHILD pidl, _Out_ UINT * puItem) PURE; // tickles the listview to re-draw the item
//    STDMETHOD(SetRedraw) (THIS_ BOOL bRedraw) PURE; // sends WM_SETREDRAW to the listview
//    STDMETHOD(GetSelectedCount) (THIS_ _Out_ UINT * puSelected) PURE; // use IFolderView2::GetSelection
//    // NOTE: GetSelectedObjects hands out const pointers to internal ITEMID_CHILD structures. The caller is expected to act on them immediately (and not cache them).  LocalFree the array, but not the items it contains.
//    STDMETHOD(GetSelectedObjects) (THIS_ _Outptr_result_buffer_(*puItems) PCUITEMID_CHILD * *pppidl, _Out_ UINT * puItems) PURE; // use IFolderView2::GetSelection.
//    STDMETHOD(IsDropOnSource) (THIS_ _In_opt_ IDropTarget * pDropTarget) PURE; // use IFolderView2::IsMoveInSameFolder
//    STDMETHOD(GetDragPoint) (THIS_ _Out_ POINT * ppt) PURE; // returns point corresponding to drag-and-drop operation
//    STDMETHOD(GetDropPoint) (THIS_ _Out_ POINT * ppt) PURE; // returns point corresponding to drag-and-drop operation
//    STDMETHOD(MoveIcons) (THIS_ _In_ IDataObject * pDataObject) PURE; // not implemented
//    STDMETHOD(SetItemPos) (THIS_ _In_ PCUITEMID_CHILD pidl, _In_ POINT * ppt) PURE; // use IFolderView::SelectAndPositionItems
//    STDMETHOD(IsBkDropTarget) (THIS_ _In_opt_ IDropTarget * pDropTarget) PURE; // returns S_OK if drag-and-drop is on the background, S_FALSE otherwise
//    STDMETHOD(SetClipboard) (THIS_ BOOL bMove) PURE; // if bMove is TRUE, this attempts to cut (edit.cut, ctrl-x) the current selection.  bMove of FALSE is not supported.
//    STDMETHOD(SetPoints) (THIS_ _In_ IDataObject * pDataObject) PURE; // copies points of current selection in to data object.  Call is not needed if drag operation was originated by the IShellView.
//    STDMETHOD(GetItemSpacing) (THIS_ _Out_ ITEMSPACING * pSpacing) PURE; // use IFolderView::GetSpacing instead.  GetItemSpacing returns the spacing for small and large view modes only, returning S_OK if the current view mode is is positionable, S_FALSE otherwise.
//    STDMETHOD(SetCallback) (THIS_ _In_opt_ IShellFolderViewCB * pNewCB, _Outptr_result_maybenull_ IShellFolderViewCB * *ppOldCB) PURE; // replace the IShellFolderViewCB that the IShellView uses
//    STDMETHOD(Select) (THIS_  UINT dwFlags) PURE; // SFVS_ select flags: select all, select none, invert selection
//    STDMETHOD(QuerySupport) (THIS_ _Inout_ UINT * pdwSupport) PURE; // does nothing, returns S_OK.
//    STDMETHOD(SetAutomationObject)(THIS_ _In_opt_ IDispatch * pdisp) PURE; // replaces the IShellView's internal automation object.
//};

//NOTE: V_TABLE SWAP REQUIRED
//Default 0/S_OK return interpreted as message handled
//Need to return E_NOTIMPL in order for default handler to kick in
[
	odl,
	uuid(2047E320-F2A9-11CE-AE65-08002B2E1262)
]
interface IShellFolderViewCB : stdole.IUnknown
{
	HRESULT MessageSFVCB(
		[in] UINT   uMsg,
        [in] LONG wParam,
        [in] LONG lParam);
};


typedef enum SFV_Messages {
	SFVM_MERGEMENU = 1,    // -                  LPQCMINFO
	SFVM_INVOKECOMMAND = 2,    // idCmd              -
	SFVM_GETHELPTEXT = 3,    // idCmd,cchMax       pszText
	SFVM_GETTOOLTIPTEXT = 4,    // idCmd,cchMax       pszText
	SFVM_GETBUTTONINFO = 5,    // -                  LPTBINFO
	SFVM_GETBUTTONS = 6,    // idCmdFirst,cbtnMax LPTBBUTTON
	SFVM_INITMENUPOPUP = 7,    // idCmdFirst,nIndex  hmenu
	SFVM_FSNOTIFY = 14,    // LPCITEMIDLIST*     lEvent
	SFVM_WINDOWCREATED = 15,    // hwnd               -
	SFVM_GETDETAILSOF = 23,    // iColumn            DETAILSINFO*
	SFVM_COLUMNCLICK = 24,    // iColumn            -
	SFVM_QUERYFSNOTIFY = 25,    // -                  SHChangeNotifyEntry *
	SFVM_DEFITEMCOUNT = 26,    // -                  UINT*
	SFVM_DEFVIEWMODE = 27,   // -                  FOLDERVIEWMODE*
	SFVM_UNMERGEMENU = 28,    // -                  hmenu
	SFVM_UPDATESTATUSBAR = 31,    // fInitialize        -
	SFVM_BACKGROUNDENUM = 32,    // -                  -
	SFVM_DIDDRAGDROP = 36,    // dwEffect           IDataObject *
	SFVM_SETISFV = 39,    // -                  IShellFolderView*
	SFVM_THISIDLIST = 41,    // -                  LPITMIDLIST*
	SFVM_ADDPROPERTYPAGES = 47,    // -                  SFVM_PROPPAGE_DATA *
	SFVM_BACKGROUNDENUMDONE = 48,    // -                  -
	SFVM_GETNOTIFY = 49,    // LPITEMIDLIST*      LONG*
	SFVM_GETSORTDEFAULTS = 53,    // iDirection         iParamSort
	SFVM_SIZE = 57,    // -                  -
	SFVM_GETZONE = 58,    // -                  DWORD*
	SFVM_GETPANE = 59,    // Pane ID            DWORD*
	SFVM_GETHELPTOPIC = 63,    // -                  SFVM_HELPTOPIC_DATA *
	SFVM_GETANIMATION = 68    // HINSTANCE *        WCHAR *
} SFV_Messages;

[
	odl,
	uuid(76e54780-ad74-48e3-a695-3ba9a0aff10d)
]
interface IPreviousVersionsInfo : stdole.IUnknown
{
	HRESULT AreSnapShotsAvailable(
		[in] LONG pszPath,
		[in] BOOL fOkToBeSlow,
		[out, retval] BOOL *pfAvailable);
};

//typedef enum URLZONE { 
//  URLZONE_INVALID         = -1,
//  URLZONE_PREDEFINED_MIN  = 0,
//  URLZONE_LOCAL_MACHINE   = 0,
//  URLZONE_INTRANET,
//  URLZONE_TRUSTED,
//  URLZONE_INTERNET,
//  URLZONE_UNTRUSTED,
//  URLZONE_PREDEFINED_MAX  = 999,
//  URLZONE_USER_MIN        = 1000,
//  URLZONE_USER_MAX        = 10000
//} URLZONE;


[
    odl,
    uuid(cd45f185-1b21-48e2-967b-ead743a8914e)
]
interface IZoneIdentifier : stdole.IUnknown
{
    long GetId([out] DWORD *pdwZone);
    long SetId([in] DWORD dwZone);
    long Remove();
};

[
	odl,
	uuid(EB5E760C-09EF-45C0-B510-70830CE31E6A)
]
interface IZoneIdentifier2 : IZoneIdentifier
{
	long GetLastWriterPackageFamilyName([out] long* packageFamilyName);
	long SetLastWriterPackageFamilyName([in] long packageFamilyName);
	long RemoveLastWriterPackageFamilyName();

	long GetAppZoneId([out] DWORD* zone);
	long SetAppZoneId([in] DWORD zone);
	long RemoveAppZoneId();
};

typedef enum ASSOCIATIONLEVEL
{
    AL_MACHINE,
    AL_EFFECTIVE,
    AL_USER,
} ASSOCIATIONLEVEL;

typedef enum ASSOCIATIONTYPE
{
    AT_FILEEXTENSION,
    AT_URLPROTOCOL,
    AT_STARTMENUCLIENT,
    AT_MIMETYPE,
} ASSOCIATIONTYPE;

// Application File Extension and URL Protocol Registration
//Create with SHCreateAssociationRegistration
[
    odl,
    uuid(4e530b0a-e611-4c77-a3ac-9031d022281b)
]
interface IApplicationAssociationRegistration : stdole.IUnknown
{
    HRESULT QueryCurrentDefault(
        [in] LONG pszQuery,
        [in] ASSOCIATIONTYPE atQueryType,
        [in] ASSOCIATIONLEVEL alQueryLevel,
        [out] LONG *ppszAssociation);

    HRESULT QueryAppIsDefault(
        [in] LONG pszQuery,
        [in] ASSOCIATIONTYPE atQueryType,
        [in] ASSOCIATIONLEVEL alQueryLevel,
        [in] LONG pszAppRegistryName,
        [out] BOOL* pfDefault);

    HRESULT QueryAppIsDefaultAll(
        [in] ASSOCIATIONLEVEL alQueryLevel,
        [in] LONG pszAppRegistryName,
        [out] BOOL* pfDefault);

    HRESULT SetAppAsDefault(
        [in] LONG pszAppRegistryName,
        [in] LONG pszSet,
        [in] ASSOCIATIONTYPE atSetType);

    HRESULT SetAppAsDefaultAll(
        [in] LONG pszAppRegistryName);

    HRESULT ClearUserAssociations();
}

// SHCreateAssociationRegistration can be used to create an IApplicationAssociationRegistration

// Application File Extension and URL Protocol Registration UI
[
    odl,
    uuid(1f76a169-f994-40ac-8fc8-0959e8874710)
]
interface IApplicationAssociationRegistrationUI : stdole.IUnknown
{
    HRESULT LaunchAdvancedAssociationUI([in] LONG pszAppRegistryName);
}
[
	odl,
	uuid(ADE87BF7-7B56-4275-8FAB-B9B0E591844B)
]
interface ISystemInformation : stdole.IDispatch
{
	HRESULT OemHardwareSupportLink([out, retval] BSTR *rtval);

	HRESULT RebootRequired([out, retval] BOOL *rtval);
};

[
	odl,
	uuid(7d688a70-c613-11d0-999b-00c04fd655e1)
]
interface IShellIconOverlay : stdole.IUnknown
{
	HRESULT GetOverlayIndex([in] LONG pidlRel,
							[in] LONG pIndex);
	HRESULT GetOverlayIconIndex([in] LONG pidlRel,
								[in] LONG pIndex);
};

[
	odl,
	uuid(0c6c4200-c589-11d0-999a-00c04fd655e1)
]
interface IShellIconOverlayIdentifier : stdole.IUnknown
{
	HRESULT IsMemberOf([in] LONG pwszPath, [in] LONG dwAttrib);
	HRESULT GetOverlayInfo([out] LONG* pwszIconFile, [out] int* cchMax, [out] int *pIndex, [out] LONG *pdwFlags);
	HRESULT GetPriority([out] int* pIPriority);
};

//[
//	odl,
//	uuid(f10b5e34-dd3b-42a7-aa7d-2f4ec54bb09b)
//]
//interface IShellIconOverlayManager : stdole.IUnknown

typedef enum FVTEXTTYPE
{
    FVST_EMPTYTEXT  = 0,
} FVTEXTTYPE;


[
	odl,
    uuid(1af3a467-214f-4298-908e-06b03e0b39f9)
]
interface IFolderView2 : IFolderView
{
    // Sets the group by property and starts a grouping operation
    HRESULT SetGroupBy(
        [in] PROPERTYKEY *key,
        [in] BOOL fAscending);

    HRESULT GetGroupBy(
        [out] PROPERTYKEY* pkey,
        [out] BOOL *pfAscending);

    // Setting and Getting per item view properties is not possible for Libraries or Search results views.
    // Consider using existing item properties instead.
    HRESULT SetViewProperty(
        [in] PCUITEMID_CHILD pidl,
        [in] PROPERTYKEY *propkey,
        [in] VARIANT *propvar);

    // Setting and Getting per item view properties is not possible for Libraries or Search results views.
    // Consider using existing item properties instead.
    HRESULT GetViewProperty(
        [in] PCUITEMID_CHILD pidl,
        [in] PROPERTYKEY *propkey,
        [out] VARIANT *ppropvar);

    // Setting per item Tile view properties is not possible for Libraries or Search results views.
    // Consider setting property lists for your item types instead (see PKEY_PropList_TileInfo)
    HRESULT SetTileViewProperties(
        [in] PCUITEMID_CHILD pidl,
        [in] LONG pszPropList);

    // Setting per item Extended Tile view properties is not possible for Libraries or Search results views.
    // Consider setting property lists for your item types instead (see PKEY_PropList_ExtendedTileInfo)
    HRESULT SetExtendedTileViewProperties(
        [in] PCUITEMID_CHILD pidl,
        [in] LONG pszPropList);

    HRESULT SetText(
        [in] FVTEXTTYPE iType,
        [in] LONG pwszText);

    HRESULT SetCurrentFolderFlags(
        [in] DWORD /* FOLDERFLAGS */ dwMask,
        [in] DWORD /* FOLDERFLAGS */ dwFlags);



    HRESULT GetCurrentFolderFlags([out] DWORD *pdwFlags);



    HRESULT GetSortColumnCount([out] int *pcColumns);

    // Sets the sort by property and starts a sort operation
    HRESULT SetSortColumns(
        [in] SORTCOLUMN *rgSortColumns,
        [in] int cColumns);

    HRESULT GetSortColumns(
        [in] long rgSortColumns,
        [in] int cColumns);
    // return IShellItem for an item based on its index
    HRESULT GetItem(
        [in] int iItem,
        [in] UUID *riid,
        [out] LPVOID ppv);

    HRESULT GetVisibleItem(
        [in] int iStart,
        [in] BOOL fPrevious,
        [out] int *piItem);

    HRESULT GetSelectedItem(
        [in] int iStart,
        [out] int *piItem);

    HRESULT GetSelection(
        [in] BOOL fNoneImpliesFolder,
        [out] IShellItemArray **ppsia);

    // Gets the selection state including check state.  Same as the flags for IFolderView::SelectAndPositionItems
    HRESULT GetSelectionState(
        [in] PCUITEMID_CHILD pidl,
        [out] DWORD *pdwFlags);

    // If pszVerb is NULL, then the default verb is invoked.
    HRESULT InvokeVerbOnSelection([in] LONG pszVerb);

    // Sets default icon size if iImageSize == -1
    HRESULT SetViewModeAndIconSize(
        [in] FOLDERVIEWMODE uViewMode,
        [in] int iImageSize);

    HRESULT GetViewModeAndIconSize(
        [out] FOLDERVIEWMODE *puViewMode,
        [out] int *piImageSize);

    HRESULT SetGroupSubsetCount([in] UINT cVisibleRows);

    HRESULT GetGroupSubsetCount([out] UINT *pcVisibleRows);

    HRESULT SetRedraw([in] BOOL fRedrawOn);

    // S_OK means this view sourced the current drag drop or cut/paste operation (used by drop target objects)
    HRESULT IsMoveInSameFolder();

    HRESULT DoRename();
}

[
	odl,
    uuid(ae8c987d-8797-4ed3-be72-2a47dd938db0)
]
interface IFolderViewSettings : stdole.IUnknown
{
    // GetColumnPropertyList - returns IPropertyDescriptionList.  Ordered list of columns that must correspond to column enumerated
    // via ISF::GetDetailsOf. Any column from ISF::GetDetailsOf not included in this list will be marked SHCOLSTATE_SECONDARYUI
    // (or maintain SHCOLSTATE_HIDDEN)
    HRESULT GetColumnPropertyList(
        [in] UUID *riid,
		[out] LPVOID ppv);

    HRESULT GetGroupByProperty(
        [out] PROPERTYKEY *pkey,
        [out] BOOL *pfGroupAscending);

    HRESULT GetViewMode(
        [out] FOLDERLOGICALVIEWMODE *plvm);

    HRESULT GetIconSize(
        [out] UINT *puIconSize);

    HRESULT GetFolderFlags(
        [out] FOLDERFLAGS *pfolderMask,
        [out] FOLDERFLAGS *pfolderFlags);

    HRESULT GetSortColumns(
        [out] SORTCOLUMN *rgSortColumns,
        [in] UINT cColumnsIn,
        [out] UINT *pcColumnsOut);

    HRESULT GetGroupSubsetCount([out] UINT *pcVisibleRows);
};

    typedef enum FOLDERVIEWOPTIONS
    {
        FVO_DEFAULT               = 0x00000000, // default needs none of these options and will use Itemsview
        FVO_VISTALAYOUT           = 0x00000001, // always use listview to maintain vista parity
        FVO_CUSTOMPOSITION        = 0x00000002, // requires the custom positioning of items within the X,Y space of the view
        FVO_CUSTOMORDERING        = 0x00000004, // requires the custom reordering feature of the view
        FVO_SUPPORTHYPERLINKS     = 0x00000008, // requires the use of hyperlinks in tiles and details modes
        FVO_NOANIMATIONS          = 0x00000010, // turn off animations within the view
        FVO_NOSCROLLTIPS          = 0x00000020, // turn off scroll tips 
    } FOLDERVIEWOPTIONS;
[
	odl,
    uuid(3cc974d2-b302-4d36-ad3e-06d93f695d3f)
]
interface IFolderViewOptions : stdole.IUnknown
{

    HRESULT SetFolderViewOptions(
               [in] FOLDERVIEWOPTIONS fvoMask,
               [in] FOLDERVIEWOPTIONS fvoFlags);

    HRESULT GetFolderViewOptions(
               [out] FOLDERVIEWOPTIONS *pfvoFlags);
};

[
    odl,
    uuid(5cd52983-9449-11d2-963a-00c04f79adf0)
]
interface IResolveShellLink : stdole.IUnknown
{
    HRESULT ResolveShellLink(
        [in] IUnknown *punkLink,
        [in] HWND hwnd,
        [in] SLR_FLAGS fFlags);
};
[
	odl,
    uuid(4CD19ADA-25A5-4A32-B3B7-347BEE5BE36B)
]
interface IStartMenuPinnedList : stdole.IUnknown
{
    //  if pitem is not pinned, return S_OK
    //  if pitem is pinned, the pitem is successfully removed from pinned list, return S_OK
    //  if pitem is pinned, the pitem fail to be removed from pinned list, return error HRESULT
    HRESULT RemoveFromList([in] IShellItem *pitem);
};

[
        uuid(00BB2761-6A77-11D0-A535-00C04FD7D062),
        odl
]
interface IObjMgr : stdole.IUnknown
{
	HRESULT Append([in] IUnknown *punk);
	HRESULT Remove([in] IUnknown *punk);
};
[
		uuid(3CD141F4-3C6A-11d2-BCAA-00C04FD929DB),
		odl
]
interface IAutoCompleteDropDown : stdole.IUnknown
{
	HRESULT GetDropDownStatus([out] LONG *pdwFlags, [out] LONG *ppwszString);
	HRESULT ResetEnumerator();
};

[
	odl,
    uuid(9CC22886-DC8E-11d2-B1D0-00C04F8EEB3E) // IID_IFolderFilter
]
interface IFolderFilter : stdole.IUnknown
{
    HRESULT ShouldShow(
        [in] IShellFolder* psf,
        [in] PCIDLIST_ABSOLUTE pidlFolder,
        [in] PCUITEMID_CHILD pidlItem);

    HRESULT GetEnumFlags(
        [in] IShellFolder* psf,
        [in] PCIDLIST_ABSOLUTE pidlFolder,
        [in, out] HWND *phwnd,
        [in, out] DWORD *pgrfFlags);
};

typedef enum SHELL_LINK_DATA_FLAGS { 
  SLDF_DEFAULT                                = 0x00000000,
  SLDF_HAS_ID_LIST                            = 0x00000001,
  SLDF_HAS_LINK_INFO                          = 0x00000002,
  SLDF_HAS_NAME                               = 0x00000004,
  SLDF_HAS_RELPATH                            = 0x00000008,
  SLDF_HAS_WORKINGDIR                         = 0x00000010,
  SLDF_HAS_ARGS                               = 0x00000020,
  SLDF_HAS_ICONLOCATION                       = 0x00000040,
  SLDF_UNICODE                                = 0x00000080,
  SLDF_FORCE_NO_LINKINFO                      = 0x00000100,
  SLDF_HAS_EXP_SZ                             = 0x00000200,
  SLDF_RUN_IN_SEPARATE                        = 0x00000400,
  SLDF_HAS_LOGO3ID                            = 0x00000800,
  SLDF_HAS_DARWINID                           = 0x00001000,
  SLDF_RUNAS_USER                             = 0x00002000,
  SLDF_HAS_EXP_ICON_SZ                        = 0x00004000,
  SLDF_NO_PIDL_ALIAS                          = 0x00008000,
  SLDF_FORCE_UNCNAME                          = 0x00010000,
  SLDF_RUN_WITH_SHIMLAYER                     = 0x00020000,
  SLDF_FORCE_NO_LINKTRACK                     = 0x00040000,
  SLDF_ENABLE_TARGET_METADATA                 = 0x00080000,
  SLDF_DISABLE_LINK_PATH_TRACKING             = 0x00100000,
  SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING  = 0x00200000,
  SLDF_NO_KF_ALIAS                            = 0x00400000,
  SLDF_ALLOW_LINK_TO_LINK                     = 0x00800000,
  SLDF_UNALIAS_ON_SAVE                        = 0x01000000,
  SLDF_PREFER_ENVIRONMENT_PATH                = 0x02000000,
  SLDF_KEEP_LOCAL_IDLIST_FOR_UNC_TARGET       = 0x04000000,
  SLDF_PERSIST_VOLUME_ID_RELATIVE             = 0x08000000,
  SLDF_VALID                                  = 0x0FFFF7FF,
  SLDF_RESERVED                               = 0x80000000
} SHELL_LINK_DATA_FLAGS;

typedef enum SHELL_LINK_DATABLOCK_SIG {
	EXP_SZ_LINK_SIG         = 0xA0000001,
	NT_CONSOLE_PROPS_SIG    = 0xA0000002,
	NT_FE_CONSOLE_PROPS_SIG = 0xA0000004,
	EXP_SPECIAL_FOLDER_SIG  = 0xA0000005,
	EXP_DARWIN_ID_SIG       = 0xA0000006,
	EXP_SZ_ICON_SIG         = 0xA0000007,
	EXP_PROPERTYSTORAGE_SIG = 0xA0000009
} SHELL_LINK_DATABLOCK_SIG;

typedef struct DATABLOCKHEADER
{
    DWORD   cbSize;             // Size of this extra data block
    SHELL_LINK_DATABLOCK_SIG   dwSignature;        // signature of this extra data block
} DATABLOCK_HEADER;
typedef struct COORD {
	SHORT x;
	SHORT y;
} COORD;

typedef struct NT_CONSOLE_PROPS {
    DATABLOCK_HEADER dbh;
    WORD     wFillAttribute;         // fill attribute for console
    WORD     wPopupFillAttribute;    // fill attribute for console popups
    COORD    dwScreenBufferSize;     // screen buffer size for console
    COORD    dwWindowSize;           // window size for console
    COORD    dwWindowOrigin;         // window origin for console
    DWORD    nFont;
    DWORD    nInputBufferSize;
    COORD    dwFontSize;
    UINT     uFontFamily;
    UINT     uFontWeight;
    WCHAR    FaceName[32]; //[LF_FACESIZE]
    UINT     uCursorSize;
    BOOL     bFullScreen;
    BOOL     bQuickEdit;
    BOOL     bInsertMode;
    BOOL     bAutoPosition;
    UINT     uHistoryBufferSize;
    UINT     uNumberOfHistoryBuffers;
    BOOL     bHistoryNoDup;
    COLORREF ColorTable[ 16 ];
} NT_CONSOLE_PROPS;
// This is a FE Console property
typedef struct NT_FE_CONSOLE_PROPS {
    DATABLOCK_HEADER dbh;
    UINT     uCodePage;
} NT_FE_CONSOLE_PROPS;
typedef struct EXP_DARWIN_LINK {
    DATABLOCK_HEADER dbh;
    BYTE        szDarwinID[260];  // ANSI darwin ID associated with link
    WCHAR       szwDarwinID[260]; // UNICODE darwin ID associated with link
} EXP_DARWIN_LINK;
typedef struct EXP_SPECIAL_FOLDER
{
    DWORD       cbSize;             // Size of this extra data block
    SHELL_LINK_DATABLOCK_SIG       dwSignature;        // signature of this extra data block
    DWORD       idSpecialFolder;    // special folder id this link points into
    DWORD       cbOffset;           // ofset into pidl from SLDF_HAS_ID_LIST for child
} EXP_SPECIAL_FOLDER;
typedef struct EXP_SZ_LINK
{
    DWORD       cbSize;             // Size of this extra data block
    SHELL_LINK_DATABLOCK_SIG       dwSignature;        // signature of this extra data block
    BYTE        szTarget[260];   // ANSI target name w/EXP_SZ in it
    WCHAR       swzTarget[260];  // UNICODE target name w/EXP_SZ in it
} EXP_SZ_LINK;
typedef struct EXP_PROPERTYSTORAGE
{
    DWORD       cbSize;             // Size of this extra data block
    SHELL_LINK_DATABLOCK_SIG       dwSignature;        // signature of this extra data block
    BYTE abPropertyStorage[1];
} EXP_PROPERTYSTORAGE; //Vista+


[
	odl,
    uuid(45e2b4ae-b1c3-11d0-b92f-00a0c90312e1)
]
interface IShellLinkDataList : stdole.IUnknown
{
	long AddDataBlock(
        [in] void * pDataBlock);

	long CopyDataBlock(
        [in] SHELL_LINK_DATABLOCK_SIG dwSig,
        [out] LPVOID ppDataBlock);

	long RemoveDataBlock(
        [in] SHELL_LINK_DATABLOCK_SIG dwSig);

    // flags are SLDF_ values as defined in shlobj.h
	long GetFlags(
        [out] SHELL_LINK_DATA_FLAGS *pdwFlags);

	long SetFlags(
        [in] SHELL_LINK_DATA_FLAGS dwFlags);
}

[
	odl,
	uuid(3D8B0590-F691-11d2-8EA9-006097DF5BD4)
]
interface IDataObjectAsyncCapability : stdole.IUnknown
{
    HRESULT SetAsyncMode([in] BOOL fDoOpAsync);
    HRESULT GetAsyncMode([out] BOOL * pfIsOpAsync);
	[helpstring("Optional IBindContext pbcReserved replaced with LONG; use ObjPtr")]
    HRESULT StartOperation([in] LONG pbcReserved);
    HRESULT InOperation([out] BOOL * pfInAsyncOp);
	[helpstring("Optional IBindContext pbcReserved replaced with LONG; use ObjPtr")]
    HRESULT EndOperation([in] LONG hResult, [in] LONG pbcReserved, [in] DWORD dwEffects);
}

typedef enum NWMF
{
    NWMF_UNLOADING        = 0x00000001,  // The query is occuring during onBeforeUnload or onUnload
    NWMF_USERINITED       = 0x00000002,  // The query is occuring in the context of what trident considers to be a user initiated action
    NWMF_FIRST            = 0x00000004,  // This is the first query since the begining of the last user initiated action
    NWMF_OVERRIDEKEY      = 0x00000008,  // The override key was pressed at the time the query was made
    NWMF_SHOWHELP         = 0x00000010,  // New window is an HTML help window
    NWMF_HTMLDIALOG       = 0x00000020,  // New window is an HTML dialog
    NWMF_FROMDIALOGCHILD  = 0x00000040,  // Called from an HTML dialog - do not show UI in parent window
    NWMF_USERREQUESTED    = 0x00000080,  // There is no doubt the user requested this window (from RClick->Open in New Window, or Shift+Clicked a link)
    NWMF_USERALLOWED      = 0x00000100,  // This popup is the result of the user requesting a replay that resulted in a refresh
    NWMF_FORCEWINDOW      = 0x00010000,  // This popup should be forced to open in a new window
    NWMF_FORCETAB         = 0x00020000,  // This popup should be forced to open in a new tab
    NWMF_SUGGESTWINDOW    = 0x00040000,  // This popup should open in a new window unless user forced pop-ups to a tab
    NWMF_SUGGESTTAB       = 0x00080000,  // This popup should open in a new tab unless user forced pop-ups to a window
    NWMF_INACTIVETAB      = 0x00100000,  // This popup came from an inactive tab
} NWMF;

[
	odl,
    uuid(D2BC4C84-3F72-4a52-A604-7BCBF3982CBB)
]
interface INewWindowManager : stdole.IUnknown
{
    HRESULT EvaluateNewWindow(
        [in, string] LPCWSTR pszUrl,
        [in, string] LPCWSTR pszName,
        [in, string] LPCWSTR pszUrlContext,
        [in, string] LPCWSTR pszFeatures,
        [in] BOOL fReplace,
        [in] DWORD dwFlags,
        [in] DWORD dwUserActionTime);
}

[
	odl,
    uuid(ADD8BA80-002B-11D0-8F0F-00C04FD7D062)
]
interface IDelegateFolder : stdole.IUnknown
{
    // use to give the delegate folder the IMalloc interface that it
    // needs to use to alloc and free item IDs.
    // These IDs are in the form of DELEGATEITEMIDs
    // and it is the delegates job to pack its data into the pidl
    // in the delegate format
    long SetItemAlloc([in] IMalloc *pmalloc);
}

[
    odl,
    uuid(41ded17d-d6b3-4261-997d-88c60e4b1d58)
]
interface IDefaultExtractIconInit : stdole.IUnknown
{
    // set IExtractIcon GIL_XXX flags
    HRESULT SetFlags([in] GILFlags uFlags);

    // set the registry key to load "DefaultIcon" value from
    HRESULT SetKey([in] HKEY hkey);

    // set the various forms of icons, if pszFile is NULL iIcon is SHSTOCKICONID (SIID_) value
    HRESULT SetNormalIcon(
        [in] LONG pszFile,
        [in] int iIcon);

    HRESULT SetOpenIcon(
        [in] LONG pszFile,
        [in] int iIcon);

    HRESULT SetShortcutIcon(
        [in] LONG pszFile,
        [in] int iIcon);

    HRESULT SetDefaultIcon(
        [in] LONG pszFile,
        [in] int iIcon);
}

interface IEnumExplorerCommand;

typedef enum EXPCMDSTATE
{
    ECS_ENABLED     = 0x00,
    ECS_DISABLED    = 0x01,
    ECS_HIDDEN      = 0x02,
    ECS_CHECKBOX    = 0x04,
    ECS_CHECKED     = 0x08,
    ECS_RADIOCHECK  = 0x10,
} EXPCMDSTATE;

typedef enum EXPCMDFLAGS
{
    ECF_DEFAULT =          0x000,
    ECF_HASSUBCOMMANDS =   0x001,
    ECF_HASSPLITBUTTON =   0x002,
    ECF_HIDELABEL =        0x004,
    ECF_ISSEPARATOR =      0x008,
    ECF_HASLUASHIELD =     0x010,
    ECF_SEPARATORBEFORE =  0x020,
    ECF_SEPARATORAFTER =   0x040,
    ECF_ISDROPDOWN =       0x080,
    ECF_TOGGLEABLE =       0x100, // New for NTDDI_WIN8
    ECF_AUTOMENUICONS =    0x200, // New for NTDDI_WIN8
} EXPCMDFLAGS;

[
	odl,
    uuid(a08ce4d0-fa25-44ab-b57c-c7b1c323e0b9)
]
interface IExplorerCommand : stdole.IUnknown
{


    HRESULT GetTitle([in] IShellItemArray *psiItemArray, [out] LONG *ppszName);

    // fill in ppszIcon with an icon resource strings format, for example "shell32,-123"
    HRESULT GetIcon([in] IShellItemArray *psiItemArray, [out] LONG *ppszIcon);

    HRESULT GetToolTip([in] IShellItemArray *psiItemArray, [out] LONG *ppszInfotip);

    HRESULT GetCanonicalName([out] UUID *pguidCommandName);

    // Compute the visibility state of the verb here
    // When "fOkToBeSlow" is FALSE this method must return quickly, in this case you can
    // return E_PENDING and this object will be recreated on a background thread and called with
    // fOkToBeSlow == TRUE where you can do expensive work.
    HRESULT GetState([in] IShellItemArray *psiItemArray, [in] BOOL fOkToBeSlow, [out] EXPCMDSTATE *pCmdState);

    HRESULT Invoke([in] IShellItemArray *psiItemArray, [in] IBindCtx *pbc);

    HRESULT GetFlags([out] EXPCMDFLAGS *pFlags);

    // If GetFlags() returned ECF_HASSUBCOMMANDS this will be used to discover the sub commands.
    HRESULT EnumSubCommands([out] IEnumExplorerCommand **ppEnum);
}

[
	odl,
    uuid(bddacb60-7657-47ae-8445-d23e1acf82ae)
]
interface IExplorerCommandState : stdole.IUnknown
{
    // Compute the visibility state of the verb here
    // When "fOkToBeSlow" is FALSE this method must return quickly, in this case you can
    // return E_PENDING and this object will be recreated on a background thread and called with
    // fOkToBeSlow == TRUE where you can do expensive work.
    // this method has the same semantics as IExplorerCommand::GetState()
    HRESULT GetState([in] IShellItemArray *psiItemArray, [in] BOOL fOkToBeSlow, [out] EXPCMDSTATE *pCmdState);
}

[
    odl,
    uuid(85075acf-231f-40ea-9610-d26b7b58f638)
]
interface IInitializeCommand : stdole.IUnknown
{
    // pszCommandName - This parameter is the verb that this handler instance is
    // being created for. If the same handler is used for different verbs this lets the
    // handler have different behavior for different verbs.
    //
    // ppb - This parameter provides access to values stored in the registry under the verb.
    // These values can be used to control the behavior of the verb handler for
    // different verb isntances.
    //
    // Another property bag can be used to share state between handler instances. This can be
    // accessed by implementing IObjectWithSite and then querying the site for SID_CommandsPropertyBag.
    HRESULT Initialize([in] LONG pszCommandName, [in] IPropertyBag *ppb);
}

[
	odl,
    uuid(a88826f8-186f-4987-aade-ea0cef8fbfe8)
]
interface IEnumExplorerCommand : stdole.IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out] IExplorerCommand** pUICommand,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out] IEnumExplorerCommand **ppenum);
}

[
	odl,
    uuid(64961751-0835-43c0-8ffe-d57686530e64)
]
interface IExplorerCommandProvider : stdole.IUnknown
{
    // IEnumExplorerCommand
    HRESULT GetCommands(
        [in] IUnknown *punkSite,
        [in] UUID *riid,
        [out] LPVOID ppv);

    // IExplorerCommand
    HRESULT GetCommand(
        [in] UUID *rguidCommandId,
        [in] UUID *riid,
        [out] LPVOID ppv);
}

typedef enum EC_HOST_UI_MODE
{
    ECHUIM_DESKTOP,
    ECHUIM_IMMERSIVE,
    ECHUIM_SYSTEM_LAUNCHER,
} EC_HOST_UI_MODE;

// IExecuteCommandHost is implemented by the host who invokes an ExplorerCommand based shell verb via
// ShellExecuteEx() or IContextMenu::InvokeCommand(). This interface is implemented on an object 
// reachable via the site chain provided to ShellExecuteEx() or the context menu and retrieved by 
// IServiceProvider::QueryService(..., SID_ExecuteCommandHost, ...).
// IExecuteCommandHost::GetUIMode is called by an ExplorerCommand based verb handler to query the host UI mode.
[
    odl,
    uuid(4b6832a2-5f04-4c9d-b89d-727a15d103e7)
]
interface IExecuteCommandHost : stdole.IUnknown
{
    HRESULT GetUIMode([out] EC_HOST_UI_MODE *pUIMode);
}

[
	odl,
    uuid(10DF43C8-1DBE-11d3-8B34-006097DF5BD4)
]
interface IBrowserFrameOptions : stdole.IUnknown
{
    typedef enum BROWSERFRAMEOPTIONS
    {
        BFO_NONE                            = 0x00000000,      // Do nothing.
        BFO_BROWSER_PERSIST_SETTINGS        = 0x00000001,      // Does this item want the browser stream? (Same window position as IE browser windows?)
        BFO_RENAME_FOLDER_OPTIONS_TOINTERNET = 0x00000002,     // Rename "Folder Options" to "Internet Options" in the Tools or View menu?
        BFO_BOTH_OPTIONS                    = 0x00000004,      // Keep both "Folder Options" and "Internet Options" in the Tools or View menu?
        BIF_PREFER_INTERNET_SHORTCUT        = 0x00000008,      // NSE would prefer a .url shortcut over a .lnk shortcut
        BFO_BROWSE_NO_IN_NEW_PROCESS        = 0x00000010,      // Specify this flag if you don't want the "Browse in New Process" via invoking a shortcut.
        BFO_ENABLE_HYPERLINK_TRACKING       = 0x00000020,      // Does this NSE want it's display name tracked to determine when hyperlinks should be tagged as previously used?
        BFO_USE_IE_OFFLINE_SUPPORT          = 0x00000040,      // Use "Internet Explorer"'s offline support?
        BFO_SUBSTITUE_INTERNET_START_PAGE   = 0x00000080,      // Does this NSE want to use the Start Page support?
        BFO_USE_IE_LOGOBANDING              = 0x00000100,      // Use the Brand block in the Toolbar.  (Spinning globe or whatever it is this year)
        BFO_ADD_IE_TOCAPTIONBAR             = 0x00000200,      // Should " - Internet Explorer" be appended to display name in the Captionbar
        BFO_USE_DIALUP_REF                  = 0x00000400,      // Should the DialUp ref count get a ref while the browse is navigated to this location?  This will also enable the ICW and Software update.
        BFO_USE_IE_TOOLBAR                  = 0x00000800,      // Should the IE toolbar be used?
        BFO_NO_PARENT_FOLDER_SUPPORT        = 0x00001000,      // Can you NOT navigate to a parent folder?  Used for Backspace button to parent folder or the View.GoTo.ParentFolder feature.
        BFO_NO_REOPEN_NEXT_RESTART          = 0x00002000,      // Browser windows are NOT reopened the next time the shell boots if the windows were left open on the previous logoff.  Does this NSE want the same feature?
        BFO_GO_HOME_PAGE                    = 0x00004000,      // Add "Home Page" to menu (Go).
        BFO_PREFER_IEPROCESS                = 0x00008000,      // prefers to use IEXPLORE.EXE over EXPLORER.EXE
        BFO_SHOW_NAVIGATION_CANCELLED       = 0x00010000,      // If navigation is aborted, show the "Action Cancelled" HTML page.
        BFO_USE_IE_STATUSBAR                = 0x00020000,      // Use the persisted IE status bar settings
        BFO_QUERY_ALL                       = 0xFFFFFFFF, // Return all values set.
    } BROWSERFRAMEOPTIONS;

    HRESULT GetFrameOptions(
        [in] BROWSERFRAMEOPTIONS dwMask,
        [out] BROWSERFRAMEOPTIONS *pdwOptions);
}

[
    odl,
    helpstring("Initialize With IPropertyStore"),
    uuid(C3E12EB5-7D8D-44f8-B6DD-0E77B34D6DE4)
]
interface IInitializeWithPropertyStore : stdole.IUnknown
{
    HRESULT Initialize([in] IPropertyStore *pps);
}
// Implemented by objects the need to be provided a window, often an owner window for displaying UI.
// Used by clients of those objects to provide the window.
[
	odl,
    uuid(3E68D4BD-7135-4D10-8018-9FB6D9F33FA1)
]
interface IInitializeWithWindow : stdole.IUnknown
{
    HRESULT Initialize([in] HWND hwnd);
}

[
	odl,
    uuid(75121952-e0d0-43e5-9380-1d80483acf72)
]
interface ICreateObject : stdole.IUnknown
{
    HRESULT CreateObject(
        [in] UUID *clsid,
        [in] IUnknown *pUnkOuter,
        [in] UUID *riid,
        [out] LPVOID ppv);
};

typedef struct QCMINFO {
  HMENU         hmenu;
  UINT          indexMenu;
  UINT          idCmdFirst;
  UINT          idCmdLast;
  UINT          pIdMap;
} QCMINFO;

typedef struct DFMICS {
  DWORD                 cbSize;
  DWORD                 fMask;
  LONG                  lParam;
  UINT                  idCmdFirst;
  UINT                  idDefMax;
  UINT                  pici; //LPCMINVOKECOMMANDINFO   pici;
  LONG                  pUnkSite; //IUnknown              *punkSite;
} DFMICS;

[
    odl,
    uuid(3409E930-5A39-11d1-83FA-00A0C90DC849)
]
interface IContextMenuCB : stdole.IUnknown
{
    // uMsg is one of DFM_XXX values
    HRESULT CallBack(
        [in] IShellFolder *psf,
        [in] HWND hwndOwner,
        [in] IDataObject *pdtobj,
        [in] UINT uMsg,
        [in] LONG wParam,
        [in] LONG lParam);
}

[	odl,
	uuid(0811AEBE-0B87-4C54-9E72-548CF649016B)
]
interface IContextMenuSite : stdole.IUnknown
{
	HRESULT DoContextMenuPopup(
		[in] long punkContextMenu,
		[in] UINT fFlags,
		[in] POINT pt);

};

typedef enum HOMEGROUPSHARINGCHOICES
{
    HGSC_NONE             = 0x00000000,
    HGSC_MUSICLIBRARY     = 0x00000001,
    HGSC_PICTURESLIBRARY  = 0x00000002,
    HGSC_VIDEOSLIBRARY    = 0x00000004,
    HGSC_DOCUMENTSLIBRARY = 0x00000008,
    HGSC_PRINTERS         = 0x00000010,
} HOMEGROUPSHARINGCHOICES;

[
	odl,
    uuid(7a3bd1d9-35a9-4fb3-a467-f48cac35e2d0)
]
interface IHomeGroup : stdole.IUnknown
{

    HRESULT IsMember([out] BOOL *member);
    HRESULT ShowSharingWizard([in] HWND owner, [out] HOMEGROUPSHARINGCHOICES *sharingchoices);
}

[
	odl,
    uuid(7F9185B0-CB92-43c5-80A9-92277A4F7B54)
]
interface IExecuteCommand : stdole.IUnknown
{
    // key state values MK_CONTROL & MK_SHIFT
    HRESULT SetKeyState([in] DWORD grfKeyState);

    // for context menu invokes this comes from CMINVOKECOMMANDINFO.lpParameters
    HRESULT SetParameters([in] LONG pszParameters);

    // default Position = center of default monitor
    HRESULT SetPosition([in] POINT pt);

    // default = SW_NORMAL
    HRESULT SetShowWindow([in] int nShow);

    // default = FALSE
    HRESULT SetNoShowUI([in] BOOL fNoShowUI);

    // default Directory = GetCurrentDirectory()
    HRESULT SetDirectory([in] LONG pszDirectory);

    // this is where the work happens!
    HRESULT Execute();
}



typedef enum CPVIEW
{
    CPVIEW_CLASSIC   = 0,
    CPVIEW_ALLITEMS  = 0, //CPVIEW_CLASSIC,
    CPVIEW_CATEGORY  = 1,
    CPVIEW_HOME      = 1 //CPVIEW_CATEGORY,
} CPVIEW;

[
    odl,
    uuid(D11AD862-66DE-4DF4-BF6C-1F5621996AF1)
]
interface IOpenControlPanel : stdole.IUnknown
{
    HRESULT Open(
        [in] LONG pszName,
        [in] LONG pszPage,
        [in] IUnknown *punkSite);

    HRESULT GetPath(
        [in] LONG pszName,
        [out] LONG *pszPath,
        [in] UINT cchPath);

    HRESULT GetCurrentView([out] CPVIEW *pView);
}
[
    odl,
    uuid(01E18D10-4D8B-11d2-855D-006008059367)
]
interface IFileSystemBindData : stdole.IUnknown
{
    HRESULT SetFindData([in] WIN32_FIND_DATAW *pfd);
    HRESULT GetFindData([out] WIN32_FIND_DATAW *pfd);
}
[
    odl,
    uuid(3acf075f-71db-4afa-81f0-3fc4fdf2a5b8)
]
interface IFileSystemBindData2 : IFileSystemBindData
{
    HRESULT SetFileID([in] LARGE_INTEGER liFileID);
    HRESULT GetFileID([out] LARGE_INTEGER *pliFileID);
    HRESULT SetJunctionCLSID([in] UUID *clsid);
    HRESULT GetJunctionCLSID([out] UUID *pclsid);
}

typedef enum FOLDER_ENUM_MODE
{
    FEM_VIEWRESULT    = 0, // main enumeration mode. default enumeration for a folder view, etc.
    FEM_NAVIGATION    = 1, // alternate enumeration mode for navigating folder's content. default enumeration for a navigation pane, etc.
} FOLDER_ENUM_MODE;

[
	odl,
    uuid(6a9d9026-0e6e-464c-b000-42ecc07de673)
]
interface IObjectWithFolderEnumMode : stdole.IUnknown
{
    HRESULT SetMode([in] FOLDER_ENUM_MODE feMode);
    HRESULT GetMode([out] FOLDER_ENUM_MODE *pfeMode);
}


typedef enum APPDOCLISTTYPE
{
    ADLT_RECENT = 0,   // The recently used documents list
    ADLT_FREQUENT,     // The frequently used documents list
} APPDOCLISTTYPE;
[
	odl,
    uuid(3c594f9f-9f30-47a1-979a-c9e83d3d0a06)
]
interface IApplicationDocumentLists : stdole.IUnknown
{


    // Set the App User Model ID for the application retrieving this list.  If an AppID is not provided via this method,
    // the system will use a heuristically determined ID.  This method must be called before GetList.
    HRESULT SetAppID([in] LONG pszAppID);
    // Retrieve an IEnumObjects or IObjectArray for IShellItems and/or IShellLinks.
    // Items may appear in both the frequent and recent lists.
    HRESULT GetList([in] APPDOCLISTTYPE listtype, 
					[in] UINT cItemsDesired, 
					[in] UUID *riid, 
					[out] LPVOID ppv);
}

//WARNING: IShellFolder3, IFilterCondition, and IItemFilter is an undocumented interface
[
	odl,
	uuid(FCA2857D-1760-4AD3-8C63-C9B602FCBAEA)
]
interface IFilterCondition : stdole.IUnknown
{
	HRESULT GetFilterName([in] LONG filtername, [out] LONG* lpszName);
	HRESULT GetTypeFlags([out] LONG* dwFlags);
	HRESULT GetPropertyKey([out] PROPERTYKEY* pKey);
	HRESULT GetCondition([out] ICondition **ppCondition);
};
[
	odl,
	uuid(7FCBEB25-ED60-45C9-9F5E-57B48493C4DD),
	hidden
]
interface IItemFilter : stdole.IUnknown
{
	HRESULT HasFilter([in] LONG idx, [out] BOOL *result);
	HRESULT GetTextFilterCondition([in] LONG textfilteroptions, [out] IFilterCondition **ppFilterCond);
	HRESULT GetTextPropKeys([out] LONG *lpKey, [out] LONG *nKey);
	HRESULT GetFilterCondition([out] IFilterCondition **ppFilterCond);
	HRESULT GetPropertyFilter([in] PROPERTYKEY *pKey, [out] IFilterCondition **ppFilterCond);
	HRESULT GetIDListFilters([out] IObjectArray **ppObjs);
};

// Base interface from which to derive "related items"
// with specific relationships, and identical method signatures.
//
// Use with
// IShellItem::BindToHandler, BHID_SFObject
// IShellFolder::BindToObject
[
	odl,
	uuid(a73ce67a-8ab1-44f1-8d43-d2fcbf6b1cd0)
]
interface IRelatedItem : stdole.IUnknown
{
	HRESULT GetItemIDList([out] PIDLIST_ABSOLUTE *ppidl);

	HRESULT GetItem([out] IShellItem **ppsi);
}

// Used to obtain the true identity of the item, so it can be
// determined if two items actually represent the same item.
[
	odl,
	uuid(7d903fca-d6f9-4810-8332-946c0177e247)
]
interface IIdentityName : IRelatedItem
{
}

// Used to obtain the delegate item of an item, where the
// item is delegating to the underlying "delegate" item.
// Unlike IIdentityName, IDelegateItem only "unwraps" one
// level of aliasing.
[
	odl,
	uuid(3c5a1c94-c951-4cb7-bb6d-3b93f30cce93)
]
interface IDelegateItem : IRelatedItem
{
}

// If an item represents a snapshot of an item taken at a previous time,
// ICurrentItem will let you obtain the current version of the item.
[
	odl,
	uuid(240a7174-d653-4a1d-a6d3-d4943cfbfe3d)
]
interface ICurrentItem : IRelatedItem
{
}

// used to find the transfer object. that is the object that should be
// queried and enumerated for copy/move/delete.
[
	odl,
	uuid(77f295d5-2d6f-4e19-b8ae-322f3e721ab5)
]
interface ITransferMediumItem : IRelatedItem
{
}

// used to find the item that should be used when browsing to this item (used by pagespace control)
[
	odl,
	uuid(05edda5c-98a3-4717-8adb-c5e7da991eb1)
]
interface IUseToBrowseItem : IRelatedItem
{
}

// IDisplayItem provides the item to show UI on (used by the copy engine dialogs)
[
	odl,
	uuid(c6fd5997-9f6b-4888-8703-94e80e8cde3f)
]
interface IDisplayItem : IRelatedItem
{
}

// IViewStateIdentityItem is used to provide a canonical persistence item
// This is item for which view customizations will be remembered
// (example: the orignal folder item minus the search query)
[
	odl,
	uuid(9D264146-A94F-4195-9F9F-3BB12CE0C955)
]
interface IViewStateIdentityItem : IRelatedItem
{
}

// IPreviewItem provides an item to show in the preview pane
[
	odl,
	uuid(36149969-0A8F-49c8-8B00-4AECB20222FB)
]
interface IPreviewItem : IRelatedItem
{
}
typedef enum NMCII_FLAGS {
  NMCII_NONE = 0x0000,
  NMCII_ITEMS = 0x0001,
  NMCII_FOLDERS = 0x0002
} NMCII_FLAGS;

typedef enum NMCSAEI_FLAGS {
  NMCSAEI_SELECT = 0x0000,
  NMCSAEI_EDIT = 0x0001
} NMCSAEI_FLAGS;
[
	odl,
        uuid(dcb07fdc-3bb5-451c-90be-966644fed7b0)
]
interface INewMenuClient : stdole.IUnknown {
  HRESULT IncludeItems([in, out] NMCII_FLAGS *pflags);
  HRESULT SelectAndEditItem([in] PCIDLIST_ABSOLUTE pidlItem,[in] NMCSAEI_FLAGS flags);
};

[
	odl,
	uuid (1df0d7f1-b267-4d28-8b10-12e23202a5c4)
]
interface IItemNameLimits : stdole.IUnknown {
  HRESULT GetValidCharacters([in, out] LONG *ppwszValidChars,[in, out] LONG *ppwszInvalidChars);
  HRESULT GetMaxLength([in] LONG pszName,[in, out] int *piMaxNameLen);
}
typedef struct PERSIST_FOLDER_TARGET_INFO {
	long pidlTargetFolder;
	WCHAR            szTargetParsingName[260];
	WCHAR            szNetworkProvider[260];
	DWORD            dwAttributes;
	int              csidl;
} PERSIST_FOLDER_TARGET_INFO;

[
	odl,
	uuid(CEF04FDF-FE72-11d2-87a5-00c04f6837cf)
]
interface IPersistFolder3 : IPersistFolder2 {
	HRESULT InitializeEx([in] IBindCtx *pbc, [in] long pidlRoot, [in] PERSIST_FOLDER_TARGET_INFO *ppfti);
	HRESULT GetFolderTargetInfo([out] PERSIST_FOLDER_TARGET_INFO *ppfti);
}

[
	odl,
	uuid(61E00D45-8FFF-4e60-924E-6537B61612DD)
]
interface IEnumReadyCallback : stdole.IUnknown {
	HRESULT EnumReady();
}
[
	odl,
	uuid(8C8BF236-1AEC-495f-9894-91D57C3C686F)
]
interface IEnumerableView : stdole.IUnknown {
	HRESULT SetEnumReadyCallback([in] IEnumReadyCallback* percb);
	HRESULT CreateEnumIDListFromContents([in] long pidlFolder, [in] SHCONTF dwEnumFlags, [out] IEnumIDList **ppEnumIDList);
}

[
	odl,
	uuid(6e0f9881-42a8-4f2a-97f8-8af4e026d92d)
]
interface IInitializeNetworkFolder : stdole.IUnknown {
	long Initialize(
				[in] long pidl,
				[in] long pidlTarget,
				[in] long uDisplayType,
				[in] long pszResName,
				[in] long pszProvider);
}

[
	odl,
	uuid(96E5AE6D-6AE1-4b1c-900C-C6480EAA8828)
]
interface IResultsFolder : stdole.IUnknown {
	HRESULT AddItem([in] IShellItem *psi);
	HRESULT AddIDList([in] long pidl, [out] long *ppidlAdded);
	HRESULT RemoveItem([in] IShellItem *psi);
	HRESULT RemoveIDList([in] long pidl);
	HRESULT RemoveAll(void);

}

[
	odl,
	uuid(a5cd92ff-29be-454c-8d04-d82879fb3f1b)
]
interface IVirtualDesktopManager : stdole.IUnknown{
	HRESULT IsWindowOnCurrentVirtualDesktop([in] HWND topLevelWindow,
											[out] BOOL* onCurrentDesktop);
	HRESULT GetWindowDesktopId([in] HWND topLevelWindow, [out] UUID *desktopId);
	HRESULT MoveWindowToDesktop([in] HWND topLevelWindow, [in] UUID *desktopId);
}


typedef enum CALLTYPE
{
	CALLTYPE_TOPLEVEL = 1,
	CALLTYPE_NESTED = 2,
	CALLTYPE_ASYNC = 3,
	CALLTYPE_TOPLEVEL_CALLPENDING = 4,
	CALLTYPE_ASYNC_CALLPENDING = 5
} 	CALLTYPE;

typedef enum SERVERCALL
{
	SERVERCALL_ISHANDLED = 0,
	SERVERCALL_REJECTED = 1,
	SERVERCALL_RETRYLATER = 2
} 	SERVERCALL;

typedef enum PENDINGTYPE
{
	PENDINGTYPE_TOPLEVEL = 1,
	PENDINGTYPE_NESTED = 2
} 	PENDINGTYPE;

typedef enum ENDINGMSG
{
	PENDINGMSG_CANCELCALL = 0,
	PENDINGMSG_WAITNOPROCESS = 1,
	PENDINGMSG_WAITDEFPROCESS = 2
} 	PENDINGMSG;

typedef struct INTERFACEINFO
{
	long pUnk; //IUnknown *pUnk
	UUID iid;
	WORD wMethod;
} 	INTERFACEINFO;


[
	odl,
	uuid(00000016-0000-0000-C000-000000000046)

]
interface IMessageFilter : stdole.IUnknown
{
	SERVERCALL HandleInComingCall([in] CALLTYPE dwCallType,[in] HTASK htaskCaller,[in] DWORD dwTickCount,[in] INTERFACEINFO* lpInterfaceInfo);
	DWORD RetryRejectedCall([in] HTASK htaskCallee,[in] DWORD dwTickCount,[in] SERVERCALL dwRejectType);
	PENDINGMSG MessagePending([in] HTASK htaskCallee,[in] DWORD dwTickCount,[in] PENDINGTYPE dwPendingType);

};

typedef struct MULTI_QI
{
	long pIID;
	long pItf;
	long hr;
} 	MULTI_QI;

[
	odl,
	uuid(00000020-0000-0000-C000-000000000046)
]
interface IMultiQI : stdole.IUnknown
{
	long QueryMultipleInterfaces(
	[in] long cMQIs,
	[in] long pMQIs); //ptr to MULTI_QI array
}

[
	odl,
	uuid(40F074E0-4700-11CF-80F9-00AA004BA1C8)
]
interface IZombie : stdole.IUnknown {
	HRESULT MakeZombie([in] void *pUnk, [in] long dwReserved);
};

[
    odl,
    uuid(00000125-0000-0000-C000-000000000046)
]
interface IAdviseSink2 : IAdviseSink
{

    void OnLinkSrcChange(
        [in] IMoniker* pmk);

//#if 0
//    [call_as(OnLinkSrcChange), async]
//    void RemoteOnLinkSrcChange(
//        [in, unique] IVBMoniker* pmk);
//#endif
};
    typedef struct SOLE_AUTHENTICATION_SERVICE
    {
        DWORD    dwAuthnSvc;
        DWORD    dwAuthzSvc;
        LongPtr /* OLECHAR * */ pPrincipalName;
        HRESULT  hr;
    } SOLE_AUTHENTICATION_SERVICE;

    typedef enum EOLE_AUTHENTICATION_CAPABILITIES
    {
        EOAC_NONE = 0x0,
        EOAC_MUTUAL_AUTH = 0x1,
        EOAC_SECURE_REFS = 0x2
    } EOLE_AUTHENTICATION_CAPABILITIES;
[
    odl,
    uuid(0000013D-0000-0000-C000-000000000046)
]
interface IClientSecurity : stdole.IUnknown
{
    HRESULT QueryBlanket
    (
        [in]  IUnknown* pProxy,
        [in, out] DWORD* pAuthnSvc,
        [in, out] DWORD* pAuthzSvc,
        [in, out] LongPtr *pServerPrincName,
        [in, out] DWORD* pAuthnLevel,
        [in, out] DWORD* pImpLevel,
        [in, out] LPVOID pAuthInfo,
        [in, out] DWORD* pCapabilites
    );

    HRESULT SetBlanket
    (
        [in] IUnknown* pProxy,
        [in] DWORD                     AuthnSvc,
        [in] DWORD                     AuthzSvc,
        [in] OLECHAR* pServerPrincName,
        [in] DWORD                     AuthnLevel,
        [in] DWORD                     ImpLevel,
        [in] void* pAuthInfo,
        [in] DWORD                     Capabilities
    );

    HRESULT CopyProxy
    (
        [in]  stdole.IUnknown* pProxy,
        [out, retval] stdole.IUnknown** ppCopy
    );
}

[
    odl,
    uuid(0000013E-0000-0000-C000-000000000046)
]
interface IServerSecurity : stdole.IUnknown
{
    HRESULT QueryBlanket
    (
        [in, out] DWORD* pAuthnSvc,
        [in, out] DWORD* pAuthzSvc,
        [in, out] LongPtr *pServerPrincName,
        [in, out] DWORD* pAuthnLevel,
        [in, out] DWORD* pImpLevel,
        [in, out] LongPtr *pPrivs,
        [in, out] DWORD* pCapabilities
    );

    HRESULT ImpersonateClient();

    HRESULT RevertToSelf();

    BOOL IsImpersonating();
}

[
    odl,
    uuid(00000140-0000-0000-C000-000000000046)
]
interface IClassActivator : stdole.IUnknown
{
    HRESULT GetClassObject(
        [in] REFCLSID rclsid,
        [in] DWORD dwClassContext,
        [in] LCID locale,
        [in] REFIID riid,
        [in, out] LPVOID ppv);
};

[
    odl,
    uuid(a9d758a0-4617-11cf-95fc-00aa00680db4)
]
interface IProgressNotify : stdole.IUnknown
{


    HRESULT OnProgress(
        [in]        DWORD           dwProgressCurrent,
        [in]        DWORD           dwProgressMaximum,
        [in]        BOOL            fAccurate,
        [in]        BOOL            fOwner
    );

};

[
    odl,
    uuid(0000001d-0000-0000-C000-000000000046),
    helpstring("Visual Basic version of IMallocSpy interface")
]
interface IMallocSpy : stdole.IUnknown 
{
    ULONG PreAlloc([in] ULONG cbRequest);

    LongPtr PostAlloc([in] LongPtr pActual);

    LongPtr PreFree([in] LongPtr pRequest,
        [in] BOOL  fSpyed);

    void  PostFree([in] BOOL  fSpyed);

    ULONG PreRealloc([in] LongPtr pRequest,
        [in] ULONG cbRequest,
        [in] LongPtr ppNewRequest,
        [in] BOOL    fSpyed);

    LongPtr PostRealloc([in] LongPtr pActual,
        [in] BOOL  fSpyed);

    LongPtr PreGetSize([in] LongPtr pRequest,
        [in] BOOL  fSpyed);

    ULONG PostGetSize([in] ULONG cbActual, [in] BOOL  fSpyed);

    LongPtr PreDidAlloc([in] LongPtr pRequest,
        [in] BOOL  fSpyed);

    int   PostDidAlloc([in] LongPtr pRequest,
        [in] BOOL  fSpyed,
        [in] int   fActual);

    void  PreHeapMinimize(void);

    void  PostHeapMinimize(void);
}

[
    odl,
    uuid(00000018-0000-0000-C000-000000000046),
    helpstring("Visual Basic version of IStdMarshalInfo interface")
]
interface IStdMarshalInfo : stdole.IUnknown 
{
    HRESULT GetClassForHandler
    (
        [in] DWORD dwDestContext,
        [in] void* pvDestContext,
        [in, out] CLSID* pClsid
    );
}
    // bit flags for IExternalConnection
    typedef enum EXTCONN
    {
        EXTCONN_STRONG = 0x0001,   // strong connection
        EXTCONN_WEAK = 0x0002,   // weak connection (table, container)
        EXTCONN_CALLABLE = 0x0004,   // table .vs. callable
    } EXTCONN;
[
    odl,
    uuid(00000019-0000-0000-C000-000000000046),
    helpstring("Visual Basic version of IExternalConnection interface")
]
interface IExternalConnection : stdole.IUnknown
{

    // *** IExternalConnection methods ***
    DWORD AddConnection
    (
        [in] DWORD extconn,
        [in] DWORD reserved
    );

    DWORD ReleaseConnection
    (
        [in] DWORD extconn,
        [in] DWORD reserved,
        [in] BOOL  fLastReleaseCloses
    );
};

[
    odl,
    uuid(969dc708-5c76-11d1-8d86-0000f804b057)
]
interface IThumbnailExtractor : stdole.IUnknown
{
    HRESULT ExtractThumbnail(
        [in] IStorage * pStg,
        [in] ULONG ulLength,
        [in] ULONG ulHeight,
        [out] ULONG * pulOutputLength,
        [out] ULONG * pulOutputHeight,
        [out] HBITMAP * phOutputBitmap
    );


    HRESULT OnFileUpdated(
        [in] IStorage* pStg
    );
};



typedef struct HWDEVICEINFO
{
    DWORD cbSize;

    WCHAR szDeviceIntfID[200];
    GUID  guidInterface;

    DWORD dwState;
    DWORD dwDeviceFlags;
} HWDEVICEINFO;

typedef enum SHHARDWAREEVENT_IDs
{
    SHHARDWAREEVENT_VOLUMEARRIVED = 0x00000001,
    SHHARDWAREEVENT_VOLUMEUPDATED = 0x00000002,
    SHHARDWAREEVENT_VOLUMEREMOVED = 0x00000004,
    SHHARDWAREEVENT_MOUNTPOINTARRIVED = 0x00000008,
    SHHARDWAREEVENT_MOUNTPOINTREMOVED = 0x00000010,
    SHHARDWAREEVENT_DEVICEARRIVED = 0x00000020,
    SHHARDWAREEVENT_DEVICEUPDATED = 0x00000040,
    SHHARDWAREEVENT_DEVICEREMOVED = 0x00000080,
    SHHARDWAREEVENT_VOLUMEMOUNTED = 0x00000100,
    SHHARDWAREEVENT_VOLUMEDISMOUNTED = 0x00000200
} SHHARDWAREEVENT_IDs;


//cpp_quote("#define MAX_FILESYSNAME         30")
//cpp_quote("#define MAX_LABEL_NTFS           32  // not including the NULL")
//cpp_quote("#define MAX_LABEL               MAX_LABEL_NTFS + 1")
//cpp_quote("#define MAX_ICONLOCATION           MAX_PATH + 12 // + 12 for comma and index")
//cpp_quote("#define MAX_VOLUMEINFO2 (sizeof(VOLUMEINFO2) + (4 * MAX_ICONLOCATION + 1 * MAX_LABEL) * sizeof(WCHAR))")

typedef struct SHHARDWAREEVENT
{
    DWORD   cbSize;
    SHHARDWAREEVENT_IDs   dwEvent;
    BYTE    rgbPayLoad[1];
} SHHARDWAREEVENT;

typedef struct MTPTADDED
{
    WCHAR szMountPoint[260/*MAX_PATH*/];
    WCHAR szDeviceIDVolume[200/*MAX_DEVICEID*/];
} MTPTADDED;


typedef enum MEDIA_STATES
{
    HWDMS_PRESENT = 0x10000000,
    HWDMS_FORMATTED = 0x20000000,
    HWDMS_WRITEPROTECTED_SUPPORTDETECTION = 0x40000000,
    HWDMS_WRITEPROTECTED = 0x80000000
} MEDIA_STATES;

typedef enum MEDIA_CAPABILITIES
{
    HWDMC_WRITECAPABILITY_SUPPORTDETECTION = 0x00000001,
    HWDMC_CDROM = 0x00000002,
    HWDMC_CDRECORDABLE = 0x00000004,
    HWDMC_CDREWRITABLE = 0x00000008,
    HWDMC_DVDROM = 0x00000010,
    HWDMC_DVDRECORDABLE = 0x00000020,
    HWDMC_DVDREWRITABLE = 0x00000040,
    HWDMC_DVDRAM = 0x00000080,
    HWDMC_ANALOGAUDIOOUT = 0x00000100,

    HWDMC_RANDOMWRITE = 0x00001000,

    HWDMC_HASAUTORUNINF = 0x00002000,
    HWDMC_HASAUTORUNCOMMAND = 0x00004000,
    HWDMC_HASDESKTOPINI = 0x00008000,
    HWDMC_HASDVDMOVIE = 0x00010000,
    HWDMC_HASAUDIOTRACKS = 0x00020000,
    HWDMC_HASDATATRACKS = 0x00040000,
    HWDMC_HASAUDIOTRACKS_UNDETERMINED = 0x00080000,
    HWDMC_HASDATATRACKS_UNDETERMINED = 0x00100000,
    HWDMC_HASUSEAUTOPLAY = 0x00200000

    //HWDMC_CDTYPEMASK                              (HWDMC_CDROM | HWDMC_CDRECORDABLE | HWDMC_CDREWRITABLE | HWDMC_DVDROM | HWDMC_DVDRECORDABLE | HWDMC_DVDREWRITABLE | HWDMC_DVDRAM)")
} MEDIA_CAPABILITIES;

typedef enum DRIVE_STATE
{
    HWDDS_PRESENT_SUPPORTDETECTION = 0x10000000,
    HWDDS_PRESENT = 0x20000000,
    HWDDS_SLEEPING_SUPPORTDETECTION = 0x40000000,
    HWDDS_SLEEPING = 0x80000000
} DRIVE_STATE;

typedef enum DRIVE_CAPABILITIES
{
    HWDDC_CAPABILITY_SUPPORTDETECTION = 0x00000001,
    HWDDC_CDROM = 0x00000002,
    HWDDC_CDRECORDABLE = 0x00000004,
    HWDDC_CDREWRITABLE = 0x00000008,
    HWDDC_DVDROM = 0x00000010,
    HWDDC_DVDRECORDABLE = 0x00000020,
    HWDDC_DVDREWRITABLE = 0x00000040,
    HWDDC_DVDRAM = 0x00000080,
    HWDDC_ANALOGAUDIOOUT = 0x00000100,

    HWDDC_RANDOMWRITE = 0x00001000,
    HWDDC_NOSOFTEJECT = 0x00002000,
    HWDDC_FLOPPYSOFTEJECT = 0x00004000,
    HWDDC_REMOVABLEDEVICE = 0x00008000

    //HWDDC_CDTYPEMASK                              HWDMC_CDTYPEMASK
} DRIVE_CAPABILITIES;

typedef enum VOLUME_FLAGS
{
    HWDVF_STATE_SUPPORTNOTIFICATION = 0x00000001,
    HWDVF_STATE_ACCESSDENIED = 0x00000002,
    HWDVF_STATE_DISMOUNTED = 0x00000004,
    HWDVF_STATE_HASAUTOPLAYHANDLER = 0x00000008,
    HWDVF_STATE_DONOTSNIFFCONTENT = 0x00000010,
    HWDVF_STATE_JUSTDOCKED = 0x00000020
} VOLUME_FLAGS;

typedef enum DRIVE_TYPES
{
    HWDTS_FLOPPY35 = 0x00000001,
    HWDTS_FLOPPY525 = 0x00000002,
    HWDTS_REMOVABLEDISK = 0x00000004,
    HWDTS_FIXEDDISK = 0x00000008,
    HWDTS_CDROM = 0x00000010
} DRIVE_TYPES;

typedef enum DEVICE_FLAGS
{
    HWDDF_HASDEVICEHANDLER = 0x00000001,
    HWDDF_HASDEVICEHANDLER_UNDETERMINED = 0x00000002,
    HWDDF_REMOVABLEDEVICE = 0x00000004,
    HWDDF_REMOVABLEDEVICE_UNDETERMINED = 0x00000008
} DEVICE_FLAGS;

[
    odl,
    uuid(99BC7510-0A96-43fa-8BB1-C928A0302EFB),
    helpstring("Hardware Event Device Info Interface")
]
interface IHWDevice : stdole.IUnknown
{
    HRESULT Init([in] LongPtr pszDeviceID);

    HRESULT AutoplayHandler([in] LongPtr pszEventType,
       [in] LongPtr pszHandler);
};

//cpp_quote("#define HWDEVCUSTOMPROP_USEVOLUMEPROCESSING      0x00000001")

[
    odl,
    uuid(77D5D69C-D6CE-4026-B625-26964EEC733F),
    helpstring("HW Device Custom Properties")
]
interface IHWDeviceCustomProperties : stdole.IUnknown
{
    HRESULT InitFromDeviceID([in] LongPtr  pszDeviceID, [in] DWORD dwFlags);
    HRESULT InitFromDevNode([in] LongPtr  pszDevNode, [in] DWORD dwFlags);

    HRESULT GetDWORDProperty([in] LongPtr  pszPropName,
        [out] DWORD* pdwProp);

    // Will not retrieve REG_MULTI_SZ values
    HRESULT GetStringProperty([in] LongPtr  pszPropName,
        [out] LongPtr* ppszProp);

    // Will not retrieve REG_SZ values
    // The MultiSz string is in ppblob->asData
    HRESULT GetMultiStringProperty([in] LongPtr  pszPropName,
        [in] BOOL fMergeMultiSz, [out] LongPtr* ppblob);

    HRESULT GetBlobProperty([in] LongPtr pszPropName,
        [out] LongPtr* ppblob);
};

[
    odl,
    uuid(66057ABA-FFDB-4077-998E-7F131C3F8157),
    helpstring("Autoplay Handler Enumerator Interface")
]
interface IEnumAutoplayHandler : stdole.IUnknown
{
    long Next([out] LongPtr* ppszHandler,
        [out] LongPtr* ppszAction,
        [out] LongPtr* ppszProvider,
        [out] LongPtr* ppszIconLocation);
};

typedef enum AHDEFAULT
{
    HANDLERDEFAULT_USERCHOSENDEFAULT              =  0x00000002,
    HANDLERDEFAULT_EVENTHANDLERDEFAULT            =  0x00000004,
    HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED    =  0x00000008,
    HANDLERDEFAULT_DEFAULTSAREDIFFERENT           =  0x00000010
} AHDEFAULT;

[
    odl,
    uuid(335E9E5D-37FC-4d73-8BA8-FD4E16B28134),
    helpstring("Autoplay Handler Interface")
]
interface IAutoplayHandler : stdole.IUnknown
{
    HRESULT Init([in] LongPtr pszDeviceID,
        [in] LongPtr pszEventType);
    HRESULT InitWithContent([in] LongPtr pszDeviceID,
        [in] LongPtr pszEventType,
        [in] LongPtr pszContentTypeHandler);

    HRESULT EnumHandlers([out] IEnumAutoplayHandler** ppenum);

    HRESULT GetDefaultHandler([out] LongPtr* ppszHandler);
    HRESULT SetDefaultHandler([in] LongPtr pszHandler);
};

[
    odl,
    uuid(557730F6-41FA-4d11-B9FD-F88AB155347F),
    helpstring("Autoplay Handler Properties Interface")
]
interface IAutoplayHandlerProperties : stdole.IUnknown
{
    HRESULT Init([in] LongPtr pszHandler);

    HRESULT GetInvokeProgIDAndVerb([out] LongPtr* ppszInvokeProgID,
        [out] LongPtr* ppszInvokeVerb);
};

typedef struct VOLUMEINFO
{
    DWORD dwState;                      // State of volume 
    LongPtr pszDeviceIDVolume;           // \\?\STORAGE#Volume#...{...GUID...}
    LongPtr pszVolumeGUID;               // \\?\Volume{...GUID...}
    VOLUME_FLAGS dwVolumeFlags;                // see HWDVF_... flags
    DRIVE_TYPES dwDriveType;                  // see HWDT_... flags
    DRIVE_CAPABILITIES dwDriveCapability;            // see HWDDC_... flags
    LongPtr pszLabel;
    LongPtr pszFileSystem;
    DWORD dwFileSystemFlags;
    DWORD dwMaxFileNameLen;
    DWORD dwRootAttributes;
    DWORD dwSerialNumber;               // 
    DRIVE_STATE dwDriveState;                 // see HWDDS_...; 
    MEDIA_STATES dwMediaState;                 // see HWDMS_...; 
    MEDIA_CAPABILITIES dwMediaCap;                   // see HWDMC_...; 
    LongPtr pszAutorunIconLocation;      // Autorun IconLocation from autorun.inf 
    LongPtr pszAutorunLabel;             // Autorun Label from autorun.inf 
    LongPtr pszIconLocationFromService;  // Icon location from Custom Properties
    LongPtr pszNoMediaIconLocationFromService;  // Icon location from Custom Properties
    LongPtr pszLabelFromService;         // Label from Custom Properties
} VOLUMEINFO;

typedef struct VOLUMEINFO2
{
    DWORD cbSize;

    WCHAR szDeviceIDVolume[200];
    WCHAR szVolumeGUID[50];
    WCHAR szLabel[33];
    WCHAR szFileSystem[30];

    DWORD dwState;
    VOLUME_FLAGS dwVolumeFlags;
    DRIVE_TYPES dwDriveType;
    DRIVE_CAPABILITIES dwDriveCapability;
    DWORD dwFileSystemFlags;
    DWORD dwMaxFileNameLen;
    DWORD dwRootAttributes;
    DWORD dwSerialNumber;
    DRIVE_STATE dwDriveState;
    MEDIA_STATES dwMediaState;
    MEDIA_CAPABILITIES dwMediaCap;
    DWORD oAutorunIconLocation;
    DWORD oAutorunLabel;
    DWORD oIconLocationFromService;
    DWORD oNoMediaIconLocationFromService;
    DWORD oLabelFromService;

    WCHAR szOptionalStrings[1];
} VOLUMEINFO2;


[
    odl,
    uuid(553A4A55-681C-440e-B109-597B9219CFB2),
    helpstring("Hardware Device Enumerator")
]
interface IHardwareDevicesEnum : stdole.IUnknown
{
    long Next(
        [out] LongPtr* ppszDeviceID,
        [out] UUID* pguidDeviceID);
};

[
    odl,
    uuid(3342BDE1-50AF-4c5d-9A19-DABD01848DAE),
    helpstring("Hardware Device Volumes Enumerator")
]
interface IHardwareDevicesVolumesEnum : stdole.IUnknown
{
    long Next([out] VOLUMEINFO* pvolinfo);
};

[
    odl,
    uuid(EE93D145-9B4E-480c-8385-1E8119A6F7B2),
    helpstring("Hardware Device MountPoints Enumerator"),
]
interface IHardwareDevicesMountPointsEnum : stdole.IUnknown
{
    long Next(
        [out] LongPtr* ppszMountPoint,     // "c:\", or "d:\MountFolder\"
        [out] LongPtr* ppszDeviceIDVolume);// \\?\STORAGE#Volume#...{...GUID...}
};

// HWDEV: HardWareDevice EnumVolume
//cpp_quote("#define HWDEV_GETCUSTOMPROPERTIES                 0x000000001")

[
    odl,
    uuid(CC271F08-E1DD-49bf-87CC-CD6DCF3F3D9F),
    helpstring("Hardware Device Interface")
]
interface IHardwareDevices : stdole.IUnknown
{
    HRESULT EnumVolumes([in] DWORD dwFlags, [out] IHardwareDevicesVolumesEnum** ppenum);
    HRESULT EnumMountPoints([out] IHardwareDevicesMountPointsEnum** ppenum);
    HRESULT EnumDevices([out] IHardwareDevicesEnum** ppenum);

    HRESULT Advise([in] DWORD dwProcessID,
        [in] LongPtr hThread, [in] LongPtr pfctCallback, [out] DWORD* pdwToken);

    HRESULT Unadvise([in] DWORD dwToken);
};


[
	odl,
	uuid(226C537B-1E76-4D9E-A760-33DB29922F18)
]
interface IFrameworkInputPaneHandler : stdole.IUnknown
{
	long Showing([in] RECT *prcInputPaneScreenLocation,
				 [in] BOOL fEnsureFocusedElementInView);

	long Hiding([in] BOOL fEnsureFocusedElementInView);
};

[
	odl,
	uuid(5752238B-24F0-495A-82F1-2FD593056796)
]
interface IFrameworkInputPane : stdole.IUnknown
{
	long Advise([in] LPVOID pWindow,
				[in] IFrameworkInputPaneHandler *pHandler,
				[out] DWORD *pdwCookie);

	long AdviseWithHWND([in] LONG hwnd,
						[in] IFrameworkInputPaneHandler *pHandler,
						[out] DWORD *pdwCookie);

	long Unadvise([in] DWORD dwCookie);

	long Location([out] RECT *prcInputPaneScreenLocation);
};

[
	odl,
	uuid(da22171f-70b4-43db-b38f-296741d1494c)
]
interface ICustomizeInfoTip : stdole.IUnknown
{
	// copies text to an internal buffer that seems to go unused.
	// The text isn't used to prefix tips returned from IQueryInfo::GetInfoTip
	HRESULT SetPrefixText([in] long text);

	// sets additional properties to be included in the info-tip text
	// 8 is the maximum number of extra props allowed
	// any previous values set by this function are overwritten
	// when you call it
	HRESULT SetExtraProperties([in] PROPERTYKEY* pPropArray, [in] UINT numElems);
};


typedef enum DEFAULT_FOLDER_MENU_RESTRICTIONS
{
	DFMR_DEFAULT = 0,
	DFMR_NO_STATIC_VERBS = 0x8,
	DFMR_STATIC_VERBS_ONLY = 0x10,
	DFMR_NO_RESOURCE_VERBS = 0x20,
	DFMR_OPTIN_HANDLERS_ONLY = 0x40,
	DFMR_RESOURCE_AND_FOLDER_VERBS_ONLY = 0x80,
	DFMR_USE_SPECIFIED_HANDLERS = 0x100,
	DFMR_USE_SPECIFIED_VERBS = 0x200,
	DFMR_NO_ASYNC_VERBS = 0x400
} DEFAULT_FOLDER_MENU_RESTRICTIONS;

[
	odl,
	uuid(7690aa79-f8fc-4615-a327-36f7d18f5d91)
]
interface IDefaultFolderMenuInitialize : stdole.IUnknown
{
	HRESULT Initialize([in] long hwnd,
					   [in] IContextMenuCB *pcmcb,
					   [in] long pidlFolder,
					   [in] IShellFolder *psf,
					   [in] long cidl,
					   [in] long* apidl,
					   [in] void *punkAssociation,
					   [in] UINT cKeys,
					   [in] HKEY *aKeys);

	HRESULT SetMenuRestrictions([in] DEFAULT_FOLDER_MENU_RESTRICTIONS dfmrValues);

	HRESULT GetMenuRestrictions([in] DEFAULT_FOLDER_MENU_RESTRICTIONS dfmrMask,
							    [out] DEFAULT_FOLDER_MENU_RESTRICTIONS *pdfmrValues);

	HRESULT SetHandlerClsid([in] UUID *rclsid);
};



typedef enum DEF_SHARE_ID
{
	DEFSHAREID_USERS = 1,
	DEFSHAREID_PUBLIC = 2
} 	DEF_SHARE_ID;

typedef enum SHARE_ROLE
{
	SHARE_ROLE_INVALID = -1,
	SHARE_ROLE_READER = 0,
	SHARE_ROLE_CONTRIBUTOR = 1,
	SHARE_ROLE_CO_OWNER = 2,
	SHARE_ROLE_OWNER = 3,
	SHARE_ROLE_CUSTOM = 4,
	SHARE_ROLE_MIXED = 5
} 	SHARE_ROLE;

[
	odl,
	uuid(B4CD448A-9C86-4466-9201-2E62105B87AE)
]
interface ISharingConfigurationManager : stdole.IUnknown
{
	long CreateShare([in] DEF_SHARE_ID dsid,[in] SHARE_ROLE role);
	long DeleteShare([in] DEF_SHARE_ID dsid);
	long ShareExists([in] DEF_SHARE_ID dsid);
	long GetSharePermissions([in] DEF_SHARE_ID dsid, [out] SHARE_ROLE *pRole);
	long SharePrinters(void);
	long StopSharingPrinters(void);
	long ArePrintersShared(void);
};

[
	odl,
	uuid(819d1334-9d74-4254-9ac8-dc745ebc5386)
]
interface IInfoBarMessage : stdole.IUnknown
{
	HRESULT GetMessageID([in] UUID* guid, [out] INT* intVal);
	HRESULT GetMessageW([out] long* message);
	HRESULT CreateMenu([out] HMENU* pMwnu);
	HRESULT HandleMenu([in] HWND hwnd, [in] int intVal);
};

[
	odl,
	uuid(e38fe0f3-3db0-47ee-a314-25cf7f4bf521)
]
interface IInfoBarHost : stdole.IUnknown
{
	HRESULT Inform([in] IInfoBarMessage* msg);
	HRESULT CancelInform([in] UUID* guid);
};

[
	odl,
	uuid(18140CBD-AA23-4384-A38D-6A8D3E2BE505)
]
interface IBrowserProgressSessionProvider : stdole.IUnknown
{
	HRESULT BeginSession(void); //Unknown
	HRESULT EndSession(void);//Unknown
	HRESULT GetCurrentSession([out] DWORD* sessionId);
	HRESULT ActivateSession(void);//Unknown
};

[
	odl,
	uuid(00000146-0000-0000-C000-000000000046)
]
interface IGlobalInterfaceTable : stdole.IUnknown
{
	HRESULT RegisterInterfaceInGlobal(
		[in] IUnknown *pUnk,
		[in] UUID* riid,
		[out] DWORD *pdwCookie);

	HRESULT RevokeInterfaceFromGlobal(
		[in] DWORD dwCookie);

	HRESULT GetInterfaceFromGlobal(
		[in] DWORD dwCookie,
		[in] UUID *riid,
		[out] LPVOID ppv);

};

[
	odl,
	uuid(fce4bde0-4b68-4b80-8e9c-7426315a7388)
]
interface IShellRunDll : stdole.IUnknown
{
	HRESULT Run([in] long pszArgs);
}

typedef enum SIOM_Flags
{
	SIOM_OVERLAYINDEX        = 0x1,
	SIOM_ICONINDEX           = 0x2
} SIOM_Flags;

typedef enum SIOM_Reserved
{
	SIOM_RESERVED_SHARED     = 0,
	SIOM_RESERVED_LINK       = 1,
	SIOM_RESERVED_SLOWFILE   = 2,
	SIOM_RESERVED_DEFAULT    = 3
} SIOM_Reserved;
[
	odl,
	uuid(f10b5e34-dd3b-42a7-aa7d-2f4ec54bb09b)
]
interface IShellIconOverlayManager : stdole.IUnknown
{
	HRESULT GetFileOverlayInfo([in] long pwszPath,
							   [in] DWORD dwAttrib,
							   [in, out] long *pIndex,
							   [in] SIOM_Flags dwFlags);

	HRESULT GetReservedOverlayInfo([in] long pwszPath,
									[in] DWORD dwAttrib,
									[in, out] long *pIndex,
									[in] SIOM_Flags dwFlags,
									[in] SIOM_Reserved iReservedID);


	HRESULT RefreshOverlayImages([in] SIOM_Flags dwFlags);

	HRESULT LoadNonloadedOverlayIdentifiers(void);

	HRESULT OverlayIndexFromImageIndex([in] long iImage,
										[in, out] long *piIndex,
										[in] BOOL fAdd);

};

typedef /* [v1_enum] */
enum MANIPULATION_PROCESSOR_MANIPULATIONS
{
	MANIPULATION_NONE = 0,
	MANIPULATION_TRANSLATE_X = 0x1,
	MANIPULATION_TRANSLATE_Y = 0x2,
	MANIPULATION_SCALE = 0x4,
	MANIPULATION_ROTATE = 0x8,
	MANIPULATION_ALL = 0xf
} 	MANIPULATION_PROCESSOR_MANIPULATIONS;
typedef long MANIPULATOR_ID; //unsigned

[
	odl,
	uuid(4f62c8da-9c53-4b22-93df-927a862bbb03)
]
interface IManipulationEvents : stdole.IUnknown
{
	HRESULT ManipulationStarted([in] float x,[in] float y);

	HRESULT ManipulationDelta([in] float x, [in] float y,
		[in] float translationDeltaX, [in] float translationDeltaY,
		[in] float scaleDelta, [in] float expansionDelta, [in] float rotationDelta,
		[in] float cumulativeTranslationX, [in] float cumulativeTranslationY,
		[in] float cumulativeScale, [in] float cumulativeExpansion, [in] float cumulativeRotation);

	HRESULT ManipulationCompleted([in] float x, [in] float y,
		[in] float cumulativeTranslationX, [in] float cumulativeTranslationY,
		[in] float cumulativeScale, [in] float cumulativeExpansion, [in] float cumulativeRotation);

};

[
	odl,
	uuid(18b00c6d-c5ee-41b1-90a9-9d4a929095ad)
]
interface IInertiaProcessor : stdole.IUnknown
{
	HRESULT get_InitialOriginX([in, out] FLOAT *x);

	HRESULT put_InitialOriginX([in]  FLOAT x);

	HRESULT get_InitialOriginY([in, out] FLOAT *y);

	HRESULT put_InitialOriginY([in] FLOAT y);

	HRESULT get_InitialVelocityX([in, out] FLOAT *x);

	HRESULT put_InitialVelocityX([in] FLOAT x);

	HRESULT get_InitialVelocityY([in, out] FLOAT *y);

	HRESULT put_InitialVelocityY([in] FLOAT y);

	HRESULT get_InitialAngularVelocity([in, out] FLOAT *velocity);

	HRESULT put_InitialAngularVelocity([in] FLOAT velocity);

	HRESULT get_InitialExpansionVelocity([in, out] FLOAT *velocity);

	HRESULT put_InitialExpansionVelocity([in] FLOAT velocity);

	HRESULT get_InitialRadius([in, out] FLOAT *radius);

	HRESULT put_InitialRadius([in] FLOAT radius);

	HRESULT get_BoundaryLeft([in, out] FLOAT *left);

	HRESULT put_BoundaryLeft([in] FLOAT left);

	HRESULT get_BoundaryTop([in, out] FLOAT *top);

	HRESULT put_BoundaryTop([in] FLOAT top);

	HRESULT get_BoundaryRight([in, out] FLOAT *right);

	HRESULT put_BoundaryRight([in] FLOAT right);

	HRESULT get_BoundaryBottom([in, out] FLOAT *bottom);

	HRESULT put_BoundaryBottom([in] FLOAT bottom);

	HRESULT get_ElasticMarginLeft([in, out] FLOAT *left);

	HRESULT put_ElasticMarginLeft([in] FLOAT left);

	HRESULT get_ElasticMarginTop([in, out] FLOAT *top);

	HRESULT put_ElasticMarginTop([in] FLOAT top);

	HRESULT get_ElasticMarginRight([in, out] FLOAT *right);

	HRESULT put_ElasticMarginRight([in] FLOAT right);

	HRESULT get_ElasticMarginBottom([in, out] FLOAT *bottom);

	HRESULT put_ElasticMarginBottom([in] FLOAT bottom);

	HRESULT get_DesiredDisplacement([in, out] FLOAT *displacement);

	HRESULT put_DesiredDisplacement([in] FLOAT displacement);

	HRESULT get_DesiredRotation([in, out] FLOAT *rotation);

	HRESULT put_DesiredRotation([in] FLOAT rotation);

	HRESULT get_DesiredExpansion([in, out] FLOAT *expansion);

	HRESULT put_DesiredExpansion([in] FLOAT expansion);

	HRESULT get_DesiredDeceleration([in, out] FLOAT *deceleration);

	HRESULT put_DesiredDeceleration([in] FLOAT deceleration);

	HRESULT get_DesiredAngularDeceleration([in, out] FLOAT *deceleration);

	HRESULT put_DesiredAngularDeceleration([in] FLOAT deceleration);

	HRESULT get_DesiredExpansionDeceleration([in, out] FLOAT *deceleration);

	HRESULT put_DesiredExpansionDeceleration([in] FLOAT deceleration);

	HRESULT get_InitialTimestamp([in, out] DWORD *timestamp);

	HRESULT put_InitialTimestamp([in] DWORD timestamp);

	HRESULT Reset(void);

	HRESULT Process([in, out] BOOL *completed);

	HRESULT ProcessTime([in] DWORD timestamp, [in, out] BOOL *completed);

	HRESULT Complete(void);

	HRESULT CompleteTime([in] DWORD timestamp);

};

[
	odl,
	uuid(A22AC519-8300-48a0-BEF4-F1BE8737DBA4)
]
interface IManipulationProcessor : stdole.IUnknown
{
	HRESULT get_SupportedManipulations([in, out] MANIPULATION_PROCESSOR_MANIPULATIONS *manipulations);

	HRESULT put_SupportedManipulations([in] MANIPULATION_PROCESSOR_MANIPULATIONS manipulations);

	HRESULT get_PivotPointX([in, out] FLOAT *pivotPointX);

	HRESULT put_PivotPointX([in] FLOAT pivotPointX);

	HRESULT get_PivotPointY([in, out] FLOAT *pivotPointY);

	HRESULT put_PivotPointY([in] FLOAT pivotPointY);

	HRESULT get_PivotRadius([in, out] FLOAT *pivotRadius);

	HRESULT put_PivotRadius([in] FLOAT pivotRadius);

	HRESULT CompleteManipulation(void);

	HRESULT ProcessDown(
		[in] MANIPULATOR_ID manipulatorId,
		[in] FLOAT x,
		[in] FLOAT y);

	HRESULT ProcessMove(
		[in] MANIPULATOR_ID manipulatorId,
		[in] FLOAT x,
		[in] FLOAT y);

	HRESULT ProcessUp(
		[in] MANIPULATOR_ID manipulatorId,
		[in] FLOAT x,
		[in] FLOAT y);

	HRESULT ProcessDownWithTime(
		[in] MANIPULATOR_ID manipulatorId,
		[in] FLOAT x,
		[in] FLOAT y,
		[in] DWORD timestamp);

	HRESULT ProcessMoveWithTime(
		[in] MANIPULATOR_ID manipulatorId,
		[in] FLOAT x,
		[in] FLOAT y,
		[in] DWORD timestamp);

	HRESULT ProcessUpWithTime(
		[in] MANIPULATOR_ID manipulatorId,
		[in] FLOAT x,
		[in] FLOAT y,
		[in] DWORD timestamp);

	HRESULT GetVelocityX([in, out] FLOAT *velocityX);

	HRESULT GetVelocityY([in, out] FLOAT *velocityY);

	HRESULT GetExpansionVelocity([in, out] FLOAT *expansionVelocity);

	HRESULT GetAngularVelocity([in, out] FLOAT *angularVelocity);

	HRESULT get_MinimumScaleRotateRadius([in, out] FLOAT *minRadius);

	HRESULT put_MinimumScaleRotateRadius([in] FLOAT minRadius);

	};


//CLSID_InertiaProcessor;
[uuid(abb27087-4ce0-4e58-a0cb-e24df96814be)]
coclass InertiaProcessor {
	[default] interface IInertiaProcessor;
    [default, source] interface IManipulationEvents;
};


//CLSID_ManipulationProcessor;
[uuid(597D4FB0-47FD-4aff-89B9-C6CFAE8CF08E)] 
coclass ManipulationProcessor { 
	[default] interface IManipulationProcessor;
    [default, source] interface IManipulationEvents;
};

[
    odl,
    uuid(0000002D-0000-0000-C000-000000000046)
]
interface ITypeMarshal : stdole.IUnknown{

    [propget]
    HRESULT Size(
        [in] void* pvType,
        [in] long dwDestContext,
        [in] void* pvDestContext,
        [out, retval]long* pSize);

    HRESULT Marshal(
        [in] void* pvType,
        [in] long dwDestContext,
        [in] void* pvDestContext,
        [in] long cbBufferLength,
        [in, out] void* pBuffer,
        [out, retval] long* pcbWritten);

    HRESULT Unmarshal(
        [in, out] void* pvType,
        [in] long dwFlags,
        [in] long cbBufferLength,
        [in] void* pBuffer,
        [out, retval] long* pcbRead);

    HRESULT Free(
        [in] void* pvType);

};

[
    odl,
    uuid(0000002E-0000-0000-C000-000000000046)
]

interface ITypeFactory : stdole.IUnknown
{
    HRESULT CreateFromTypeInfo(
        [in] ITypeInfo* pTypeInfo,
        [in] REFIID riid,
        [out] LPVOID ppv
    );
}

// notification messages used by the dynamic typeinfo protocol.
typedef enum CHANGEKIND {
    CHANGEKIND_ADDMEMBER,
    CHANGEKIND_DELETEMEMBER,
    CHANGEKIND_SETNAMES,
    CHANGEKIND_SETDOCUMENTATION,
    CHANGEKIND_GENERAL,
    CHANGEKIND_INVALIDATE,
    CHANGEKIND_CHANGEFAILED,
    CHANGEKIND_MAX
} CHANGEKIND;
[
    odl,
    uuid(00020410-0000-0000-C000-000000000046)
]
interface ITypeChangeEvents : stdole.IUnknown
{

    HRESULT RequestTypeChange(
        [in] CHANGEKIND changeKind,
        [in] ITypeInfo * pTInfoBefore,
        [in] long pStrName,
        [out] INT * pfCancel
    );

    HRESULT AfterTypeChange(
        [in] CHANGEKIND changeKind,
        [in] ITypeInfo* pTInfoAfter,
        [in] long pStrName
    );
};

[
    odl,
    uuid(ED6A8A2A-B160-4E77-8F73-AA7435CD5C27)
]
interface ITypeLibRegistrationReader : stdole.IUnknown
{
    HRESULT EnumTypeLibRegistrations(
         [out] IEnumUnknown * *ppEnumUnknown);

};

[
    odl,
    uuid(76A3E735-02DF-4A12-98EB-043AD3600AF3)
]
interface ITypeLibRegistration : stdole.IUnknown
{
    HRESULT GetGuid(
         [out] UUID * pGuid);

    HRESULT GetVersion(
         [out] BSTR* pVersion);

    HRESULT GetLcid(
         [out] LCID* pLcid);

    HRESULT GetWin32Path(
         [out] BSTR* pWin32Path);

    HRESULT GetWin64Path(
         [out] BSTR* pWin64Path);

    HRESULT GetDisplayName(
         [out] BSTR* pDisplayName);

    HRESULT GetFlags(
         [out] DWORD* pFlags);

    HRESULT GetHelpDir(
         [out] BSTR* pHelpDir);

};

[
    odl,
    uuid(CFCC809F-295D-42e8-9FFC-424B33C487E6)
]
interface IHWEventHandler2 : IHWEventHandler
{
    HRESULT HandleEventWithHWND(
        [in, string] LPCWSTR pszDeviceID,
        [in, string] LPCWSTR pszAltDeviceID,
        [in, string] LPCWSTR pszEventType,
        [in] HWND hwndOwner);
}


//
// IDynamicHWHandler is a new feature in AutoPlay V3 (Vista)
// A handler can register this interface for show/hide itself from the Autoplay prompt dialog.
// Additionally, it may specify a different action string than one supplied by the static
// handler registration under HKLM.
//
// params:
//  [in]  pszDeviceID - DevicePath or drive root (e.g. G:\),
//  [in]  dwContentType - bitfield of content types detected so far, similar to the param in IQueryCancelAutoPlay
//  [out] *ppszAction - if not NULL, use this as the Action string.
//                      if NULL, fallback to default static action string.
//
// returns:
//  S_OK = show, S_FALSE = hide, E_xx = error
//
// Dynamic HW Handler Interface
[
    odl,,
    uuid(DC2601D7-059E-42fc-A09D-2AFD21B6D5F7)
]
interface IDynamicHWHandler : stdole.IUnknown
{
    HRESULT GetDynamicInfo(
        [in, string] LPCWSTR pszDeviceID,
        [in] DWORD dwContentType,
        [in, out] LPWSTR* ppszAction);
}

[
    odl,
    uuid(3D25F6D6-4B2A-433c-9184-7C33AD35D001)
]
interface IDataObjectProvider : stdole.IUnknown
{
    HRESULT GetDataObject([in, out] IDataObject** dataObject);
    HRESULT SetDataObject([in] IDataObject* dataObject);
}

[
    odl,
    uuid(3A3DCD6C-3EAB-43DC-BCDE-45671CE800C8)
]
interface IDataTransferManagerInterop : stdole.IUnknown
{
    HRESULT GetForWindow([in] HWND appWindow, [in] REFIID riid, [in, out] LPVOID dataTransferManager);
    HRESULT ShowShareUIForWindow([in] HWND appWindow);
}

typedef enum PACKAGE_EXECUTION_STATE
{
    PES_UNKNOWN = 0,
    PES_RUNNING = 1,
    PES_SUSPENDING = 2,
    PES_SUSPENDED = 3,
    PES_TERMINATED = 4
} PACKAGE_EXECUTION_STATE;

[
    odl,
    uuid(1BB12A62-2AD8-432B-8CCF-0C2C52AFCD5B)
]
interface IPackageExecutionStateChangeNotification : stdole.IUnknown
{
    HRESULT OnStateChanged([in] long pszPackageFullName, [in] PACKAGE_EXECUTION_STATE pesNewState);
}

[
    odl,
    uuid(F27C3930-8029-4AD1-94E3-3DBA417810C1)
]
interface IPackageDebugSettings : stdole.IUnknown
{
    HRESULT EnableDebugging([in] long packageFullName, [in] long debuggerCommandLine, [in] long environment);
    HRESULT DisableDebugging([in] long packageFullName);

    HRESULT Suspend([in] long packageFullName);
    HRESULT Resume([in] long packageFullName);

    HRESULT TerminateAllProcesses([in] long packageFullName);

    HRESULT SetTargetSessionId([in] ULONG sessionId);

    HRESULT EnumerateBackgroundTasks(
        [in] long packageFullName,
        [in, out] ULONG* taskCount,
        [in, out] UUID* taskIds,
        [in, out] long* taskNames
    );

    HRESULT ActivateBackgroundTask([in] REFIID taskId);

    HRESULT StartServicing([in] long packageFullName);
    HRESULT StopServicing([in] long packageFullName);

    HRESULT StartSessionRedirection([in] long packageFullName, [in] ULONG sessionId);
    HRESULT StopSessionRedirection([in] long packageFullName);

    HRESULT GetPackageExecutionState([in] long packageFullName, [in, out] PACKAGE_EXECUTION_STATE* packageExecutionState);

    HRESULT RegisterForPackageStateChanges([in] long packageFullName, [in] IPackageExecutionStateChangeNotification* pPackageExecutionStateChangeNotification, [in, out] DWORD* pdwCookie);
    HRESULT UnregisterForPackageStateChanges([in] DWORD dwCookie);
}

[
    odl,
    uuid(6E3194BB-AB82-4D22-93F5-FABDA40E7B16)
]
interface IPackageDebugSettings2 : IPackageDebugSettings
{
    HRESULT EnumerateApps(
        [in] long packageFullName,
        [in, out] ULONG* appCount,
        [in, out] long* appUserModelIds,
        [in, out] long* appDisplayNames);
}

[
    odl,
    uuid(52B83A42-2543-416A-81D9-C0DE7969C8B3)
]
interface ISuspensionDependencyManager : stdole.IUnknown
{
    HRESULT RegisterAsChild([in] HANDLE processHandle);
    HRESULT GroupChildWithParent([in] HANDLE childProcessHandle);
    HRESULT UngroupChildFromParent([in] HANDLE childProcessHandle);
}

// These values specify the types of application host environment
typedef enum AHE_TYPE
{
    AHE_DESKTOP = 0,
    AHE_IMMERSIVE = 1,
} AHE_TYPE;

[
    odl,
    uuid(18B21AA9-E184-4FF0-9F5E-F882D03771B3)
]
interface IExecuteCommandApplicationHostEnvironment : stdole.IUnknown
{
    HRESULT GetValue([in, out] AHE_TYPE* pahe);
}

// This enum matches up exactly with the WinRT enum Windows.UI.ViewManagement.ApplicationViewState.
// Do NOT modify without updating it there as well.
typedef enum APPLICATION_VIEW_STATE
{
    AVS_FULLSCREEN_LANDSCAPE = 0,
    AVS_FILLED,
    AVS_SNAPPED,
    AVS_FULLSCREEN_PORTRAIT,
} APPLICATION_VIEW_STATE;

// This enum matches up exactly with the WinRT enum Windows.UI.Input.EdgeGestureKind.
// Do NOT modify without updating it there as well.
typedef enum EDGE_GESTURE_KIND
{
    EGK_TOUCH = 0,
    EGK_KEYBOARD,
    EGK_MOUSE,
} EDGE_GESTURE_KIND;

typedef enum DEVICE_SCALE_FACTOR {
    DEVICE_SCALE_FACTOR_INVALID = 0,
    SCALE_100_PERCENT = 100,
    SCALE_120_PERCENT = 120,
    SCALE_125_PERCENT = 125,
    SCALE_140_PERCENT = 140,
    SCALE_150_PERCENT = 150,
    SCALE_160_PERCENT = 160,
    SCALE_175_PERCENT = 175,
    SCALE_180_PERCENT = 180,
    SCALE_200_PERCENT = 200,
    SCALE_225_PERCENT = 225,
    SCALE_250_PERCENT = 250,
    SCALE_300_PERCENT = 300,
    SCALE_350_PERCENT = 350,
    SCALE_400_PERCENT = 400,
    SCALE_450_PERCENT = 450,
    SCALE_500_PERCENT = 500
} DEVICE_SCALE_FACTOR;

[
    odl,
    uuid(2A3DEE9A-E31D-46D6-8508-BCC597DB3557)
]
interface IApplicationDesignModeSettings : stdole.IUnknown
{
    HRESULT SetNativeDisplaySize([in] long nativeDisplaySizePixelsCX,[in] long nativeDisplaySizePixelsCY);
    HRESULT SetScaleFactor([in] DEVICE_SCALE_FACTOR scaleFactor);
    HRESULT SetApplicationViewState([in] APPLICATION_VIEW_STATE viewState);
    HRESULT ComputeApplicationSize([in, out] SIZE* applicationSizePixels);
    HRESULT IsApplicationViewStateSupported(
        [in] APPLICATION_VIEW_STATE viewState,
        [in] long nativeDisplaySizePixelsCX, [in] long nativeDisplaySizePixelsCY,
        [in] DEVICE_SCALE_FACTOR scaleFactor,
        [in, out] BOOL* supported);
    HRESULT TriggerEdgeGesture([in] EDGE_GESTURE_KIND edgeGestureKind);
}

typedef enum NATIVE_DISPLAY_ORIENTATION
{
    NDO_LANDSCAPE = 0,
    NDO_PORTRAIT,
} NATIVE_DISPLAY_ORIENTATION;

// This enum matches up exactly with the WinRT enum Windows.UI.ViewManagement.ApplicationViewOrientation.
// Do NOT modify without updating it there as well.
typedef enum APPLICATION_VIEW_ORIENTATION
{
    AVO_LANDSCAPE = 0,
    AVO_PORTRAIT,
} APPLICATION_VIEW_ORIENTATION;

typedef enum ADJACENT_DISPLAY_EDGES
{
    ADE_NONE = 0,
    ADE_LEFT = 0x1,
    ADE_RIGHT = 0x2,
} ADJACENT_DISPLAY_EDGES;


typedef enum APPLICATION_VIEW_MIN_WIDTH
{
    AVMW_DEFAULT = 0,
    AVMW_320 = 1,
    AVMW_500 = 2,
} APPLICATION_VIEW_MIN_WIDTH;

[
    odl,
    uuid(490514E1-675A-4D6E-A58D-E54901B4CA2F)
]

interface IApplicationDesignModeSettings2 : IApplicationDesignModeSettings
{
    HRESULT SetNativeDisplayOrientation([in] NATIVE_DISPLAY_ORIENTATION nativeDisplayOrientation);
    HRESULT SetApplicationViewOrientation([in] APPLICATION_VIEW_ORIENTATION viewOrientation);
    HRESULT SetAdjacentDisplayEdges([in] ADJACENT_DISPLAY_EDGES adjacentDisplayEdges);
    HRESULT SetIsOnLockScreen([in] BOOL isOnLockScreen);
    HRESULT SetApplicationViewMinWidth([in] APPLICATION_VIEW_MIN_WIDTH viewMinWidth);
    HRESULT GetApplicationSizeBounds([in, out] SIZE* minApplicationSizePixels, [in, out] SIZE* maxApplicationSizePixels);
    HRESULT GetApplicationViewOrientation([in] long applicationSizePixelsCX, [in] long applicationSizePixelsCY, [in, out] APPLICATION_VIEW_ORIENTATION* viewOrientation);
}


//cpp_quote("DEFINE_GUID(SID_URLExecutionContext, 0xFB5F8EBC, 0xBBB6, 0x4D10, 0xA4, 0x61, 0x77, 0x72, 0x91, 0xA0, 0x90, 0x30);")
//cpp_quote("#define STR_TAB_REUSE_IDENTIFIER   L\"Tab Reuse Identifier\"")
//cpp_quote("#define STR_REFERRER_IDENTIFIER    L\"Referrer Identifier\"")

// Implemented by an immersive capable browser or any desktop application
// which uses CLSID_ApplicationActivationManager to launch a Windows Store
// application. The object which implements ILaunchTargetMonitor must be set
// on the site chain of CLSID_ApplicationActivationManager before any method
// on IApplicationActivationManager is called. The monitor specified by the
// ILaunchTargetMonitor interface tells Windows which monitor the launched
// application should be shown on.
[
    odl,
    uuid(266FBC7E-490D-46ED-A96B-2274DB252003)
]
interface ILaunchTargetMonitor : stdole.IUnknown
{
    HRESULT GetMonitor([in, out] HMONITOR* monitor);
}

// SID_LaunchTargetMonitor: {8D547FA1-CC45-40C8-B7C1-D48C183F13F3}
// To avoid having to link in a somethinguuid.lib to get the definition, we define the SID as a __uuidof
// from a one-time structure so that the value is generated at compile time rather than resolved at link time.
//cpp_quote("#define SID_LaunchTargetMonitor __uuidof((struct __declspec(uuid(\"8D547FA1-CC45-40C8-B7C1-D48C183F13F3\")) LaunchTargetMonitor*)0)")

// This enum exactly matches the WinRT enum Windows.UI.ViewManagement.ViewSizePreference.
typedef enum APPLICATION_VIEW_SIZE_PREFERENCE
{
    AVSP_DEFAULT = 0,
    AVSP_USE_LESS = 1,
    AVSP_USE_HALF = 2,
    AVSP_USE_MORE = 3,
    AVSP_USE_MINIMUM = 4,
    AVSP_USE_NONE = 5,
    AVSP_CUSTOM = 6,
} APPLICATION_VIEW_SIZE_PREFERENCE;

// Implemented by an immersive capable browser (source app) which uses
// CLSID_ApplicationActivationManager to launch a Window Store application
// (target app). The object which implements ILaunchSourceViewSizePreference
// must be set on the site chain of CLSID_ApplicationActivationManager before
// any method on IApplicationActivationManager is called. The size preference
// information will be used by Windows in placing the source app window once
// the target app is shown on screen.
[
    odl,
    uuid(E5AA01F7-1FB8-4830-8720-4E6734CBD5F3)
]
interface ILaunchSourceViewSizePreference : stdole.IUnknown
{
    HRESULT GetSourceViewToPosition([in, out] HWND* hwnd);
    HRESULT GetSourceViewSizePreference([in, out] APPLICATION_VIEW_SIZE_PREFERENCE* sourceSizeAfterLaunch);
}

// SID_LaunchSourceViewSizePreference: {80605492-67D9-414F-AF89-A1CDF1242BC1}
//cpp_quote("DEFINE_GUID(SID_LaunchSourceViewSizePreference, 0x80605492, 0x67d9, 0x414f, 0xaf, 0x89, 0xa1, 0xcd, 0xf1, 0x24, 0x2b, 0xc1);")

// Implemented by an immersive capable browser and set on the site chain of
// CLSID_ApplicationActivationManager when the browser's IExecuteCommand
// handler receives the invocation and it is about to call
// IApplicationActivationManager to launch the browser itself. Windows will
// use the size preference information to decide how the browser window
// should be shown once it is launched.
[
    odl,
    uuid(2F0666C6-12F7-4360-B511-A394A0553725)
]
interface ILaunchTargetViewSizePreference : stdole.IUnknown
{
    HRESULT GetTargetViewSizePreference([in, out] APPLICATION_VIEW_SIZE_PREFERENCE* targetSizeOnLaunch);
}

// SID_LaunchTargetViewSizePreference: {26DB2472-B7B7-406B-9702-730A4E20D3BF}
//cpp_quote("DEFINE_GUID(SID_LaunchTargetViewSizePreference, 0x26db2472, 0xb7b7, 0x406b, 0x97, 0x2, 0x73, 0xa, 0x4e, 0x20, 0xd3, 0xbf);")

// Implemented by Windows. When a Windows Store app launches an immersive
// capable browser via association launch, an object implementing the
// ILaunchSourceAppUserModelId interface will be set on the site chain of
// the CoreApplication object of the browser. The browser may call
// QueryService(SID_LaunchSourceAppUserModelId, ...) on the site pointer
// to retrieve the interface from which the AppUserModelId of the app that
// launches the browser is available.
[
    odl,
    uuid(989191AC-28FF-4CF0-9584-E0D078BC2396)
]
interface ILaunchSourceAppUserModelId : stdole.IUnknown
{
    HRESULT GetAppUserModelId([in, out] long* launchingApp);
}

// SID_LaunchSourceAppUserModelId: {2CE78010-74DB-48BC-9C6A-10F372495723}
//cpp_quote("DEFINE_GUID(SID_LaunchSourceAppUserModelId, 0x2ce78010, 0x74db, 0x48bc, 0x9c, 0x6a, 0x10, 0xf3, 0x72, 0x49, 0x57, 0x23);")

//cpp_quote("#endif // NTDDI_WINBLUE")


// Provided to the IHandlerActivationHost methods, provides information about the handler.
// May also be retrieved using IServiceProvider::QueryService(SID_HandlerInfo) on the site
// chain provided in ShellExecute and verb handler invocations.
[
    odl,
    uuid(997706ef-f880-453b-8118-39e1a2d2655a)
]
interface IHandlerInfo : stdole.IUnknown
{
    // Return the application display name suitable for display in UI. If not available this will
    // return the file name of the application .exe.
    HRESULT GetApplicationDisplayName([in, out] long* value);
    // Return the application publisher suitable for display in UI. If not available this will fail.
    HRESULT GetApplicationPublisher([in, out] long* value);
    // Return the application icon suitable for display in UI. If not available this will fail.
    HRESULT GetApplicationIconReference([in, out] long* value);
}

// Used to retrieve an IHandlerInfo instance
//cpp_quote("#define SID_HandlerInfo IID_IHandlerInfo")

// Clients of shell item activation including callers of ShellExecuteEx() and
// IContextMenu::InvokeCommand() can implement IHandlerActivationHost
// to be given a chance to veto or perform some action before the activation of verb handlers.
// This interface is implemented by an object reachable through the site chain provided
// to ShellExecuteEx or the context menu handler. Applications will return this object
// in there IServiceProvider::QueryService() implementation when asked for the
// serviceId SID_SHandlerActivationHost.
//
// Handlers are identified by either a COM CLSID or the .exe file that will be passed to
// CreateProcess().
[
    odl,
    uuid(35094a87-8bb1-4237-96c6-c417eebdb078)
]
interface IHandlerActivationHost : stdole.IUnknown
{
    // Implementations of these methods return S_OK to enable the activation of the handler,
    // or an error code to cancel it. If the user canceled the operation
    // HRESULT_FROM_WIN32(ERROR_CANCELLED) should be returned. EXECUTE_E_LAUNCH_APPLICATION
    // can be returned to indicate that this verb implementation should be skipped and the next
    // one tried (if there is one). Generally these error codes will propagate out of the sub system activating the handlers.
    HRESULT BeforeCoCreateInstance([in] REFIID clsidHandler,
        [in] IShellItemArray* itemsBeingActivated, [in] IHandlerInfo* handlerInfo);
    // The applicationPath will normally be a fully qualified path to an application .exe
    // but it can also be a .dll in the case of rundll32.exe based handlers.
    HRESULT BeforeCreateProcess([in] long applicationPath,
        [in] long commandLine, [in] IHandlerInfo* handlerInfo);
}

//cpp_quote("#define SID_SHandlerActivationHost IID_IHandlerActivationHost")
//
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_WIN10)")

// Retrieve an instance of this interface using IServierProvider::QueryService(SID_AppActivationUIInfo)
// on the site chain used in ShellExecute, verb handler invoke and Application Activation Manager.
[
    odl,
    uuid(abad189d-9fa3-4278-b3ca-8ca448a88dcb)
]
interface IAppActivationUIInfo : stdole.IUnknown
{
    // These methods will fail with E_NOT_SET if the values are not available.
    // The monitor that originated the activation. UI generated should go on the same monitor.
    HRESULT GetMonitor([in, out] HMONITOR* value);
    // Point in screen coordinates where the click or touch that originated the activation.
    HRESULT GetInvokePoint([in, out] POINT* value);
    // ShowWindow() values, SW_NORMAL, SW_SHOWMINIMIZED, etc.
    HRESULT GetShowCommand([in, out] int* value);
    // Indicates if UI should be displayed or not.
    HRESULT GetShowUI([in, out] BOOL* value);
    // State of shift and control keys at activation time: MK_SHIFT, MK_CONTROL.
    HRESULT GetKeyState([in, out] DWORD* value);
}
//cpp_quote("#define SID_AppActivationUIInfo IID_IAppActivationUIInfo")
//
//cpp_quote("#endif // NTDDI_WIN10")
//
//cpp_quote("DEFINE_GUID(SID_ShellExecuteNamedPropertyStore, 0xeb84ada2, 0x00ff, 0x4992, 0x83, 0x24, 0xed, 0x5c, 0xe0, 0x61, 0xcb, 0x29);")
//
//cpp_quote("#endif // NTDDI_WIN8")
//
//// Contacts API
//cpp_quote("#if (NTDDI_VERSION >= NTDDI_WINBLUE)")

typedef enum FLYOUT_PLACEMENT
{
    FP_DEFAULT = 0,
    FP_ABOVE,
    FP_BELOW,
    FP_LEFT,
    FP_RIGHT,
} FLYOUT_PLACEMENT;

[
    odl,
    uuid(99eacba7-e073-43b6-a896-55afe48a0833)
]
interface IContactManagerInterop : stdole.IUnknown
{
    // Default browser will use this method to launch contact card from its tab window, specified
    // by the appWindow parameter.
    HRESULT ShowContactCardForWindow(
        [in] HWND appWindow,
        // Must be a Windows::ApplicationModel::Contacts::IContact object.
        // Use IUnknown here because classic COM IDL cannot use WinRT types.
        [in] IUnknown* contact,
        [in] RECT* selection,
        [in] FLYOUT_PLACEMENT preferredPlacement);
}


typedef enum ACTIVATEOPTIONS
{
    AO_NONE = 0x00000000,  // No flags set
    AO_DESIGNMODE = 0x00000001,  // The application is being activated for design mode, and thus will not be able to
                                     // to create an immersive window. Window creation must be done by design tools which
                                     // load the necessary components by communicating with a designer-specified service on
                                     // the site chain established on the activation manager.  The splash screen normally
                                     // shown when an application is activated will also not appear.  Most activations
                                     // will not use this flag.
                                     AO_NOERRORUI = 0x00000002,  // Do not show an error dialog if the app fails to activate.
                                     AO_NOSPLASHSCREEN = 0x00000004,  // Do not show the splash screen when activating the app.
                                     AO_PRELAUNCH = 0x02000000,  // The application is being activated in Prelaunch mode.
} ACTIVATEOPTIONS;

[
    odl,
    uuid(2e941141-7f97-4756-ba1d-9decde894a3d)
]
interface IApplicationActivationManager : stdole.IUnknown
{
    // Activates the specified immersive application for the "Launch" contract, passing the provided arguments
    // string into the application.  Callers can obtain the process Id of the application instance fulfilling this contract.
    HRESULT ActivateApplication(
        [in] long appUserModelId,
        [in] long arguments,
        [in] ACTIVATEOPTIONS options,
        [in, out] DWORD* processId);
    HRESULT ActivateForFile(
        [in] long appUserModelId,
        [in] IShellItemArray* itemArray,
        [in] long verb,
        [in, out] DWORD* processId);
    HRESULT ActivateForProtocol(
        [in] long appUserModelId,
        [in] IShellItemArray* itemArray,
        [in, out] DWORD* processId);
}

typedef enum MONITOR_APP_VISIBILITY
{
    MAV_UNKNOWN = 0,         // The mode for the monitor is unknown
    MAV_NO_APP_VISIBLE = 1,
    MAV_APP_VISIBLE = 2
} MONITOR_APP_VISIBILITY;

[
    odl,
    uuid(6584CE6B-7D82-49C2-89C9-C6BC02BA8C38)
]
interface IAppVisibilityEvents : stdole.IUnknown
{
    HRESULT AppVisibilityOnMonitorChanged([in] HMONITOR hMonitor,
        [in] MONITOR_APP_VISIBILITY previousMode,
        [in] MONITOR_APP_VISIBILITY currentMode);

    HRESULT LauncherVisibilityChange([in] BOOL currentVisibleState);
}

[
    odl,
    uuid(2246EA2D-CAEA-4444-A3C4-6DE827E44313)
]
interface IAppVisibility : stdole.IUnknown
{
    HRESULT GetAppVisibilityOnMonitor([in] HMONITOR hMonitor, [in, out] MONITOR_APP_VISIBILITY* pMode);
    HRESULT IsLauncherVisible([in, out] BOOL* pfVisible);
    HRESULT Advise([in] IAppVisibilityEvents* pCallback, [in, out] DWORD* pdwCookie);
    HRESULT Unadvise([in] DWORD dwCookie);
}

// IDesktopWallpaper
    // This enumeration is used to set and get slideshow options.
    typedef enum DESKTOP_SLIDESHOW_OPTIONS
{
    DSO_SHUFFLEIMAGES = 0x01,     // When set, indicates that the order in which images in the slideshow are displayed can be randomized.
} DESKTOP_SLIDESHOW_OPTIONS;


// This enumeration is used by GetStatus to indicate the current status of the slideshow.
typedef enum DESKTOP_SLIDESHOW_STATE
{
    DSS_ENABLED = 0x01,                    // Slideshows are enabled. This is normally true, unless the Enable method is used.
    DSS_SLIDESHOW = 0x02,                  // A slideshow is currently configured (e.g., using SetSlideshow).
    DSS_DISABLED_BY_REMOTE_SESSION = 0x04  // A remote session has temporarily disabled the slideshow
} DESKTOP_SLIDESHOW_STATE;

// This enumeration is used by the AdvanceSlideshow method to indicate whether to advance the slideshow forward or backward.
typedef enum DESKTOP_SLIDESHOW_DIRECTION
{
    DSD_FORWARD = 0,              // Advance slideshow forward.
    DSD_BACKWARD = 1,             // Advance slideshow backward.
} DESKTOP_SLIDESHOW_DIRECTION;

// This enumeration indicates the wallpaper position for all monitors. (This includes when slideshows are running.)
// The wallpaper position specifies how the image that is assigned to a monitor should be displayed.
typedef enum DESKTOP_WALLPAPER_POSITION
{
    DWPOS_CENTER = 0,             // Center the image, do not stretch (WPSTYLE_CENTER in IActiveDesktop).
    DWPOS_TILE = 1,               // Tile the image across all monitors (WPSTYLE_TILE in IActiveDesktop).
    DWPOS_STRETCH = 2,            // Stretch the image to exactly fit on the monitor (WPSTYLE_STRETCH in IActiveDesktop).
    DWPOS_FIT = 3,                // Stretch the image to exactly the height or width of the monitor without
                                  // changing its aspect ratio or cropping (WPSTYLE_KEEPASPECT in IActiveDesktop).
                                  // This often results in letterbox bars on the sides or top/bottom of the image.
                                  DWPOS_FILL = 4,               // Like DWPOS_FIT, but stretches the image until it completely fills the screen, allowing
                                                                // cropping to avoid letterbox bars (WPSTYLE_CROPTOFIT in IActiveDesktop).
                                                                DWPOS_SPAN = 5,               // Spans a single image across all monitors (new, no IActiveDesktop equivalent).
} DESKTOP_WALLPAPER_POSITION;

[
    odl,
    uuid(B92B56A9-8B55-4E14-9A89-0199BBB6F93B)
]
interface IDesktopWallpaper : stdole.IUnknown
{



    // These methods allow the wallpaper to be set and get for each monitor. The first parameter indicates the monitor by its
    // identifier (obtained with GetMonitorDevicePathAt) and the second a path to the wallpaper. If NULL is passed as the monitor
    // identifier to SetWallpaper, then that wallpaper will be set for all monitors. Passing NULL as the monitor identifier to
    // GetWallpaper will return S_OK and a valid wallpaper path if all monitors are displaying the same image, or S_FALSE and an
    // empty string if they are not (i.e., there are multiple static images on each monitor or a slideshow is running). An empty
    // wallpaper string indicates no image, or a monitor that is displaying the system color for the background.
    HRESULT SetWallpaper([in] long monitorID, [in] long wallpaper);
    HRESULT GetWallpaper([in] long monitorID, [in, out] long* wallpaper);

    // These methods allow the monitor count and a unique identifier for each monitor to be obtained.
    // This includes monitors that are currently detached but have an image assigned to them; such a monitor
    // would display its assigned image when it is reattached. Use GetMonitorRECT to distinguish between
    // attached and detached monitors.
    // Note that these methods wrap existing CCD library functionality.
    HRESULT GetMonitorDevicePathAt([in] UINT monitorIndex, [in, out] long* monitorID);
    HRESULT GetMonitorDevicePathCount([in, out] UINT* count);

    // This method allows the display rectangle of the specified monitor to be obtained, in screen coordinates. If the monitor
    // is not currently attached, it will return S_FALSE and an empty RECT. Checking for S_FALSE is a valid way to determine
    // which monitors are currently attached to the system.
    HRESULT GetMonitorRECT([in] long monitorID, [in, out] RECT* displayRect);

    // These are callthroughs to SetSysColor(COLOR_BACKGROUND) and GetSysColor(COLOR_BACKGROUND).
    // This is the color that is visible on the desktop when no image is currently displayed or when the
    // Enable method is used to disable the background. The color will also be visible when the wallpaper does not
    // fill the entire monitor (e.g., often when the wallpaper position is Fit or Center).
    HRESULT SetBackgroundColor([in] COLORREF color);
    HRESULT GetBackgroundColor([in, out] COLORREF* color);

    // These methods allow the wallpaper position to be set and get, as indicated by the DESKTOP_WALLPAPER_POSITION enumeration.
    HRESULT SetPosition([in] DESKTOP_WALLPAPER_POSITION position);
    HRESULT GetPosition([in, out] DESKTOP_WALLPAPER_POSITION* position);

    // These methods are used to set and get the items that will be displayed in a slideshow. When setting the slideshow,
    // the IShellItemArray can specify either a set of items that are all part of the same container or a single item that
    // is itself a container; any other IShellItemArray will cause SetSlideshow to fail.
    HRESULT SetSlideshow([in] IShellItemArray* items);
    HRESULT GetSlideshow([in, out] IShellItemArray** items);

    // These methods are used to set and get the slideshow options that are part of the DESKTOP_SLIDESHOW_OPTIONS
    // enumeration, as well as the slideshow "tick" (the interval between slideshow background image transitions), in milliseconds.
    HRESULT SetSlideshowOptions([in] DESKTOP_SLIDESHOW_OPTIONS options, [in] UINT slideshowTick);
    HRESULT GetSlideshowOptions([in, out] DESKTOP_SLIDESHOW_OPTIONS* options, [in, out] UINT* slideshowTick);

    // Call this method to advance the slideshow. The first parameter indicates the monitor to change; when NULL, it advances the
    // monitor that would be expected to change on the next tick of the slideshow. The second parameter uses the
    // DESKTOP_SLIDESHOW_DIRECTION enumeration to indicate whether to advance the slideshow forward or backward.
    HRESULT AdvanceSlideshow([in] long monitorID, [in] DESKTOP_SLIDESHOW_DIRECTION direction);

    // This method returns the current status of the slideshow, as indicated by the
    // DESKTOP_SLIDESHOW_STATE enumeration.
    HRESULT GetStatus([in, out] DESKTOP_SLIDESHOW_STATE* state);

    // This method allows the desktop background to be enabled or disabled, depending on the
    // value of the argument. This is primarily intended for situations such as terminal server
    // where it may be desirable to disable the background for performance reasons.
    // Note that a call to SetWallpaper or SetSlideshow will re-enable the background even if it
    // is disabled by this method.
    HRESULT Enable([in] BOOL enable);
}

[
    odl,
    uuid(6589b6d2-5f8d-4b9e-b7e0-23cdd9717d8c)
]
interface IUpdateIDList : stdole.IUnknown
{
    // Implemented by an IShellFolder implementation, this method updates the provided child IDList based on the
    // parameters specified by the provided IBindCtx.  If pbc is NULL, or does not contain any parameters that
    // apply to the current Shell Folder, pidlIn should simply be cloned into ppidlOut.
    HRESULT Update(
        [in] IBindCtx* pbc,
        [in] PCUITEMID_CHILD pidlIn,
        [in, out] PITEMID_CHILD* ppidlOut);
}

[
    odl,
    uuid(36db0196-9665-46d1-9ba7-d3709eecf9ed)
]
interface IObjectWithAppUserModelID : stdole.IUnknown
{
    HRESULT SetAppID([in] long pszAppID);
    HRESULT GetAppID([in, out] long* ppszAppID);
}

// Provides access to the ProgID associated with an object
[
    odl,
    uuid(71e806fb-8dee-46fc-bf8c-7748a8a1ae13)
]
interface IObjectWithProgID : stdole.IUnknown
{
    HRESULT SetProgID([in] long pszProgID);
    HRESULT GetProgID([in, out] long* ppszProgID);
}

[
    odl,
    uuid(F279B885-0AE9-4b85-AC06-DDECF9408941)
]
interface IObjectWithCancelEvent : stdole.IUnknown
{
    // Call this function to retrieve an event that will be signaled when
    // the callee cancels the operation it's performing.
    // The caller is responsible for closing the returned handle.
    HRESULT GetCancelEvent([in, out] HANDLE* phEvent);
}

[
    odl,
    uuid(1c9cd5bb-98e9-4491-a60f-31aacc72b83c),
]
interface IObjectWithSelection : stdole.IUnknown
{
    HRESULT SetSelection([in] IShellItemArray* psia);

    HRESULT GetSelection(
        [in] REFIID riid,
        [in, out] long *ppv);
}

[
    odl,
    uuid(321a6a6a-d61f-4bf3-97ae-14be2986bb36)
]
interface IObjectWithBackReferences : stdole.IUnknown
{
    // This method is used for all tasks associated with freeing/releasing back references held
    // by an object, and may prepare an object for reuse
    HRESULT RemoveBackReferences();
}




[
    odl,
    uuid(000214FE-0000-0000-C000-000000000046)
]
interface IRemoteComputer : stdole.IUnknown
{
    // function is called when the explorer is initializing or
    // enumerating the name space extension. If failure is returned during
    // enumeration, the extension won't appear for this computer. Otherwise,
    // the extension will appear, and should target the given machine.
    //
    // pszMachine       Specifies the name of the machine to target. (\\server)
    // bEnumerationg    test to see if this object should be enumerated
    //                  on this server
    HRESULT Initialize(
        [in] long pszMachine,
        [in] BOOL bEnumerating);
}

typedef enum CDBURNINGEXTENSIONRET
{
    CDBE_RET_DEFAULT = 0x00000000,
    CDBE_RET_DONTRUNOTHEREXTS = 0x00000001,
    CDBE_RET_STOPWIZARD = 0x00000002,
} CDBURNINGEXTENSIONRET;

typedef enum CDBE_ACTIONS
{
    CDBE_TYPE_MUSIC = 0x00000001,
    CDBE_TYPE_DATA = 0x00000002,
    CDBE_TYPE_ALL = 0xFFFFFFFF
} CDBE_ACTIONS;

[
    odl,
    uuid(2271dcca-74fc-4414-8fb7-c56b05ace2d7)
]
interface ICDBurnExt : stdole.IUnknown
{
    HRESULT GetSupportedActionTypes([out] CDBE_ACTIONS* pdwActions);
}

// supports inserting an item into a folder
[
    odl,
    uuid(D2B57227-3D23-4b95-93C0-492BD454C356)
]
interface IInsertItem : stdole.IUnknown
{
    HRESULT InsertItem([in] PCUIDLIST_RELATIVE pidl);
}

[
    odl,
    uuid(f5b0bf81-8cb5-4b1b-9449-1a159e0c733c)
]
interface IIOCancelInformation : stdole.IUnknown
{
    // When the progress UI is cancled by the user, dwThreadID will have
    // 1) any pending or future IO requests canceled using CancelSynchronousIo()
    // 2) uMsgCancel will be posted to the thread to tell it to
    //    exit a wait that it might be in waiting for async IO to complete
    HRESULT SetCancelInformation([in] DWORD dwThreadID, [in] UINT uMsgCancel);
    HRESULT GetCancelInformation([out] DWORD* pdwThreadID, [out] UINT* puMsgCancel);
}

[
    odl,
    uuid(2c1c7e2e-2d0e-4059-831e-1e6f82335c2e)
]
interface IEnumObjects : stdole.IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [in] REFIID riid,
        [in, out] void* rgelt,
        [in, out] ULONG* pceltFetched);

    HRESULT Skip([in] ULONG celt);

    HRESULT Reset();

    HRESULT Clone([out, retval] IEnumObjects** ppenum);
}

[
    odl,
    uuid(a6087428-3be3-4d73-b308-7c04a540bf1a)
]
interface IObjectProvider : stdole.IUnknown
{
    // IObjectProvider is similar to IServiceProvider except that it
    // does not imply that unhandled/unknown requests should be forwarded,
    // as IServiceProvider does. the object being queired for is identified
    // by guidObject, usually named as OID_XXX
    HRESULT QueryObject([in] REFGUID guidObject, [in] REFIID riid, [in, out] long* ppvOut);
}

[
    odl,
    uuid(5852A2C3-6530-11D1-B6A3-0000F8757BF9)
]
interface IPrintDialogCallback : stdole.IUnknown
{
    HRESULT InitDone(void);
    HRESULT SelectionChange(void);
    HRESULT HandleMessage([in] HWND hDlg, [in] UINT uMsg, [in] WPARAM wParam, [in] LONG lParam, [in, out] long* plResult);
}

typedef struct DEVMODEW {
    WCHAR  dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    /*union {
        /* printer only fields
        struct {
            short dmOrientation;
            short dmPaperSize;
            short dmPaperLength;
            short dmPaperWidth;
            short dmScale;
            short dmCopies;
            short dmDefaultSource;
            short dmPrintQuality;
        } DUMMYSTRUCTNAME;
        /* display only fields 
        struct {
            POINTL dmPosition;
            DWORD  dmDisplayOrientation;
            DWORD  dmDisplayFixedOutput;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME;*/
    BYTE PrinterOrDisplayFields[16];
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR  dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    /*union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    } DUMMYUNIONNAME2;*/
    DWORD DisplayFlagsOrNup;
    DWORD  dmDisplayFrequency;
//#if(WINVER >= 0x0400)
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
//#if (WINVER >= 0x0500) || (_WIN32_WINNT >= _WIN32_WINNT_NT4)
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
//#endif
//#endif /* WINVER >= 0x0400 */
} DEVMODEW;
[
    odl,
    uuid(509AAEDA-5639-11D1-B6A1-0000F8757BF9)
]
interface IPrintDialogServices : stdole.IUnknown
{
    HRESULT GetCurrentDevMode([in, out] DEVMODEW * pDevMode,[in, out] UINT * pcbSize);
    HRESULT GetCurrentPrinterName([in, out] long* pPrinterName, [in, out] UINT *pcchSize);
    HRESULT GetCurrentPortName([in, out] long* pPortName, [in, out] UINT* pcchSize);
}

[
    odl,
    uuid(6D67E846-5B9C-4db8-9CBC-DDE12F4254F1)
]
interface ITrayDeskBand : stdole.IUnknown
{
    HRESULT ShowDeskBand([in] REFCLSID clsid);

    HRESULT HideDeskBand([in] REFCLSID clsid);

    HRESULT IsDeskBandShown([in] REFCLSID clsid);

    HRESULT DeskBandRegistrationChanged();
}

[
    odl,
    uuid(B9075C7C-D48E-403f-AB99-D6C77A1084AC)
]
interface IBandHost : stdole.IUnknown
{
    HRESULT CreateBand(
        [in] REFCLSID rclsidBand,
        [in] BOOL fAvailable,
        [in] BOOL fVisible,
        [in] REFIID riid,
        [in, out] long* ppv);

    HRESULT SetBandAvailability(
        [in] REFCLSID rclsidBand,
        [in] BOOL fAvailable);

    HRESULT DestroyBand([in] REFCLSID rclsidBand);
}



typedef enum BANDSITECID {
    BSID_BANDADDED,
    BSID_BANDREMOVED,
} BANDSITECID;

// Field mask
typedef enum BandSiteMask
{
    BSIM_STATE = 0x00000001,
    BSIM_STYLE = 0x00000002
} BandSiteMask;

// State flags
typedef enum BandSiteState
{
    BSSF_VISIBLE = 0x00000001,
    BSSF_NOTITLE = 0x00000002,
    BSSF_UNDELETEABLE = 0x00001000
} BandSiteState;


typedef enum BandSiteStyle
{
    BSIS_AUTOGRIPPER = 0x00000000,
    BSIS_NOGRIPPER = 0x00000001,
    BSIS_ALWAYSGRIPPER = 0x00000002,
    BSIS_LEFTALIGN = 0x00000004,
    BSIS_SINGLECLICK = 0x00000008,
    BSIS_NOCONTEXTMENU = 0x00000010,
    BSIS_NODROPTARGET = 0x00000020,
    BSIS_NOCAPTION = 0x00000040,
    BSIS_PREFERNOLINEBREAK = 0x00000080,
    BSIS_LOCKED = 0x00000100,

    BSIS_PRESERVEORDERDURINGLAYOUT = 0x00000200,
    BSIS_FIXEDORDER = 0x00000400
} BandSiteStyle;

typedef struct BANDSITEINFO
{
    BandSiteMask        dwMask;         // BSIM_* flags
    BandSiteState       dwState;        // BSSF_* flags
    BandSiteStyle       dwStyle;        // BSIS_* flags
} BANDSITEINFO;

[
    odl,
    uuid(4CF504B0-DE96-11D0-8B3F-00A0C911E8E5)
]
interface IBandSite : stdole.IUnknown
{
    HRESULT AddBand([in] stdole.IUnknown* punk);

    HRESULT EnumBands(
        [in] UINT uBand,
        [out] DWORD* pdwBandID);

    //[local]
    HRESULT QueryBand(
        [in] DWORD dwBandID,
        [out] IDeskBand** ppstb,
        [out] DWORD* pdwState,
        [out] long* pszName,
        [in] int cchName);

    //[call_as(QueryBand)]
    //HRESULT RemoteQueryBand(
    //    [in] DWORD dwBandID,
    //    [out] IDeskBand** ppstb,
    //    [out] DWORD* pdwState,
    //    [out, string, size_is(cchName)] LPWSTR pszName,
    //    [in] int cchName);

    HRESULT SetBandState(
        [in] DWORD dwBandID,
        [in] BandSiteMask dwMask,
        [in] BandSiteState dwState);

    HRESULT RemoveBand([in] DWORD dwBandID);

    HRESULT GetBandObject(
        [in] DWORD dwBandID,
        [in] REFIID riid,
        [out] LPVOID ppv);

    HRESULT SetBandSiteInfo([in] BANDSITEINFO* pbsinfo);

    HRESULT GetBandSiteInfo([in, out] BANDSITEINFO* pbsinfo);
}

[
    odl,
    uuid(79D16DE4-ABEE-4021-8D9D-9169B261D657)
]
interface IDeskBand2 : IDeskBand
{
    HRESULT CanRenderComposited([out] BOOL* pfCanRenderComposited);

    HRESULT SetCompositionState([in] BOOL fCompositionEnabled);

    HRESULT GetCompositionState([out] BOOL* pfCompositionEnabled);
}

[
    odl,
    uuid(77E425FC-CBF9-4307-BA6A-BB5727745661)
]
interface IDeskBandInfo : stdole.IUnknown
{
    HRESULT GetDefaultBandWidth(
        [in] DWORD dwBandID,
        [in] DWORD dwViewMode,
        [out] int* pnWidth);
}
    // CmdIDs for the IOleCommandTarget Group: CGID_MenuBandHandler (defined in shguidp.h)
    typedef enum MENUBANDHANDLERCID {
        MBHANDCID_PIDLSELEC         // A PIDL from a menuband was selected
    }MENUBANDHANDLERCID;
[
    odl,
    uuid(568804CD-CBD7-11d0-9816-00C04FD91972)
]
interface IMenuBand : stdole.IUnknown
{


    HRESULT IsMenuMessage([in] MSG* pmsg);

    HRESULT TranslateMenuMessage(
        [in, out] MSG* pmsg,
        [out] long* plRet);
}

// callback objects for CRegTreeOptions items
[
    odl,
    uuid(A9521922-0812-4d44-9EC3-7FD38C726F3D)
]
interface IRegTreeItem : stdole.IUnknown
{
    HRESULT GetCheckState([out] BOOL* pbCheck);
    HRESULT SetCheckState([in] BOOL bCheck);
}

[
    odl,
    uuid(91956D21-9276-11d1-921A-006097DF5BD4)
]
interface ICurrentWorkingDirectory : stdole.IUnknown
{
    HRESULT GetDirectory([in, out] long* pwzPath,[in] DWORD cchSize);
    HRESULT SetDirectory([in] long pwzPath);
}

typedef enum SFB_Mask
{
    ISFB_MASK_STATE         = 0x00000001, // TRUE if dwStateMask and dwState is valid
    ISFB_MASK_BKCOLOR       = 0x00000002, // TRUE if crBkgnd field is valid
    ISFB_MASK_VIEWMODE      = 0x00000004, // TRUE if wViewMode field is valid
    ISFB_MASK_SHELLFOLDER   = 0x00000008,
    ISFB_MASK_IDLIST        = 0x00000010,
    ISFB_MASK_COLORS        = 0x00000020 // TRUE if crXXXX fields are valid (except bkgnd)
} SFB_Mask;

typedef enum SFB_State
{
    ISFB_STATE_DEFAULT      = 0x00000000,
    ISFB_STATE_DEBOSSED     = 0x00000001,
    ISFB_STATE_ALLOWRENAME  = 0x00000002,
    ISFB_STATE_NOSHOWTEXT   = 0x00000004, // TRUE if _fNoShowText
    ISFB_STATE_CHANNELBAR   = 0x00000010, // TRUE if we want NavigateTarget support
    ISFB_STATE_QLINKSMODE   = 0x00000020, // TRUE if we want to turn off drag & drop onto content items
    ISFB_STATE_FULLOPEN     = 0x00000040, // TRUE if band should maximize when opened
    ISFB_STATE_NONAMESORT   = 0x00000080, // TRUE if band should _not_ sort icons by name
    ISFB_STATE_BTNMINSIZE   = 0x00000100 // TRUE if band should report min thickness of button
} SFB_State;

typedef struct BANDINFOSFB
{
    SFB_Mask    dwMask;       // [in] ISFB_MASK mask of valid fields from crBkgnd on
    SFB_State   dwStateMask;  // [in] ISFB_STATE mask of dwState bits being set/queried
    SFB_State   dwState;      // [in/out] ISFB_STATE bits
    COLORREF    crBkgnd;      // [in/out]
    COLORREF    crBtnLt;      // [in/out]
    COLORREF    crBtnDk;      // [in/out]
    WORD        wViewMode;    // [in/out]
    WORD        wAlign;       // not used (yet)
    long        psf;       // [out]
    PIDLIST_ABSOLUTE pidl;      // [out]
} BANDINFOSFB;

typedef enum SFB_ViewMode
{
    ISFBVIEWMODE_SMALLICONS  = 0x0001,
    ISFBVIEWMODE_LARGEICONS  = 0x0002,
    ISFBVIEWMODE_LOGOS       = 0x0003
} SFB_ViewMode;

typedef enum SFB_CmdTgtIds
{
    SFBID_PIDLCHANGED
} SFB_CmdTgtIds;

[
    odl,
    uuid(7FE80CC8-C247-11d0-B93A-00A0C90312E1)
]
interface IShellFolderBand : stdole.IUnknown
{
    HRESULT InitializeSFB([in] IShellFolder * psf,[in] PCIDLIST_ABSOLUTE pidl);
    HRESULT SetBandInfoSFB([in] BANDINFOSFB* pbi);
    HRESULT GetBandInfoSFB([in, out] BANDINFOSFB* pbi);
}

typedef enum DBC_Msgs
{
    DBC_GS_IDEAL        =  0,  // get the ideal size
    DBC_GS_SIZEDOWN     =  1,  // clip the height of a rect to a multiple of the rebar's integral size
    DBC_HIDE        = 0, // Band is hidden (being destroyed)
    DBC_SHOW        = 1, // Band is visible
    DBC_SHOWOBSCURE = 2 // Band is completely obscured
} DBC_Msgs;

typedef enum DBC_IDs {
    DBCID_EMPTY = 0,        // bandsite is empty
    DBCID_ONDRAG = 1,       // (down)DragMoveEnter/Leave vaIn:I4:eDrag
    DBCID_CLSIDOFBAR = 2,   // clsid of bar inside
    DBCID_RESIZE = 3,       // resize from keyboard accelerator
    DBCID_GETBAR = 4,       // returns vaOut:VT_UNKNOWN of hosting dockbar (IDeskBar)
    DBCID_UPDATESIZE = 5,   // resize from non-user source (search activation failure)
} DBC_IDs;

[
    odl,
    uuid(EB0FE175-1A3A-11D0-89B3-00A0C90A90AC)
]
interface IDeskBarClient : IOleWindow
{
    HRESULT SetDeskBarSite([in] IUnknown* punkSite);
    HRESULT SetModeDBC([in] DWORD dwMode);
    HRESULT UIActivateDBC([in] DWORD dwState);
    HRESULT GetSize([in] DWORD dwWhich, [in, out] RECT *prc);
}
 

[
    odl,
    uuid(31cca04c-04d3-4ea9-90de-97b15e87a532)
]
interface IHandlerInfo2 : IHandlerInfo
{
    // Get the AppId of the application that will be launched.
    HRESULT GetApplicationId([in, out] long* value);
}
    typedef enum BANNER_NOTIFICATION_EVENT
    {
        BNE_Rendered = 0,
        BNE_Hovered,
        BNE_Closed,      // Implicit close due to navigation
        BNE_Dismissed,   // Explicit close by user using dismiss button
        BNE_Button1Clicked,
        BNE_Button2Clicked
    } BANNER_NOTIFICATION_EVENT;

    typedef struct BANNER_NOTIFICATION
    {
        BANNER_NOTIFICATION_EVENT event;
        long providerIdentity;
        long contentId;
    } BANNER_NOTIFICATION;
[
    odl,
    uuid(8d7b2ba7-db05-46a8-823c-d2b6de08ee91)
]
interface IBannerNotificationHandler : stdole.IUnknown
{


    HRESULT OnBannerEvent([in] BANNER_NOTIFICATION* notification);
}

typedef enum SORT_ORDER_TYPE
{
    SOT_DEFAULT = 0,
    SOT_IGNORE_FOLDERNESS = 1,
} SORT_ORDER_TYPE;

[
    odl,
    uuid(6dfc60fb-f2e9-459b-beb5-288f1a7c7d54)
]
interface ISortColumnArray : stdole.IUnknown
{
    HRESULT GetCount([out] UINT* columnCount);
    HRESULT GetAt([in] UINT index, [out] SORTCOLUMN* sortcolumn);
    HRESULT GetSortType([out] SORT_ORDER_TYPE* type);
}

[
    odl,
    uuid(75BD59AA-F23B-4963-ABA4-0B355752A91B)
]
interface IPropertyKeyStore : stdole.IUnknown
{
    HRESULT GetKeyCount([out] int* keyCount);
    HRESULT GetKeyAt([in] int index, [out] PROPERTYKEY* pkey);
    HRESULT AppendKey([in] REFPROPERTYKEY key);
    HRESULT DeleteKey([in] int index);
    HRESULT IsKeyInStore([in] REFPROPERTYKEY key); // S_OK means yes, S_FALSE means no.
    HRESULT RemoveKey([in] REFPROPERTYKEY key);
}

[
    odl,
    uuid(95A391C5-9ED4-4c28-8401-AB9E06719E11)
]
interface IAccessibleObject : stdole.IUnknown
{
    HRESULT SetAccessibleName([in] long pszName);
}

[
    odl,
    uuid(47c01f95-e185-412c-b5c5-4f27df965aea)
]
interface IFolderBandPriv : stdole.IUnknown
{
    HRESULT SetCascade([in] BOOL fCascade);

    HRESULT SetAccelerators([in] BOOL fAccelerators);

    HRESULT SetNoIcons([in] BOOL fNoIcons);

    HRESULT SetNoText([in] BOOL fNoText);
}

[
    odl,
    uuid(2D91EEA1-9932-11d2-BE86-00A0C9A83DA1), // IID_IFileSearchBand
    helpstring("IFileSearchBand Interface"),
    oleautomation,
    dual
]
interface IFileSearchBand : IDispatch
{
    [id(1), helpstring("method SetFocus")]
    HRESULT SetFocus(void);

    [id(2), helpstring("method SetSearchParameters")]
    HRESULT SetSearchParameters([in] BSTR* pbstrSearchID, [in]VARIANT_BOOL bNavToResults, [in, optional] VARIANT* pvarScope, [in, optional]VARIANT* pvarQueryFile);

    [id(3), propget, helpstring("Retrieve the guid of the currently active search.")]
    HRESULT SearchID([out, retval] BSTR* pbstrSearchID);

    [id(4), propget, helpstring("Get the search scope")]
    HRESULT Scope([out, retval] VARIANT* pvarScope);

    [id(5), propget, helpstring("Retrieve the file from which the search was restored.")]
    HRESULT QueryFile([out, retval] VARIANT* pvarFile);
};

[
    odl,
    uuid(c1646bc4-f298-4f91-a204-eb2dd1709d1a),
]
interface IDesktopGadget : stdole.IUnknown
{
    HRESULT RunGadget([in] LPCWSTR gadgetPath);
}

[
    odl,
    uuid(7bf992a9-af7a-4dba-b2e5-4d080b1ecbc6)
]
interface IStorageProviderCopyHook : stdole.IUnknown
{
    HRESULT CopyCallback(
        [in] HWND hwnd,
        [in] FILEOP operation,
        [in] FILEOP_FLAGS  flags,
        [in] long srcFile,
        [in] FILE_ATTRIBUTES srcAttribs,
        [in] long destFile,
        [in] FILE_ATTRIBUTES destAttribs,
        [out] UINT* result);
};

[
    odl,
    uuid(C7B236CE-EE80-11D0-985F-006008059382)
]
interface IQueryCodePage : stdole.IUnknown
{
    HRESULT GetCodePage([out] UINT  *puiCodePage);
    HRESULT SetCodePage([in] UINT uiCodePage);
}

[
    odl,
    uuid(8a68fdda-1fdc-4c20-8ceb-416643b5a625)
]
interface IStreamUnbufferedInfo : stdole.IUnknown
{
    HRESULT GetSectorSize([out] ULONG  *pcbSectorSize);
}

[
    odl,
    uuid(a561e69a-b4b8-4113-91a5-64c6bcca3430)
]
interface IUserAccountChangeCallback : stdole.IUnknown
{
    HRESULT OnPicrureChange([in] long pszUsername);
}

[
    odl,
    helpstring("OpenSearch Data Source API"),
    uuid(F0EE7333-E6FC-479b-9F25-A860C234A38E)
]
interface IOpenSearchSource : stdole.IUnknown
{
    HRESULT GetResults(
        [in] HWND hwnd,
        [in] long pszQuery,
        [in] DWORD dwStartIndex,
        [in] DWORD dwCount,
        [in] REFIID riid,
        [out] LPVOID ppv);  // return IStream

}

[
    odl,
    uuid(8a87781b-39a7-4a1f-aab3-a39b9c34a7d9)
]
interface IDestinationStreamFactory : stdole.IUnknown
{
    HRESULT GetDestinationStream([out] IStream** ppstm);
}


typedef enum CreateProcessFlags
{
    DEBUG_PROCESS = 0x00000001,
    DEBUG_ONLY_THIS_PROCESS = 0x00000002,
    CREATE_SUSPENDED = 0x00000004,
    DETACHED_PROCESS = 0x00000008,
    CREATE_NEW_CONSOLE = 0x00000010,
    NORMAL_PRIORITY_CLASS_FLAG = 0x00000020,
    IDLE_PRIORITY_CLASS_FLAG = 0x00000040,
    HIGH_PRIORITY_CLASS_FLAG = 0x00000080,
    REALTIME_PRIORITY_CLASS = 0x00000100,
    CREATE_NEW_PROCESS_GROUP = 0x00000200,
    CREATE_UNICODE_ENVIRONMENT = 0x00000400,
    CREATE_SEPARATE_WOW_VDM = 0x00000800,
    CREATE_SHARED_WOW_VDM = 0x00001000,
    CREATE_FORCEDOS = 0x00002000,
    BELOW_NORMAL_PRIORITY_CLASS_FLAG = 0x00004000,
    ABOVE_NORMAL_PRIORITY_CLASS_FLAG = 0x00008000,
    INHERIT_PARENT_AFFINITY = 0x00010000,
    INHERIT_CALLER_PRIORITY = 0x00020000, // Deprecated
    CREATE_PROTECTED_PROCESS = 0x00040000,
    EXTENDED_STARTUPINFO_PRESENT = 0x00080000,
    PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000,
    PROCESS_MODE_BACKGROUND_END = 0x00200000,
    CREATE_SECURE_PROCESS = 0x00400000,
    CREATE_BREAKAWAY_FROM_JOB = 0x01000000,
    CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000,
    CREATE_DEFAULT_ERROR_MODE = 0x04000000,
    CREATE_NO_WINDOW = 0x08000000,
    PROFILE_USER = 0x10000000,
    PROFILE_KERNEL = 0x20000000,
    PROFILE_SERVER = 0x40000000,
    CREATE_IGNORE_SYSTEM_DEFAULT = 0x80000000
} CreateProcessFlags;

typedef enum STARTUP_FLAGS
{
    STARTF_USESHOWWINDOW = 0x1,
    STARTF_USESIZE = 0x2,
    STARTF_USEPOSITION = 0x4,
    STARTF_USECOUNTCHARS = 0x8,
    STARTF_USEFILLATTRIBUTE = 0x10,
    STARTF_RUNFULLSCREEN = 0x20,         // ignored For non - x86 platforms
    STARTF_FORCEONFEEDBACK = 0x40,
    STARTF_FORCEOFFFEEDBACK = 0x80,
    STARTF_USESTDHANDLES = 0x100,
    STARTF_USEHOTKEY = 0x200,
    STARTF_TITLEISLINKNAME = 0x800,
    STARTF_TITLEISAPPID = 0x1000,
    STARTF_PREVENTPINNING = 0x2000,
    STARTF_UNTRUSTEDSOURCE = 0x8000
} STARTUP_FLAGS;

// SID_ExecuteCreatingProcess/ICreatingProcess
// A service implemented by callers of ShellExecute that lets them modify the inputs
// of CreateProcess before it is called.
// See SEE_MASK_FLAG_HINST_IS_SITE for details on how to provide this service.
[
    odl,
    uuid(F6EF6140-E26F-4D82-bAC4-E9BA5FD239A8)
]
interface ICreateProcessInputs : stdole.IUnknown
{
    // CreateProcess() dwCreationFlags parameter
    HRESULT GetCreateFlags([in, out] CreateProcessFlags* pdwCreationFlags);
    HRESULT SetCreateFlags([in] CreateProcessFlags dwCreationFlags);
    HRESULT AddCreateFlags([in] CreateProcessFlags dwCreationFlags);

    HRESULT SetHotKey([in] WORD wHotKey);

    // STARTUPINFO.dwFlags
    HRESULT AddStartupFlags([in] STARTUP_FLAGS dwStartupInfoFlags);
    HRESULT SetTitle([in] long pszTitle);
    HRESULT SetEnvironmentVariable(
        [in] long pszName,
        [in] long pszValue);
}

[
    odl,
    uuid(c2b937a9-3110-4398-8a56-f34c6342d244)
]
interface ICreatingProcess : stdole.IUnknown
{
    HRESULT OnCreating([in] ICreateProcessInputs* pcpi);
}


[
    odl,
    uuid(1C2056CC-5EF4-101B-8BC8-00AA003E3B29)
]
interface IOleInPlaceObjectWindowless : IOleInPlaceObject
{
    //typedef IOleInPlaceObjectWindowless* LPOLEINPLACEOBJECTWINDOWLESS;

    HRESULT OnWindowMessage(
        [in] UINT msg,
        [in] WPARAM wParam,
        [in] LPARAM lParam,
        [out] LRESULT* plResult
    );

    HRESULT GetDropTarget(
        [out] IDropTarget** ppDropTarget
    );
}

    typedef enum ACTIVATEFLAGS {
        ACTIVATE_WINDOWLESS = 1,
    } ACTIVATEFLAGS;
[
    odl,
    uuid(9C2CAD80-3424-11CF-B670-00AA004CD6D8)
]
interface IOleInPlaceSiteEx : IOleInPlaceSite
{
    //typedef IOleInPlaceSiteEx* LPOLEINPLACESITEEX;



    HRESULT OnInPlaceActivateEx(
        [in, out] BOOL* pfNoRedraw,
        [in] DWORD dwFlags
    );

    HRESULT OnInPlaceDeactivateEx(
        [in] BOOL fNoRedraw
    );

    HRESULT RequestUIActivate(
        void
    );
}


    typedef enum OLEDCFLAGS {
        OLEDC_NODRAW = 0x01,
        OLEDC_PAINTBKGND = 0x02,
        OLEDC_OFFSCREEN = 0x04
    } OLEDCFLAGS;
[
    odl,
    uuid(922EADA0-3424-11CF-B670-00AA004CD6D8)
]
interface IOleInPlaceSiteWindowless : IOleInPlaceSiteEx
{
    //typedef IOleInPlaceSiteWindowless* LPOLEINPLACESITEWINDOWLESS;


    HRESULT CanWindowlessActivate(
        void
    );

    HRESULT GetCapture(
        void
    );

    HRESULT SetCapture(
        [in] BOOL fCapture
    );

    HRESULT GetFocus(
        void
    );

    HRESULT SetFocus(
        [in] BOOL fFocus
    );

    HRESULT GetDC(
        [in] RECT* pRect,
        [in] DWORD grfFlags,
        [in, out] HDC* phDC
    );

    HRESULT ReleaseDC(
        [in] HDC hDC
    );

    HRESULT InvalidateRect(
        [in] RECT* pRect,
        [in] BOOL fErase
    );

    HRESULT InvalidateRgn(
        [in] HRGN hRGN,
        [in] BOOL fErase
    );

    HRESULT ScrollRect(
        [in] INT dx,
        [in] INT dy,
        [in] RECT* pRectScroll,
        [in] RECT* pRectClip
    );

    HRESULT AdjustRect(
        [in, out] RECT* prc
    );

    HRESULT OnDefWindowMessage(
            [in] UINT msg,
            [in] WPARAM wParam,
            [in] LPARAM lParam,
            [in, out] LRESULT* plResult
        );
}


    typedef enum VIEWSTATUS {
        VIEWSTATUS_OPAQUE = 1,
        VIEWSTATUS_SOLIDBKGND = 2,
        VIEWSTATUS_DVASPECTOPAQUE = 4,
        VIEWSTATUS_DVASPECTTRANSPARENT = 8,
        VIEWSTATUS_SURFACE = 16,
        VIEWSTATUS_3DSURFACE = 32
    } VIEWSTATUS;

    typedef enum HITRESULT {
        HITRESULT_OUTSIDE = 0,
        HITRESULT_TRANSPARENT = 1,
        HITRESULT_CLOSE = 2,
        HITRESULT_HIT = 3
    } HITRESULT;

    typedef enum DVASPECT2 {
        DVASPECT_OPAQUE = 16,
        DVASPECT_TRANSPARENT = 32,
    } DVASPECT2;

    typedef enum DVEXTENTMODE {
        DVEXTENT_CONTENT,
        DVEXTENT_INTEGRAL
    } DVEXTENTMODE;

    typedef struct DVEXTENTINFO {
        ULONG   cb;
        DVEXTENTMODE   dwExtentMode;
        SIZE   sizelProposed;
    } DVEXTENTINFO;


    //typedef enum DVASPECTINFOFLAG {
    //    DVASPECTINFOFLAG_CANOPTIMIZE = 1
    //} DVASPECTINFOFLAG;

    //typedef struct DVASPECTINFO {
    //    ULONG   cb;
    //    DWORD   dwFlags;
    //} DVASPECTINFO;
[
    odl,
    uuid(3AF24292-0C96-11CE-A0CF-00AA00600AB8)
]
interface IViewObjectEx : IViewObject2
{
    //typedef IViewObjectEx* LPVIEWOBJECTEX;


    HRESULT GetRect(
        [in] DWORD dwAspect,
        [out] RECT* pRect
    );

    HRESULT GetViewStatus(
        [out] DWORD* pdwStatus
    );

    HRESULT QueryHitPoint(
        [in] DWORD dwAspect,
        [in] RECT* pRectBounds,
        //[in] POINT ptlLoc,
        [in] int ptlLocX, [in] int ptlLocY,
        [in] LONG lCloseHint,
        [out] DWORD* pHitResult
    );

    HRESULT QueryHitRect(
        [in] DWORD dwAspect,
        [in] RECT* pRectBounds,
        [in] RECT* pRectLoc,
        [in] LONG lCloseHint,
        [out] DWORD* pHitResult
    );

    HRESULT GetNaturalExtent(
        [in] DWORD dwAspect,
        [in] LONG lindex,
        [in] DVTARGETDEVICE* ptd,
        [in] HDC hicTargetDev,
        [in] DVEXTENTINFO* pExtentInfo,
        [out] SIZE* pSizel
    );
}

typedef enum UASFLAGS {
    UAS_NORMAL = 0,
    UAS_BLOCKED = 0x1,
    UAS_NOPARENTENABLE = 0x2,
    UAS_MASK = 0x3
} UASFLAGS;

interface IOleUndoManager;
[
    odl,
    uuid(894AD3B0-EF97-11CE-9BC9-00AA00608E01)
]
interface IOleUndoUnit : stdole.IUnknown
{
    //typedef IOleUndoUnit* LPOLEUNDOUNIT;

    HRESULT Do(
        [in] IOleUndoManager* pUndoManager
    );

    HRESULT GetDescription(
        [out] BSTR* pBstr
    );

    HRESULT GetUnitType(
        [out] UUID* pClsid,
        [out] LONG* plID
    );

    HRESULT OnNextAdd(
        void
    );
}


[
    odl,
    uuid(A1FAF330-EF97-11CE-9BC9-00AA00608E01)
]
interface IOleParentUndoUnit : IOleUndoUnit
{
    //typedef IOleParentUndoUnit* LPOLEPARENTUNDOUNIT;

    HRESULT Open(
        [in] IOleParentUndoUnit* pPUU
    );

    HRESULT Close(
        [in] IOleParentUndoUnit* pPUU,
        [in] BOOL fCommit
    );

    HRESULT Add(
        [in] IOleUndoUnit* pUU
    );

    HRESULT FindUnit(
        [in] IOleUndoUnit* pUU
    );

    HRESULT GetParentState(
        [out] UASFLAGS* pdwState
    );
}


[
    odl,
    uuid(B3E7C340-EF97-11CE-9BC9-00AA00608E01)
]
interface IEnumOleUndoUnits : stdole.IUnknown
{
    //typedef IEnumOleUndoUnits* LPENUMOLEUNDOUNITS;

    //[local]
    HRESULT Next(
        [in] ULONG cElt,
        [in, out] IOleUndoUnit** rgElt,
        [in, out] ULONG* pcEltFetched
        );

    //[call_as(Next)]
    //HRESULT RemoteNext(
    //    [in] ULONG cElt,
    //    [out, size_is(cElt), length_is(*pcEltFetched)]
    //IOleUndoUnit** rgElt,
    //    [out] ULONG* pcEltFetched
    //    );

    HRESULT Skip(
        [in] ULONG cElt
    );

    HRESULT Reset(
        void
    );

    HRESULT Clone(
        [in, out] IEnumOleUndoUnits** ppEnum
    );
}


[
    odl,
    uuid(D001F200-EF97-11CE-9BC9-00AA00608E01)
]
interface IOleUndoManager : stdole.IUnknown
{
    //cpp_quote("#define SID_SOleUndoManager IID_IOleUndoManager")

        //typedef IOleUndoManager* LPOLEUNDOMANAGER;

    HRESULT Open(
        [in] IOleParentUndoUnit* pPUU
    );

    HRESULT Close(
        [in] IOleParentUndoUnit* pPUU,
        [in] BOOL fCommit
    );

    HRESULT Add(
        [in] IOleUndoUnit* pUU
    );

    HRESULT GetOpenParentState(
        [out] UASFLAGS* pdwState
    );

    HRESULT DiscardFrom(
        [in] IOleUndoUnit* pUU
    );

    HRESULT UndoTo(
        [in] IOleUndoUnit* pUU
    );

    HRESULT RedoTo(
        [in] IOleUndoUnit* pUU
    );

    HRESULT EnumUndoable(
        [out] IEnumOleUndoUnits** ppEnum
    );

    HRESULT EnumRedoable(
        [out] IEnumOleUndoUnits** ppEnum
    );

    HRESULT GetLastUndoDescription(
        [out] BSTR* pBstr
    );

    HRESULT GetLastRedoDescription(
        [out] BSTR* pBstr
    );

    HRESULT Enable(
        [in] BOOL fEnable
    );
}

    typedef  enum POINTERINACTIVE {
        POINTERINACTIVE_ACTIVATEONENTRY = 1,
        POINTERINACTIVE_DEACTIVATEONLEAVE = 2,
        POINTERINACTIVE_ACTIVATEONDRAG = 4
    } POINTERINACTIVE;

[
    odl,
    uuid(55980BA0-35AA-11CF-B671-00AA004CD6D8)
]
interface IPointerInactive : stdole.IUnknown
{
    //typedef IPointerInactive* LPPOINTERINACTIVE;



    HRESULT GetActivationPolicy(
        [out] DWORD* pdwPolicy
    );

    HRESULT OnInactiveMouseMove(
        [in] RECT* pRectBounds,
        [in] LONG x,
        [in] LONG y,
        [in] DWORD grfKeyState
    );

    HRESULT OnInactiveSetCursor(
        [in] RECT* pRectBounds,
        [in] LONG x,
        [in] LONG y,
        [in] DWORD dwMouseMsg,
        [in] BOOL fSetAlways
    );
}

[
    odl,
    uuid(3AF24290-0C96-11CE-A0CF-00AA00600AB8)
]
interface IAdviseSinkEx : IAdviseSink
{



    //typedef IAdviseSinkEx* LPADVISESINKEX;

    //[local]
    HRESULT OnViewStatusChange(
        [in] DWORD dwViewStatus
    );

    //[call_as(OnViewStatusChange)]
    //HRESULT RemoteOnViewStatusChange(
    //    [in] DWORD dwViewStatus
    //);
}


typedef enum QACONTAINERFLAGS {
    QACONTAINER_SHOWHATCHING = 0x0001,
    QACONTAINER_SHOWGRABHANDLES = 0x0002,
    QACONTAINER_USERMODE = 0x0004,
    QACONTAINER_DISPLAYASDEFAULT = 0x0008,
    QACONTAINER_UIDEAD = 0x0010,
    QACONTAINER_AUTOCLIP = 0x0020,
    QACONTAINER_MESSAGEREFLECT = 0x0040,
    QACONTAINER_SUPPORTSMNEMONICS = 0x0080
} QACONTAINERFLAGS;

typedef struct QACONTAINER {
    ULONG                   cbSize;
    IOleClientSite* pClientSite;
    IAdviseSinkEx* pAdviseSink;
    IPropertyNotifySink* pPropertyNotifySink;
    IUnknown* pUnkEventSink;
    DWORD                   dwAmbientFlags;
    OLE_COLOR               colorFore;
    OLE_COLOR               colorBack;
    IFont* pFont;
    IOleUndoManager* pUndoMgr;
    DWORD                   dwAppearance;
    LONG                    lcid;
    HPALETTE                hpal;
    IBindHost* pBindHost;
    IOleControlSite* pOleControlSite;
    IServiceProvider* pServiceProvider;
} QACONTAINER;

typedef struct QACONTROL {
    ULONG   cbSize;
    DWORD   dwMiscStatus;
    DWORD   dwViewStatus;
    DWORD   dwEventCookie;
    DWORD   dwPropNotifyCookie;
    DWORD   dwPointerActivationPolicy;
} QACONTROL;
[
    odl,
    uuid(CF51ED10-62FE-11CF-BF86-00A0C9034836)
]
interface IQuickActivate : stdole.IUnknown
{


    //[local]
    HRESULT QuickActivate(
        [in] QACONTAINER* pQaContainer,
        [in, out] QACONTROL* pQaControl
    );

    //[call_as(QuickActivate)]
    //HRESULT RemoteQuickActivate(
    //    [in] QACONTAINER* pQaContainer,
    //    [out] QACONTROL* pQaControl
    //);

    HRESULT SetContentExtent(
        [in] SIZE* pSizel
    );

    HRESULT GetContentExtent(
        [out] SIZE* pSizel
    );
}

[
    odl,
    uuid(00000110-0000-0000-C000-000000000046)
]
interface IDataAdviseHolder : stdole.IUnknown
{

    //typedef [unique] IDataAdviseHolder* LPDATAADVISEHOLDER;

    HRESULT Advise
    (
        [in] IDataObject* pDataObject,
        [in] FORMATETC* pFetc,
        [in] ADVF advf,
        [in] IAdviseSink* pAdvise,
        [in, out] DWORD* pdwConnection
    );

    HRESULT Unadvise
    (
        [in] DWORD dwConnection
    );

    HRESULT EnumAdvise
    (
        [in, out] IEnumSTATDATA** ppenumAdvise
    );

    HRESULT SendOnDataChange
    (
        [in] IDataObject* pDataObject,
        [in] DWORD dwReserved,
        [in] ADVF advf
    );

}

[
    odl,
    uuid(00000111-0000-0000-C000-000000000046)
]
interface IOleAdviseHolder : stdole.IUnknown
{

    //typedef [unique] IOleAdviseHolder* LPOLEADVISEHOLDER;

    HRESULT Advise
    (
        [in] IAdviseSink* pAdvise,
        [in, out] DWORD* pdwConnection
    );

    HRESULT Unadvise
    (
        [in] DWORD dwConnection
    );

    HRESULT EnumAdvise
    (
        [in, out] IEnumSTATDATA** ppenumAdvise
    );

    HRESULT SendOnRename
    (
        [in] IMoniker* pmk
    );

    HRESULT SendOnSave
    (
        void
    );

    HRESULT SendOnClose
    (
        void
    );

}


[
    odl,
    uuid(0000012B-0000-0000-C000-000000000046)
]
interface IDropSourceNotify : stdole.IUnknown
{
    HRESULT DragEnterTarget
    (
        [in] HWND hwndTarget
    );
    HRESULT DragLeaveTarget
    (
        void
    );
}

[
    odl,
    uuid(390E3878-FD55-4E18-819D-4682081C0CFD)
]
interface IEnterpriseDropTarget : stdole.IUnknown
{
    HRESULT SetDropSourceEnterpriseId([in] long identity);
    HRESULT IsEvaluatingEdpPolicy([out, retval] BOOL* value);
}

[
    odl,
    uuid(0000012a-0000-0000-C000-000000000046)
]
interface IContinue : stdole.IUnknown
{
    HRESULT FContinue();
}

typedef struct ComCallData {
    DWORD   dwDispid;
    DWORD   dwReserved;
    long    pUserDefined;
} ComCallData;


// IContextCallback interface
[
    odl,
    uuid(000001da-0000-0000-C000-000000000046)
]
interface IContextCallback : stdole.IUnknown
{
    //typedef [ref] HRESULT __stdcall (*PFNCONTEXTCALL)(ComCallData* pParam);

    HRESULT ContextCallback([in] long pfnCallback,
        [in] ComCallData* pParam,
        [in] REFIID riid,
        [in] int iMethod,
        [in] IUnknown* pUnk);
}

[
    odl,
    uuid(301DFBE5-524C-4B0F-8B2D-21C40B3A2988)
]
interface IStorageProviderPropertyHandler : stdole.IUnknown
{
    HRESULT RetrieveProperties([in] PROPERTYKEY* propertiesToRetrieve,
        [in] ULONG propertiesToRetrieveCount,
        [out] IPropertyStore** retrievedProperties);
    HRESULT SaveProperties([in] IPropertyStore* propertiesToSave);
}

[
    odl,
    uuid(162C6FB5-44D3-435B-903D-E613FA093FB5)
]
interface IStorageProviderHandler : stdole.IUnknown
{
    HRESULT GetPropertyHandlerFromPath([in] long path, [out] IStorageProviderPropertyHandler** propertyHandler);
    HRESULT GetPropertyHandlerFromUri([in] long uri, [out] IStorageProviderPropertyHandler** propertyHandler);
    HRESULT GetPropertyHandlerFromFileId([in] long fileId, [out] IStorageProviderPropertyHandler** propertyHandler);
}


typedef enum ThumbnailStreamCacheOptions
{
    TSC_ExtractIfNotCached = 0x00000000,
    TSC_ReturnOnlyIfCached = 0x00000001,
    TSC_ResizeThumbnail = 0x00000002,    // resize to match the requested size
    TSC_AllowSmallerSize = 0x00000004,    // can return a cached thumbnail that is smaller than the requested size.
} ThumbnailStreamCacheOptions;

[
    odl,
    uuid(90E11430-9569-41D8-AE75-6D4D2AE7CCA0),
]
interface IThumbnailStreamCache : stdole.IUnknown
{
    HRESULT GetThumbnailStream(
        [in] LPCWSTR path,
        [in] ULONGLONG cacheId,
        [in] ThumbnailStreamCacheOptions options,
        [in] UINT requestedThumbnailSize,
        [out] SIZE* thumbnailSize,
        [out] IStream** thumbnailStream);

    HRESULT SetThumbnailStream(
        [in] LPCWSTR path,
        [in] ULONGLONG cacheId,
        [in] int thumbnailSizeX, [in] int thumbnailSizeY,
        [in] IStream* thumbnailStream);
}

typedef enum VBGCWhich {
     GC_WCH_SIBLING        = 0x00000001,
     GC_WCH_CONTAINER = 0x00000002,   // no FONLYAFTER/BEFORE
     GC_WCH_CONTAINED = 0x00000003,   // no FONLYAFTER/BEFORE
     GC_WCH_ALL = 0x00000004,
     GC_WCH_FREVERSEDIR = 0x08000000,   // OR'd with others
     GC_WCH_FONLYAFTER = 0x10000000,   // OR'd with others
     GC_WCH_FONLYBEFORE = 0x20000000,   // OR'd with others
     GC_WCH_FSELECTED = 0x40000000   // OR'd with others
} VBGCWhich;

[
    odl,
        uuid(40A050A0-3C31-101B-A82E-08002B2B2337)
]
interface IVBGetControl : stdole.IUnknown
{
    // *** IVBGetControl methods ****
    HRESULT EnumControls([in] DWORD dwOleContF, [in] VBGCWhich dwWhich, [in, out] IEnumUnknown **ppenumUnk);
};

//---------------------------------------------------------------------------
// IGetOleObject
//---------------------------------------------------------------------------
// This interface lives on the Extender Object (X-Object / hctl)
//---------------------------------------------------------------------------
[
    odl,
        uuid(8A701DA0-4FEB-101B-A82E-08002B2B2337)
]
interface IGetOleObject : stdole.IUnknown
{
    HRESULT GetOleObject([in] REFIID riid, [in, out] LongPtr* ppvObj);
};

[
    odl,
        uuid(9849FD60-3768-101B-8D72-AE6164FFE3CF)
]
interface IVBFormat : stdole.IUnknown
{
    HRESULT Format([in] VARIANT* vData, [in] BSTR bstrFormat, [in] LongPtr lpBuffer,
        [in] USHORT cb, [in] LONG lcid ,[in] SHORT sFirstDayOfWeek,
        [in] USHORT sFirstWeekOfYear,[in, out] USHORT * rcb);
};

[
    odl,
    uuid(91733A60-3F4C-101B-A3F6-00AA0034E4E9)
]
interface IGetVBAObject : stdole.IUnknown
{
   HRESULT GetObject([in] REFIID riid, [in, out] LongPtr* ppvObj, [in] DWORD dwReserved);
};


[
    odl,
        uuid(ED2AA515-602F-469C-A130-CE69FD0FA878)
]
interface IObjectWithPackageFullName : stdole.IUnknown
{
 
      HRESULT   GetPackageFullName(
        [in, out] LongPtr * packageFullName);

};


    // Thumbnail Stream Cache
    [uuid(CBE0FED3-4B91-4E90-8354-8A8C84EC6872)] coclass ThumbnailStreamCache { interface IThumbnailStreamCache; }

//CLSID_ContextSwitcher
[uuid(0000034e-0000-0000-c000-000000000046)] coclass ContextSwitcher { interface IContextCallback; }


// CLSID_DesktopGadget
[uuid(924ccc1b-6562-4c85-8657-d177925222b6)] coclass DesktopGadget { interface IDesktopGadget; }

[
    uuid(C4EE31F3-4768-11D2-BE5C-00A0C9A83DA1),     // CLSID_FileSearchBand
    helpstring("FileSearchBand Class")
]
coclass FileSearchBand
{
    [default] interface IFileSearchBand;
};


// CLSID_TrayBandSiteService
[uuid(F60AD0A0-E5E1-45cb-B51A-E15B9F8B2934)] coclass TrayBandSiteService { interface IBandSite; }

// CLSID_TrayDeskBand
[uuid(E6442437-6C68-4f52-94DD-2CFED267EFB9)] coclass TrayDeskBand { interface ITrayDeskBand; }

// CLSID_HWEventSettings
[uuid(5560c070-114e-4e97-929a-7e39f40debc7)] coclass HWEventSettings { interface IAutoplayHandler; }

// CLSID_AutoplayHandlerProperties
[uuid(11F6B41F-3BE5-4ce3-AF60-398551797DF6)] coclass AutoplayHandlerProperties { interface IAutoplayHandlerProperties; }

// CLSID_HWDevice
[uuid(aac41048-53e3-4867-a0aa-5fbceae7e5f5)] coclass HWDevice { interface IHWDevice; }

// CLSID_HardwareDevices
[uuid(dd522acc-f821-461a-a407-50b198b896dc)] coclass HardwareDevices { interface IHardwareDevices; }

// CLSID_HWDeviceCustomProperties
[uuid(555F3418-D99E-4e51-800A-6E89CFD8B1D7)] coclass HWDeviceCustomProperties { interface IHWDeviceCustomProperties; }


[uuid(cefc65d8-66d8-11d1-8d8c-0000f804b057)] coclass ThumbnailFCNHandler { interface IThumbnailExtractor; }

// CLSID_DesktopWallpaper
[uuid(C2CF3110-460E-4fc1-B9D0-8A1C0C9CC4BD)] coclass DesktopWallpaper { interface IDesktopWallpaper; }

// CLSID_AppStartupLink
[uuid(273eb5e7-88b0-4843-bfef-e2c81d43aae5)] coclass AppStartupLink { interface IShellLinkW; }

// CLSID_PackageDebugSettings
[uuid(B1AEC16F-2383-4852-B0E9-8F0B1DC66B4D)] coclass PackageDebugSettings { interface IPackageDebugSettings2; }

// CLSID_SuspensionDependencyManager
[uuid(6B273FC5-61FD-4918-95A2-C3B5E9D7F581)] coclass SuspensionDependencyManager { interface ISuspensionDependencyManager; }

// CLSID_ApplicationActivationManager
[uuid(45BA127D-10A8-46EA-8AB7-56EA9078943C)] coclass ApplicationActivationManager { interface IApplicationActivationManager; }

// CLSID_ApplicationDesignModeSettings
[uuid(958a6fb5-dcb2-4faf-aafd-7fb054ad1a3b)] coclass ApplicationDesignModeSettings { interface IApplicationDesignModeSettings2; }

//CLSID_CFSIconOverlayManager
[uuid(63B51F81-C868-11D0-999C-00C04FD655E1)] coclass CFSIconOverlayManager { interface IShellIconOverlayManager; }


//CLSID_StdGlobalInterfaceTable
[uuid(00000323-0000-0000-C000-000000000046)] coclass StdGlobalInterfaceTable { interface IGlobalInterfaceTable; }

//CLSID_DefFolderMenu
[uuid(c63382be-7933-48d0-9ac8-85fb46be2fdd)] coclass DefFolderMenu { interface IDefaultFolderMenuInitialize; }

//CLSID_SharingConfigurationManager
[uuid(49F371E1-8C5C-4d9c-9A3B-54A6827F513C)] coclass SharingConfigurationManager { interface ISharingConfigurationManager; }

//CLSID_FrameworkInputPane
[ uuid(D5120AA3-46BA-44C5-822D-CA8092C1FC72) ] coclass FrameworkInputPane { interface IFrameworkInputPane; }

//CLSID_VirtualDesktopManager
[ uuid(aa509086-5ca9-4c25-8f95-589d3c07b48a) ] coclass VirtualDesktopManager { interface IVirtualDesktopManager;  } 

// CLSID_ExecuteFolder
[ uuid(11dbb47c-a525-400b-9e80-a54615a090c0) ] coclass ExecuteFolder { interface IExecuteCommand; }

// CLSID_AppShellVerbHandler
[ uuid(4ED3A719-CEA8-4BD9-910D-E252F997AFC2)] coclass AppShellVerbHandler { interface IExecuteCommand; }

// CLSID_ExecuteUnknown
[ uuid(e44e9428-bdbc-4987-a099-40dc8fd255e7) ] coclass ExecuteUnknown { interface IExecuteCommand; }


// CLSID_ApplicationDocumentLists
[ uuid(86bec222-30f2-47e0-9f25-60d11cd75c28) ]
coclass ApplicationDocumentLists {
	interface IApplicationDocumentLists;
}

// CLSID_HomeGroup
[ uuid(DE77BA04-3C92-4d11-A1A5-42352A53E0E3) ]
coclass HomeGroup {
	interface IHomeGroup;
}

//CLSID_OpenControlPanel
[ uuid(06622D85-6856-4460-8DE1-A81921B41C4B) ]
coclass OpenControlPanel {
	interface IOpenControlPanel;
}

//CLSID_TrackShellMenu
[ uuid(8278F931-2A3E-11d2-838F-00C04FD918D0) ]
coclass TrackShellMenu {
	interface ITrackShellMenu;
}

//CLSID_ApplicationAssociationRegistrationUI
[ uuid(1968106d-f3b5-44cf-890e-116fcb9ecef1) ]
coclass ApplicationAssociationRegistrationUI {
	interface IApplicationAssociationRegistrationUI;
}

//CLSID_ApplicationAssociationRegistration
[ uuid(591209c7-767b-42b2-9fba-44ee4615f2c7) ]
coclass ApplicationAssociationRegistration
{
 interface IApplicationAssociationRegistration;
}

//CLSID_StartMenuPin
[ uuid(a2a9545d-a0c2-42b4-9708-a0b2badd77c8) ]
coclass StartMenuPin {
	interface IStartMenuPinnedList;
}

//CLSID_SystemInformation
[ uuid(C01B9BA0-BEA7-41BA-B604-D0A36F469133) ]
coclass SystemInformation {
	interface ISystemInformation;
}

//CLSID_PersistentZoneIdentifier
[ uuid(0968E258-16C7-4DBA-AA86-462DD61E31A3) ]
coclass PersistentZoneIdentifier {
	interface IZoneIdentifier;
}

//CLSID_PreviousVersions
[ uuid(596AB062-B4D2-4215-9F74-E9109B0A8153) ]
coclass PreviousVersions {
	interface IPreviousVersionsInfo;
}

//CLSID_ImageRecompress
[ uuid(6e33091c-d2f8-4740-b55e-2e11d1477a2c) ]
coclass ImageRecompress {
	interface IImageRecompress;
}
//CLSID_ImageTranscode;
[ uuid(17B75166-928F-417d-9685-64AA135565C1) ]
coclass ImageTranscode {
	interface ITranscodeImage;
}



//CLSID_SearchFolderItemFactory
[ uuid(14010e02-bbbd-41f0-88e3-eda371216584) ]
coclass SearchFolderItemFactory {
	interface ISearchFolderItemFactory;
}


// CLSID_ImageList
[ uuid(7C476BA2-02B1-48f4-8048-B24619DDC058) ] 
coclass ImageList {
    //interface IImageList;
    interface IImageList2;
}

// CLSID_KnownFolderManager
[ uuid(4df0c730-df9d-4ae3-9153-aa6b82e9795a) ]
coclass KnownFolderManager {
	interface IKnownFolderManager;
}

//CLSID_DragDropHelper
[ uuid(4657278A-411B-11D2-839A-00C04FD918D0) ]
coclass DragDropHelper {
	interface IDragSourceHelper2;
	interface IDragSourceHelper;
	interface IDropTargetHelper;
}

// CLSID_UserNotification
[ uuid(0010890e-8789-413c-adbc-48f5b511b3af) ]
coclass UserNotification2 {
	interface IUserNotification2;
}
//CLSID_NamespaceWalker
[ uuid(72eb61e0-8672-4303-9175-f2e4c68b2e7c) ]
coclass NamespaceWalker {
	interface INamespaceWalk;
}

//CLSID_FileOpenDialog
[ uuid(DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7) ]
coclass FileOpenDialog {
	interface IFileOpenDialog;
}

//CLSID_FileSaveDialog
[ uuid(C0B4E2F3-BA21-4773-8DBA-335EC946EB8B) ]
coclass FileSaveDialog {
	interface IFileSaveDialog;
}

//CLSID_ShellLibrary
[ uuid(D9B3211D-E57F-4426-AAEF-30A806ADD397) ]
coclass ShellLibrary {
	interface IShellLibrary;
}

// CLSID_TaskbarList
[ uuid(56FDF344-FD6D-11d0-958A-006097C9A090) ]
coclass TaskbarList {
	interface ITaskbarList4;
}
[ uuid(00021401-0000-0000-C000-000000000046),
   helpstring("VB IShellLinkW Class")
]
coclass ShellLinkW {
   [default] interface IShellLinkW;
   interface IPersistFile;
};
 
[uuid(0afaced1-e828-11d1-9187-b532f1e9575d),
helpstring("VB IShellLinkW Class")
]
coclass FolderShortcut {
    [default] interface IShellLinkW;
    interface IPersistFile;
};
// CLSID_FileOperation
[ uuid(3ad05575-8857-4850-9277-11b85bdb8e09) ]
coclass FileOperation {
	interface IFileOperation;
}
//CLSID_EnumerableObjectCollection
[ uuid(2D3468C1-36A7-43B6-AC24-D3F02FD9607A) ]
coclass EnumerableObjectCollection {
	interface IObjectCollection;
};
//CLSID_DestinationList
[ uuid(77F10CF0-3DB5-4966-B520-B7C54FD35ED6) ]
coclass DestinationList {
	interface ICustomDestinationList;
};

//CLSID_MenuBand
[ uuid(71D88C20-41CF-4CDF-A81F-D8609836347D) ]
coclass MenuBand {
	interface IShellMenu;
};
// CLSID_ProgressDialog
[ uuid(F8383852-FCD3-11d1-A6B9-006097DF5BD4) ]
coclass ProgressDialog {
	[default] interface IProgressDialog;
	interface IOperationsProgressDialog;
}

//CLSID_InternetSecurityManager
[ uuid(7b8a2d94-0ac9-11d1-896c-00c04fb6bfc4) ]
coclass InternetSecurityManager {
	interface IInternetSecurityManager;
}

//CLSID_InternetZoneManager
[uuid(7b8a2d95-0ac9-11d1-896c-00c04Fb6bfc4)]
coclass InternetZoneManager {
	interface IInternetZoneManager;
}

[
	helpstring("My Network Places"),
	uuid(208d2c60-3aea-1069-a2d7-08002b30309d)
] coclass NetworkPlaces { [default] interface IInitializeNetworkFolder;
									interface IShellFolder2; }

[uuid(E88DCCE0-B7B3-11d1-A9F0-00AA0060FA31)]
coclass CompressedFolder {
    [default] interface IShellExtInit;
    interface IPersistFolder;
    interface IPersistFolder2;
    interface IStorage;
    interface IShellFolder;
};
