// Forward declare all types defined in this typelib
interface IDWriteFactory;
interface IDWriteFontCollection;
interface IDWriteFontFamily;
interface IDWriteFontList;
interface IDWriteFont;
interface IDWriteLocalizedStrings;
interface IDWriteFontFace;
interface IDWriteRenderingParams;
interface IDWriteFontCollectionLoader;
interface IDWriteFontFileEnumerator;
interface IDWriteFontFile;
interface IDWriteFontFileLoader;
interface IDWriteFontFileStream;
interface IDWriteTextFormat;
interface IDWriteInlineObject;
interface IDWriteTextRenderer;
interface IDWritePixelSnapping;
interface IDWriteTypography;
interface IDWriteGdiInterop;
interface IDWriteBitmapRenderTarget;
interface IDWriteTextLayout;
interface IDWriteTextAnalyzer;
interface IDWriteTextAnalysisSource;
interface IDWriteNumberSubstitution;
interface IDWriteTextAnalysisSink;
interface IDWriteGlyphRunAnalysis;
interface IDWriteLocalFontFileLoader;
interface ID2D1SimplifiedGeometrySink;
interface ID2D1Factory;
interface ID2D1RenderTarget;
interface ID2D1BitmapRenderTarget;
interface ID2D1SimplifiedGeometrySink;
interface ID2D1TessellationSink;
interface ID2D1Geometry;
interface ID2D1Brush;
typedef float single;

typedef enum {
    DWRITE_FONT_FACE_TYPE_CFF = 0,
    DWRITE_FONT_FACE_TYPE_TRUETYPE = 1,
    DWRITE_FONT_FACE_TYPE_TRUETYPE_COLLECTION = 2,
    DWRITE_FONT_FACE_TYPE_TYPE1 = 3,
    DWRITE_FONT_FACE_TYPE_VECTOR = 4,
    DWRITE_FONT_FACE_TYPE_BITMAP = 5,
    DWRITE_FONT_FACE_TYPE_UNKNOWN = 6
} DWRITE_FONT_FACE_TYPE;

typedef enum {
    DWRITE_FONT_WEIGHT_THIN = 100,
    DWRITE_FONT_WEIGHT_EXTRA_LIGHT = 200,
    DWRITE_FONT_WEIGHT_ULTRA_LIGHT = 200,
    DWRITE_FONT_WEIGHT_LIGHT = 300,
    DWRITE_FONT_WEIGHT_NORMAL = 400,
    DWRITE_FONT_WEIGHT_REGULAR = 400,
    DWRITE_FONT_WEIGHT_MEDIUM = 500,
    DWRITE_FONT_WEIGHT_DEMI_BOLD = 600,
    DWRITE_FONT_WEIGHT_SEMI_BOLD = 600,
    DWRITE_FONT_WEIGHT_BOLD = 700,
    DWRITE_FONT_WEIGHT_EXTRA_BOLD = 800,
    DWRITE_FONT_WEIGHT_ULTRA_BOLD = 800,
    DWRITE_FONT_WEIGHT_BLACK = 900,
    DWRITE_FONT_WEIGHT_HEAVY = 900,
    DWRITE_FONT_WEIGHT_EXTRA_BLACK = 950,
    DWRITE_FONT_WEIGHT_ULTRA_BLACK = 950
} DWRITE_FONT_WEIGHT;

typedef enum {
    DWRITE_FONT_STRETCH_UNDEFINED = 0,
    DWRITE_FONT_STRETCH_ULTRA_CONDENSED = 1,
    DWRITE_FONT_STRETCH_EXTRA_CONDENSED = 2,
    DWRITE_FONT_STRETCH_CONDENSED = 3,
    DWRITE_FONT_STRETCH_SEMI_CONDENSED = 4,
    DWRITE_FONT_STRETCH_NORMAL = 5,
    DWRITE_FONT_STRETCH_MEDIUM = 5,
    DWRITE_FONT_STRETCH_SEMI_EXPANDED = 6,
    DWRITE_FONT_STRETCH_EXPANDED = 7,
    DWRITE_FONT_STRETCH_EXTRA_EXPANDED = 8,
    DWRITE_FONT_STRETCH_ULTRA_EXPANDED = 9
} DWRITE_FONT_STRETCH;

typedef enum {
    DWRITE_FONT_STYLE_NORMAL = 0,
    DWRITE_FONT_STYLE_OBLIQUE = 1,
    DWRITE_FONT_STYLE_ITALIC = 2
} DWRITE_FONT_STYLE;

typedef enum {
    DWRITE_MEASURING_MODE_NATURAL = 0,
    DWRITE_MEASURING_MODE_GDI_CLASSIC = 1,
    DWRITE_MEASURING_MODE_GDI_NATURAL = 2
} DWRITE_MEASURING_MODE;

typedef enum {
    DWRITE_INFORMATIONAL_STRING_NONE = 0,
    DWRITE_INFORMATIONAL_STRING_COPYRIGHT_NOTICE = 1,
    DWRITE_INFORMATIONAL_STRING_VERSION_STRINGS = 2,
    DWRITE_INFORMATIONAL_STRING_TRADEMARK = 3,
    DWRITE_INFORMATIONAL_STRING_MANUFACTURER = 4,
    DWRITE_INFORMATIONAL_STRING_DESIGNER = 5,
    DWRITE_INFORMATIONAL_STRING_DESIGNER_URL = 6,
    DWRITE_INFORMATIONAL_STRING_DESCRIPTION = 7,
    DWRITE_INFORMATIONAL_STRING_FONT_VENDOR_URL = 8,
    DWRITE_INFORMATIONAL_STRING_LICENSE_DESCRIPTION = 9,
    DWRITE_INFORMATIONAL_STRING_LICENSE_INFO_URL = 10,
    DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES = 11,
    DWRITE_INFORMATIONAL_STRING_WIN32_SUBFAMILY_NAMES = 12,
    DWRITE_INFORMATIONAL_STRING_PREFERRED_FAMILY_NAMES = 13,
    DWRITE_INFORMATIONAL_STRING_PREFERRED_SUBFAMILY_NAMES = 14,
    DWRITE_INFORMATIONAL_STRING_SAMPLE_TEXT = 15
} DWRITE_INFORMATIONAL_STRING_ID;

typedef enum {
    DWRITE_FONT_SIMULATIONS_NONE = 0,
    DWRITE_FONT_SIMULATIONS_BOLD = 1,
    DWRITE_FONT_SIMULATIONS_OBLIQUE = 2
} DWRITE_FONT_SIMULATIONS;

typedef struct DWRITE_FONT_METRICS {

    short designUnitsPerEm;

    short ascent;

    short descent;

    short lineGap;

    short capHeight;

    short xHeight;

    short underlinePosition;

    short underlineThickness;

    short strikethroughPosition;

    short strikethroughThickness;
} DWRITE_FONT_METRICS;

typedef enum {
    DWRITE_PIXEL_GEOMETRY_FLAT = 0,
    DWRITE_PIXEL_GEOMETRY_RGB = 1,
    DWRITE_PIXEL_GEOMETRY_BGR = 2
} DWRITE_PIXEL_GEOMETRY;

typedef enum DWRITE_RENDERING_MODE
{
    /// <summary>
    /// Specifies that the rendering mode is determined automatically based on the font and size.
    /// </summary>
    DWRITE_RENDERING_MODE_DEFAULT,

    /// <summary>
    /// Specifies that no antialiasing is performed. Each pixel is either set to the foreground 
    /// color of the text or retains the color of the background.
    /// </summary>
    DWRITE_RENDERING_MODE_ALIASED,

    /// <summary>
    /// Specifies that antialiasing is performed in the horizontal direction and the appearance
    /// of glyphs is layout-compatible with GDI using CLEARTYPE_QUALITY. Use DWRITE_MEASURING_MODE_GDI_CLASSIC 
    /// to get glyph advances. The antialiasing may be either ClearType or grayscale depending on
    /// the text antialiasing mode.
    /// </summary>
    DWRITE_RENDERING_MODE_GDI_CLASSIC,

    /// <summary>
    /// Specifies that antialiasing is performed in the horizontal direction and the appearance
    /// of glyphs is layout-compatible with GDI using CLEARTYPE_NATURAL_QUALITY. Glyph advances
    /// are close to the font design advances, but are still rounded to whole pixels. Use
    /// DWRITE_MEASURING_MODE_GDI_NATURAL to get glyph advances. The antialiasing may be either
    /// ClearType or grayscale depending on the text antialiasing mode.
    /// </summary>
    DWRITE_RENDERING_MODE_GDI_NATURAL,

    /// <summary>
    /// Specifies that antialiasing is performed in the horizontal direction. This rendering
    /// mode allows glyphs to be positioned with subpixel precision and is therefore suitable
    /// for natural (i.e., resolution-independent) layout. The antialiasing may be either
    /// ClearType or grayscale depending on the text antialiasing mode.
    /// </summary>
    DWRITE_RENDERING_MODE_NATURAL,

    /// <summary>
    /// Similar to natural mode except that antialiasing is performed in both the horizontal
    /// and vertical directions. This is typically used at larger sizes to make curves and
    /// diagonal lines look smoother. The antialiasing may be either ClearType or grayscale
    /// depending on the text antialiasing mode.
    /// </summary>
    DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC,

    /// <summary>
    /// Specifies that rendering should bypass the rasterizer and use the outlines directly. 
    /// This is typically used at very large sizes.
    /// </summary>
    DWRITE_RENDERING_MODE_OUTLINE,

    // The following names are obsolete, but are kept as aliases to avoid breaking existing code.
    // Each of these rendering modes may result in either ClearType or grayscale antialiasing 
    // depending on the DWRITE_TEXT_ANTIALIASING_MODE.
    DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC = 2, //DWRITE_RENDERING_MODE_GDI_CLASSIC,
    DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL = 3, //DWRITE_RENDERING_MODE_GDI_NATURAL,
    DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL = 4, //DWRITE_RENDERING_MODE_NATURAL,
    DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC = 5 //DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
} DWRITE_RENDERING_MODE;

typedef enum {
    DWRITE_SCRIPT_SHAPES_DEFAULT = 0,
    DWRITE_SCRIPT_SHAPES_NO_VISUAL = 1
} DWRITE_SCRIPT_SHAPES;

typedef struct DWRITE_SCRIPT_ANALYSIS {

    short script;

    DWRITE_SCRIPT_SHAPES shapes;
} DWRITE_SCRIPT_ANALYSIS;



typedef struct DWRITE_SHAPING_TEXT_PROPERTIES {
    short bitfield;
} DWRITE_SHAPING_TEXT_PROPERTIES;

typedef struct DWRITE_SHAPING_GLYPH_PROPERTIES {

    short flags;
} DWRITE_SHAPING_GLYPH_PROPERTIES;

typedef struct DWRITE_GLYPH_OFFSET {

    single advanceOffset;

    single ascenderOffset;
} DWRITE_GLYPH_OFFSET;

typedef enum {
    DWRITE_NUMBER_SUBSTITUTION_METHOD_FROM_CULTURE = 0,
    DWRITE_NUMBER_SUBSTITUTION_METHOD_CONTEXTUAL = 1,
    DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE = 2,
    DWRITE_NUMBER_SUBSTITUTION_METHOD_NATIONAL = 3,
    DWRITE_NUMBER_SUBSTITUTION_METHOD_TRADITIONAL = 4
} DWRITE_NUMBER_SUBSTITUTION_METHOD;



typedef struct DWRITE_MATRIX {

    single m11;

    single m12;

    single m21;

    single m22;

    single dx;

    single dy;
} DWRITE_MATRIX;

typedef struct DWRITE_GLYPH_RUN {

    IDWriteFontFace* fontFace;

    single fontEmSize;

    long glyphCount;

    int pglyphIndices;

    int pglyphAdvances;

    int pglyphOffsets;

    long isSideways;

    long bidiLevel;
} DWRITE_GLYPH_RUN;

typedef struct DWRITE_GLYPH_RUN_DESCRIPTION {

    int plocaleName;

    int pstring;

    long stringLength;

    int pclusterMap;

    long textPosition;
} DWRITE_GLYPH_RUN_DESCRIPTION;


typedef enum {
    DWRITE_TEXT_ALIGNMENT_LEADING = 0,
    DWRITE_TEXT_ALIGNMENT_TRAILING = 1,
    DWRITE_TEXT_ALIGNMENT_CENTER = 2
} DWRITE_TEXT_ALIGNMENT;

typedef enum {
    DWRITE_PARAGRAPH_ALIGNMENT_NEAR = 0,
    DWRITE_PARAGRAPH_ALIGNMENT_FAR = 1,
    DWRITE_PARAGRAPH_ALIGNMENT_CENTER = 2
} DWRITE_PARAGRAPH_ALIGNMENT;

typedef enum {
    DWRITE_WORD_WRAPPING_WRAP = 0,
    DWRITE_WORD_WRAPPING_NO_WRAP = 1
} DWRITE_WORD_WRAPPING;

typedef enum {
    DWRITE_READING_DIRECTION_LEFT_TO_RIGHT = 0,
    DWRITE_READING_DIRECTION_RIGHT_TO_LEFT = 1
} DWRITE_READING_DIRECTION;

typedef enum {
    DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM = 0
} DWRITE_FLOW_DIRECTION;

typedef enum {
    DWRITE_TRIMMING_GRANULARITY_NONE = 0,
    DWRITE_TRIMMING_GRANULARITY_CHARACTER = 1,
    DWRITE_TRIMMING_GRANULARITY_WORD = 2
} DWRITE_TRIMMING_GRANULARITY;

typedef struct DWRITE_TRIMMING {

    DWRITE_TRIMMING_GRANULARITY granularity;

    long delimiter;

    long delimiterCount;
} DWRITE_TRIMMING;



typedef struct DWRITE_UNDERLINE {

    single width;

    single thickness;

    single offset;

    single runHeight;

    DWRITE_READING_DIRECTION readingDirection;

    DWRITE_FLOW_DIRECTION flowDirection;

    int plocaleName;

    DWRITE_MEASURING_MODE measuringMode;
} DWRITE_UNDERLINE;

typedef struct DWRITE_STRIKETHROUGH {

    single width;

    single thickness;

    single offset;

    DWRITE_READING_DIRECTION readingDirection;

    DWRITE_FLOW_DIRECTION flowDirection;

    int plocaleName;

    DWRITE_MEASURING_MODE measuringMode;
} DWRITE_STRIKETHROUGH;

typedef struct DWRITE_INLINE_OBJECT_METRICS {

    single width;

    single height;

    single baseline;

    long supportsSideways;
} DWRITE_INLINE_OBJECT_METRICS;

typedef struct DWRITE_OVERHANG_METRICS {

    single left;

    single top;

    single right;

    single bottom;
} DWRITE_OVERHANG_METRICS;

typedef enum {
    DWRITE_BREAK_CONDITION_NEUTRAL = 0,
    DWRITE_BREAK_CONDITION_CAN_BREAK = 1,
    DWRITE_BREAK_CONDITION_MAY_NOT_BREAK = 2,
    DWRITE_BREAK_CONDITION_MUST_BREAK = 3
} DWRITE_BREAK_CONDITION;

typedef enum {
    DWRITE_LINE_SPACING_METHOD_DEFAULT = 0,
    DWRITE_LINE_SPACING_METHOD_UNIFORM = 1
} DWRITE_LINE_SPACING_METHOD;



typedef enum {
    DWRITE_FONT_FEATURE_TAG_ALTERNATIVE_FRACTIONS = 0x63726661,
    DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS_FROM_CAPITALS = 0x63703263,
    DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS_FROM_CAPITALS = 0x63733263,
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_ALTERNATES = 0x746c6163,
    DWRITE_FONT_FEATURE_TAG_CASE_SENSITIVE_FORMS = 0x65736163,
    DWRITE_FONT_FEATURE_TAG_GLYPH_COMPOSITION_DECOMPOSITION = 0x706d6363,
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_LIGATURES = 0x67696c63,
    DWRITE_FONT_FEATURE_TAG_CAPITAL_SPACING = 0x70737063,
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_SWASH = 0x68777363,
    DWRITE_FONT_FEATURE_TAG_CURSIVE_POSITIONING = 0x73727563,
    DWRITE_FONT_FEATURE_TAG_DEFAULT = 0x746c6664,
    DWRITE_FONT_FEATURE_TAG_DISCRETIONARY_LIGATURES = 0x67696c64,
    DWRITE_FONT_FEATURE_TAG_EXPERT_FORMS = 0x74707865,
    DWRITE_FONT_FEATURE_TAG_FRACTIONS = 0x63617266,
    DWRITE_FONT_FEATURE_TAG_FULL_WIDTH = 0x64697766,
    DWRITE_FONT_FEATURE_TAG_HALF_FORMS = 0x666c6168,
    DWRITE_FONT_FEATURE_TAG_HALANT_FORMS = 0x6e6c6168,
    DWRITE_FONT_FEATURE_TAG_ALTERNATE_HALF_WIDTH = 0x746c6168,
    DWRITE_FONT_FEATURE_TAG_HISTORICAL_FORMS = 0x74736968,
    DWRITE_FONT_FEATURE_TAG_HORIZONTAL_KANA_ALTERNATES = 0x616e6b68,
    DWRITE_FONT_FEATURE_TAG_HISTORICAL_LIGATURES = 0x67696c68,
    DWRITE_FONT_FEATURE_TAG_HALF_WIDTH = 0x64697768,
    DWRITE_FONT_FEATURE_TAG_HOJO_KANJI_FORMS = 0x6f6a6f68,
    DWRITE_FONT_FEATURE_TAG_JIS04_FORMS = 0x3430706a,
    DWRITE_FONT_FEATURE_TAG_JIS78_FORMS = 0x3837706a,
    DWRITE_FONT_FEATURE_TAG_JIS83_FORMS = 0x3338706a,
    DWRITE_FONT_FEATURE_TAG_JIS90_FORMS = 0x3039706a,
    DWRITE_FONT_FEATURE_TAG_KERNING = 0x6e72656b,
    DWRITE_FONT_FEATURE_TAG_STANDARD_LIGATURES = 0x6167696c,
    DWRITE_FONT_FEATURE_TAG_LINING_FIGURES = 0x6d756e6c,
    DWRITE_FONT_FEATURE_TAG_LOCALIZED_FORMS = 0x6c636f6c,
    DWRITE_FONT_FEATURE_TAG_MARK_POSITIONING = 0x6b72616d,
    DWRITE_FONT_FEATURE_TAG_MATHEMATICAL_GREEK = 0x6b72676d,
    DWRITE_FONT_FEATURE_TAG_MARK_TO_MARK_POSITIONING = 0x6b6d6b6d,
    DWRITE_FONT_FEATURE_TAG_ALTERNATE_ANNOTATION_FORMS = 0x746c616e,
    DWRITE_FONT_FEATURE_TAG_NLC_KANJI_FORMS = 0x6b636c6e,
    DWRITE_FONT_FEATURE_TAG_OLD_STYLE_FIGURES = 0x6d756e6f,
    DWRITE_FONT_FEATURE_TAG_ORDINALS = 0x6e64726f,
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_ALTERNATE_WIDTH = 0x746c6170,
    DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS = 0x70616370,
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_FIGURES = 0x6d756e70,
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_WIDTHS = 0x64697770,
    DWRITE_FONT_FEATURE_TAG_QUARTER_WIDTHS = 0x64697771,
    DWRITE_FONT_FEATURE_TAG_REQUIRED_LIGATURES = 0x67696c72,
    DWRITE_FONT_FEATURE_TAG_RUBY_NOTATION_FORMS = 0x79627572,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_ALTERNATES = 0x746c6173,
    DWRITE_FONT_FEATURE_TAG_SCIENTIFIC_INFERIORS = 0x666e6973,
    DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS = 0x70636d73,
    DWRITE_FONT_FEATURE_TAG_SIMPLIFIED_FORMS = 0x6c706d73,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1 = 0x31307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_2 = 0x32307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_3 = 0x33307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_4 = 0x34307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_5 = 0x35307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_6 = 0x36307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_7 = 0x37307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_8 = 0x38307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_9 = 0x39307373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_10 = 0x30317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_11 = 0x31317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_12 = 0x32317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_13 = 0x33317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_14 = 0x34317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_15 = 0x35317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_16 = 0x36317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_17 = 0x37317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_18 = 0x38317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_19 = 0x39317373,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_20 = 0x30327373,
    DWRITE_FONT_FEATURE_TAG_SUBSCRIPT = 0x73627573,
    DWRITE_FONT_FEATURE_TAG_SUPERSCRIPT = 0x73707573,
    DWRITE_FONT_FEATURE_TAG_SWASH = 0x68737773,
    DWRITE_FONT_FEATURE_TAG_TITLING = 0x6c746974,
    DWRITE_FONT_FEATURE_TAG_TRADITIONAL_NAME_FORMS = 0x6d616e74,
    DWRITE_FONT_FEATURE_TAG_TABULAR_FIGURES = 0x6d756e74,
    DWRITE_FONT_FEATURE_TAG_TRADITIONAL_FORMS = 0x64617274,
    DWRITE_FONT_FEATURE_TAG_THIRD_WIDTHS = 0x64697774,
    DWRITE_FONT_FEATURE_TAG_UNICASE = 0x63696e75,
    DWRITE_FONT_FEATURE_TAG_SLASHED_ZERO = 0x6f72657a
} DWRITE_FONT_FEATURE_TAG;

typedef struct DWRITE_FONT_FEATURE {

    DWRITE_FONT_FEATURE_TAG nameTag;

    long parameter;
} DWRITE_FONT_FEATURE;

typedef enum {
    DWRITE_FONT_FILE_TYPE_UNKNOWN = 0,
    DWRITE_FONT_FILE_TYPE_CFF = 1,
    DWRITE_FONT_FILE_TYPE_TRUETYPE = 2,
    DWRITE_FONT_FILE_TYPE_TRUETYPE_COLLECTION = 3,
    DWRITE_FONT_FILE_TYPE_TYPE1_PFM = 4,
    DWRITE_FONT_FILE_TYPE_TYPE1_PFB = 5,
    DWRITE_FONT_FILE_TYPE_VECTOR = 6,
    DWRITE_FONT_FILE_TYPE_BITMAP = 7
} DWRITE_FONT_FILE_TYPE;


typedef struct DWRITE_LINE_METRICS {

    long length;

    long trailingWhitespaceLength;

    long newlineLength;

    single height;

    single baseline;

    long isTrimmed;
} DWRITE_LINE_METRICS;

typedef struct DWRITE_TEXT_METRICS {

    single left;

    single top;

    single width;

    single widthIncludingTrailingWhitespace;

    single height;

    single layoutWidth;

    single layoutHeight;

    long maxBidiReorderingDepth;

    long lineCount;
} DWRITE_TEXT_METRICS;

typedef struct DWRITE_CLUSTER_METRICS {

    single width;

    short length;

    short flags;
} DWRITE_CLUSTER_METRICS;

typedef struct DWRITE_HIT_TEST_METRICS {

    long textPosition;

    long length;

    single left;

    single top;

    single width;

    single height;

    long bidiLevel;

    long isText;

    long isTrimmed;
} DWRITE_HIT_TEST_METRICS;

typedef enum {
    DWRITE_FACTORY_TYPE_SHARED = 0,
    DWRITE_FACTORY_TYPE_ISOLATED = 1
} DWRITE_FACTORY_TYPE;

typedef enum {
    canWrapLineAfter = 1,
    isWhitespace = 2,
    isNewline = 4,
    isSoftHyphen = 8,
    isRightToLeft = 16
} DWRITE_CLUSTER_METRICS_FLAGS;

typedef enum {
    isClusterStart = 16,
    isDiacritic = 32,
    isZeroWidthSpace = 64,
    justification_mask = 15
} DWRITE_SHAPING_GLYPH_PROPERTIES_FLAGS;

typedef enum {
    isShapedAlone = 1
} DWRITE_SHAPING_TEXT_PROPERTIES_FLAGS;

typedef enum {
    breakConditionBefore_mask = 3,
    breakConditionBefore_shift = 1,
    breakConditionAfter_mask = 12,
    breakConditionAfter_shift = 4,
    lbisWhitespace = 16,
    lbisSoftHyphen = 32
} DWRITE_LINE_BREAKPOINT_FLAGS;

typedef struct DWRITE_GLYPH_METRICS {

    long leftSideBearing;

    long advanceWidth;

    long rightSideBearing;

    long topSideBearing;

    long advanceHeight;

    long bottomSideBearing;

    long verticalOriginY;
} DWRITE_GLYPH_METRICS;

typedef struct DWRITE_TEXT_RANGE {

    long startPosition;

    long length;
} DWRITE_TEXT_RANGE;

typedef struct DWRITE_TYPOGRAPHIC_FEATURES {

    long features;

    long featureCount;
} DWRITE_TYPOGRAPHIC_FEATURES;

typedef struct DWRITE_LINE_BREAKPOINT {

    unsigned char flags;
} DWRITE_LINE_BREAKPOINT;

typedef enum {
    DWRITE_TEXTURE_ALIASED_1x1 = 0,
    DWRITE_TEXTURE_CLEARTYPE_3x1 = 1
} DWRITE_TEXTURE_TYPE;

[
    odl,
    uuid(B859EE5A-D838-4B5B-A2E8-1ADC7D93DB48),
    helpstring("The root factory interface for all DWrite objects.")
]
interface IDWriteFactory : stdole.IUnknown {
    [helpstring("Gets a font collection representing the set of installed fonts.")]
    HRESULT _stdcall GetSystemFontCollection(
        [out] IDWriteFontCollection** fontCollection,
        [in] long checkForUpdates);
    [helpstring("Creates a font collection using a custom font collection loader.")]
    HRESULT _stdcall CreateCustomFontCollection(
        [in] IDWriteFontCollectionLoader* collectionLoader,
        [in] void* collectionKey,
        [in] long collectionKeySize,
        [out, retval] IDWriteFontCollection** fontCollection);
    [helpstring("Registers a custom font collection loader with the factory object.")]
    HRESULT _stdcall RegisterFontCollectionLoader([in] IDWriteFontCollectionLoader* fontCollectionLoader);
    [helpstring("Unregisters a custom font collection loader that was previously registered using RegisterFontCollectionLoader.")]
    HRESULT _stdcall UnregisterFontCollectionLoader([in] IDWriteFontCollectionLoader* fontCollectionLoader);
    [helpstring("CreateFontFileReference creates a font file reference object from a local font file.")]
    HRESULT _stdcall CreateFontFileReference(
        [in] long filePath,
        [in] FILETIME* lastWriteTime,
        [out, retval] IDWriteFontFile** fontFile);
    [helpstring("CreateCustomFontFileReference creates a reference to an application specific font file resource.")]
    HRESULT _stdcall CreateCustomFontFileReference(
        [in] void* fontFileReferenceKey,
        [in] long fontFileReferenceKeySize,
        [in] IDWriteFontFileLoader* fontFileLoader,
        [out, retval] IDWriteFontFile** fontFile);
    [helpstring("Creates a font face object.")]
    HRESULT _stdcall CreateFontFace(
        [in] DWRITE_FONT_FACE_TYPE fontFaceType,
        [in] long numberOfFiles,
        [in] IDWriteFontFile* fontFiles,
        [in] long faceIndex,
        [in] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,
        [out, retval] IDWriteFontFace** fontFace);
    [helpstring("Creates a rendering parameters object with default settings for the primary monitor.")]
    HRESULT _stdcall CreateRenderingParams([out, retval] IDWriteRenderingParams** renderingParams);
    [helpstring("Creates a rendering parameters object with default settings for the specified monitor.")]
    HRESULT _stdcall CreateMonitorRenderingParams(
        [in] long monitor,
        [out, retval] IDWriteRenderingParams** renderingParams);
    [helpstring("Creates a rendering parameters object with the specified properties.")]
    HRESULT _stdcall CreateCustomRenderingParams(
        [in] single gamma,
        [in] single enhancedContrast,
        [in] single clearTypeLevel,
        [in] DWRITE_PIXEL_GEOMETRY pixelGeometry,
        [in] DWRITE_RENDERING_MODE renderingMode,
        [out, retval] IDWriteRenderingParams** renderingParams);
    [helpstring("Registers a font file loader with DirectWrite.")]
    HRESULT _stdcall RegisterFontFileLoader([in] IDWriteFontFileLoader* fontFileLoader);
    [helpstring("Unregisters a font file loader that was previously registered with the DirectWrite font system using RegisterFontFileLoader.")]
    HRESULT _stdcall UnregisterFontFileLoader([in] IDWriteFontFileLoader* fontFileLoader);
    [helpstring("Create a text format object used for text layout.")]
    HRESULT _stdcall CreateTextFormat(
        [in] long fontFamilyName,
        [in] IDWriteFontCollection* fontCollection,
        [in] DWRITE_FONT_WEIGHT fontWeight,
        [in] DWRITE_FONT_STYLE fontStyle,
        [in] DWRITE_FONT_STRETCH fontStretch,
        [in] single fontSize,
        [in] long localeName,
        [out, retval] IDWriteTextFormat** textFormat);
    [helpstring("Create a typography object used in conjunction with text format for text layout.")]
    HRESULT _stdcall CreateTypography([out, retval] IDWriteTypography** typography);
    [helpstring("Create an object used for interoperability with GDI.")]
    HRESULT _stdcall GetGdiInterop([out, retval] IDWriteGdiInterop** gdiInterop);
    [helpstring("CreateTextLayout takes a string, format, and associated constraints and produces and object representing the fully analyzed and formatted result.")]
    HRESULT _stdcall CreateTextLayout(
        [in] long string,
        [in] long stringLength,
        [in] IDWriteTextFormat* textFormat,
        [in] single maxWidth,
        [in] single maxHeight,
        [out, retval] IDWriteTextLayout** textLayout);
    [helpstring("CreateGdiCompatibleTextLayout takes a string, format, and associated constraints and produces and object representing the result formatted for a particular display resolution and measuring method.")]
    HRESULT _stdcall CreateGdiCompatibleTextLayout(
        [in] long string,
        [in] long stringLength,
        [in] IDWriteTextFormat* textFormat,
        [in] single layoutWidth,
        [in] single layoutHeight,
        [in] single pixelsPerDip,
        [in] void* transform,
        [in] long useGdiNatural,
        [out, retval] IDWriteTextLayout** textLayout);
    [helpstring("The application may call this function to create an inline object for trimming, using an ellipsis as the omission sign.")]
    HRESULT _stdcall CreateEllipsisTrimmingSign(
        [in] IDWriteTextFormat* textFormat,
        [out, retval] IDWriteInlineObject** trimmingSign);
    [helpstring("Return an interface to perform text analysis with.")]
    HRESULT _stdcall CreateTextAnalyzer([out, retval] IDWriteTextAnalyzer** textAnalyzer);
    [helpstring("Creates a number substitution object using a locale name, substitution method, and whether to ignore user overrides (uses NLS defaults for the given culture instead).")]
    HRESULT _stdcall CreateNumberSubstitution(
        [in] DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod,
        [in] long localeName,
        [in] long ignoreUserOverride,
        [out, retval] IDWriteNumberSubstitution** numberSubstitution);
    [helpstring("Creates a glyph run analysis object, which encapsulates information used to render a glyph run.")]
    HRESULT _stdcall CreateGlyphRunAnalysis(
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] single pixelsPerDip,
        [in] void* transform,
        [in] DWRITE_RENDERING_MODE renderingMode,
        [in] DWRITE_MEASURING_MODE measuringMode,
        [in] single baselineOriginX,
        [in] single baselineOriginY,
        [out, retval] IDWriteGlyphRunAnalysis** glyphRunAnalysis);
};

[
    odl,
    uuid(A84CEE02-3EEA-4EEE-A827-87C1A02A0FCC),
    helpstring("The IDWriteFontCollection encapsulates a collection of fonts.")
]
interface IDWriteFontCollection : stdole.IUnknown {
    [helpstring("Gets the number of font families in the collection.")]
    long _stdcall GetFontFamilyCount();
    [helpstring("Creates a font family object given a zero-based font family index.")]
    HRESULT _stdcall GetFontFamily(
        [in] long index,
        [out, retval] IDWriteFontFamily** fontFamily);
    [helpstring("Finds the font family with the specified family name.")]
    HRESULT _stdcall FindFamilyName(
        [in] long familyName,
        [out] long* index,
        [out, retval] long* exists);
    [helpstring("Gets the font object that corresponds to the same physical font as the specified font face object. The specified physical font must belong to the font collection.")]
    HRESULT _stdcall GetFontFromFontFace(
        [in] IDWriteFontFace* fontFace,
        [out, retval] IDWriteFont** font);
};



[
    odl,
    uuid(1A0D8438-1D97-4EC1-AEF9-A2FB86ED6ACB),
    helpstring("The IDWriteFontList interface represents a list of fonts.")
]
interface IDWriteFontList : stdole.IUnknown {
    [helpstring("Gets the font collection that contains the fonts.")]
    HRESULT _stdcall GetFontCollection([out, retval] IDWriteFontCollection** fontCollection);
    [helpstring("Gets the number of fonts in the font list.")]
    long _stdcall GetFontCount();
    [helpstring("Gets a font given its zero-based index.")]
    HRESULT _stdcall GetFont(
        [in] long index,
        [out, retval] IDWriteFont** font);
};

[
    odl,
    uuid(ACD16696-8C14-4F5D-877E-FE3FC1D32737),
    helpstring("The IDWriteFont interface represents a physical font in a font collection.")
]
interface IDWriteFont : stdole.IUnknown {
    [helpstring("Gets the font family to which the specified font belongs.")]
    HRESULT _stdcall GetFontFamily([out, retval] IDWriteFontFamily** fontFamily);
    [helpstring("Gets the weight of the specified font.")]
    DWRITE_FONT_WEIGHT _stdcall GetWeight();
    [helpstring("Gets the stretch (aka. width) of the specified font.")]
    DWRITE_FONT_STRETCH _stdcall GetStretch();
    [helpstring("Gets the style (aka. slope) of the specified font.")]
    DWRITE_FONT_STYLE _stdcall GetStyle();
    [helpstring("Returns TRUE if the font is a symbol font or FALSE if not.")]
    long _stdcall IsSymbolFont();
    [helpstring("Gets a localized strings collection containing the face names for the font (e.g., Regular or Bold), indexed by locale name.")]
    HRESULT _stdcall GetFaceNames([out, retval] IDWriteLocalizedStrings** names);
    [helpstring("Gets a localized strings collection containing the specified informational strings, indexed by locale name.")]
    HRESULT _stdcall GetInformationalStrings(
        [in] DWRITE_INFORMATIONAL_STRING_ID informationalStringID,
        [out] IDWriteLocalizedStrings** informationalStrings,
        [out, retval] long* exists);
    [helpstring("Gets a value that indicates what simulation are applied to the specified font.")]
    DWRITE_FONT_SIMULATIONS _stdcall GetSimulations();
    [helpstring("Gets the metrics for the font.")]
    void _stdcall GetMetrics([out] DWRITE_FONT_METRICS* fontMetrics);
    [helpstring("Determines whether the font supports the specified character.")]
    HRESULT _stdcall HasCharacter(
        [in] long unicodeValue,
        [out, retval] long* exists);
    [helpstring("Creates a font file enumerator object that encapsulates a collection of font files.")]
    HRESULT _stdcall CreateFontFace([out, retval] IDWriteFontFace** fontFace);
};



[
    odl,
    uuid(08256209-099A-4B34-B86D-C22B110E7771),
    helpstring("Represents a collection of strings indexed by locale name.")
]
interface IDWriteLocalizedStrings : stdole.IUnknown {
    [helpstring("Gets the number of language/string pairs.")]
    long _stdcall GetCount();
    [helpstring("Gets the index of the item with the specified locale name.")]
    HRESULT _stdcall FindLocaleName(
        [in] long localeName,
        [in] long* index,
        [out, retval] long* exists);
    [helpstring("Gets the length in characters (not including the null terminator) of the locale name with the specified index.")]
    HRESULT _stdcall GetLocaleNameLength(
        [in] long index,
        [out, retval] long* length);
    [helpstring("Copies the locale name with the specified index to the specified array.")]
    HRESULT _stdcall GetLocaleName(
        [in] long index,
        [in, out] long* localeName,
        [in] long size);
    [helpstring("Gets the length in characters (not including the null terminator) of the string with the specified index.")]
    HRESULT _stdcall GetStringLength(
        [in] long index,
        [out, retval] long* length);
    [helpstring("Copies the string with the specified index to the specified array.")]
    HRESULT _stdcall GetString(
        [in] long index,
        [in, out] long* stringBuffer,
        [in] long size);
};


[
    odl,
    uuid(5F49804D-7024-4D43-BFA9-D25984F53849),
    helpstring("The interface that represents an absolute reference to a font face.")
]
interface IDWriteFontFace : stdole.IUnknown {
    [helpstring("Obtains the file format type of a font face.")]
    DWRITE_FONT_FACE_TYPE _stdcall GetType();
    [helpstring("Obtains the font files representing a font face.")]
    HRESULT _stdcall GetFiles(
        [in] long* numberOfFiles,
        [in] void* fontFiles);
    [helpstring("Obtains the zero-based index of the font face in its font file or files. If the font files contain a single face, the return value is zero.")]
    long _stdcall GetIndex();
    [helpstring("Obtains the algorithmic style simulation flags of a font face.")]
    DWRITE_FONT_SIMULATIONS _stdcall GetSimulations();
    [helpstring("Determines whether the font is a symbol font.")]
    long _stdcall IsSymbolFont();
    [helpstring("Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.")]
    void _stdcall GetMetrics([out] DWRITE_FONT_METRICS* fontFaceMetrics);
    [helpstring("Obtains the number of glyphs in the font face.")]
    short _stdcall GetGlyphCount();
    [helpstring("Obtains ideal glyph metrics in font design units. Design glyphs metrics are used for glyph positioning.")]
    HRESULT _stdcall GetDesignGlyphMetrics(
        [in] void* glyphIndices,
        [in] long glyphCount,
        [in] void* glyphMetrics,
        [in] long isSideways);
    [helpstring("Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table.")]
    HRESULT _stdcall GetGlyphIndices(
        [in] void* codePoints,
        [in] long codePointCount,
        [in] void* glyphIndices);
    [helpstring("Finds the specified OpenType font table if it exists and returns a pointer to it.")]
    HRESULT _stdcall TryGetFontTable(
        [in] long openTypeTableTag,
        [in] void* tableData,
        [in] long* tableSize,
        [in] void* tableContext,
        [in] long* exists);
    [helpstring("Releases the table obtained earlier from TryGetFontTable.")]
    void _stdcall ReleaseFontTable([in] void* tableContext);
    [helpstring("Computes the outline of a run of glyphs by calling back to the outline sink interface.")]
    HRESULT _stdcall GetGlyphRunOutline(
        [in] single emSize,
        [in] void* glyphIndices,
        [in] void* glyphAdvances,
        [in] void* glyphOffsets,
        [in] long glyphCount,
        [in] long isSideways,
        [in] long isRightToLeft,
        [in] ID2D1SimplifiedGeometrySink* geometrySink);
    [helpstring("Determines the recommended rendering mode for the font given the specified size and rendering parameters.")]
    HRESULT _stdcall GetRecommendedRenderingMode(
        [in] single emSize,
        [in] single pixelsPerDip,
        [in] DWRITE_MEASURING_MODE measuringMode,
        [in] IDWriteRenderingParams* renderingParams,
        [out, retval] DWRITE_RENDERING_MODE* renderingMode);
    [helpstring("Obtains design units and common metrics for the font face.")]
    HRESULT _stdcall GetGdiCompatibleMetrics(
        [in] single emSize,
        [in] single pixelsPerDip,
        [in] void* transform,
        [out, retval] DWRITE_FONT_METRICS* fontFaceMetrics);
    [helpstring("Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.")]
    HRESULT _stdcall GetGdiCompatibleGlyphMetrics(
        [in] single emSize,
        [in] single pixelsPerDip,
        [in] void* transform,
        [in] long useGdiNatural,
        [in] void* glyphIndices,
        [in] long glyphCount,
        [in] void* glyphMetrics,
        [in] long isSideways);
};

[
    odl,
    uuid(2F0DA53A-2ADD-47CD-82EE-D9EC34688E75),
    helpstring("The interface that represents text rendering settings for glyph rasterization and filtering.")
]
interface IDWriteRenderingParams : stdole.IUnknown {
    [helpstring("Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.")]
    single _stdcall GetGamma();
    [helpstring("Gets the amount of contrast enhancement. Valid values are greater than or equal to zero.")]
    single _stdcall GetEnhancedContrast();
    [helpstring("Gets the ClearType level. Valid values range from 0.0f (no ClearType) to 1.0f (full ClearType).")]
    single _stdcall GetClearTypeLevel();
    [helpstring("Gets the pixel geometry.")]
    DWRITE_PIXEL_GEOMETRY _stdcall GetPixelGeometry();
    [helpstring("Gets the rendering mode.")]
    DWRITE_RENDERING_MODE _stdcall GetRenderingMode();
};



[
    odl,
    uuid(CCA920E4-52F0-492B-BFA8-29C72EE0A468),
    helpstring("The font collection loader interface is used to construct a collection of fonts given a particular type of key.")
]
interface IDWriteFontCollectionLoader : stdole.IUnknown {
    [helpstring("Creates a font file enumerator object that encapsulates a collection of font files.")]
    HRESULT _stdcall CreateEnumeratorFromKey(
        [in] IDWriteFactory* factory,
        [in] void* collectionKey,
        [in] long collectionKeySize,
        [out] IDWriteFontFileEnumerator** fontFileEnumerator);
};

[
    odl,
    uuid(72755049-5FF7-435D-8348-4BE97CFA6C7C),
    helpstring("The font file enumerator interface encapsulates a collection of font files. The font system uses this interface to enumerate font files when building a font collection.")
]
interface IDWriteFontFileEnumerator : stdole.IUnknown {
    HRESULT _stdcall MoveNext([out, retval] long* hasCurrentFile);
    HRESULT _stdcall GetCurrentFontFile([out, retval] IDWriteFontFile** fontFile);
};

[
    odl,
    uuid(739D886A-CEF5-47DC-8769-1A8B41BEBBB0),
    helpstring("The interface that represents a reference to a font file.")
]
interface IDWriteFontFile : stdole.IUnknown {
    [helpstring("This method obtains the pointer to the reference key of a font file. The pointer is only valid until the object that refers to it is released.")]
    HRESULT _stdcall GetReferenceKey(
        [out] LPVOID fontFileReferenceKey,
        [out, retval] long* fontFileReferenceKeySize);
    [helpstring("Obtains the file loader associated with a font file object.")]
    HRESULT _stdcall GetLoader([out, retval] IDWriteFontFileLoader** fontFileLoader);
    [helpstring("Analyzes a file and returns whether it represents a font, and whether the font type is supported by the font system.")]
    HRESULT _stdcall Analyze(
        [out] long* isSupportedFontType,
        [out] DWRITE_FONT_FILE_TYPE* fontFileType,
        [in, out] DWRITE_FONT_FACE_TYPE* fontFaceType,
        [out] long* numberOfFaces);
};

[
    odl,
    uuid(727CAD4E-D6AF-4C9E-8A08-D695B11CAA49),
    helpstring("Font file loader interface handles loading font file resources of a particular type from a key.")
]
interface IDWriteFontFileLoader : stdole.IUnknown {
    [helpstring("Creates a font file stream object that encapsulates an open file resource.")]
    HRESULT _stdcall CreateStreamFromKey(
        [in] void* fontFileReferenceKey,
        [in] long fontFileReferenceKeySize,
        [out] IDWriteFontFileStream** fontFileStream);
};

[
    odl,
    uuid(6D4865FE-0AB8-4D91-8F62-5DD6BE34A3E0),
    helpstring("The interface for loading font file data.")
]
interface IDWriteFontFileStream : stdole.IUnknown {
    [helpstring("Reads a fragment from a file.")]
    HRESULT _stdcall ReadFileFragment(
        [in] void* fragmentStart,
        [in] CURRENCY fileOffset,
        [in] CURRENCY fragmentSize,
        [in] void* fragmentContext);
    [helpstring("Releases a fragment from a file.")]
    void _stdcall ReleaseFileFragment([in] void* fragmentContext);
    [helpstring("Obtains the total size of a file.")]
    HRESULT _stdcall GetFileSize([out, retval] CURRENCY* fileSize);
    [helpstring("Obtains the last modified time of the file. The last modified time is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.")]
    HRESULT _stdcall GetLastWriteTime([out, retval] CURRENCY* lastWriteTime);
};



[
    odl,
    uuid(9C906818-31D7-4FD3-A151-7C5E225DB55A),
    helpstring("The format of text used for text layout purpose.")
]
interface IDWriteTextFormat : stdole.IUnknown {
    [helpstring("Set alignment option of text relative to layout box's leading and trailing edge.")]
    HRESULT _stdcall SetTextAlignment([in] DWRITE_TEXT_ALIGNMENT textAlignment);
    [helpstring("Set alignment option of paragraph relative to layout box's top and bottom edge.")]
    HRESULT _stdcall SetParagraphAlignment([in] DWRITE_PARAGRAPH_ALIGNMENT paragraphAlignment);
    [helpstring("Set word wrapping option.")]
    HRESULT _stdcall SetWordWrapping([in] DWRITE_WORD_WRAPPING wordWrapping);
    [helpstring("Set paragraph reading direction.")]
    HRESULT _stdcall SetReadingDirection([in] DWRITE_READING_DIRECTION readingDirection);
    [helpstring("Set paragraph flow direction.")]
    HRESULT _stdcall SetFlowDirection([in] DWRITE_FLOW_DIRECTION flowDirection);
    [helpstring("Set incremental tab stop position.")]
    HRESULT _stdcall SetIncrementalTabStop([in] single incrementalTabStop);
    [helpstring("Set trimming options for any trailing text exceeding the layout width or for any far text exceeding the layout height.")]
    HRESULT _stdcall SetTrimming(
        [in] DWRITE_TRIMMING* trimmingOptions,
        [in] IDWriteInlineObject* trimmingSign);
    [helpstring("Set line spacing.")]
    HRESULT _stdcall SetLineSpacing(
        [in] DWRITE_LINE_SPACING_METHOD lineSpacingMethod,
        [in] single lineSpacing,
        [in] single baseline);
    [helpstring("Get alignment option of text relative to layout box's leading and trailing edge.")]
    DWRITE_TEXT_ALIGNMENT _stdcall GetTextAlignment();
    [helpstring("Get alignment option of paragraph relative to layout box's top and bottom edge.")]
    DWRITE_PARAGRAPH_ALIGNMENT _stdcall GetParagraphAlignment();
    [helpstring("Get word wrapping option.")]
    DWRITE_WORD_WRAPPING _stdcall GetWordWrapping();
    [helpstring("Get paragraph reading direction.")]
    DWRITE_READING_DIRECTION _stdcall GetReadingDirection();
    [helpstring("Get paragraph flow direction.")]
    DWRITE_FLOW_DIRECTION _stdcall GetFlowDirection();
    [helpstring("Get incremental tab stop position.")]
    single _stdcall GetIncrementalTabStop();
    [helpstring("Get trimming options for text overflowing the layout width.")]
    HRESULT _stdcall GetTrimming(
        [in] DWRITE_TRIMMING* trimmingOptions,
        [out, retval] IDWriteInlineObject** trimmingSign);
    [helpstring("Get line spacing.")]
    HRESULT _stdcall GetLineSpacing(
        [in] DWRITE_LINE_SPACING_METHOD* lineSpacingMethod,
        [in] single* lineSpacing,
        [in] single* baseline);
    [helpstring("Get the font collection.")]
    HRESULT _stdcall GetFontCollection([in, out] IDWriteFontCollection** fontCollection);
    [helpstring("Get the length of the font family name, in characters, not including the terminating NULL character.")]
    long _stdcall GetFontFamilyNameLength();
    [helpstring("Get a copy of the font family name.")]
    HRESULT _stdcall GetFontFamilyName(
        [in, out] long* fontFamilyName,
        [in] long nameSize);
    [helpstring("Get the font weight.")]
    DWRITE_FONT_WEIGHT _stdcall GetFontWeight();
    [helpstring("Get the font style.")]
    DWRITE_FONT_STYLE _stdcall GetFontStyle();
    [helpstring("Get the font stretch.")]
    DWRITE_FONT_STRETCH _stdcall GetFontStretch();
    [helpstring("Get the font em height.")]
    single _stdcall GetFontSize();
    [helpstring("Get the length of the locale name, in characters, not including the terminating NULL character.")]
    long _stdcall GetLocaleNameLength();
    [helpstring("Get a copy of the locale name.")]
    HRESULT _stdcall GetLocaleName(
        [in, out] long* localeName,
        [in] long nameSize);
};

[
    odl,
    uuid(8339FDE3-106F-47AB-8373-1C6295EB10B3),
    helpstring("The IDWriteInlineObject interface wraps an application defined inline graphic, allowing DWrite to query metrics as if it was a glyph inline with the text.")
]
interface IDWriteInlineObject : stdole.IUnknown {
    [helpstring("The application implemented rendering callback (IDWriteTextRenderer::DrawInlineObject) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly.")]
    HRESULT _stdcall Draw(
        [in] void* clientDrawingContext,
        [in] IDWriteTextRenderer* renderer,
        [in] single originX,
        [in] single originY,
        [in] long isSideways,
        [in] long isRightToLeft,
        [in] IUnknown* clientDrawingEffect);
    [helpstring("TextLayout calls this callback function to get the measurement of the inline object.")]
    HRESULT _stdcall GetMetrics([out, retval] DWRITE_INLINE_OBJECT_METRICS* metrics);
    [helpstring("TextLayout calls this callback function to get the visible extents (in DIPs) of the inline object.")]
    HRESULT _stdcall GetOverhangMetrics([out, retval] DWRITE_OVERHANG_METRICS* overhangs);
    [helpstring("Layout uses this to determine the line breaking behavior of the inline object amidst the text.")]
    HRESULT _stdcall GetBreakConditions(
        [in] DWRITE_BREAK_CONDITION* breakConditionBefore,
        [in] DWRITE_BREAK_CONDITION* breakConditionAfter);
};

[
    odl,
    uuid(EAF3A2DA-ECF4-4D24-B644-B34F6842024B),
    helpstring("The IDWritePixelSnapping interface defines the pixel snapping properties of a text renderer.")
]
interface IDWritePixelSnapping : stdole.IUnknown{
    [helpstring("Determines whether pixel snapping is disabled. The recommended default is FALSE, unless doing animation that requires subpixel vertical placement.")]
    HRESULT _stdcall IsPixelSnappingDisabled(
        [in] void* clientDrawingContext,
        [out, retval] long* isDisabled);
    [helpstring("Gets the current transform that maps abstract coordinates to DIPs, which may disable pixel snapping upon any rotation or shear.")]
    HRESULT _stdcall GetCurrentTransform(
        [in] void* clientDrawingContext,
        [out, retval] DWRITE_MATRIX* transform);
    [helpstring("Gets the number of physical pixels per DIP. A DIP (device-independent pixel) is 1/96 inch, so the pixelsPerDip value is the number of logical pixels per inch divided by 96 (yieldinga value of 1 for 96 DPI and 1.25 for 120).")]
    HRESULT _stdcall GetPixelsPerDip(
        [in] void* clientDrawingContext,
        [out, retval] single* pixelsPerDip);
};


[
    odl,
    uuid(55F1112B-1DC2-4B3C-9541-F46894ED85B6),
    helpstring("Font typography setting.")
]
interface IDWriteTypography : stdole.IUnknown{
    [helpstring("Add font feature.")]
    HRESULT _stdcall AddFontFeature([in] DWRITE_FONT_FEATURE fontFeature);
    [helpstring("Get the number of font features.")]
    long _stdcall GetFontFeatureCount();
    [helpstring("Get the font feature at the specified index.")]
    HRESULT _stdcall GetFontFeature(
        [in] long fontFeatureIndex,
        [out, retval] DWRITE_FONT_FEATURE* fontFeature);
};


[
    odl,
    uuid(1EDD9491-9853-4299-898F-6432983B6F3A),
    helpstring("The GDI interop interface provides interoperability with GDI.")
]
interface IDWriteGdiInterop : stdole.IUnknown{
    [helpstring("Creates a font object that matches the properties specified by the LOGFONT structure.")]
    HRESULT _stdcall CreateFontFromLOGFONT(
        [in] void* logFont,
        [out, retval] IDWriteFont * *font);
    [helpstring("Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font.")]
    HRESULT _stdcall ConvertFontToLOGFONT(
        [in] IDWriteFont* font,
        [in] void* logFont,
        [out, retval] long* isSystemFont);
    [helpstring("Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font.")]
    HRESULT _stdcall ConvertFontFaceToLOGFONT(
        [in] IDWriteFontFace* font,
        [in] void* logFont);
    [helpstring("Creates a font face object that corresponds to the currently selected HFONT.")]
    HRESULT _stdcall CreateFontFaceFromHdc(
        [in] long hdc,
        [out, retval] IDWriteFontFace** fontFace);
    [helpstring("Creates an object that encapsulates a bitmap and memory DC which can be used for rendering glyphs.")]
    HRESULT _stdcall CreateBitmapRenderTarget(
        [in] long hdc,
        [in] long width,
        [in] long height,
        [out, retval] IDWriteBitmapRenderTarget** renderTarget);
};

[
    odl,
    uuid(5E5A32A3-8DFF-4773-9FF6-0696EAB77267),
    helpstring("Encapsulates a 32-bit device independent bitmap and device context, which can be used for rendering glyphs.")
]
interface IDWriteBitmapRenderTarget : stdole.IUnknown{
    [helpstring("Draws a run of glyphs to the bitmap.")]
    HRESULT _stdcall DrawGlyphRun(
        [in] single baselineOriginX,
        [in] single baselineOriginY,
        [in] DWRITE_MEASURING_MODE measuringMode,
        [in] DWRITE_GLYPH_RUN * glyphRun,
        [in] IDWriteRenderingParams * renderingParams,
        [in] long textColor,
        [in] void* blackBoxRect);
    [helpstring("Gets a handle to the memory device context.")]
    long _stdcall GetMemoryDC();
    [helpstring("Gets the number of bitmap pixels per DIP. A DIP (device-independent pixel) is 1/96 inch so this value is the number if pixels per inch divided by 96.")]
    single _stdcall GetPixelsPerDip();
    [helpstring("Sets the number of bitmap pixels per DIP. A DIP (device-independent pixel) is 1/96 inch so this value is the number if pixels per inch divided by 96.")]
    HRESULT _stdcall SetPixelsPerDip([in] single pixelsPerDip);
    [helpstring("Gets the transform that maps abstract coordinate to DIPs. By default this is the identity transform.")]
    HRESULT _stdcall GetCurrentTransform([out, retval] DWRITE_MATRIX* transform);
    [helpstring("Sets the transform that maps abstract coordinate to DIPs. This does not affect the world transform of the underlying device context.")]
    HRESULT _stdcall SetCurrentTransform([in] void* transform);
    [helpstring("Gets the dimensions of the bitmap.")]
    HRESULT _stdcall GetSize([out, retval] SIZE* size);
    [helpstring("Resizes the bitmap.")]
    HRESULT _stdcall Resize(
        [in] long width,
        [in] long height);
};


[
    odl,
    uuid(DA20D8EF-812A-4C43-9802-62EC4ABD7ADD),
    helpstring("The IDWriteFontFamily interface represents a set of fonts that share the same design but are differentiated by weight, stretch, and style.")
]
interface IDWriteFontFamily : IDWriteFontList {
    [helpstring("Creates an localized strings object that contains the family names for the font family, indexed by locale name.")]
    HRESULT _stdcall GetFamilyNames([out, retval] IDWriteLocalizedStrings** names);
    [helpstring("Gets the font that best matches the specified properties.")]
    HRESULT _stdcall GetFirstMatchingFont(
        [in] DWRITE_FONT_WEIGHT weight,
        [in] DWRITE_FONT_STRETCH stretch,
        [in] DWRITE_FONT_STYLE style,
        [out, retval] IDWriteFont** matchingFont);
    [helpstring("Gets a list of fonts in the font family ranked in order of how well they match the specified properties.")]
    HRESULT _stdcall GetMatchingFonts(
        [in] DWRITE_FONT_WEIGHT weight,
        [in] DWRITE_FONT_STRETCH stretch,
        [in] DWRITE_FONT_STYLE style,
        [out, retval] IDWriteFontList** matchingFonts);
};


[
    odl,
    uuid(EF8A8135-5CC6-45FE-8825-C5A0724EB819),
    helpstring("The IDWriteTextLayout interface represents a set of application-defined callbacks that perform rendering of text, inline objects, and decorations such as underlines.")
]
interface IDWriteTextRenderer : IDWritePixelSnapping {
    [helpstring("IDWriteTextLayout::Draw calls this function to instruct the client to render a run of glyphs.")]
    HRESULT _stdcall DrawGlyphRun(
        [in] void* clientDrawingContext,
        [in] single baselineOriginX,
        [in] single baselineOriginY,
        [in] DWRITE_MEASURING_MODE measuringMode,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
        [in] IUnknown* clientDrawingEffect);
    [helpstring("IDWriteTextLayout::Draw calls this function to instruct the client to draw an underline.")]
    HRESULT _stdcall DrawUnderline(
        [in] void* clientDrawingContext,
        [in] single baselineOriginX,
        [in] single baselineOriginY,
        [in] DWRITE_UNDERLINE* underline,
        [in] IUnknown* clientDrawingEffect);
    [helpstring("IDWriteTextLayout::Draw calls this function to instruct the client to draw a strikethrough.")]
    HRESULT _stdcall DrawStrikethrough(
        [in] void* clientDrawingContext,
        [in] single baselineOriginX,
        [in] single baselineOriginY,
        [in] DWRITE_STRIKETHROUGH* strikethrough,
        [in] IUnknown* clientDrawingEffect);
    [helpstring("IDWriteTextLayout::Draw calls this application callback when it needs to draw an inline object.")]
    HRESULT _stdcall DrawInlineObject(
        [in] void* clientDrawingContext,
        [in] single originX,
        [in] single originY,
        [in] IDWriteInlineObject* inlineObject,
        [in] long isSideways,
        [in] long isRightToLeft,
        [in] IUnknown* clientDrawingEffect);
};

[
    odl,
    uuid(53737037-6D14-410B-9BFE-0B182BB70961),
    helpstring("The IDWriteTextLayout interface represents a block of text after it has been fully analyzed and formatted.")
]
interface IDWriteTextLayout : IDWriteTextFormat {
    [helpstring("Set layout maximum width")]
    HRESULT _stdcall SetMaxWidth([in] single maxWidth);
    [helpstring("Set layout maximum height")]
    HRESULT _stdcall SetMaxHeight([in] single maxHeight);
    [helpstring("Set the font collection.")]
    HRESULT _stdcall SetFontCollection(
        [in] IDWriteFontCollection* fontCollection,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set null-terminated font family name.")]
    HRESULT _stdcall SetFontFamilyName(
        [in] long fontFamilyName,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set font weight.")]
    HRESULT _stdcall SetFontWeight(
        [in] DWRITE_FONT_WEIGHT fontWeight,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set font style.")]
    HRESULT _stdcall SetFontStyle(
        [in] DWRITE_FONT_STYLE fontStyle,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set font stretch.")]
    HRESULT _stdcall SetFontStretch(
        [in] DWRITE_FONT_STRETCH fontStretch,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set font em height.")]
    HRESULT _stdcall SetFontSize(
        [in] single fontSize,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set underline.")]
    HRESULT _stdcall SetUnderline(
        [in] long hasUnderline,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set strikethrough.")]
    HRESULT _stdcall SetStrikethrough(
        [in] long hasStrikethrough,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set application-defined drawing effect.")]
    HRESULT _stdcall SetDrawingEffect(
        [in] IUnknown* drawingEffect,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set inline object.")]
    HRESULT _stdcall SetInlineObject(
        [in] IDWriteInlineObject* inlineObject,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set font typography features.")]
    HRESULT _stdcall SetTypography(
        [in] IDWriteTypography* typography,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Set locale name.")]
    HRESULT _stdcall SetLocaleName(
        [in] long localeName,
        [in] long textRange_startPosition,
        [in] long textRange_length);
    [helpstring("Get layout maximum width.")]
    single _stdcall GetMaxWidth();
    [helpstring("Get layout maximum height.")]
    single _stdcall GetMaxHeight();
    [helpstring("Get the font collection where the current position is at.")]
    HRESULT _stdcall GetFontCollection(
        [in] long currentPosition,
        [out] IDWriteFontCollection** fontCollection,
        [in] void* textRange);
    [helpstring("Get the length of the font family name where the current position is at.")]
    HRESULT _stdcall GetFontFamilyNameLength(
        [in] long currentPosition,
        [in] long* nameLength,
        [in] void* textRange);
    [helpstring("Copy the font family name where the current position is at.")]
    HRESULT _stdcall GetFontFamilyName(
        [in] long currentPosition,
        [in, out] long* fontFamilyName,
        [in] long nameSize,
        [in] void* textRange);
    [helpstring("Get the font weight where the current position is at.")]
    HRESULT _stdcall GetFontWeight(
        [in] long currentPosition,
        [in] DWRITE_FONT_WEIGHT* fontWeight,
        [in] void* textRange);
    [helpstring("Get the font style where the current position is at.")]
    HRESULT _stdcall GetFontStyle(
        [in] long currentPosition,
        [in] DWRITE_FONT_STYLE* fontStyle,
        [in] void* textRange);
    [helpstring("Get the font stretch where the current position is at.")]
    HRESULT _stdcall GetFontStretch(
        [in] long currentPosition,
        [in] DWRITE_FONT_STRETCH* fontStretch,
        [in] void* textRange);
    [helpstring("Get the font em height where the current position is at.")]
    HRESULT _stdcall GetFontSize(
        [in] long currentPosition,
        [in] single* fontSize,
        [in] void* textRange);
    [helpstring("Get the underline presence where the current position is at.")]
    HRESULT _stdcall GetUnderline(
        [in] long currentPosition,
        [in] long* hasUnderline,
        [in] void* textRange);
    [helpstring("Get the strikethrough presence where the current position is at.")]
    HRESULT _stdcall GetStrikethrough(
        [in] long currentPosition,
        [in]  long* hasStrikethrough,
        [in] void* textRange);
    [helpstring("Get the application-defined drawing effect where the current position is at.")]
    HRESULT _stdcall GetDrawingEffect(
        [in] long currentPosition,
        [out] IUnknown** drawingEffect,
        [in] void* textRange);
    [helpstring("Get the inline object at the given position.")]
    HRESULT _stdcall GetInlineObject(
        [in] long currentPosition,
        [out] IDWriteInlineObject** inlineObject,
        [in] void* textRange);
    [helpstring("Get the typography setting where the current position is at.")]
    HRESULT _stdcall GetTypography(
        [in] long currentPosition,
        [out] IDWriteTypography** typography,
        [in] void* textRange);
    [helpstring("Get the length of the locale name where the current position is at.")]
    HRESULT _stdcall GetLocaleNameLength(
        [in] long currentPosition,
        [in] long* nameLength,
        [in] void* textRange);
    [helpstring("Get the locale name where the current position is at.")]
    HRESULT _stdcall GetLocaleName(
        [in] long currentPosition,
        [in, out] long* localeName,
        [in] long nameSize,
        [in] void* textRange);
    [helpstring("Initiate drawing of the text.")]
    HRESULT _stdcall Draw(
        [in] void* clientDrawingContext,
        [in] IDWriteTextRenderer* renderer,
        [in] single originX,
        [in] single originY);
    [helpstring("GetLineMetrics returns properties of each line.")]
    HRESULT _stdcall GetLineMetrics(
        [in] DWRITE_LINE_METRICS* lineMetrics,
        [in] long maxLineCount,
        [out, retval] long* actualLineCount);
    [helpstring("GetMetrics retrieves overall metrics for the formatted string.")]
    HRESULT _stdcall GetMetrics([out, retval] DWRITE_TEXT_METRICS* textMetrics);
    [helpstring("GetOverhangMetrics returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.")]
    HRESULT _stdcall GetOverhangMetrics([out, retval] DWRITE_OVERHANG_METRICS* overhangs);
    [helpstring("Retrieve logical properties and measurement of each cluster.")]
    HRESULT _stdcall GetClusterMetrics(
        [in] DWRITE_CLUSTER_METRICS* clusterMetrics,
        [in] long maxClusterCount,
        [out, retval] long* actualClusterCount);
    [helpstring("Determines the minimum possible width the layout can be set to without emergency breaking between the characters of whole words.")]
    HRESULT _stdcall DetermineMinWidth([out, retval] single* minWidth);
    [helpstring("Given a coordinate (in DIPs) relative to the top-left of the layout box, this returns the corresponding hit-test metrics of the text string where the hit-test has occurred.")]
    HRESULT _stdcall HitTestPoint(
        [in] single pointX,
        [in] single pointY,
        [in] long* isTrailingHit,
        [in] long* isInside,
        [in] DWRITE_HIT_TEST_METRICS* hitTestMetrics);
    [helpstring("Given a text position and whether the caret is on the leading or trailing edge of that position, this returns the corresponding coordinate (in DIPs) relative to the top-left of the layout box.")]
    HRESULT _stdcall HitTestTextPosition(
        [in] long textPosition,
        [in] long isTrailingHit,
        [in] single* pointX,
        [in] single* pointY,
        [in] DWRITE_HIT_TEST_METRICS* hitTestMetrics);
    [helpstring("The application calls this function to get a set of hit-test metrics corresponding to a range of text positions.")]
    HRESULT _stdcall HitTestTextRange(
        [in] long textPosition,
        [in] long textLength,
        [in] single originX,
        [in] single originY,
        [in] DWRITE_HIT_TEST_METRICS* hitTestMetrics,
        [in] long maxHitTestMetricsCount,
        [in] long* actualHitTestMetricsCount);
};


[
    odl,
    uuid(B7E6163E-7F46-43B4-84B3-E4E6249C365D),
    helpstring("Analyzes various text properties for complex script processing.")
]
interface IDWriteTextAnalyzer : stdole.IUnknown {
    [helpstring("Analyzes a text range for script boundaries, reading text attributes from the source and reporting the Unicode script ID to the sink callback SetScript.")]
    HRESULT _stdcall AnalyzeScript(
        [in] IDWriteTextAnalysisSource* analysisSource,
        [in] long textPosition,
        [in] long textLength,
        [in] IDWriteTextAnalysisSink* analysisSink);
    [helpstring("Analyzes a text range for script directionality, reading attributes from the source and reporting levels to the sink callback SetBidiLevel.")]
    HRESULT _stdcall AnalyzeBidi(
        [in] IDWriteTextAnalysisSource* analysisSource,
        [in] long textPosition,
        [in] long textLength,
        [in] IDWriteTextAnalysisSink* analysisSink);
    [helpstring("Analyzes a text range for spans where number substitution is applicable, reading attributes from the source and reporting substitutable ranges to the sink callback SetNumberSubstitution.")]
    HRESULT _stdcall AnalyzeNumberSubstitution(
        [in] IDWriteTextAnalysisSource* analysisSource,
        [in] long textPosition,
        [in] long textLength,
        [in] IDWriteTextAnalysisSink* analysisSink);
    [helpstring("Analyzes a text range for potential breakpoint opportunities, reading attributes from the source and reporting breakpoint opportunities to the sink callback SetLineBreakpoints.")]
    HRESULT _stdcall AnalyzeLineBreakpoints(
        [in] IDWriteTextAnalysisSource* analysisSource,
        [in] long textPosition,
        [in] long textLength,
        [in] IDWriteTextAnalysisSink* analysisSink);
    [helpstring("Parses the input text string and maps it to the set of glyphs and associated glyph data according to the font and the writing system's rendering rules.")]
    HRESULT _stdcall GetGlyphs(
        [in] long textString,
        [in] long textLength,
        [in] IDWriteFontFace* fontFace,
        [in] long isSideways,
        [in] long isRightToLeft,
        [in] DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,
        [in] long localeName,
        [in] IDWriteNumberSubstitution* numberSubstitution,
        [in] void* features,
        [in] void* featureRangeLengths,
        [in] long featureRanges,
        [in] long maxGlyphCount,
        [in] short* clusterMap,
        [in] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        [in] short* glyphIndices,
        [in] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,
        [out] long* actualGlyphCount);
    [helpstring("Place glyphs output from the GetGlyphs method according to the font and the writing system's rendering rules.")]
    HRESULT _stdcall GetGlyphPlacements(
        [in] long textString,
        [in] short* clusterMap,
        [in] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        [in] long textLength,
        [in] short* glyphIndices,
        [in] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,
        [in] long glyphCount,
        [in] IDWriteFontFace* fontFace,
        [in] single fontEmSize,
        [in] long isSideways,
        [in] long isRightToLeft,
        [in] DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,
        [in] long localeName,
        [in] void* features,
        [in] void* featureRangeLengths,
        [in] long featureRanges,
        [in] single* glyphAdvances,
        [in] DWRITE_GLYPH_OFFSET* glyphOffsets);
    [helpstring("Place glyphs output from the GetGlyphs method according to the font and the writing system's rendering rules.")]
    HRESULT _stdcall GetGdiCompatibleGlyphPlacements(
        [in] long textString,
        [in] short* clusterMap,
        [in] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        [in] long textLength,
        [in] short* glyphIndices,
        [in] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,
        [in] long glyphCount,
        [in] IDWriteFontFace* fontFace,
        [in] single fontEmSize,
        [in] single pixelsPerDip,
        [in] void* transform,
        [in] long useGdiNatural,
        [in] long isSideways,
        [in] long isRightToLeft,
        [in] DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,
        [in] long localeName,
        [in] void* features,
        [in] void* featureRangeLengths,
        [in] long featureRanges,
        [in] single* glyphAdvances,
        [in] DWRITE_GLYPH_OFFSET* glyphOffsets);
};

[
    odl,
    uuid(688E1A58-5094-47C8-ADC8-FBCEA60AE92B),
    helpstring("The interface implemented by the text analyzer's client to provide text to the analyzer.")
]
interface IDWriteTextAnalysisSource : stdole.IUnknown {
    HRESULT _stdcall GetTextAtPosition(
        [in] long textPosition,
        [in] int* textString,
        [in] long* textLength);
    HRESULT _stdcall GetTextBeforePosition(
        [in] long textPosition,
        [in] int* textString,
        [in] long* textLength);
    DWRITE_READING_DIRECTION _stdcall GetParagraphReadingDirection();
    HRESULT _stdcall GetLocaleName(
        [in] long textPosition,
        [in] long* textLength,
        [in] int* localeName);
    HRESULT _stdcall GetNumberSubstitution(
        [in] long textPosition,
        [in] long* textLength,
        [in] IDWriteNumberSubstitution** numberSubstitution);
};

[
    odl,
    uuid(14885CC9-BAB0-4F90-B6ED-5C366A2CD03D),
    helpstring("Holds the appropriate digits and numeric punctuation for a given locale.")
]
interface IDWriteNumberSubstitution : stdole.IUnknown {
};

[
    odl,
    uuid(5810CD44-0CA0-4701-B3FA-BEC5182AE4F6),
    helpstring("The interface implemented by the text analyzer's client to receive the output of a given text analysis.")
]
interface IDWriteTextAnalysisSink : stdole.IUnknown {
    [helpstring("Report script analysis for the text range.")]
    HRESULT _stdcall SetScriptAnalysis(
        [in] long textPosition,
        [in] long textLength,
        [in] int* scriptAnalysis);
    [helpstring("Repport line-break opportunities for each character, starting from the specified position.")]
    HRESULT _stdcall SetLineBreakpoints(
        [in] long textPosition,
        [in] long textLength,
        [in] int* lineBreakpoints);
    [helpstring("Set bidirectional level on the range, called once per each level run change (either explicit or resolved implicit).")]
    HRESULT _stdcall SetBidiLevel(
        [in] long textPosition,
        [in] long textLength,
        [in] unsigned char explicitLevel,
        [in] unsigned char resolvedLevel);
    [helpstring("Set number substitution on the range.")]
    HRESULT _stdcall SetNumberSubstitution(
        [in] long textPosition,
        [in] long textLength,
        [in] IDWriteNumberSubstitution* numberSubstitution);
};



[
    odl,
    uuid(7D97DBF7-E085-42D4-81E3-6A883BDED118),
    helpstring("Interface that encapsulates information used to render a glyph run.")
]
interface IDWriteGlyphRunAnalysis : stdole.IUnknown {
    [helpstring("Gets the bounding rectangle of the physical pixels affected by the glyph run.")]
    HRESULT _stdcall GetAlphaTextureBounds(
        [in] DWRITE_TEXTURE_TYPE textureType,
        [out, retval] RECT* textureBounds);
    [helpstring("Creates an alpha texture of the specified type.")]
    HRESULT _stdcall CreateAlphaTexture(
        [in] DWRITE_TEXTURE_TYPE textureType,
        [in] RECT* textureBounds,
        [in] void* alphaValues,
        [in] long bufferSize);
    [helpstring("Gets properties required for ClearType blending.")]
    HRESULT _stdcall GetAlphaBlendParams(
        [in] IDWriteRenderingParams* renderingParams,
        [in] single* blendGamma,
        [in] single* blendEnhancedContrast,
        [in] single* blendClearTypeLevel);
};


[
    odl,
    uuid(B2D9F3EC-C9FE-4A11-A2EC-D86208F7C0A2),
    helpstring("A built-in implementation of IDWriteFontFileLoader interface that operates on local font files and exposes local font file information from the font file reference key.")
]
interface IDWriteLocalFontFileLoader : IDWriteFontFileLoader {
    [helpstring("Obtains the length of the absolute file path from the font file reference key.")]
    HRESULT _stdcall GetFilePathLengthFromKey(
        [in] void* fontFileReferenceKey,
        [in] long fontFileReferenceKeySize,
        [out] long* filePathLength);
    [helpstring("Obtains the absolute font file path from the font file reference key.")]
    HRESULT _stdcall GetFilePathFromKey(
        [in] void* fontFileReferenceKey,
        [in] long fontFileReferenceKeySize,
        [in] short* filePath,
        [in] long filePathSize);
    [helpstring("Obtains the last write time of the file from the font file reference key.")]
    HRESULT _stdcall GetLastWriteTimeFromKey(
        [in] void* fontFileReferenceKey,
        [in] long fontFileReferenceKeySize,
        [out] FILETIME* lastWriteTime);
};



[
    dllname("Dwrite.dll")
]
module Dwrite{
    [entry("DWriteCreateFactory")]
    HRESULT _stdcall DWriteCreateFactory(
                    [in] DWRITE_FACTORY_TYPE factoryType,
                    [in] UUID * iid,
                    [out, retval] IUnknown * *factory);
    const int DWRITE_ALPHA_MAX = 255;
    const int DWRITE_E_FILEFORMAT = 0x88995000;
    const int DWRITE_E_UNEXPECTED = 0x88995001;
    const int DWRITE_E_NOFONT = 0x88995002;
    const int DWRITE_E_FILENOTFOUND = 0x88995003;
    const int DWRITE_E_FILEACCESS = 0x88995004;
    const int DWRITE_E_FONTCOLLECTIONOBSOLETE = 0x88995005;
    const int DWRITE_E_ALREADYREGISTERED = 0x88995006;
};



//**************************************************************

//   DWRITE_1.h

//**************************************************************


/// <summary>
/// The overall kind of family.
/// </summary>
typedef enum DWRITE_PANOSE_FAMILY
{
    DWRITE_PANOSE_FAMILY_ANY = 0,
    DWRITE_PANOSE_FAMILY_NO_FIT = 1,
    DWRITE_PANOSE_FAMILY_TEXT_DISPLAY = 2,
    DWRITE_PANOSE_FAMILY_SCRIPT = 3, // or hand written
    DWRITE_PANOSE_FAMILY_DECORATIVE = 4,
    DWRITE_PANOSE_FAMILY_SYMBOL = 5, // or symbol
    DWRITE_PANOSE_FAMILY_PICTORIAL = 5 //DWRITE_PANOSE_FAMILY_SYMBOL
} DWRITE_PANOSE_FAMILY;

/// <summary>
/// Appearance of the serifs.
/// Present for families: 2-text
/// </summary>
typedef enum DWRITE_PANOSE_SERIF_STYLE
{
    DWRITE_PANOSE_SERIF_STYLE_ANY = 0,
    DWRITE_PANOSE_SERIF_STYLE_NO_FIT = 1,
    DWRITE_PANOSE_SERIF_STYLE_COVE = 2,
    DWRITE_PANOSE_SERIF_STYLE_OBTUSE_COVE = 3,
    DWRITE_PANOSE_SERIF_STYLE_SQUARE_COVE = 4,
    DWRITE_PANOSE_SERIF_STYLE_OBTUSE_SQUARE_COVE = 5,
    DWRITE_PANOSE_SERIF_STYLE_SQUARE = 6,
    DWRITE_PANOSE_SERIF_STYLE_THIN = 7,
    DWRITE_PANOSE_SERIF_STYLE_OVAL = 8,
    DWRITE_PANOSE_SERIF_STYLE_EXAGGERATED = 9,
    DWRITE_PANOSE_SERIF_STYLE_TRIANGLE = 10,
    DWRITE_PANOSE_SERIF_STYLE_NORMAL_SANS = 11,
    DWRITE_PANOSE_SERIF_STYLE_OBTUSE_SANS = 12,
    DWRITE_PANOSE_SERIF_STYLE_PERPENDICULAR_SANS = 13,
    DWRITE_PANOSE_SERIF_STYLE_FLARED = 14,
    DWRITE_PANOSE_SERIF_STYLE_ROUNDED = 15,
    DWRITE_PANOSE_SERIF_STYLE_SCRIPT = 16,
    DWRITE_PANOSE_SERIF_STYLE_PERP_SANS = 13, //DWRITE_PANOSE_SERIF_STYLE_PERPENDICULAR_SANS,
    DWRITE_PANOSE_SERIF_STYLE_BONE = 8, //DWRITE_PANOSE_SERIF_STYLE_OVAL
} DWRITE_PANOSE_SERIF_STYLE;

/// <summary>
/// PANOSE font weights. These roughly correspond to the DWRITE_FONT_WEIGHT's
/// using (panose_weight - 2) * 100.
/// Present for families: 2-text, 3-script, 4-decorative, 5-symbol
/// </summary>
typedef enum DWRITE_PANOSE_WEIGHT
{
    DWRITE_PANOSE_WEIGHT_ANY = 0,
    DWRITE_PANOSE_WEIGHT_NO_FIT = 1,
    DWRITE_PANOSE_WEIGHT_VERY_LIGHT = 2,
    DWRITE_PANOSE_WEIGHT_LIGHT = 3,
    DWRITE_PANOSE_WEIGHT_THIN = 4,
    DWRITE_PANOSE_WEIGHT_BOOK = 5,
    DWRITE_PANOSE_WEIGHT_MEDIUM = 6,
    DWRITE_PANOSE_WEIGHT_DEMI = 7,
    DWRITE_PANOSE_WEIGHT_BOLD = 8,
    DWRITE_PANOSE_WEIGHT_HEAVY = 9,
    DWRITE_PANOSE_WEIGHT_BLACK = 10,
    DWRITE_PANOSE_WEIGHT_EXTRA_BLACK = 11,
    DWRITE_PANOSE_WEIGHT_NORD = 11 //DWRITE_PANOSE_WEIGHT_EXTRA_BLACK
} DWRITE_PANOSE_WEIGHT;

/// <summary>
/// Proportion of the glyph shape considering additional detail to standard
/// characters.
/// Present for families: 2-text
/// </summary>
typedef enum DWRITE_PANOSE_PROPORTION
{
    DWRITE_PANOSE_PROPORTION_ANY = 0,
    DWRITE_PANOSE_PROPORTION_NO_FIT = 1,
    DWRITE_PANOSE_PROPORTION_OLD_STYLE = 2,
    DWRITE_PANOSE_PROPORTION_MODERN = 3,
    DWRITE_PANOSE_PROPORTION_EVEN_WIDTH = 4,
    DWRITE_PANOSE_PROPORTION_EXPANDED = 5,
    DWRITE_PANOSE_PROPORTION_CONDENSED = 6,
    DWRITE_PANOSE_PROPORTION_VERY_EXPANDED = 7,
    DWRITE_PANOSE_PROPORTION_VERY_CONDENSED = 8,
    DWRITE_PANOSE_PROPORTION_MONOSPACED = 9
} DWRITE_PANOSE_PROPORTION;

/// <summary>
/// Ratio between thickest and thinnest point of the stroke for a letter such
/// as uppercase 'O'.
/// Present for families: 2-text, 3-script, 4-decorative
/// </summary>
typedef enum DWRITE_PANOSE_CONTRAST
{
    DWRITE_PANOSE_CONTRAST_ANY = 0,
    DWRITE_PANOSE_CONTRAST_NO_FIT = 1,
    DWRITE_PANOSE_CONTRAST_NONE = 2,
    DWRITE_PANOSE_CONTRAST_VERY_LOW = 3,
    DWRITE_PANOSE_CONTRAST_LOW = 4,
    DWRITE_PANOSE_CONTRAST_MEDIUM_LOW = 5,
    DWRITE_PANOSE_CONTRAST_MEDIUM = 6,
    DWRITE_PANOSE_CONTRAST_MEDIUM_HIGH = 7,
    DWRITE_PANOSE_CONTRAST_HIGH = 8,
    DWRITE_PANOSE_CONTRAST_VERY_HIGH = 9,
    DWRITE_PANOSE_CONTRAST_HORIZONTAL_LOW = 10,
    DWRITE_PANOSE_CONTRAST_HORIZONTAL_MEDIUM = 11,
    DWRITE_PANOSE_CONTRAST_HORIZONTAL_HIGH = 12,
    DWRITE_PANOSE_CONTRAST_BROKEN = 13
} DWRITE_PANOSE_CONTRAST;

/// <summary>
/// Relationship between thin and thick stems.
/// Present for families: 2-text
/// </summary>
typedef enum DWRITE_PANOSE_STROKE_VARIATION
{
    DWRITE_PANOSE_STROKE_VARIATION_ANY = 0,
    DWRITE_PANOSE_STROKE_VARIATION_NO_FIT = 1,
    DWRITE_PANOSE_STROKE_VARIATION_NO_VARIATION = 2,
    DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_DIAGONAL = 3,
    DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_TRANSITIONAL = 4,
    DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_VERTICAL = 5,
    DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_HORIZONTAL = 6,
    DWRITE_PANOSE_STROKE_VARIATION_RAPID_VERTICAL = 7,
    DWRITE_PANOSE_STROKE_VARIATION_RAPID_HORIZONTAL = 8,
    DWRITE_PANOSE_STROKE_VARIATION_INSTANT_VERTICAL = 9,
    DWRITE_PANOSE_STROKE_VARIATION_INSTANT_HORIZONTAL = 10
} DWRITE_PANOSE_STROKE_VARIATION;

/// <summary>
/// Style of termination of stems and rounded letterforms.
/// Present for families: 2-text
/// </summary>
typedef enum DWRITE_PANOSE_ARM_STYLE
{
    DWRITE_PANOSE_ARM_STYLE_ANY = 0,
    DWRITE_PANOSE_ARM_STYLE_NO_FIT = 1,
    DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_HORIZONTAL = 2,
    DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_WEDGE = 3,
    DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_VERTICAL = 4,
    DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_SINGLE_SERIF = 5,
    DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_DOUBLE_SERIF = 6,
    DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_HORIZONTAL = 7,
    DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_WEDGE = 8,
    DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_VERTICAL = 9,
    DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_SINGLE_SERIF = 10,
    DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_DOUBLE_SERIF = 11,
    DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_HORZ = 2, // DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_HORIZONTAL,
    DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_VERT = 4, //DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_VERTICAL,
    DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_HORZ = 7, //DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_HORIZONTAL,
    DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_WEDGE = 8, // DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_WEDGE,
    DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_VERT = 9, //DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_VERTICAL,
    DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_SINGLE_SERIF = 10, //DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_SINGLE_SERIF,
    DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_DOUBLE_SERIF = 11 //DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_DOUBLE_SERIF
} DWRITE_PANOSE_ARM_STYLE;

/// <summary>
/// Roundness of letterform.
/// Present for families: 2-text
/// </summary>
typedef enum DWRITE_PANOSE_LETTERFORM
{
    DWRITE_PANOSE_LETTERFORM_ANY = 0,
    DWRITE_PANOSE_LETTERFORM_NO_FIT = 1,
    DWRITE_PANOSE_LETTERFORM_NORMAL_CONTACT = 2,
    DWRITE_PANOSE_LETTERFORM_NORMAL_WEIGHTED = 3,
    DWRITE_PANOSE_LETTERFORM_NORMAL_BOXED = 4,
    DWRITE_PANOSE_LETTERFORM_NORMAL_FLATTENED = 5,
    DWRITE_PANOSE_LETTERFORM_NORMAL_ROUNDED = 6,
    DWRITE_PANOSE_LETTERFORM_NORMAL_OFF_CENTER = 7,
    DWRITE_PANOSE_LETTERFORM_NORMAL_SQUARE = 8,
    DWRITE_PANOSE_LETTERFORM_OBLIQUE_CONTACT = 9,
    DWRITE_PANOSE_LETTERFORM_OBLIQUE_WEIGHTED = 10,
    DWRITE_PANOSE_LETTERFORM_OBLIQUE_BOXED = 11,
    DWRITE_PANOSE_LETTERFORM_OBLIQUE_FLATTENED = 12,
    DWRITE_PANOSE_LETTERFORM_OBLIQUE_ROUNDED = 13,
    DWRITE_PANOSE_LETTERFORM_OBLIQUE_OFF_CENTER = 14,
    DWRITE_PANOSE_LETTERFORM_OBLIQUE_SQUARE = 15
} DWRITE_PANOSE_LETTERFORM;

/// <summary>
/// Placement of midline across uppercase characters and treatment of diagonal
/// stem apexes.
/// Present for families: 2-text
/// </summary>
typedef enum DWRITE_PANOSE_MIDLINE
{
    DWRITE_PANOSE_MIDLINE_ANY = 0,
    DWRITE_PANOSE_MIDLINE_NO_FIT = 1,
    DWRITE_PANOSE_MIDLINE_STANDARD_TRIMMED = 2,
    DWRITE_PANOSE_MIDLINE_STANDARD_POINTED = 3,
    DWRITE_PANOSE_MIDLINE_STANDARD_SERIFED = 4,
    DWRITE_PANOSE_MIDLINE_HIGH_TRIMMED = 5,
    DWRITE_PANOSE_MIDLINE_HIGH_POINTED = 6,
    DWRITE_PANOSE_MIDLINE_HIGH_SERIFED = 7,
    DWRITE_PANOSE_MIDLINE_CONSTANT_TRIMMED = 8,
    DWRITE_PANOSE_MIDLINE_CONSTANT_POINTED = 9,
    DWRITE_PANOSE_MIDLINE_CONSTANT_SERIFED = 10,
    DWRITE_PANOSE_MIDLINE_LOW_TRIMMED = 11,
    DWRITE_PANOSE_MIDLINE_LOW_POINTED = 12,
    DWRITE_PANOSE_MIDLINE_LOW_SERIFED = 13
} DWRITE_PANOSE_MIDLINE;

/// <summary>
/// Relative size of lowercase letters and treament of diacritic marks
/// and uppercase glyphs.
/// Present for families: 2-text
/// </summary>
typedef enum DWRITE_PANOSE_XHEIGHT
{
    DWRITE_PANOSE_XHEIGHT_ANY = 0,
    DWRITE_PANOSE_XHEIGHT_NO_FIT = 1,
    DWRITE_PANOSE_XHEIGHT_CONSTANT_SMALL = 2,
    DWRITE_PANOSE_XHEIGHT_CONSTANT_STANDARD = 3,
    DWRITE_PANOSE_XHEIGHT_CONSTANT_LARGE = 4,
    DWRITE_PANOSE_XHEIGHT_DUCKING_SMALL = 5,
    DWRITE_PANOSE_XHEIGHT_DUCKING_STANDARD = 6,
    DWRITE_PANOSE_XHEIGHT_DUCKING_LARGE = 7,
    DWRITE_PANOSE_XHEIGHT_CONSTANT_STD = 3, // DWRITE_PANOSE_XHEIGHT_CONSTANT_STANDARD,
    DWRITE_PANOSE_XHEIGHT_DUCKING_STD = 6 //DWRITE_PANOSE_XHEIGHT_DUCKING_STANDARD
} DWRITE_PANOSE_XHEIGHT;

/// <summary>
/// Kind of tool used to create character forms.
/// Present for families: 3-script
/// </summary>
typedef enum DWRITE_PANOSE_TOOL_KIND
{
    DWRITE_PANOSE_TOOL_KIND_ANY = 0,
    DWRITE_PANOSE_TOOL_KIND_NO_FIT = 1,
    DWRITE_PANOSE_TOOL_KIND_FLAT_NIB = 2,
    DWRITE_PANOSE_TOOL_KIND_PRESSURE_POINT = 3,
    DWRITE_PANOSE_TOOL_KIND_ENGRAVED = 4,
    DWRITE_PANOSE_TOOL_KIND_BALL = 5,
    DWRITE_PANOSE_TOOL_KIND_BRUSH = 6,
    DWRITE_PANOSE_TOOL_KIND_ROUGH = 7,
    DWRITE_PANOSE_TOOL_KIND_FELT_PEN_BRUSH_TIP = 8,
    DWRITE_PANOSE_TOOL_KIND_WILD_BRUSH = 9
} DWRITE_PANOSE_TOOL_KIND;

/// <summary>
/// Monospace vs proportional.
/// Present for families: 3-script, 5-symbol
/// </summary>
typedef enum DWRITE_PANOSE_SPACING
{
    DWRITE_PANOSE_SPACING_ANY = 0,
    DWRITE_PANOSE_SPACING_NO_FIT = 1,
    DWRITE_PANOSE_SPACING_PROPORTIONAL_SPACED = 2,
    DWRITE_PANOSE_SPACING_MONOSPACED = 3,
} DWRITE_PANOSE_SPACING;

/// <summary>
/// Ratio between width and height of the face.
/// Present for families: 3-script
/// </summary>
typedef enum DWRITE_PANOSE_ASPECT_RATIO
{
    DWRITE_PANOSE_ASPECT_RATIO_ANY = 0,
    DWRITE_PANOSE_ASPECT_RATIO_NO_FIT = 1,
    DWRITE_PANOSE_ASPECT_RATIO_VERY_CONDENSED = 2,
    DWRITE_PANOSE_ASPECT_RATIO_CONDENSED = 3,
    DWRITE_PANOSE_ASPECT_RATIO_NORMAL = 4,
    DWRITE_PANOSE_ASPECT_RATIO_EXPANDED = 5,
    DWRITE_PANOSE_ASPECT_RATIO_VERY_EXPANDED = 6
} DWRITE_PANOSE_ASPECT_RATIO;

/// <summary>
/// Topology of letterforms.
/// Present for families: 3-script
/// </summary>
typedef enum DWRITE_PANOSE_SCRIPT_TOPOLOGY
{
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_ANY = 0,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_NO_FIT = 1,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_DISCONNECTED = 2,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_TRAILING = 3,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_CONNECTED = 4,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_DISCONNECTED = 5,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_TRAILING = 6,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_CONNECTED = 7,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_DISCONNECTED = 8,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_TRAILING = 9,
    DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_CONNECTED = 10
} DWRITE_PANOSE_SCRIPT_TOPOLOGY;

/// <summary>
/// General look of the face, considering slope and tails.
/// Present for families: 3-script
/// </summary>
typedef enum DWRITE_PANOSE_SCRIPT_FORM
{
    DWRITE_PANOSE_SCRIPT_FORM_ANY = 0,
    DWRITE_PANOSE_SCRIPT_FORM_NO_FIT = 1,
    DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_NO_WRAPPING = 2,
    DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_SOME_WRAPPING = 3,
    DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_MORE_WRAPPING = 4,
    DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_EXTREME_WRAPPING = 5,
    DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_NO_WRAPPING = 6,
    DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_SOME_WRAPPING = 7,
    DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_MORE_WRAPPING = 8,
    DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_EXTREME_WRAPPING = 9,
    DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_NO_WRAPPING = 10,
    DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_SOME_WRAPPING = 11,
    DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_MORE_WRAPPING = 12,
    DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_EXTREME_WRAPPING = 13
} DWRITE_PANOSE_SCRIPT_FORM;

/// <summary>
/// How character ends and miniscule ascenders are treated.
/// Present for families: 3-script
/// </summary>
typedef enum DWRITE_PANOSE_FINIALS
{
    DWRITE_PANOSE_FINIALS_ANY = 0,
    DWRITE_PANOSE_FINIALS_NO_FIT = 1,
    DWRITE_PANOSE_FINIALS_NONE_NO_LOOPS = 2,
    DWRITE_PANOSE_FINIALS_NONE_CLOSED_LOOPS = 3,
    DWRITE_PANOSE_FINIALS_NONE_OPEN_LOOPS = 4,
    DWRITE_PANOSE_FINIALS_SHARP_NO_LOOPS = 5,
    DWRITE_PANOSE_FINIALS_SHARP_CLOSED_LOOPS = 6,
    DWRITE_PANOSE_FINIALS_SHARP_OPEN_LOOPS = 7,
    DWRITE_PANOSE_FINIALS_TAPERED_NO_LOOPS = 8,
    DWRITE_PANOSE_FINIALS_TAPERED_CLOSED_LOOPS = 9,
    DWRITE_PANOSE_FINIALS_TAPERED_OPEN_LOOPS = 10,
    DWRITE_PANOSE_FINIALS_ROUND_NO_LOOPS = 11,
    DWRITE_PANOSE_FINIALS_ROUND_CLOSED_LOOPS = 12,
    DWRITE_PANOSE_FINIALS_ROUND_OPEN_LOOPS = 13
} DWRITE_PANOSE_FINIALS;

/// <summary>
/// Relative size of the lowercase letters.
/// Present for families: 3-script
/// </summary>
typedef enum DWRITE_PANOSE_XASCENT
{
    DWRITE_PANOSE_XASCENT_ANY = 0,
    DWRITE_PANOSE_XASCENT_NO_FIT = 1,
    DWRITE_PANOSE_XASCENT_VERY_LOW = 2,
    DWRITE_PANOSE_XASCENT_LOW = 3,
    DWRITE_PANOSE_XASCENT_MEDIUM = 4,
    DWRITE_PANOSE_XASCENT_HIGH = 5,
    DWRITE_PANOSE_XASCENT_VERY_HIGH = 6
} DWRITE_PANOSE_XASCENT;

/// <summary>
/// General look of the face.
/// Present for families: 4-decorative
/// </summary>
typedef enum DWRITE_PANOSE_DECORATIVE_CLASS
{
    DWRITE_PANOSE_DECORATIVE_CLASS_ANY = 0,
    DWRITE_PANOSE_DECORATIVE_CLASS_NO_FIT = 1,
    DWRITE_PANOSE_DECORATIVE_CLASS_DERIVATIVE = 2,
    DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_TOPOLOGY = 3,
    DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_ELEMENTS = 4,
    DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_ASPECT = 5,
    DWRITE_PANOSE_DECORATIVE_CLASS_INITIALS = 6,
    DWRITE_PANOSE_DECORATIVE_CLASS_CARTOON = 7,
    DWRITE_PANOSE_DECORATIVE_CLASS_PICTURE_STEMS = 8,
    DWRITE_PANOSE_DECORATIVE_CLASS_ORNAMENTED = 9,
    DWRITE_PANOSE_DECORATIVE_CLASS_TEXT_AND_BACKGROUND = 10,
    DWRITE_PANOSE_DECORATIVE_CLASS_COLLAGE = 11,
    DWRITE_PANOSE_DECORATIVE_CLASS_MONTAGE = 12
} DWRITE_PANOSE_DECORATIVE_CLASS;

/// <summary>
/// Ratio between the width and height of the face.
/// Present for families: 4-decorative
/// </summary>
typedef enum DWRITE_PANOSE_ASPECT
{
    DWRITE_PANOSE_ASPECT_ANY = 0,
    DWRITE_PANOSE_ASPECT_NO_FIT = 1,
    DWRITE_PANOSE_ASPECT_SUPER_CONDENSED = 2,
    DWRITE_PANOSE_ASPECT_VERY_CONDENSED = 3,
    DWRITE_PANOSE_ASPECT_CONDENSED = 4,
    DWRITE_PANOSE_ASPECT_NORMAL = 5,
    DWRITE_PANOSE_ASPECT_EXTENDED = 6,
    DWRITE_PANOSE_ASPECT_VERY_EXTENDED = 7,
    DWRITE_PANOSE_ASPECT_SUPER_EXTENDED = 8,
    DWRITE_PANOSE_ASPECT_MONOSPACED = 9
} DWRITE_PANOSE_ASPECT;

/// <summary>
/// Type of fill/line (treatment).
/// Present for families: 4-decorative
/// </summary>
typedef enum DWRITE_PANOSE_FILL
{
    DWRITE_PANOSE_FILL_ANY = 0,
    DWRITE_PANOSE_FILL_NO_FIT = 1,
    DWRITE_PANOSE_FILL_STANDARD_SOLID_FILL = 2,
    DWRITE_PANOSE_FILL_NO_FILL = 3,
    DWRITE_PANOSE_FILL_PATTERNED_FILL = 4,
    DWRITE_PANOSE_FILL_COMPLEX_FILL = 5,
    DWRITE_PANOSE_FILL_SHAPED_FILL = 6,
    DWRITE_PANOSE_FILL_DRAWN_DISTRESSED = 7,
} DWRITE_PANOSE_FILL;

/// <summary>
/// Outline handling.
/// Present for families: 4-decorative
/// </summary>
typedef enum DWRITE_PANOSE_LINING
{
    DWRITE_PANOSE_LINING_ANY = 0,
    DWRITE_PANOSE_LINING_NO_FIT = 1,
    DWRITE_PANOSE_LINING_NONE = 2,
    DWRITE_PANOSE_LINING_INLINE = 3,
    DWRITE_PANOSE_LINING_OUTLINE = 4,
    DWRITE_PANOSE_LINING_ENGRAVED = 5,
    DWRITE_PANOSE_LINING_SHADOW = 6,
    DWRITE_PANOSE_LINING_RELIEF = 7,
    DWRITE_PANOSE_LINING_BACKDROP = 8
} DWRITE_PANOSE_LINING;

/// <summary>
/// Overall shape characteristics of the font.
/// Present for families: 4-decorative
/// </summary>
typedef enum DWRITE_PANOSE_DECORATIVE_TOPOLOGY
{
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_ANY = 0,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_NO_FIT = 1,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_STANDARD = 2,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_SQUARE = 3,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_MULTIPLE_SEGMENT = 4,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_ART_DECO = 5,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_UNEVEN_WEIGHTING = 6,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_DIVERSE_ARMS = 7,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_DIVERSE_FORMS = 8,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_LOMBARDIC_FORMS = 9,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_UPPER_CASE_IN_LOWER_CASE = 10,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_IMPLIED_TOPOLOGY = 11,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_HORSESHOE_E_AND_A = 12,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_CURSIVE = 13,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_BLACKLETTER = 14,
    DWRITE_PANOSE_DECORATIVE_TOPOLOGY_SWASH_VARIANCE = 15
} DWRITE_PANOSE_DECORATIVE_TOPOLOGY;

/// <summary>
/// Type of characters available in the font.
/// Present for families: 4-decorative
/// </summary>
typedef enum DWRITE_PANOSE_CHARACTER_RANGES
{
    DWRITE_PANOSE_CHARACTER_RANGES_ANY = 0,
    DWRITE_PANOSE_CHARACTER_RANGES_NO_FIT = 1,
    DWRITE_PANOSE_CHARACTER_RANGES_EXTENDED_COLLECTION = 2,
    DWRITE_PANOSE_CHARACTER_RANGES_LITERALS = 3,
    DWRITE_PANOSE_CHARACTER_RANGES_NO_LOWER_CASE = 4,
    DWRITE_PANOSE_CHARACTER_RANGES_SMALL_CAPS = 5
} DWRITE_PANOSE_CHARACTER_RANGES;

/// <summary>
/// Kind of symbol set.
/// Present for families: 5-symbol
/// </summary>
typedef enum DWRITE_PANOSE_SYMBOL_KIND
{
    DWRITE_PANOSE_SYMBOL_KIND_ANY = 0,
    DWRITE_PANOSE_SYMBOL_KIND_NO_FIT = 1,
    DWRITE_PANOSE_SYMBOL_KIND_MONTAGES = 2,
    DWRITE_PANOSE_SYMBOL_KIND_PICTURES = 3,
    DWRITE_PANOSE_SYMBOL_KIND_SHAPES = 4,
    DWRITE_PANOSE_SYMBOL_KIND_SCIENTIFIC = 5,
    DWRITE_PANOSE_SYMBOL_KIND_MUSIC = 6,
    DWRITE_PANOSE_SYMBOL_KIND_EXPERT = 7,
    DWRITE_PANOSE_SYMBOL_KIND_PATTERNS = 8,
    DWRITE_PANOSE_SYMBOL_KIND_BOARDERS = 9,
    DWRITE_PANOSE_SYMBOL_KIND_ICONS = 10,
    DWRITE_PANOSE_SYMBOL_KIND_LOGOS = 11,
    DWRITE_PANOSE_SYMBOL_KIND_INDUSTRY_SPECIFIC = 12
} DWRITE_PANOSE_SYMBOL_KIND;

/// <summary>
/// Aspect ratio of symbolic characters.
/// Present for families: 5-symbol
/// </summary>
typedef enum DWRITE_PANOSE_SYMBOL_ASPECT_RATIO
{
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_ANY = 0,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NO_FIT = 1,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NO_WIDTH = 2,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_EXCEPTIONALLY_WIDE = 3,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_SUPER_WIDE = 4,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_VERY_WIDE = 5,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_WIDE = 6,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NORMAL = 7,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NARROW = 8,
    DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_VERY_NARROW = 9
} DWRITE_PANOSE_SYMBOL_ASPECT_RATIO;

/// <summary>
/// Specifies the policy used by GetRecommendedRenderingMode to determine whether to 
/// render glyphs in outline mode. Glyphs are rendered in outline mode by default at
/// large sizes for performance reasons, but how large (i.e., the outline threshold)
/// depends on the quality of outline rendering. If the graphics system renders anti-
/// aliased outlines then a relatively low threshold is used, but if the graphics
/// system renders aliased outlines then a much higher threshold is used.
/// </summary>
typedef enum DWRITE_OUTLINE_THRESHOLD
{
    DWRITE_OUTLINE_THRESHOLD_ANTIALIASED,
    DWRITE_OUTLINE_THRESHOLD_ALIASED
} DWRITE_OUTLINE_THRESHOLD;

/// <summary>
/// Baseline for text alignment.
/// </summary>
typedef enum DWRITE_BASELINE
{
    /// <summary>
    /// The Roman baseline for horizontal, Central baseline for vertical.
    /// </summary>
    DWRITE_BASELINE_DEFAULT,

    /// <summary>
    /// The baseline used by alphabetic scripts such as Latin, Greek, Cyrillic.
    /// </summary>
    DWRITE_BASELINE_ROMAN,

    /// <summary>
    /// Central baseline, generally used for vertical text.
    /// </summary>
    DWRITE_BASELINE_CENTRAL,

    /// <summary>
    /// Mathematical baseline which math characters are centered on.
    /// </summary>
    DWRITE_BASELINE_MATH,

    /// <summary>
    /// Hanging baseline, used in scripts like Devanagari.
    /// </summary>
    DWRITE_BASELINE_HANGING,

    /// <summary>
    /// Ideographic bottom baseline for CJK, left in vertical.
    /// </summary>
    DWRITE_BASELINE_IDEOGRAPHIC_BOTTOM,

    /// <summary>
    /// Ideographic top baseline for CJK, right in vertical.
    /// </summary>
    DWRITE_BASELINE_IDEOGRAPHIC_TOP,

    /// <summary>
    /// The bottom-most extent in horizontal, left-most in vertical.
    /// </summary>
    DWRITE_BASELINE_MINIMUM,

    /// <summary>
    /// The top-most extent in horizontal, right-most in vertical.
    /// </summary>
    DWRITE_BASELINE_MAXIMUM,
} DWRITE_BASELINE;

/// <summary>
/// The desired kind of glyph orientation for the text. The client specifies
/// this to the analyzer as the desired orientation, but note this is the
/// client preference, and the constraints of the script will determine the
/// final presentation.
/// </summary>
typedef enum DWRITE_VERTICAL_GLYPH_ORIENTATION
{
    /// <summary>
    /// In vertical layout, naturally horizontal scripts (Latin, Thai, Arabic,
    /// Devanagari) rotate 90 degrees clockwise, while ideographic scripts
    /// (Chinese, Japanese, Korean) remain upright, 0 degrees.
    /// </summary>
    DWRITE_VERTICAL_GLYPH_ORIENTATION_DEFAULT,

    /// <summary>
    /// Ideographic scripts and scripts that permit stacking
    /// (Latin, Hebrew) are stacked in vertical reading layout.
    /// Connected scripts (Arabic, Syriac, 'Phags-pa, Ogham),
    /// which would otherwise look broken if glyphs were kept
    /// at 0 degrees, remain connected and rotate.
    /// </summary>
    DWRITE_VERTICAL_GLYPH_ORIENTATION_STACKED,
} DWRITE_VERTICAL_GLYPH_ORIENTATION;

/// <summary>
/// How the glyph is oriented to the x-axis. This is an output from the text
/// analyzer, dependent on the desired orientation, bidi level, and character
/// properties.
/// </summary>
typedef enum DWRITE_GLYPH_ORIENTATION_ANGLE
{
    /// <summary>
    /// Glyph orientation is upright.
    /// </summary>
    DWRITE_GLYPH_ORIENTATION_ANGLE_0_DEGREES,

    /// <summary>
    /// Glyph orientation is rotated 90 clockwise.
    /// </summary>
    DWRITE_GLYPH_ORIENTATION_ANGLE_90_DEGREES,

    /// <summary>
    /// Glyph orientation is upside-down.
    /// </summary>
    DWRITE_GLYPH_ORIENTATION_ANGLE_180_DEGREES,

    /// <summary>
    /// Glyph orientation is rotated 270 clockwise.
    /// </summary>
    DWRITE_GLYPH_ORIENTATION_ANGLE_270_DEGREES,
} DWRITE_GLYPH_ORIENTATION_ANGLE;


typedef struct DWRITE_FONT_METRICS1 //: public DWRITE_FONT_METRICS
{

    short designUnitsPerEm;

    short ascent;

    short descent;

    short lineGap;

    short capHeight;

    short xHeight;

    short underlinePosition;

    short underlineThickness;

    short strikethroughPosition;

    short strikethroughThickness;

    /// <summary>
    /// Left edge of accumulated bounding blackbox of all glyphs in the font.
    /// </summary>
    INT16 glyphBoxLeft;

/// <summary>
/// Top edge of accumulated bounding blackbox of all glyphs in the font.
/// </summary>
INT16 glyphBoxTop;

/// <summary>
/// Right edge of accumulated bounding blackbox of all glyphs in the font.
/// </summary>
INT16 glyphBoxRight;

/// <summary>
/// Bottom edge of accumulated bounding blackbox of all glyphs in the font.
/// </summary>
INT16 glyphBoxBottom;

/// <summary>
/// Horizontal position of the subscript relative to the baseline origin.
/// This is typically negative (to the left) in italic/oblique fonts, and
/// zero in regular fonts.
/// </summary>
INT16 subscriptPositionX;

/// <summary>
/// Vertical position of the subscript relative to the baseline.
/// This is typically negative.
/// </summary>
INT16 subscriptPositionY;

/// <summary>
/// Horizontal size of the subscript em box in design units, used to
/// scale the simulated subscript relative to the full em box size.
/// This the numerator of the scaling ratio where denominator is the
/// design units per em. If this member is zero, the font does not specify
/// a scale factor, and the client should use its own policy.
/// </summary>
INT16 subscriptSizeX;

/// <summary>
/// Vertical size of the subscript em box in design units, used to
/// scale the simulated subscript relative to the full em box size.
/// This the numerator of the scaling ratio where denominator is the
/// design units per em. If this member is zero, the font does not specify
/// a scale factor, and the client should use its own policy.
/// </summary>
INT16 subscriptSizeY;

/// <summary>
/// Horizontal position of the superscript relative to the baseline origin.
/// This is typically positive (to the right) in italic/oblique fonts, and
/// zero in regular fonts.
/// </summary>
INT16 superscriptPositionX;

/// <summary>
/// Vertical position of the superscript relative to the baseline.
/// This is typically positive.
/// </summary>
INT16 superscriptPositionY;

/// <summary>
/// Horizontal size of the superscript em box in design units, used to
/// scale the simulated superscript relative to the full em box size.
/// This the numerator of the scaling ratio where denominator is the
/// design units per em. If this member is zero, the font does not specify
/// a scale factor, and the client should use its own policy.
/// </summary>
INT16 superscriptSizeX;

/// <summary>
/// Vertical size of the superscript em box in design units, used to
/// scale the simulated superscript relative to the full em box size.
/// This the numerator of the scaling ratio where denominator is the
/// design units per em. If this member is zero, the font does not specify
/// a scale factor, and the client should use its own policy.
/// </summary>
INT16 superscriptSizeY;

/// <summary>
/// Indicates that the ascent, descent, and lineGap are based on newer 
/// 'typographic' values in the font, rather than legacy values.
/// </summary>
BOOL hasTypographicMetrics;
} DWRITE_FONT_METRICS1;


/// <summary>
/// Metrics for caret placement in a font.
/// </summary>
typedef struct DWRITE_CARET_METRICS
{
    /// <summary>
    /// Vertical rise of the caret. Rise / Run yields the caret angle.
    /// Rise = 1 for perfectly upright fonts (non-italic).
    /// </summary>
    INT16 slopeRise;

    /// <summary>
    /// Horizontal run of th caret. Rise / Run yields the caret angle.
    /// Run = 0 for perfectly upright fonts (non-italic).
    /// </summary>
    INT16 slopeRun;

    /// <summary>
    /// Horizontal offset of the caret along the baseline for good appearance.
    /// Offset = 0 for perfectly upright fonts (non-italic).
    /// </summary>
    INT16 offset;
} DWRITE_CARET_METRICS;


/// <summary>
/// Typeface classification values, used for font selection and matching.
/// </summary>
/// <remarks>
/// Note the family type (index 0) is the only stable entry in the 10-byte
/// array, as all the following entries can change dynamically depending on
/// context of the first field.
/// </remarks>
typedef struct /* union */ DWRITE_PANOSE
{
    UINT8 values[10];
/*
    UINT8 familyKind; // this is the only field that never changes meaning

    struct
    {
        UINT8 familyKind; // = 2 for text
        UINT8 serifStyle;
        UINT8 weight;
        UINT8 proportion;
        UINT8 contrast;
        UINT8 strokeVariation;
        UINT8 armStyle;
        UINT8 letterform;
        UINT8 midline;
        UINT8 xHeight;
    } text;

    struct
    {
        UINT8 familyKind; // = 3 for script
        UINT8 toolKind;
        UINT8 weight;
        UINT8 spacing;
        UINT8 aspectRatio;
        UINT8 contrast;
        UINT8 scriptTopology;
        UINT8 scriptForm;
        UINT8 finials;
        UINT8 xAscent;
    } script;

    struct
    {
        UINT8 familyKind; // = 4 for decorative
        UINT8 decorativeClass;
        UINT8 weight;
        UINT8 aspect;
        UINT8 contrast;
        UINT8 serifVariant;
        UINT8 fill; // treatment
        UINT8 lining;
        UINT8 decorativeTopology;
        UINT8 characterRange;
    } decorative;

    struct
    {
        UINT8 familyKind; // = 5 for symbol
        UINT8 symbolKind;
        UINT8 weight;
        UINT8 spacing;
        UINT8 aspectRatioAndContrast; // hard coded to no-fit (1)
        UINT8 aspectRatio94;
        UINT8 aspectRatio119;
        UINT8 aspectRatio157;
        UINT8 aspectRatio163;
        UINT8 aspectRatio211;
    } symbol;
*/
} DWRITE_PANOSE;


/// <summary>
/// Range of Unicode codepoints.
/// </summary>
typedef struct DWRITE_UNICODE_RANGE
{
    /// <summary>
    /// The first codepoint in the Unicode range.
    /// </summary>
    UINT32 first;

    /// <summary>
    /// The last codepoint in the Unicode range.
    /// </summary>
    UINT32 last;
} DWRITE_UNICODE_RANGE;


/// <summary>
/// Script-specific properties for caret navigation and justification.
/// </summary>
typedef struct DWRITE_SCRIPT_PROPERTIES
{
    /// <summary>
    /// The standardized four character code for the given script.
    /// Note these only include the general Unicode scripts, not any
    /// additional ISO 15924 scripts for bibliographic distinction
    /// (for example, Fraktur Latin vs Gaelic Latin).
    /// http://unicode.org/iso15924/iso15924-codes.html
    /// </summary>
    UINT32 isoScriptCode;

    /// <summary>
    /// The standardized numeric code, ranging 0-999.
    /// http://unicode.org/iso15924/iso15924-codes.html
    /// </summary>
    UINT32 isoScriptNumber;

    /// <summary>
    /// Number of characters to estimate look-ahead for complex scripts.
    /// Latin and all Kana are generally 1. Indic scripts are up to 15,
    /// and most others are 8. Note that combining marks and variation
    /// selectors can produce clusters longer than these look-aheads,
    /// so this estimate is considered typical language use. Diacritics
    /// must be tested explicitly separately.
    /// </summary>
    UINT32 clusterLookahead;

    /// <summary>
    /// Appropriate character to elongate the given script for justification.
    ///
    /// Examples:
    ///   Arabic    - U+0640 Tatweel
    ///   Ogham     - U+1680 Ogham Space Mark
    /// </summary>
    UINT32 justificationCharacter;

    UINT32 Bitfield;

    /*
    /// <summary>
    /// Restrict the caret to whole clusters, like Thai and Devanagari. Scripts
    /// such as Arabic by default allow navigation between clusters. Others
    /// like Thai always navigate across whole clusters.
    /// </summary>
    UINT32 restrictCaretToClusters : 1;

    /// <summary>
    /// The language uses dividers between words, such as spaces between Latin
    /// or the Ethiopic wordspace.
    ///
    /// Examples: Latin, Greek, Devanagari, Ethiopic
    /// Excludes: Chinese, Korean, Thai.
    /// </summary>
    UINT32 usesWordDividers : 1;

    /// <summary>
    /// The characters are discrete units from each other. This includes both
    /// block scripts and clustered scripts.
    ///
    /// Examples: Latin, Greek, Cyrillic, Hebrew, Chinese, Thai
    /// </summary>
    UINT32 isDiscreteWriting : 1;

    /// <summary>
    /// The language is a block script, expanding between characters.
    ///
    /// Examples: Chinese, Japanese, Korean, Bopomofo.
    /// </summary>
    UINT32 isBlockWriting : 1;

    /// <summary>
    /// The language is justified within glyph clusters, not just between glyph
    /// clusters. One such as the character sequence is Thai Lu and Sara Am
    /// (U+E026, U+E033) which form a single cluster but still expand between
    /// them.
    ///
    /// Examples: Thai, Lao, Khmer
    /// </summary>
    UINT32 isDistributedWithinCluster : 1;

    /// <summary>
    /// The script's clusters are connected to each other (such as the
    /// baseline-linked Devanagari), and no separation should be added
    /// between characters. Note that cursively linked scripts like Arabic
    /// are also connected (but not all connected scripts are
    /// cursive).
    /// 
    /// Examples: Devanagari, Arabic, Syriac, Bengali, Gurmukhi, Ogham
    /// Excludes: Latin, Chinese, Thaana
    /// </summary>
    UINT32 isConnectedWriting : 1;

    /// <summary>
    /// The script is naturally cursive (Arabic/Syriac), meaning it uses other
    /// justification methods like kashida extension rather than intercharacter
    /// spacing. Note that although other scripts like Latin and Japanese may
    /// actually support handwritten cursive forms, they are not considered
    /// cursive scripts.
    /// 
    /// Examples: Arabic, Syriac, Mongolian
    /// Excludes: Thaana, Devanagari, Latin, Chinese
    /// </summary>
    UINT32 isCursiveWriting : 1;

    UINT32 reserved : 25;
    */
} DWRITE_SCRIPT_PROPERTIES;


/// <summary>
/// Justification information per glyph.
/// </summary>
typedef struct DWRITE_JUSTIFICATION_OPPORTUNITY
{
    /// <summary>
    /// Minimum amount of expansion to apply to the side of the glyph.
    /// This may vary from 0 to infinity, typically being zero except
    /// for kashida.
    /// </summary>
    FLOAT expansionMinimum;

    /// <summary>
    /// Maximum amount of expansion to apply to the side of the glyph.
    /// This may vary from 0 to infinity, being zero for fixed-size characters
    /// and connected scripts, and non-zero for discrete scripts, and non-zero
    /// for cursive scripts at expansion points.
    /// </summary>
    FLOAT expansionMaximum;

    /// <summary>
    /// Maximum amount of compression to apply to the side of the glyph.
    /// This may vary from 0 up to the glyph cluster size.
    /// </summary>
    FLOAT compressionMaximum;


    UINT32 Bitfield;
    /*
    /// <summary>
    /// Priority of this expansion point. Larger priorities are applied later,
    /// while priority zero does nothing.
    /// </summary>
    UINT32 expansionPriority : 8;

    /// <summary>
    /// Priority of this compression point. Larger priorities are applied later,
    /// while priority zero does nothing.
    /// </summary>
    UINT32 compressionPriority : 8;

    /// <summary>
    /// Allow this expansion point to use up any remaining slack space even
    /// after all expansion priorities have been used up.
    /// </summary>
    UINT32 allowResidualExpansion : 1;

    /// <summary>
    /// Allow this compression point to use up any remaining space even after
    /// all compression priorities have been used up.
    /// </summary>
    UINT32 allowResidualCompression : 1;

    /// <summary>
    /// Apply expansion/compression to the leading edge of the glyph. This will
    /// be false for connected scripts, fixed-size characters, and diacritics.
    /// It is generally false within a multi-glyph cluster, unless the script
    /// allows expansion of glyphs within a cluster, like Thai.
    /// </summary>
    UINT32 applyToLeadingEdge : 1;

    /// <summary>
    /// Apply expansion/compression to the trailing edge of the glyph. This will
    /// be false for connected scripts, fixed-size characters, and diacritics.
    /// It is generally false within a multi-glyph cluster, unless the script
    /// allows expansion of glyphs within a cluster, like Thai.
    /// </summary>
    UINT32 applyToTrailingEdge : 1;

    UINT32 reserved : 12;
    */
} DWRITE_JUSTIFICATION_OPPORTUNITY;


interface IDWriteTextAnalysisSource1;
interface IDWriteTextAnalysisSink1;
interface IDWriteRenderingParams1;

#define STDMETHOD(method)        HRESULT __stdcall method
#define STDMETHOD_(type,method)  type __stdcall method

/// <summary>
/// The root factory interface for all DWrite objects.
/// </summary>
[
    odl, 
    uuid(30572f99-dac6-41db-a16e-0486307e606a)
]
interface IDWriteFactory1 : IDWriteFactory
{
    /// <summary>
    /// Gets a font collection representing the set of end-user defined
    /// custom fonts.
    /// </summary>
    /// <param name="fontCollection">Receives a pointer to the EUDC font
    ///     collection object, or NULL in case of failure.</param>
    /// <param name="checkForUpdates">If this parameter is nonzero, the
    ///     function performs an immediate check for changes to the set of
    ///     EUDC fonts. If this parameter is FALSE, the function will still
    ///     detect changes, but there may be some latency. For example, an
    ///     application might specify TRUE if it has itself just modified a
    ///     font and wants to be sure the font collection contains that font.
    ///     </param>
    /// <returns>
    /// Standard HRESULT error code. Note that if no EUDC is set on the system,
    /// the returned collection will be empty, meaning it will return success
    /// but GetFontFamilyCount will be zero.
    /// </returns>
    /// <remarks>
    /// Querying via IDWriteFontCollection::FindFamilyName for a specific
    /// family (like MS Gothic) will return the matching family-specific EUDC
    /// font if one exists. Querying for "" will return the global EUDC font.
    /// For example, if you were matching an EUDC character within a run of
    /// the base font PMingLiu, you would retrieve the corresponding EUDC font
    /// face using GetEudcFontCollection, then FindFamilyName with "PMingLiu",
    /// followed by GetFontFamily and CreateFontFace.
    ///
    /// Be aware that eudcedit.exe can create placeholder empty glyphs that
    /// have zero advance width and no glyph outline. Although they are present
    /// in the font (HasCharacter returns true), you are best to ignore
    /// these and continue on with font fallback in your layout if the metrics
    /// for the glyph are zero.
    /// </remarks>
    HRESULT GetEudcFontCollection(
        [in, out] IDWriteFontCollection * *fontCollection,
        [in] BOOL checkForUpdates 
        );

/// <summary>
/// Creates a rendering parameters object with the specified properties.
/// </summary>
/// <param name="gamma">The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</param>
/// <param name="enhancedContrast">The amount of contrast enhancement, zero or greater.</param>
/// <param name="enhancedContrastGrayscale">The amount of contrast enhancement to use for grayscale antialiasing, zero or greater.</param>
/// <param name="clearTypeLevel">The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</param>
/// <param name="pixelGeometry">The geometry of a device pixel.</param>
/// <param name="renderingMode">Method of rendering glyphs. In most cases, this should be DWRITE_RENDERING_MODE_DEFAULT to automatically use an appropriate mode.</param>
/// <param name="renderingParams">Holds the newly created rendering parameters object, or NULL in case of failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
    HRESULT CreateCustomRenderingParams1(
    [in] FLOAT gamma,
    [in] FLOAT enhancedContrast,
    [in] FLOAT enhancedContrastGrayscale,
    [in] FLOAT clearTypeLevel,
    [in] DWRITE_PIXEL_GEOMETRY pixelGeometry,
    [in] DWRITE_RENDERING_MODE renderingMode,
    [in, out] IDWriteRenderingParams1** renderingParams
    );

//using IDWriteFactory::CreateCustomRenderingParams;
};


/// <summary>
/// The interface that represents an absolute reference to a font face.
/// It contains font face type, appropriate file references and face identification data.
/// Various font data such as metrics, names and glyph outlines is obtained from IDWriteFontFace.
/// </summary>
[
    odl,
    uuid(a71efdb4-9fdb-4838-ad90-cfc3be8c3daf)
]
interface IDWriteFontFace1 : IDWriteFontFace
{
    /// <summary>
    /// Gets common metrics for the font in design units.
    /// These metrics are applicable to all the glyphs within a font,
    /// and are used by applications for layout calculations.
    /// </summary>
    /// <param name="fontMetrics">Metrics structure to fill in.</param>
    STDMETHOD_(void, GetMetrics1)(
        [in, out] DWRITE_FONT_METRICS1 * fontMetrics
        );

/// <summary>
/// Gets common metrics for the font in design units.
/// These metrics are applicable to all the glyphs within a font,
/// and are used by applications for layout calculations.
/// </summary>
/// <param name="emSize">Logical size of the font in DIP units. A DIP
///     ("device-independent pixel") equals 1/96 inch.</param>
/// <param name="pixelsPerDip">Number of physical pixels per DIP. For
///     example, if the DPI of the rendering surface is 96 this value is
///     1.0f. If the DPI is 120, this value is 120.0f/96.</param>
/// <param name="transform">Optional transform applied to the glyphs and
///     their positions. This transform is applied after the scaling
///     specified by the font size and pixelsPerDip.</param>
/// <param name="fontMetrics">Font metrics structure to fill in.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetGdiCompatibleMetrics1)(
    [in] FLOAT emSize,
    [in] FLOAT pixelsPerDip,
    //_In_opt_ DWRITE_MATRIX* transform,
    [in] void* transform,
    [in, out] DWRITE_FONT_METRICS1* fontMetrics
    );

/// <summary>
/// Gets caret metrics for the font in design units. These are used by
/// text editors for drawing the correct caret placement/slant.
/// </summary>
/// <param name="caretMetrics">Metrics structure to fill in.</param>
STDMETHOD_(void, GetCaretMetrics)(
    [in, out] DWRITE_CARET_METRICS* caretMetrics
    );

/// <summary>
/// Returns the list of character ranges supported by the font, which is
/// useful for scenarios like character picking, glyph display, and
/// efficient font selection lookup. This is similar to GDI's
/// GetFontUnicodeRanges, except that it returns the full Unicode range,
/// not just 16-bit UCS-2.
/// </summary>
/// <param name="maxRangeCount">Maximum number of character ranges passed
///     in from the client.</param>
/// <param name="unicodeRanges">Array of character ranges.</param>
/// <param name="actualRangeCount">Actual number of character ranges,
///     regardless of the maximum count.</param>
/// <remarks>
/// These ranges are from the cmap, not the OS/2::ulCodePageRange1.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetUnicodeRanges)(
    [in] UINT32 maxRangeCount,
    [in, out] DWRITE_UNICODE_RANGE* unicodeRanges,
    [in, out] UINT32* actualRangeCount
    );

/// <summary>
/// Returns true if the font is monospaced, meaning its characters are the
/// same fixed-pitch width (non-proportional).
/// </summary>
STDMETHOD_(BOOL, IsMonospacedFont)();

/// <summary>
/// Returns the advances in design units for a sequences of glyphs.
/// </summary>
/// <param name="glyphCount">Number of glyphs to retrieve advances for.</param>
/// <param name="glyphIndices">Array of glyph id's to retrieve advances for.</param>
/// <param name="glyphAdvances">Returned advances in font design units for
///     each glyph.</param>
/// <param name="isSideways">Retrieve the glyph's vertical advance height
///     rather than horizontal advance widths.</param>
/// <remarks>
/// This is equivalent to calling GetGlyphMetrics and using only the
/// advance width/height.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetDesignGlyphAdvances)(
    [in] UINT32 glyphCount,
    [in] UINT16 * glyphIndices,
    [in, out] INT32* glyphAdvances,
    [in] BOOL isSideways 
    );

/// <summary>
/// Returns the pixel-aligned advances for a sequences of glyphs, the same
/// as GetGdiCompatibleGlyphMetrics would return.
/// </summary>
/// <param name="emSize">Logical size of the font in DIP units. A DIP
///     ("device-independent pixel") equals 1/96 inch.</param>
/// <param name="pixelsPerDip">Number of physical pixels per DIP. For
///     example, if the DPI of the rendering surface is 96 this value is
///     1.0f. If the DPI is 120, this value is 120.0f/96.</param>
/// <param name="transform">Optional transform applied to the glyphs and
///     their positions. This transform is applied after the scaling
///     specified by the font size and pixelsPerDip.</param>
/// <param name="useGdiNatural">When FALSE, the metrics are the same as
///     GDI aliased text (DWRITE_MEASURING_MODE_GDI_CLASSIC). When TRUE,
///     the metrics are the same as those measured by GDI using a font
///     using CLEARTYPE_NATURAL_QUALITY (DWRITE_MEASURING_MODE_GDI_NATURAL).</param>
/// <param name="isSideways">Retrieve the glyph's vertical advances rather
///     than horizontal advances.</param>
/// <param name="glyphCount">Total glyphs to retrieve adjustments for.</param>
/// <param name="glyphIndices">Array of glyph id's to retrieve advances.</param>
/// <param name="glyphAdvances">Returned advances in font design units for
///     each glyph.</param>
/// <remarks>
/// This is equivalent to calling GetGdiCompatibleGlyphMetrics and using only
/// the advance width/height. Like GetGdiCompatibleGlyphMetrics, these are in
/// design units, meaning they must be scaled down by
/// DWRITE_FONT_METRICS::designUnitsPerEm.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetGdiCompatibleGlyphAdvances)(
    [in] FLOAT emSize,
    [in] FLOAT pixelsPerDip,
    //_In_opt_ DWRITE_MATRIX* transform,
    [in] void* transform,
    [in] BOOL useGdiNatural,
    [in] BOOL isSideways,
    [in] UINT32 glyphCount,
    [in] UINT16* glyphIndices,
    [in, out] INT32* glyphAdvances
    );

/// <summary>
/// Retrieves the kerning pair adjustments from the font's kern table.
/// </summary>
/// <param name="glyphCount">Number of glyphs to retrieve adjustments for.</param>
/// <param name="glyphIndices">Array of glyph id's to retrieve adjustments
///     for.</param>
/// <param name="glyphAdvanceAdjustments">Returned advances in font design units for
///     each glyph. The last glyph adjustment is zero.</param>
/// <remarks>
/// This is not a direct replacement for GDI's character based
/// GetKerningPairs, but it serves the same role, without the client
/// needing to cache them locally. It also uses glyph id's directly
/// rather than UCS-2 characters (how the kern table actually stores
/// them) which avoids glyph collapse and ambiguity, such as the dash
/// and hyphen, or space and non-breaking space.
/// </remarks>
/// <remarks>
/// Newer fonts may have only GPOS kerning instead of the legacy pair
/// table kerning. Such fonts, like Gabriola, will only return 0's for
/// adjustments. This function does not virtualize and flatten these
/// GPOS entries into kerning pairs.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetKerningPairAdjustments)(
    [in] UINT32 glyphCount,
    [in] UINT16* glyphIndices,
    [in, out] INT32* glyphAdvanceAdjustments
    );

/// <summary>
/// Returns whether or not the font supports pair-kerning.
/// </summary>
/// <remarks>
/// If the font does not support pair table kerning, there is no need to
/// call GetKerningPairAdjustments (it would be all zeroes).
/// </remarks>
/// <returns>
/// Whether the font supports kerning pairs.
/// </returns>
STDMETHOD_(BOOL, HasKerningPairs)();

/// <summary>
/// Determines the recommended text rendering mode to be used based on the
/// font, size, world transform, and measuring mode.
/// </summary>
/// <param name="fontEmSize">Logical font size in DIPs.</param>
/// <param name="dpiX">Number of pixels per logical inch in the horizontal direction.</param>
/// <param name="dpiY">Number of pixels per logical inch in the vertical direction.</param>
/// <param name="transform">Specifies the world transform.</param>
/// <param name="outlineThreshold">Specifies the quality of the graphics system's outline rendering,
/// affects the size threshold above which outline rendering is used.</param>
/// <param name="measuringMode">Specifies the method used to measure during text layout. For proper
/// glyph spacing, the function returns a rendering mode that is compatible with the specified 
/// measuring mode.</param>
/// <param name="renderingMode">Receives the recommended rendering mode.</param>
/// <remarks>
/// This method should be used to determine the actual rendering mode in cases where the rendering 
/// mode of the rendering params object is DWRITE_RENDERING_MODE_DEFAULT.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetRecommendedRenderingMode1)(
    [in] FLOAT fontEmSize,
    [in] FLOAT dpiX,
    [in] FLOAT dpiY,
    //_In_opt_ DWRITE_MATRIX* transform,
    [in] void* transform,
    [in] BOOL isSideways,
    [in]  DWRITE_OUTLINE_THRESHOLD outlineThreshold,
    [in] DWRITE_MEASURING_MODE measuringMode,
    [in, out] DWRITE_RENDERING_MODE* renderingMode
    );

/// <summary>
/// Retrieves the vertical forms of the nominal glyphs retrieved from
/// GetGlyphIndices, using the font's 'vert' table. This is used in
/// CJK vertical layout so the correct characters are shown.
/// </summary>
/// <param name="glyphCount">Number of glyphs to retrieve.</param>
/// <param name="nominalGlyphIndices">Original glyph indices from cmap.</param>
/// <param name="verticalGlyphIndices">The vertical form of glyph indices.</param>
/// <remarks>
/// Call GetGlyphIndices to get the nominal glyph indices, followed by
/// calling this to remap the to the substituted forms, when the run
/// is sideways, and the font has vertical glyph variants.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetVerticalGlyphVariants)(
    [in] UINT32 glyphCount,
    [in] UINT16* nominalGlyphIndices,
    [in, out] UINT16* verticalGlyphIndices
    );

/// <summary>
/// Returns whether or not the font has any vertical glyph variants.
/// </summary>
/// <remarks>
/// For OpenType fonts, this will return true if the font contains a 'vert'
/// feature.
/// </remarks>
/// <returns>
/// True if the font contains vertical glyph variants.
/// </returns>
STDMETHOD_(BOOL, HasVerticalGlyphVariants)();

//using IDWriteFontFace::GetMetrics;
//using IDWriteFontFace::GetGdiCompatibleMetrics;
//using IDWriteFontFace::GetRecommendedRenderingMode;
};


/// <summary>
/// The IDWriteFont interface represents a physical font in a font collection.
/// </summary>
[
    odl,
    uuid(acd16696-8c14-4f5d-877e-fe3fc1d32738) 
]
interface IDWriteFont1 : IDWriteFont
{
    /// <summary>
    /// Gets common metrics for the font in design units.
    /// These metrics are applicable to all the glyphs within a font,
    /// and are used by applications for layout calculations.
    /// </summary>
    /// <param name="fontMetrics">Metrics structure to fill in.</param>
    STDMETHOD_(void, GetMetrics1)(
        [in, out] DWRITE_FONT_METRICS1 * fontMetrics
        );

    //using IDWriteFont::GetMetrics;

    /// <summary>
    /// Gets the PANOSE values from the font, used for font selection and
    /// matching.
    /// </summary>
    /// <param name="panose">PANOSE structure to fill in.</param>
    /// <remarks>
    /// The function does not simulate these, such as substituting a weight or
    /// proportion inferred on other values. If the font does not specify them,
    /// they are all set to 'any' (0).
    /// </remarks>
    STDMETHOD_(void, GetPanose)(
        [in, out] DWRITE_PANOSE* panose
        );

    /// <summary>
    /// Returns the list of character ranges supported by the font, which is
    /// useful for scenarios like character picking, glyph display, and
    /// efficient font selection lookup. This is similar to GDI's
    /// GetFontUnicodeRanges, except that it returns the full Unicode range,
    /// not just 16-bit UCS-2.
    /// </summary>
    /// <param name="maxRangeCount">Maximum number of character ranges passed
    ///     in from the client.</param>
    /// <param name="unicodeRanges">Array of character ranges.</param>
    /// <param name="actualRangeCount">Actual number of character ranges,
    ///     regardless of the maximum count.</param>
    /// <remarks>
    /// These ranges are from the cmap, not the OS/2::ulCodePageRange1.
    /// </remarks>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetUnicodeRanges)(
        [in] UINT32 maxRangeCount,
        [in, out] DWRITE_UNICODE_RANGE* unicodeRanges,
        [in, out] UINT32* actualRangeCount
        );

    /// <summary>
    /// Returns true if the font is monospaced, meaning its characters are the
    /// same fixed-pitch width (non-proportional).
    /// </summary>
    STDMETHOD_(BOOL, IsMonospacedFont)();
};

/// <summary>
/// The interface that represents text rendering settings for glyph rasterization and filtering.
/// </summary>
[
    odl,
    uuid(94413cf4-a6fc-4248-8b50-6674348fcad3)
]
interface IDWriteRenderingParams1 : IDWriteRenderingParams
{
    /// <summary>
    /// Gets the amount of contrast enhancement to use for grayscale antialiasing.
    /// Valid values are greater than or equal to zero.
    /// </summary>
    STDMETHOD_(FLOAT, GetGrayscaleEnhancedContrast)();
};

/// <summary>
/// Analyzes various text properties for complex script processing.
/// </summary>
[
    odl,
    uuid(80DAD800-E21F-4E83-96CE-BFCCE500DB7C)
]
interface IDWriteTextAnalyzer1 : IDWriteTextAnalyzer
{
    /// <summary>
    /// Applies spacing between characters, properly adjusting glyph clusters
    /// and diacritics.
    /// </summary>
    /// <param name="leadingSpacing">The spacing before each character, in reading order.</param>
    /// <param name="trailingSpacing">The spacing after each character, in reading order.</param>
    /// <param name="minimumAdvanceWidth">The minimum advance of each character,
    ///     to prevent characters from becoming too thin or zero-width. This
    ///     must be zero or greater.</param>
    /// <param name="textLength">The length of the clustermap and original text.</param>
    /// <param name="glyphCount">The number of glyphs.</param>
    /// <param name="clusterMap">Mapping from character ranges to glyph ranges.</param>
    /// <param name="glyphAdvances">The advance width of each glyph.</param>
    /// <param name="glyphOffsets">The offset of the origin of each glyph.</param>
    /// <param name="glyphProperties">Properties of each glyph, from GetGlyphs.</param>
    /// <param name="modifiedGlyphAdvances">The new advance width of each glyph.</param>
    /// <param name="modifiedGlyphOffsets">The new offset of the origin of each glyph.</param>
    /// <remarks>
    /// The input and output advances/offsets are allowed to alias the same array.
    /// </remarks>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(ApplyCharacterSpacing)(
        [in] FLOAT leadingSpacing,
        [in] FLOAT trailingSpacing,
        [in] FLOAT minimumAdvanceWidth,
        [in] UINT32 textLength,
        [in] UINT32 glyphCount,
        [in] UINT16* clusterMap,
        [in] FLOAT* glyphAdvances,
        [in] DWRITE_GLYPH_OFFSET* glyphOffsets,
        [in] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,
        [in, out] FLOAT * modifiedGlyphAdvances,
        [in, out] DWRITE_GLYPH_OFFSET * modifiedGlyphOffsets
        );

/// <summary>
/// Retrieves the given baseline from the font.
/// </summary>
/// <param name="fontFace">The font face to read.</param>
/// <param name="baseline">The baseline of interest.</param>
/// <param name="isVertical">Whether the baseline is vertical or horizontal.</param>
/// <param name="isSimulationAllowed">Simulate the baseline if it is missing in the font.</param>
/// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
/// <param name="localeName">The language of the run.</param>
/// <param name="baselineCoordinate">The baseline coordinate value in design units.</param>
/// <param name="exists">Whether the returned baseline exists in the font.</param>
/// <remarks>
/// If the baseline does not exist in the font, it is not considered an
/// error, but the function will return exists = false. You may then use
/// heuristics to calculate the missing base, or, if the flag
/// simulationAllowed is true, the function will compute a reasonable
/// approximation for you.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetBaseline)(
    [in] IDWriteFontFace* fontFace,
    [in] DWRITE_BASELINE baseline,
    [in] BOOL isVertical,
    [in] BOOL isSimulationAllowed,
    //[in] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,
    [in] int scriptAndPad,
    [in] DWRITE_SCRIPT_SHAPES shapes,
    [in] LongPtr localeName,
    [in, out] INT32* baselineCoordinate,
    [in, out] BOOL* exists
    );

/// <summary>
/// Analyzes a text range for script orientation, reading text and
/// attributes from the source and reporting results to the sink.
/// </summary>
/// <param name="analysisSource">Source object to analyze.</param>
/// <param name="textPosition">Starting position within the source object.</param>
/// <param name="textLength">Length to analyze.</param>
/// <param name="analysisSink">Callback object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// All bidi analysis should be resolved before calling this.
/// </remarks>
STDMETHOD(AnalyzeVerticalGlyphOrientation)(
    [in] IDWriteTextAnalysisSource1* analysisSource,
    [in] UINT32 textPosition,
    [in] UINT32 textLength,
    [in] IDWriteTextAnalysisSink1* analysisSink
    );

/// <summary>
/// Returns 2x3 transform matrix for the respective angle to draw the
/// glyph run.
/// </summary>
/// <param name="glyphOrientationAngle">The angle reported into
///     SetGlyphOrientation.</param>
/// <param name="isSideways">Whether the run's glyphs are sideways or not.</param>
/// <param name="transform">Returned transform.</param>
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// The returned displacement is zero.
/// </remarks>
STDMETHOD(GetGlyphOrientationTransform)(
    [in] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,
    [in] BOOL isSideways,
    [in, out] DWRITE_MATRIX* transform
    );

/// <summary>
/// Returns the properties for a given script.
/// </summary>
/// <param name="scriptAnalysis">The script for a run of text returned
///     from IDWriteTextAnalyzer::AnalyzeScript.</param>
/// <param name="scriptProperties">Information for the script.</param>
/// <returns>
/// Returns properties for the given script. If the script is invalid,
/// it returns generic properties for the unknown script and E_INVALIDARG.
/// </returns>
STDMETHOD(GetScriptProperties)(
    //[in] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,
    [in] int scriptAndPad,
    [in] DWRITE_SCRIPT_SHAPES shapes,
    [in, out] DWRITE_SCRIPT_PROPERTIES* scriptProperties
    );

/// <summary>
/// Determines the complexity of text, and whether or not full script
/// shaping needs to be called (GetGlyphs).
/// </summary>
/// <param name="fontFace">The font face to read.</param>
/// <param name="textLength">Length of the text to check.</param>
/// <param name="textString">The text to check for complexity. This string
///     may be UTF-16, but any supplementary characters will be considered
///     complex.</param>
/// <param name="isTextSimple">If true, the text is simple, and the
///     glyphIndices array will already have the nominal glyphs for you.
///     Otherwise you need to call GetGlyphs to properly shape complex
///     scripts and OpenType features.
///     </param>
/// <param name="textLengthRead">The length read of the text run with the
///     same complexity, simple or complex. You may call again from that
///     point onward.</param>
/// <param name="glyphIndices">Optional glyph indices for the text. If the
///     function returned that the text was simple, you already have the
///     glyphs you need. Otherwise the glyph indices are not meaningful,
///     and you should call shaping instead.</param>
/// <remarks>
/// Text is not simple if the characters are part of a script that has
/// complex shaping requirements, require bidi analysis, combine with
/// other characters, reside in the supplementary planes, or have glyphs
/// which participate in standard OpenType features. The length returned
/// will not split combining marks from their base characters.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetTextComplexity)(
    [in] LongPtr textString,
    [in] UINT32 textLength,
    [in] IDWriteFontFace* fontFace,
    [in, out] BOOL* isTextSimple,
    [in, out] UINT32* textLengthRead,
    [in, out] UINT16* glyphIndices
    );

/// <summary>
/// Retrieves justification opportunity information for each of the glyphs
/// given the text and shaping glyph properties.
/// </summary>
/// <param name="fontFace">Font face that was used for shaping. This is
///     mainly important for returning correct results of the kashida
///     width.</param>
/// <param name="fontEmSize">Font em size used for the glyph run.</param>
/// <param name="scriptAnalysis">Script of the text from the itemizer.</param>
/// <param name="textLength">Length of the text.</param>
/// <param name="glyphCount">Number of glyphs.</param>
/// <param name="textString">Characters used to produce the glyphs.</param>
/// <param name="clusterMap">Clustermap produced from shaping.</param>
/// <param name="glyphProperties">Glyph properties produced from shaping.</param>
/// <param name="justificationOpportunities">Receives information for the
///     allowed justification expansion/compression for each glyph.</param>
/// <remarks>
/// This function is called per-run, after shaping is done via GetGlyphs().
/// Note this function only supports natural metrics (DWRITE_MEASURING_MODE_NATURAL).
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetJustificationOpportunities)(
    [in] IDWriteFontFace* fontFace,
    [in] FLOAT fontEmSize,
    //[in] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,
    [in] int scriptAndPad,
    [in] DWRITE_SCRIPT_SHAPES shapes,
    [in] UINT32 textLength,
    [in] UINT32 glyphCount,
    [in] LongPtr textString,
    [in] UINT16* clusterMap,
    [in] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,
    [in, out] DWRITE_JUSTIFICATION_OPPORTUNITY* justificationOpportunities
    );

/// <summary>
/// Justifies an array of glyph advances to fit the line width.
/// </summary>
/// <param name="lineWidth">Width of the line.</param>
/// <param name="glyphCount">Number of glyphs.</param>
/// <param name="justificationOpportunities">Opportunities per glyph. Call
///     GetJustificationOpportunities() to get suitable opportunities
///     according to script.</param>
/// <param name="glyphAdvances">Original glyph advances from shaping.</param>
/// <param name="glyphOffsets">Original glyph offsets from shaping.</param>
/// <param name="justifiedGlyphAdvances">Justified glyph advances.</param>
/// <param name="justifiedGlyphOffsets">Justified glyph offsets.</param>
/// <remarks>
/// This is called after all the opportunities have been collected, and it
/// spans across the entire line. The input and output arrays are allowed
/// to alias each other, permitting in-place update.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(JustifyGlyphAdvances)(
    [in] FLOAT lineWidth,
    [in] UINT32 glyphCount,
    [in] DWRITE_JUSTIFICATION_OPPORTUNITY* justificationOpportunities,
    [in] FLOAT* glyphAdvances,
    [in] DWRITE_GLYPH_OFFSET* glyphOffsets,
    [in, out] FLOAT* justifiedGlyphAdvances,
    [in, out] DWRITE_GLYPH_OFFSET* justifiedGlyphOffsets
    );

/// <summary>
/// Fills in new glyphs for complex scripts where justification increased
/// the advances of glyphs, such as Arabic with kashida.
/// </summary>
/// <param name="fontFace">Font face used for shaping.</param>
/// <param name="fontEmSize">Font em size used for the glyph run.</param>
/// <param name="scriptAnalysis">Script of the text from the itemizer.</param>
/// <param name="textLength">Length of the text.</param>
/// <param name="glyphCount">Number of glyphs.</param>
/// <param name="maxGlyphCount">Maximum number of output glyphs allocated
///     by caller.</param>
/// <param name="clusterMap">Clustermap produced from shaping.</param>
/// <param name="glyphIndices">Original glyphs produced from shaping.</param>
/// <param name="glyphAdvances">Original glyph advances produced from shaping.</param>
/// <param name="justifiedGlyphAdvances">Justified glyph advances from
///     JustifyGlyphAdvances().</param>
/// <param name="justifiedGlyphOffsets">Justified glyph offsets from
///     JustifyGlyphAdvances().</param>
/// <param name="glyphProperties">Properties of each glyph, from GetGlyphs.</param>
/// <param name="actualGlyphCount">The new glyph count written to the
///     modified arrays, or the needed glyph count if the size is not
///     large enough.</param>
/// <param name="modifiedClusterMap">Updated clustermap.</param>
/// <param name="modifiedGlyphIndices">Updated glyphs with new glyphs
///     inserted where needed.</param>
/// <param name="modifiedGlyphAdvances">Updated glyph advances.</param>
/// <param name="modifiedGlyphOffsets">Updated glyph offsets.</param>
/// <remarks>
/// This is called after the line has been justified, and it is per-run.
/// It only needs to be called if the script has a specific justification
/// character via GetScriptProperties, and it is mainly for cursive scripts
/// like Arabic. If maxGlyphCount is not large enough, the error
/// E_NOT_SUFFICIENT_BUFFER will be returned, with actualGlyphCount holding
/// the final/needed glyph count.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetJustifiedGlyphs)(
    [in] IDWriteFontFace* fontFace,
    [in] FLOAT fontEmSize,
    //[in] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,
    [in] int scriptAndPad,
    [in] DWRITE_SCRIPT_SHAPES shapes,
    [in] UINT32 textLength,
    [in] UINT32 glyphCount,
    [in] UINT32 maxGlyphCount,
    [in] UINT16* clusterMap,
    [in] UINT16* glyphIndices,
    [in] FLOAT* glyphAdvances,
    [in] FLOAT* justifiedGlyphAdvances,
    [in] DWRITE_GLYPH_OFFSET* justifiedGlyphOffsets,
    [in] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,
    [in, out] UINT32* actualGlyphCount,
    //_Out_writes_opt_(textLength) UINT16* modifiedClusterMap,
    [in, out] void* modifiedClusterMap,
    [in, out] UINT16* modifiedGlyphIndices,
    [in, out] FLOAT* modifiedGlyphAdvances,
    [in, out] DWRITE_GLYPH_OFFSET* modifiedGlyphOffsets
    );
};


/// <summary>
/// The interface implemented by the client to provide needed information to
/// the text analyzer, such as the text and associated text properties.
/// If any of these callbacks returns an error, the analysis functions will
/// stop prematurely and return a callback error.
/// </summary>
[
    odl,
    uuid(639CFAD8-0FB4-4B21-A58A-067920120009)
]
interface IDWriteTextAnalysisSource1 : IDWriteTextAnalysisSource
{
    /// <summary>
    /// The text analyzer calls back to this to get the desired glyph
    /// orientation and resolved bidi level, which it uses along with the
    /// script properties of the text to determine the actual orientation of
    /// each character, which it reports back to the client via the sink
    /// SetGlyphOrientation method.
    /// </summary>
    /// <param name="textPosition">First position of the piece to obtain. All
    ///     positions are in UTF-16 code-units, not whole characters, which
    ///     matters when supplementary characters are used.</param>
    /// <param name="textLength">Number of UTF-16 units of the retrieved chunk.
    ///     The returned length is not the length of the block, but the length
    ///     remaining in the block, from the given position until its end.
    ///     So querying for a position that is 75 positions into a 100
    ///     postition block would return 25.</param>
    /// <param name="glyphOrientation">The type of glyph orientation the
    ///     client wants for this range, up to the returned text length.</param>
    /// <param name="bidiLevel">The bidi level for this range up to
    ///     the returned text length, which comes from an earlier
    ///     bidirectional analysis.</param>
    /// <returns>
    /// Standard HRESULT error code. Returning an error will abort the
    /// analysis.
    /// </returns>
    STDMETHOD(GetVerticalGlyphOrientation)(
        [in] UINT32 textPosition,
        [in, out] UINT32 * textLength,
        [in, out] DWRITE_VERTICAL_GLYPH_ORIENTATION * glyphOrientation,
        [in, out] UINT8 * bidiLevel
        );
};


/// <summary>
/// The interface implemented by the client to receive the
/// output of the text analyzers.
/// </summary>
[
    odl,
    uuid(B0D941A0-85E7-4D8B-9FD3-5CED9934482A)
]
interface IDWriteTextAnalysisSink1 : IDWriteTextAnalysisSink
{
    /// <summary>
    /// The text analyzer calls back to this to report the actual orientation
    /// of each character for shaping and drawing.
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF-16 units of the reported range.</param>
    /// <param name="glyphOrientationAngle">Angle of the glyphs within the text
    ///     range (pass to GetGlyphOrientationTransform to get the world
    ///     relative transform).</param>
    /// <param name="adjustedBidiLevel">The adjusted bidi level to be used by
    ///     the client layout for reordering runs. This will differ from the
    ///     resolved bidi level retrieved from the source for cases such as
    ///     Arabic stacked top-to-bottom, where the glyphs are still shaped
    ///     as RTL, but the runs are TTB along with any CJK or Latin.</param>
    /// <param name="isSideways">Whether the glyphs are rotated on their side,
    ///     which is the default case for CJK and the case stacked Latin</param>
    /// <param name="isRightToLeft">Whether the script should be shaped as
    ///     right-to-left. For Arabic stacked top-to-bottom, even when the
    ///     adjusted bidi level is coerced to an even level, this will still
    ///     be true.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    STDMETHOD(SetGlyphOrientation)(
        [in] UINT32 textPosition,
        [in] UINT32 textLength,
        [in] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,
        [in] UINT8 adjustedBidiLevel,
        [in] BOOL isSideways,
        [in] BOOL isRightToLeft
        );
};


/// <summary>
/// The IDWriteTextLayout1 interface represents a block of text after it has
/// been fully analyzed and formatted.
///
/// All coordinates are in device independent pixels (DIPs).
/// </summary>
[
    odl,
    uuid(9064D822-80A7-465C-A986-DF65F78B8FEB)
]
interface IDWriteTextLayout1 : IDWriteTextLayout
{
    /// <summary>
    /// Enables/disables pair-kerning on the given range.
    /// </summary>
    /// <param name="isPairKerningEnabled">The Boolean flag indicates whether text is pair-kerned.</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetPairKerning)(
        [in] BOOL isPairKerningEnabled,
        [in] long textRange_startPosition,
        [in] long textRange_length
        );
        //[in] DWRITE_TEXT_RANGE textRange
/// <summary>
/// Get whether or not pair-kerning is enabled at given position.
/// </summary>
/// <param name="currentPosition">The current text position.</param>
/// <param name="isPairKerningEnabled">The Boolean flag indicates whether text is pair-kerned.</param>
/// <param name="textRange">The position range of the current format.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetPairKerning)(
    [in] UINT32 currentPosition,
    [in, out] BOOL* isPairKerningEnabled,
    [in, out] void* textRange
    );
    //_Out_opt_ DWRITE_TEXT_RANGE* textRange = NULL

/// <summary>
/// Sets the spacing between characters.
/// </summary>
/// <param name="leadingSpacing">The spacing before each character, in reading order.</param>
/// <param name="trailingSpacing">The spacing after each character, in reading order.</param>
/// <param name="minimumAdvanceWidth">The minimum advance of each character,
///     to prevent characters from becoming too thin or zero-width. This
///     must be zero or greater.</param>
/// <param name="textRange">Text range to which this change applies.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetCharacterSpacing)(
    [in] FLOAT leadingSpacing,
    [in] FLOAT trailingSpacing,
    [in] FLOAT minimumAdvanceWidth,
    [in] long textRange_startPosition,
    [in] long textRange_length
    );
    //DWRITE_TEXT_RANGE textRange
/// <summary>
/// Gets the spacing between characters.
/// </summary>
/// <param name="currentPosition">The current text position.</param>
/// <param name="leadingSpacing">The spacing before each character, in reading order.</param>
/// <param name="trailingSpacing">The spacing after each character, in reading order.</param>
/// <param name="minimumAdvanceWidth">The minimum advance of each character,
///     to prevent characters from becoming too thin or zero-width. This
///     must be zero or greater.</param>
/// <param name="textRange">The position range of the current format.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetCharacterSpacing)(
    [in] UINT32 currentPosition,
    [in, out] FLOAT* leadingSpacing,
    [in, out] FLOAT* trailingSpacing,
    [in, out] FLOAT* minimumAdvanceWidth,
    [in, out] void* textRange
    );
};
    //_Out_opt_ DWRITE_TEXT_RANGE* textRange = NULL

/// <summary>
/// Represents the type of antialiasing to use for text when the rendering mode calls for
/// antialiasing.
/// </summary>
typedef enum DWRITE_TEXT_ANTIALIAS_MODE
{
    /// <summary>
    /// ClearType antialiasing computes coverage independently for the red, green, and blue
    /// color elements of each pixel. This allows for more detail than conventional antialiasing.
    /// However, because there is no one alpha value for each pixel, ClearType is not suitable
    /// rendering text onto a transparent intermediate bitmap.
    /// </summary>
    DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE,

    /// <summary>
    /// Grayscale antialiasing computes one coverage value for each pixel. Because the alpha
    /// value of each pixel is well-defined, text can be rendered onto a transparent bitmap, 
    /// which can then be composited with other content. Note that grayscale rendering with
    /// IDWriteBitmapRenderTarget1 uses premultiplied alpha.
    /// </summary>
    DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE
} DWRITE_TEXT_ANTIALIAS_MODE;

/// <summary>
/// Encapsulates a 32-bit device independent bitmap and device context, which can be used for rendering glyphs.
/// </summary>
[
    odl,
    uuid(791e8298-3ef3-4230-9880-c9bdecc42064)
]
interface IDWriteBitmapRenderTarget1 : IDWriteBitmapRenderTarget
{
    /// <summary>
    /// Gets the current text antialiasing mode of the bitmap render target.
    /// </summary>
    /// <returns>
    /// Returns the antialiasing mode.
    /// </returns>
    STDMETHOD_(DWRITE_TEXT_ANTIALIAS_MODE, GetTextAntialiasMode)();

/// <summary>
/// Sets the current text antialiasing mode of the bitmap render target.
/// </summary>
/// <returns>
/// Returns S_OK if successful, or E_INVALIDARG if the argument is not valid.
/// </returns>
/// <remarks>
/// The antialiasing mode of a newly-created bitmap render target defaults to 
/// DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE. An application can change the antialiasing
/// mode by calling SetTextAntialiasMode. For example, an application might specify
/// grayscale antialiasing when rendering text onto a transparent bitmap.
/// </remarks>
STDMETHOD(SetTextAntialiasMode)(
    [in] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode
    );
};










//**************************************************************

//   DWRITE_2.h

//**************************************************************



interface IDWriteFontFallback;


typedef enum DWRITE_OPTICAL_ALIGNMENT
{
    DWRITE_OPTICAL_ALIGNMENT_NONE,
    DWRITE_OPTICAL_ALIGNMENT_NO_SIDE_BEARINGS
} DWRITE_OPTICAL_ALIGNMENT;

typedef enum DWRITE_GRID_FIT_MODE
{
    DWRITE_GRID_FIT_MODE_DEFAULT,
    DWRITE_GRID_FIT_MODE_DISABLED,
    DWRITE_GRID_FIT_MODE_ENABLED
} DWRITE_GRID_FIT_MODE;

typedef struct DWRITE_TEXT_METRICS1
{
    /* DWRITE_TEXT_METRICS fields */
    FLOAT left;
    FLOAT top;
    FLOAT width;
    FLOAT widthIncludingTrailingWhitespace;
    FLOAT height;
    FLOAT layoutWidth;
    FLOAT layoutHeight;
    UINT32 maxBidiReorderingDepth;
    UINT32 lineCount;
    /* DWRITE_TEXT_METRICS1 fields */
    FLOAT heightIncludingTrailingWhitespace;
} DWRITE_TEXT_METRICS1;


/// <summary>
/// The text renderer interface represents a set of application-defined
/// callbacks that perform rendering of text, inline objects, and decorations
/// such as underlines.
/// </summary>
[
    odl,
    uuid(D3E0E934-22A0-427E-AAE4-7D9574B59DB1)
]
interface IDWriteTextRenderer1 : IDWriteTextRenderer
{
    /// <summary>
    /// IDWriteTextLayout::Draw calls this function to instruct the client to
    /// render a run of glyphs.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to 
    ///     IDWriteTextLayout::Draw.</param>
    /// <param name="baselineOriginX">X-coordinate of the baseline.</param>
    /// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
    /// <param name="orientationAngle">Orientation of the glyph run.</param>
    /// <param name="measuringMode">Specifies measuring method for glyphs in
    ///     the run. Renderer implementations may choose different rendering
    ///     modes for given measuring methods, but best results are seen when
    ///     the rendering mode matches the corresponding measuring mode:
    ///     DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for DWRITE_MEASURING_MODE_NATURAL
    ///     DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for DWRITE_MEASURING_MODE_GDI_CLASSIC
    ///     DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for DWRITE_MEASURING_MODE_GDI_NATURAL
    /// </param>
    /// <param name="glyphRun">The glyph run to draw.</param>
    /// <param name="glyphRunDescription">Properties of the characters 
    ///     associated with this run.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    ///     IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// If a non-identity orientation is passed, the glyph run should be
    /// rotated around the given baseline x and y coordinates. The function
    /// IDWriteAnalyzer2::GetGlyphOrientationTransform will return the
    /// necessary transform for you, which can be combined with any existing
    /// world transform on the drawing context.
    /// </remarks>
    STDMETHOD(DrawGlyphRun2)(
        [in] void* clientDrawingContext,
        [in] FLOAT baselineOriginX,
        [in] FLOAT baselineOriginY,
        [in] DWRITE_GLYPH_ORIENTATION_ANGLE orientationAngle,
        [in] DWRITE_MEASURING_MODE measuringMode,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
        [in] IUnknown * clientDrawingEffect
        );

/// <summary>
/// IDWriteTextLayout::Draw calls this function to instruct the client to draw
/// an underline.
/// </summary>
/// <param name="clientDrawingContext">The context passed to 
/// IDWriteTextLayout::Draw.</param>
/// <param name="baselineOriginX">X-coordinate of the baseline.</param>
/// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
/// <param name="orientationAngle">Orientation of the underline.</param>
/// <param name="underline">Underline logical information.</param>
/// <param name="clientDrawingEffect">The drawing effect set in
///     IDWriteTextLayout::SetDrawingEffect.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// A single underline can be broken into multiple calls, depending on
/// how the formatting changes attributes. If font sizes/styles change
/// within an underline, the thickness and offset will be averaged
/// weighted according to characters.
///
/// To get the correct top coordinate of the underline rect, add
/// underline::offset to the baseline's Y. Otherwise the underline will
/// be immediately under the text. The x coordinate will always be passed
/// as the left side, regardless of text directionality. This simplifies
/// drawing and reduces the problem of round-off that could potentially
/// cause gaps or a double stamped alpha blend. To avoid alpha overlap,
/// round the end points to the nearest device pixel.
/// </remarks>
STDMETHOD(DrawUnderline2)(
    [in] void* clientDrawingContext,
    [in] FLOAT baselineOriginX,
    [in] FLOAT baselineOriginY,
    [in] DWRITE_GLYPH_ORIENTATION_ANGLE orientationAngle,
    [in] DWRITE_UNDERLINE* underline,
    [in] IUnknown* clientDrawingEffect
    );

/// <summary>
/// IDWriteTextLayout::Draw calls this function to instruct the client to draw
/// a strikethrough.
/// </summary>
/// <param name="clientDrawingContext">The context passed to 
/// IDWriteTextLayout::Draw.</param>
/// <param name="baselineOriginX">X-coordinate of the baseline.</param>
/// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
/// <param name="orientationAngle">Orientation of the strikethrough.</param>
/// <param name="strikethrough">Strikethrough logical information.</param>
/// <param name="clientDrawingEffect">The drawing effect set in
///     IDWriteTextLayout::SetDrawingEffect.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// A single strikethrough can be broken into multiple calls, depending on
/// how the formatting changes attributes. Strikethrough is not averaged
/// across font sizes/styles changes.
/// To get the correct top coordinate of the strikethrough rect,
/// add strikethrough::offset to the baseline's Y.
/// Like underlines, the x coordinate will always be passed as the left side,
/// regardless of text directionality.
/// </remarks>
STDMETHOD(DrawStrikethrough2)(
    [in] void* clientDrawingContext,
    [in] FLOAT baselineOriginX,
    [in] FLOAT baselineOriginY,
    [in] DWRITE_GLYPH_ORIENTATION_ANGLE orientationAngle,
    [in] DWRITE_STRIKETHROUGH* strikethrough,
    [in] IUnknown* clientDrawingEffect
    );

/// <summary>
/// IDWriteTextLayout::Draw calls this application callback when it needs to
/// draw an inline object.
/// </summary>
/// <param name="clientDrawingContext">The context passed to
///     IDWriteTextLayout::Draw.</param>
/// <param name="originX">X-coordinate at the top-left corner of the
///     inline object.</param>
/// <param name="originY">Y-coordinate at the top-left corner of the
///     inline object.</param>
/// <param name="orientationAngle">Orientation of the inline object.</param>
/// <param name="inlineObject">The object set using IDWriteTextLayout::SetInlineObject.</param>
/// <param name="isSideways">The object should be drawn on its side.</param>
/// <param name="isRightToLeft">The object is in an right-to-left context
///     and should be drawn flipped.</param>
/// <param name="clientDrawingEffect">The drawing effect set in
///     IDWriteTextLayout::SetDrawingEffect.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// The right-to-left flag is a hint to draw the appropriate visual for
/// that reading direction. For example, it would look strange to draw an
/// arrow pointing to the right to indicate a submenu. The sideways flag
/// similarly hints that the object is drawn in a different orientation.
/// If a non-identity orientation is passed, the top left of the inline
/// object should be rotated around the given x and y coordinates.
/// IDWriteAnalyzer2::GetGlyphOrientationTransform returns the necessary
/// transform for this.
/// </remarks>
STDMETHOD(DrawInlineObject2)(
    [in] void* clientDrawingContext,
    [in] FLOAT originX,
    [in] FLOAT originY,
    [in] DWRITE_GLYPH_ORIENTATION_ANGLE orientationAngle,
    [in] IDWriteInlineObject* inlineObject,
    [in] BOOL isSideways,
    [in] BOOL isRightToLeft,
    [in] IUnknown* clientDrawingEffect
    );

//using IDWriteTextRenderer::DrawGlyphRun;
//using IDWriteTextRenderer::DrawUnderline;
//using IDWriteTextRenderer::DrawStrikethrough;
//using IDWriteTextRenderer::DrawInlineObject;
};


/// <summary>
/// The format of text used for text layout.
/// </summary>
/// <remarks>
/// This object may not be thread-safe and it may carry the state of text format change.
/// </remarks>
[
    odl,
    uuid(5F174B49-0D8B-4CFB-8BCA-F1CCE9D06C67) 
]
interface IDWriteTextFormat1 : IDWriteTextFormat
{
    /// <summary>
    /// Set the preferred orientation of glyphs when using a vertical reading direction.
    /// </summary>
    /// <param name="glyphOrientation">Preferred glyph orientation.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetVerticalGlyphOrientation)(
        [in] DWRITE_VERTICAL_GLYPH_ORIENTATION glyphOrientation
        );

/// <summary>
/// Get the preferred orientation of glyphs when using a vertical reading
/// direction.
/// </summary>
STDMETHOD_(DWRITE_VERTICAL_GLYPH_ORIENTATION, GetVerticalGlyphOrientation)();

/// <summary>
/// Set whether or not the last word on the last line is wrapped.
/// </summary>
/// <param name="isLastLineWrappingEnabled">Line wrapping option.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetLastLineWrapping)(
    [in] BOOL isLastLineWrappingEnabled
    );

/// <summary>
/// Get whether or not the last word on the last line is wrapped.
/// </summary>
STDMETHOD_(BOOL, GetLastLineWrapping)();

/// <summary>
/// Set how the glyphs align to the edges the margin. Default behavior is
/// to align glyphs using their default glyphs metrics which include side
/// bearings.
/// </summary>
/// <param name="opticalAlignment">Optical alignment option.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetOpticalAlignment)(
    [in] DWRITE_OPTICAL_ALIGNMENT opticalAlignment
    );

/// <summary>
/// Get how the glyphs align to the edges the margin.
/// </summary>
STDMETHOD_(DWRITE_OPTICAL_ALIGNMENT, GetOpticalAlignment)();

/// <summary>
/// Apply a custom font fallback onto layout. If none is specified,
/// layout uses the system fallback list.
/// </summary>
/// <param name="fontFallback">Custom font fallback created from
///     IDWriteFontFallbackBuilder::CreateFontFallback or from
///     IDWriteFactory2::GetSystemFontFallback.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetFontFallback)(
    [in] IDWriteFontFallback* fontFallback
    );

/// <summary>
/// Get the current font fallback object.
/// </summary>
STDMETHOD(GetFontFallback)(
    [in, out] IDWriteFontFallback** fontFallback
    );
};


/// <summary>
/// The text layout interface represents a block of text after it has
/// been fully analyzed and formatted.
///
/// All coordinates are in device independent pixels (DIPs).
/// </summary>
[
    odl,
    uuid(1093C18F-8D5E-43F0-B064-0917311B525E) 
]
interface IDWriteTextLayout2 : IDWriteTextLayout1
{
    /// <summary>
    /// GetMetrics retrieves overall metrics for the formatted string.
    /// </summary>
    /// <param name="textMetrics">The returned metrics.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Drawing effects like underline and strikethrough do not contribute
    /// to the text size, which is essentially the sum of advance widths and
    /// line heights. Additionally, visible swashes and other graphic
    /// adornments may extend outside the returned width and height.
    /// </remarks>
    STDMETHOD(GetMetrics2)(
        [in, out] DWRITE_TEXT_METRICS1 * textMetrics
        );

    //using IDWriteTextLayout::GetMetrics;

    /// <summary>
    /// Set the preferred orientation of glyphs when using a vertical reading direction.
    /// </summary>
    /// <param name="glyphOrientation">Preferred glyph orientation.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetVerticalGlyphOrientation)(
        [in] DWRITE_VERTICAL_GLYPH_ORIENTATION glyphOrientation
        );

    /// <summary>
    /// Get the preferred orientation of glyphs when using a vertical reading
    /// direction.
    /// </summary>
    STDMETHOD_(DWRITE_VERTICAL_GLYPH_ORIENTATION, GetVerticalGlyphOrientation)();

    /// <summary>
    /// Set whether or not the last word on the last line is wrapped.
    /// </summary>
    /// <param name="isLastLineWrappingEnabled">Line wrapping option.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetLastLineWrapping)(
        [in] BOOL isLastLineWrappingEnabled
        );

    /// <summary>
    /// Get whether or not the last word on the last line is wrapped.
    /// </summary>
    STDMETHOD_(BOOL, GetLastLineWrapping)();

    /// <summary>
    /// Set how the glyphs align to the edges the margin. Default behavior is
    /// to align glyphs using their default glyphs metrics which include side
    /// bearings.
    /// </summary>
    /// <param name="opticalAlignment">Optical alignment option.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetOpticalAlignment)(
        [in] DWRITE_OPTICAL_ALIGNMENT opticalAlignment
        );

    /// <summary>
    /// Get how the glyphs align to the edges the margin.
    /// </summary>
    STDMETHOD_(DWRITE_OPTICAL_ALIGNMENT, GetOpticalAlignment)();

    /// <summary>
    /// Apply a custom font fallback onto layout. If none is specified,
    /// layout uses the system fallback list.
    /// </summary>
    /// <param name="fontFallback">Custom font fallback created from
    ///     IDWriteFontFallbackBuilder::CreateFontFallback or
    ///     IDWriteFactory2::GetSystemFontFallback.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontFallback)(
        [in] IDWriteFontFallback* fontFallback
        );

    /// <summary>
    /// Get the current font fallback object.
    /// </summary>
    STDMETHOD(GetFontFallback)(
        [in, out] IDWriteFontFallback** fontFallback
        );
};


/// <summary>
/// The text analyzer interface represents a set of application-defined
/// callbacks that perform rendering of text, inline objects, and decorations
/// such as underlines.
/// </summary>
[
    odl,
    uuid(553A9FF3-5693-4DF7-B52B-74806F7F2EB9) 
]
interface IDWriteTextAnalyzer2 : IDWriteTextAnalyzer1
{
    /// <summary>
    /// Returns 2x3 transform matrix for the respective angle to draw the
    /// glyph run or other object.
    /// </summary>
    /// <param name="glyphOrientationAngle">The angle reported to one of the application callbacks,
    ///     including IDWriteTextAnalysisSink1::SetGlyphOrientation and IDWriteTextRenderer1::Draw*.</param>
    /// <param name="isSideways">Whether the run's glyphs are sideways or not.</param>
    /// <param name="originX">X origin of the element, be it a glyph run or underline or other.</param>
    /// <param name="originY">Y origin of the element, be it a glyph run or underline or other.</param>
    /// <param name="transform">Returned transform.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This rotates around the given origin x and y, returning a translation component
    /// such that the glyph run, text decoration, or inline object is drawn with the
    /// right orientation at the expected coordinate.
    /// </remarks>
    STDMETHOD(GetGlyphOrientationTransform2)(
        [in] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,
        [in] BOOL isSideways,
        [in] FLOAT originX,
        [in] FLOAT originY,
        [in, out] DWRITE_MATRIX * transform
        );

/// <summary>
/// Returns a list of typographic feature tags for the given script and language.
/// </summary>
/// <param name="fontFace">The font face to get features from.</param>
/// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
/// <param name="localeName">The locale to use when selecting the feature,
///     such en-us or ja-jp.</param>
/// <param name="maxTagCount">Maximum tag count.</param>
/// <param name="actualTagCount">Actual tag count. If greater than
///     maxTagCount, E_NOT_SUFFICIENT_BUFFER is returned, and the call
///     should be retried with a larger buffer.</param>
/// <param name="tags">Feature tag list.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetTypographicFeatures)(
    [in] IDWriteFontFace* fontFace,
    //[in] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,
    [in] int scriptAndPad,
    [in] DWRITE_SCRIPT_SHAPES shapes,
    [in] LongPtr localeName,
    [in] UINT32 maxTagCount,
    [in, out] UINT32* actualTagCount,
    [in, out] DWRITE_FONT_FEATURE_TAG* tags
    );

/// <summary>
/// Returns an array of which glyphs are affected by a given feature.
/// </summary>
/// <param name="fontFace">The font face to read glyph information from.</param>
/// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
/// <param name="localeName">The locale to use when selecting the feature,
///     such en-us or ja-jp.</param>
/// <param name="featureTag">OpenType feature name to use, which may be one
///     of the DWRITE_FONT_FEATURE_TAG values or a custom feature using
///     DWRITE_MAKE_OPENTYPE_TAG.</param>
/// <param name="glyphCount">Number of glyph indices to check.</param>
/// <param name="glyphIndices">Glyph indices to check for feature application.</param>
/// <param name="featureApplies">Output of which glyphs are affected by the
///     feature, where for each glyph affected, the respective array index
///     will be 1. The result is returned per-glyph without regard to
///     neighboring context of adjacent glyphs.</param>
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(CheckTypographicFeature)(
    [in] IDWriteFontFace* fontFace,
    //[in] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,
    [in] int scriptAndPad,
    [in] DWRITE_SCRIPT_SHAPES shapes,
    [in] LongPtr localeName,
    [in] DWRITE_FONT_FEATURE_TAG featureTag,
    [in] UINT32 glyphCount,
    [in] UINT16* glyphIndices,
    [in, out] UINT8* featureApplies
    );

//using IDWriteTextAnalyzer1::GetGlyphOrientationTransform;
};


/// <summary>
/// A font fallback definition used for mapping characters to fonts capable of
/// supporting them.
/// </summary>
[
    odl,
    uuid(EFA008F9-F7A1-48BF-B05C-F224713CC0FF) 
]
interface IDWriteFontFallback : stdole.IUnknown
{
    /// <summary>
    /// Determines an appropriate font to use to render the range of text.
    /// </summary>
    /// <param name="source">The text source implementation holds the text and
    ///     locale.</param>
    /// <param name="textLength">Length of the text to analyze.</param>
    /// <param name="baseFontCollection">Default font collection to use.</param>
    /// <param name="baseFamilyName">Family name of the base font. If you pass
    ///     null, no matching will be done against the family.</param>
    /// <param name="baseWeight">Desired weight.</param>
    /// <param name="baseStyle">Desired style.</param>
    /// <param name="baseStretch">Desired stretch.</param>
    /// <param name="mappedLength">Length of text mapped to the mapped font.
    ///     This will always be less or equal to the input text length and
    ///     greater than zero (if the text length is non-zero) so that the
    ///     caller advances at least one character each call.</param>
    /// <param name="mappedFont">The font that should be used to render the
    ///     first mappedLength characters of the text. If it returns NULL,
    ///     then no known font can render the text, and mappedLength is the
    ///     number of unsupported characters to skip.</param>
    /// <param name="scale">Scale factor to multiply the em size of the
    ///     returned font by.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(MapCharacters)(
        [in] IDWriteTextAnalysisSource * analysisSource,
        [in] UINT32 textPosition,
        [in] UINT32 textLength,
        [in] IDWriteFontCollection * baseFontCollection,
        [in] LongPtr baseFamilyName,
        [in] DWRITE_FONT_WEIGHT baseWeight,
        [in] DWRITE_FONT_STYLE baseStyle,
        [in] DWRITE_FONT_STRETCH baseStretch,
        [in, out] UINT32 * mappedLength,
        [in, out] IDWriteFont * *mappedFont,
        [in, out] FLOAT * scale
        );
};


/// <summary>
/// Builder used to create a font fallback definition by appending a series of
/// fallback mappings, followed by a creation call.
/// </summary>
/// <remarks>
/// This object may not be thread-safe.
/// </remarks>
[
    odl,
    uuid(FD882D06-8ABA-4FB8-B849-8BE8B73E14DE) 
]
interface IDWriteFontFallbackBuilder : stdole.IUnknown
{
    /// <summary>
    /// Appends a single mapping to the list. Call this once for each additional mapping.
    /// </summary>
    /// <param name="ranges">Unicode ranges that apply to this mapping.</param>
    /// <param name="rangesCount">Number of Unicode ranges.</param>
    /// <param name="localeName">Locale of the context (e.g. document locale).</param>
    /// <param name="baseFamilyName">Base family name to match against, if applicable.</param>
    /// <param name="fontCollection">Explicit font collection for this mapping (optional).</param>
    /// <param name="targetFamilyNames">List of target family name strings.</param>
    /// <param name="targetFamilyNamesCount">Number of target family names.</param>
    /// <param name="scale">Scale factor to multiply the result target font by.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(AddMapping)(
        [in] DWRITE_UNICODE_RANGE* ranges,
        [in] UINT32 rangesCount,
        [in] LongPtr* targetFamilyNames,
        [in] UINT32 targetFamilyNamesCount,
        [in] IDWriteFontCollection * fontCollection,
        [in] LongPtr localeName,
        [in] LongPtr baseFamilyName,
        [in, defaultvalue(1)] FLOAT scale
        );

/// <summary>
/// Appends all the mappings from an existing font fallback object.
/// </summary>
/// <param name="fontFallback">Font fallback to read mappings from.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(AddMappings)(
    [in] IDWriteFontFallback* fontFallback
    );

/// <summary>
/// Creates the finalized fallback object from the mappings added.
/// </summary>
/// <param name="fontFallback">Created fallback list.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(CreateFontFallback)(
     [in, out] IDWriteFontFallback** fontFallback
     );
};

/// <summary>
/// DWRITE_COLOR_F
/// </summary>
//#ifndef D3DCOLORVALUE_DEFINED
//
//typedef struct _D3DCOLORVALUE {
//    union {
//        FLOAT r;
//        FLOAT dvR;
//    };
//    union {
//        FLOAT g;
//        FLOAT dvG;
//    };
//    union {
//        FLOAT b;
//        FLOAT dvB;
//    };
//    union {
//        FLOAT a;
//        FLOAT dvA;
//    };
//} D3DCOLORVALUE;
//
//#define D3DCOLORVALUE_DEFINED
//#endif // D3DCOLORVALUE_DEFINED
typedef struct D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;

typedef D3DCOLORVALUE DWRITE_COLOR_F;

/// <summary>
/// The IDWriteFont interface represents a physical font in a font collection.
/// </summary>
/// 'DUPLICATED UUID:::IDWriteFont3 will inherit from 1 to capture this method.
//[
//    odl,
//    uuid(29748ed6-8c9c-4a6a-be0b-d912e8538944) 
//]
//interface IDWriteFont2 : IDWriteFont1
//{
//    /// <summary>
//    /// Returns TRUE if the font contains tables that can provide color information
//    /// (including COLR, CPAL, SVG, CBDT, sbix  tables), or FALSE if not. Note that
//    /// TRUE is returned even in the case when the font tables contain only grayscale
//    /// images.
//    /// </summary>
//    STDMETHOD_(BOOL, IsColorFont)();
//};

/// <summary>
/// The interface that represents an absolute reference to a font face.
/// It contains font face type, appropriate file references and face identification data.
/// Various font data such as metrics, names and glyph outlines is obtained from IDWriteFontFace.
/// </summary>
[
    odl,
    uuid(d8b768ff-64bc-4e66-982b-ec8e87f693f7) 
]
interface IDWriteFontFace2 : IDWriteFontFace1
{
    /// <summary>
    /// Returns TRUE if the font contains tables that can provide color information
    /// (including COLR, CPAL, SVG, CBDT, sbix  tables), or FALSE if not. Note that
    /// TRUE is returned even in the case when the font tables contain only grayscale
    /// images.
    /// </summary>
    STDMETHOD_(BOOL, IsColorFont)();

/// <summary>
/// Returns the number of color palettes defined by the font. The return
/// value is zero if the font has no color information. Color fonts must
/// have at least one palette, with palette index zero being the default.
/// </summary>
STDMETHOD_(UINT32, GetColorPaletteCount)();

/// <summary>
/// Returns the number of entries in each color palette. All color palettes
/// in a font have the same number of palette entries. The return value is 
/// zero if the font has no color information.
/// </summary>
STDMETHOD_(UINT32, GetPaletteEntryCount)();

/// <summary>
/// Reads color values from the font's color palette.
/// </summary>
/// <param name="colorPaletteIndex">Zero-based index of the color palette. If the
/// font does not have a palette with the specified index, the method returns 
/// DWRITE_E_NOCOLOR.<param>
/// <param name="firstEntryIndex">Zero-based index of the first palette entry
/// to read.</param>
/// <param name="entryCount">Number of palette entries to read.</param>
/// <param name="paletteEntries">Array that receives the color values.<param>
/// <returns>
/// Standard HRESULT error code.
/// The return value is E_INVALIDARG if firstEntryIndex + entryCount is greater
/// than the actual number of palette entries as returned by GetPaletteEntryCount.
/// The return value is DWRITE_E_NOCOLOR if the font does not have a palette
/// with the specified palette index.
/// </returns>
STDMETHOD(GetPaletteEntries)(
    [in] UINT32 colorPaletteIndex,
    [in] UINT32 firstEntryIndex,
    [in] UINT32 entryCount,
    [in, out] DWRITE_COLOR_F* paletteEntries
    );

/// <summary>
/// Determines the recommended text rendering and grid-fit mode to be used based on the
/// font, size, world transform, and measuring mode.
/// </summary>
/// <param name="fontEmSize">Logical font size in DIPs.</param>
/// <param name="dpiX">Number of pixels per logical inch in the horizontal direction.</param>
/// <param name="dpiY">Number of pixels per logical inch in the vertical direction.</param>
/// <param name="transform">Specifies the world transform.</param>
/// <param name="outlineThreshold">Specifies the quality of the graphics system's outline rendering,
/// affects the size threshold above which outline rendering is used.</param>
/// <param name="measuringMode">Specifies the method used to measure during text layout. For proper
/// glyph spacing, the function returns a rendering mode that is compatible with the specified 
/// measuring mode.</param>
/// <param name="renderingParams">Rendering parameters object. This parameter is necessary in case the rendering parameters 
/// object overrides the rendering mode.</param>
/// <param name="renderingMode">Receives the recommended rendering mode.</param>
/// <param name="gridFitMode">Receives the recommended grid-fit mode.</param>
/// <remarks>
/// This method should be used to determine the actual rendering mode in cases where the rendering 
/// mode of the rendering params object is DWRITE_RENDERING_MODE_DEFAULT, and the actual grid-fit
/// mode when the rendering params object is DWRITE_GRID_FIT_MODE_DEFAULT.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetRecommendedRenderingMode2)(
    [in] FLOAT fontEmSize,
    [in] FLOAT dpiX,
    [in] FLOAT dpiY,
    //_In_opt_ DWRITE_MATRIX* transform,
    [in] void* transform,
    [in] BOOL isSideways,
    [in] DWRITE_OUTLINE_THRESHOLD outlineThreshold,
    [in] DWRITE_MEASURING_MODE measuringMode,
    [in] IDWriteRenderingParams* renderingParams,
    [in, out] DWRITE_RENDERING_MODE* renderingMode,
    [in, out] DWRITE_GRID_FIT_MODE* gridFitMode
    );

//using IDWriteFontFace1::GetRecommendedRenderingMode;
};

/// <summary>
/// Reserved palette entry index that does not specify any palette entry.
/// </summary>
//#define DWRITE_NO_PALETTE_INDEX 0xFFFF

/// <summary>
/// Represents a color glyph run. The IDWriteFactory2::TranslateColorGlyphRun
/// method returns an ordered collection of color glyph runs, which can be
/// layered on top of each other to produce a color representation of the
/// given base glyph run.
/// </summary>
typedef struct DWRITE_COLOR_GLYPH_RUN
{
    /// <summary>
    /// Glyph run to render.
    /// </summary>
    DWRITE_GLYPH_RUN glyphRun;

    /// <summary>
    /// Optional glyph run description.
    /// </summary>
    //_Maybenull_ DWRITE_GLYPH_RUN_DESCRIPTION* 
    LongPtr glyphRunDescription;

    /// <summary>
    /// Location at which to draw this glyph run.
    /// </summary>
    FLOAT baselineOriginX;
    FLOAT baselineOriginY;

    /// <summary>
    /// Color to use for this layer, if any. If the paletteIndex member is
    /// DWRITE_NO_PALETTE_INDEX (0xFFFF) then no color is specifed by the font,
    /// this member is set to { 0, 0, 0, 0 }, and the client should use the 
    /// current foreground brush. Otherwise, this member is set to a color from
    /// the font's color palette, i.e., the same color that would be returned
    /// by IDWriteFontFace2::GetPaletteEntries for the current palette index.
    /// </summary>
    DWRITE_COLOR_F runColor;

    /// <summary>
    /// Zero-based index of this layer's color entry in the current color
    /// palette, or DWRITE_NO_PALETTE_INDEX (0xFFFF) if this layer
    /// is to be rendered using the current foreground brush.
    /// </summary>
    UINT16 paletteIndex;
} DWRITE_COLOR_GLYPH_RUN;

/// <summary>
/// Enumerator for an ordered collection of color glyph runs.
/// </summary>
[
    odl,
    uuid(d31fbe17-f157-41a2-8d24-cb779e0560e8) 
]
interface IDWriteColorGlyphRunEnumerator : stdole.IUnknown
{
    /// <summary>
    /// Advances to the first or next color run. The runs are enumerated
    /// in order from back to front.
    /// </summary>
    /// <param name="hasRun">Receives TRUE if there is a current run or
    /// FALSE if the end of the sequence has been reached.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(MoveNext)(
        [in, out] BOOL * hasRun
        );

/// <summary>
/// Gets the current color glyph run.
/// </summary>
/// <param name="colorGlyphRun">Receives a pointer to the color
/// glyph run. The pointer remains valid until the next call to
/// MoveNext or until the interface is released.</param>
/// <returns>
/// Standard HRESULT error code. An error is returned if there is
/// no current glyph run, i.e., if MoveNext has not yet been called
/// or if the end of the sequence has been reached.
/// </returns>
STDMETHOD(GetCurrentRun)(
    //_Outptr_ DWRITE_COLOR_GLYPH_RUN const** colorGlyphRun
    [in, out] LongPtr *colorGlyphRun
    );
};

/// <summary>
/// The interface that represents text rendering settings for glyph rasterization and filtering.
/// </summary>
[
    odl,
    uuid(F9D711C3-9777-40AE-87E8-3E5AF9BF0948) 
]
interface IDWriteRenderingParams2 : IDWriteRenderingParams1
{
    /// <summary>
    /// Gets the grid fitting mode.
    /// </summary>
    STDMETHOD_(DWRITE_GRID_FIT_MODE, GetGridFitMode)();
};

/// <summary>
/// The root factory interface for all DWrite objects.
/// </summary>
[
    odl,
    uuid(0439fc60-ca44-4994-8dee-3a9af7b732ec) 
]
interface IDWriteFactory2 : IDWriteFactory1
{
    /// <summary>
    /// Get the system-appropriate font fallback mapping list.
    /// </summary>
    /// <param name="fontFallback">The system fallback list.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSystemFontFallback)(
        [in, out] IDWriteFontFallback * *fontFallback
        );

/// <summary>
/// Create a custom font fallback builder.
/// </summary>
/// <param name="fontFallbackBuilder">Empty font fallback builder.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(CreateFontFallbackBuilder)(
    [in, out] IDWriteFontFallbackBuilder** fontFallbackBuilder
    );

/// <summary>
/// Translates a glyph run to a sequence of color glyph runs, which can be
/// rendered to produce a color representation of the original "base" run.
/// </summary>
/// <param name="baselineOriginX">Horizontal origin of the base glyph run in
/// pre-transform coordinates.</param>
/// <param name="baselineOriginY">Vertical origin of the base glyph run in
/// pre-transform coordinates.</param>
/// <param name="glyphRun">Pointer to the original "base" glyph run.</param>
/// <param name="glyphRunDescription">Optional glyph run description.</param>
/// <param name="measuringMode">Measuring mode, needed to compute the origins
/// of each glyph.</param>
/// <param name="worldToDeviceTransform">Matrix converting from the client's
/// coordinate space to device coordinates (pixels), i.e., the world transform
/// multiplied by any DPI scaling.</param>
/// <param name="colorPaletteIndex">Zero-based index of the color palette to use.
/// Valid indices are less than the number of palettes in the font, as returned
/// by IDWriteFontFace2::GetColorPaletteCount.</param>
/// <param name="colorLayers">If the function succeeds, receives a pointer
/// to an enumerator object that can be used to obtain the color glyph runs.
/// If the base run has no color glyphs, then the output pointer is NULL
/// and the method returns DWRITE_E_NOCOLOR.</param>
/// <returns>
/// Returns DWRITE_E_NOCOLOR if the font has no color information, the base
/// glyph run does not contain any color glyphs, or the specified color palette
/// index is out of range. In this case, the client should render the base glyph 
/// run. Otherwise, returns a standard HRESULT error code.
/// </returns>
STDMETHOD(TranslateColorGlyphRun)(
    [in] FLOAT baselineOriginX,
    [in] FLOAT baselineOriginY,
    [in] DWRITE_GLYPH_RUN* glyphRun,
    //_In_opt_ DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
    [in] void* glyphRunDescription,
    [in] DWRITE_MEASURING_MODE measuringMode,
    //_In_opt_ DWRITE_MATRIX* worldToDeviceTransform,
    [in] void* worldToDeviceTransform,
    [in] UINT32 colorPaletteIndex,
    [in, out] IDWriteColorGlyphRunEnumerator** colorLayers
    );

/// <summary>
/// Creates a rendering parameters object with the specified properties.
/// </summary>
/// <param name="gamma">The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</param>
/// <param name="enhancedContrast">The amount of contrast enhancement, zero or greater.</param>
/// <param name="clearTypeLevel">The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</param>
/// <param name="pixelGeometry">The geometry of a device pixel.</param>
/// <param name="renderingMode">Method of rendering glyphs. In most cases, this should be DWRITE_RENDERING_MODE_DEFAULT to automatically use an appropriate mode.</param>
/// <param name="gridFitMode">How to grid fit glyph outlines. In most cases, this should be DWRITE_GRID_FIT_DEFAULT to automatically choose an appropriate mode.</param>
/// <param name="renderingParams">Holds the newly created rendering parameters object, or NULL in case of failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(CreateCustomRenderingParams2)(
    [in] FLOAT gamma,
    [in] FLOAT enhancedContrast,
    [in] FLOAT grayscaleEnhancedContrast,
    [in] FLOAT clearTypeLevel,
    [in] DWRITE_PIXEL_GEOMETRY pixelGeometry,
    [in] DWRITE_RENDERING_MODE renderingMode,
    [in] DWRITE_GRID_FIT_MODE gridFitMode,
    [in, out] IDWriteRenderingParams2** renderingParams
    );
//
//using IDWriteFactory::CreateCustomRenderingParams;
//using IDWriteFactory1::CreateCustomRenderingParams;

/// <summary>
/// Creates a glyph run analysis object, which encapsulates information
/// used to render a glyph run.
/// </summary>
/// <param name="glyphRun">Structure specifying the properties of the glyph run.</param>
/// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
/// scaling specified by the emSize and pixelsPerDip.</param>
/// <param name="renderingMode">Specifies the rendering mode, which must be one of the raster rendering modes (i.e., not default
/// and not outline).</param>
/// <param name="measuringMode">Specifies the method to measure glyphs.</param>
/// <param name="gridFitMode">How to grid-fit glyph outlines. This must be non-default.</param>
/// <param name="baselineOriginX">Horizontal position of the baseline origin, in DIPs.</param>
/// <param name="baselineOriginY">Vertical position of the baseline origin, in DIPs.</param>
/// <param name="glyphRunAnalysis">Receives a pointer to the newly created object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(CreateGlyphRunAnalysis2)(
    [in] DWRITE_GLYPH_RUN* glyphRun,
    //_In_opt_ DWRITE_MATRIX* transform,
    [in] void* transform,
    [in] DWRITE_RENDERING_MODE renderingMode,
    [in] DWRITE_MEASURING_MODE measuringMode,
    [in] DWRITE_GRID_FIT_MODE gridFitMode,
    [in] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode,
    [in] FLOAT baselineOriginX,
    [in] FLOAT baselineOriginY,
    [in, out] IDWriteGlyphRunAnalysis** glyphRunAnalysis
    );

//using IDWriteFactory::CreateGlyphRunAnalysis;
};









//**************************************************************

//   DWRITE_3.h

//**************************************************************




interface IDWriteFontFaceReference;
interface IDWriteFont3;
interface IDWriteFontFace3;
interface IDWriteFontSet;
interface IDWriteFontSetBuilder;
interface IDWriteFontCollection1;
interface IDWriteFontFamily1;
interface IDWriteStringList;
interface IDWriteFontDownloadQueue;


/// <summary>
/// A font resource could not be accessed because it was remote. This can happen
/// when calling CreateFontFace on a non-local font or trying to measure/draw
/// glyphs that are not downloaded yet.
/// </summary>
//#ifndef DWRITE_E_REMOTEFONT
//#define DWRITE_E_REMOTEFONT    _HRESULT_TYPEDEF_(0x8898500DL)
//#endif
//
///// <summary>
///// The download was canceled, which happens if the application calls
///// IDWriteFontDownloadQueue::CancelDownload before they finish.
///// </summary>
//#ifndef DWRITE_E_DOWNLOADCANCELLED
//#define DWRITE_E_DOWNLOADCANCELLED  _HRESULT_TYPEDEF_(0x8898500EL)
//#endif
//
///// <summary>
///// The download failed to complete because the remote resource is missing
///// or the network is down.
///// </summary>
//#ifndef DWRITE_E_DOWNLOADFAILED
//#define DWRITE_E_DOWNLOADFAILED  _HRESULT_TYPEDEF_(0x8898500FL)
//#endif
//
///// <summary>
///// A download request was not added or a download failed because there
///// are too many active downloads.
///// </summary>
//#ifndef DWRITE_E_TOOMANYDOWNLOADS
//#define DWRITE_E_TOOMANYDOWNLOADS  _HRESULT_TYPEDEF_(0x88985010L)
//#endif

/// <summary>
/// The font property enumeration identifies a string in a font.
/// </summary>
typedef enum DWRITE_FONT_PROPERTY_ID
{
    /// <summary>
    /// Unspecified font property identifier.
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_NONE,

    /// <summary>
    /// Family name for the weight-stretch-style model.
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FAMILY_NAME,

    /// <summary>
    /// Family name preferred by the designer. This enables font designers to group more than four fonts in a single family without losing compatibility with
    /// GDI. This name is typically only present if it differs from the GDI-compatible family name.
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FAMILY_NAME,

    /// <summary>
    /// Face name of the for the weight-stretch-style (e.g., Regular or Bold).
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FACE_NAME,

    /// <summary>
    /// The full name of the font, e.g. "Arial Bold", from name id 4 in the name table.
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_FULL_NAME,

    /// <summary>
    /// GDI-compatible family name. Because GDI allows a maximum of four fonts per family, fonts in the same family may have different GDI-compatible family names
    /// (e.g., "Arial", "Arial Narrow", "Arial Black").
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_WIN32_FAMILY_NAME,

    /// <summary>
    /// The postscript name of the font, e.g. "GillSans-Bold" from name id 6 in the name table.
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_POSTSCRIPT_NAME,

    /// <summary>
    /// Script/language tag to identify the scripts or languages that the font was
    /// primarily designed to support.
    /// </summary>
    /// <remarks>
    /// The design script/language tag is meant to be understood from the perspective of
    /// users. For example, a font is considered designed for English if it is considered
    /// useful for English users. Note that this is different from what a font might be
    /// capable of supporting. For example, the Meiryo font was primarily designed for
    /// Japanese users. While it is capable of displaying English well, it was not
    /// meant to be offered for the benefit of non-Japanese-speaking English users.
    ///
    /// As another example, a font designed for Chinese may be capable of displaying
    /// Japanese text, but would likely look incorrect to Japanese users.
    /// 
    /// The valid values for this property are "ScriptLangTag" values. These are adapted
    /// from the IETF BCP 47 specification, "Tags for Identifying Languages" (see
    /// http://tools.ietf.org/html/bcp47). In a BCP 47 language tag, a language subtag
    /// element is mandatory and other subtags are optional. In a ScriptLangTag, a
    /// script subtag is mandatory and other subtags are option. The following
    /// augmented BNF syntax, adapted from BCP 47, is used:
    /// 
    ///     ScriptLangTag = [language "-"]
    ///                     script
    ///                     ["-" region]
    ///                     *("-" variant)
    ///                     *("-" extension)
    ///                     ["-" privateuse]
    /// 
    /// The expansion of the elements and the intended semantics associated with each
    /// are as defined in BCP 47. Script subtags are taken from ISO 15924. At present,
    /// no extensions are defined, and any extension should be ignored. Private use
    /// subtags are defined by private agreement between the source and recipient and
    /// may be ignored.
    /// 
    /// Subtags must be valid for use in BCP 47 and contained in the Language Subtag
    /// Registry maintained by IANA. (See
    /// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
    /// and section 3 of BCP 47 for details.
    /// 
    /// Any ScriptLangTag value not conforming to these specifications is ignored.
    /// 
    /// Examples:
    ///   "Latn" denotes Latin script (and any language or writing system using Latin)
    ///   "Cyrl" denotes Cyrillic script
    ///   "sr-Cyrl" denotes Cyrillic script as used for writing the Serbian language;
    ///       a font that has this property value may not be suitable for displaying
    ///       text in Russian or other languages written using Cyrillic script
    ///   "Jpan" denotes Japanese writing (Han + Hiragana + Katakana)
    ///
    /// When passing this property to GetPropertyValues, use the overload which does
    /// not take a language parameter, since this property has no specific language.
    /// </remarks>
    DWRITE_FONT_PROPERTY_ID_DESIGN_SCRIPT_LANGUAGE_TAG,

    /// <summary>
    /// Script/language tag to identify the scripts or languages that the font declares
    /// it is able to support.
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_SUPPORTED_SCRIPT_LANGUAGE_TAG,

    /// <summary>
    /// Semantic tag to describe the font (e.g. Fancy, Decorative, Handmade, Sans-serif, Swiss, Pixel, Futuristic).
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_SEMANTIC_TAG,

    /// <summary>
    /// Weight of the font represented as a decimal string in the range 1-999.
    /// </summary>
    /// <remark>
    /// This enum is discouraged for use with IDWriteFontSetBuilder2 in favor of the more generic font axis
    /// DWRITE_FONT_AXIS_TAG_WEIGHT which supports higher precision and range.
    /// </remark>
    DWRITE_FONT_PROPERTY_ID_WEIGHT,

    /// <summary>
    /// Stretch of the font represented as a decimal string in the range 1-9.
    /// </summary>
    /// <remark>
    /// This enum is discouraged for use with IDWriteFontSetBuilder2 in favor of the more generic font axis
    /// DWRITE_FONT_AXIS_TAG_WIDTH which supports higher precision and range.
    /// </remark>
    DWRITE_FONT_PROPERTY_ID_STRETCH,

    /// <summary>
    /// Style of the font represented as a decimal string in the range 0-2.
    /// </summary>
    /// <remark>
    /// This enum is discouraged for use with IDWriteFontSetBuilder2 in favor of the more generic font axes
    /// DWRITE_FONT_AXIS_TAG_SLANT and DWRITE_FONT_AXIS_TAG_ITAL.
    /// </remark>
    DWRITE_FONT_PROPERTY_ID_STYLE,

    /// <summary>
    /// Face name preferred by the designer. This enables font designers to group more than four fonts in a single
    /// family without losing compatibility with GDI.
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FACE_NAME,

    /// <summary>
    /// Total number of properties for NTDDI_WIN10 (IDWriteFontSet).
    /// </summary>
    /// <remarks>
    /// DWRITE_FONT_PROPERTY_ID_TOTAL cannot be used as a property ID.
    /// </remarks>
    DWRITE_FONT_PROPERTY_ID_TOTAL = 13, //DWRITE_FONT_PROPERTY_ID_STYLE + 1,

    /// <summary>
    /// Total number of properties for NTDDI_WIN10_RS3 (IDWriteFontSet1).
    /// </summary>
    DWRITE_FONT_PROPERTY_ID_TOTAL_RS3 = 14, //DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FACE_NAME + 1,

    // Obsolete aliases kept to avoid breaking existing code.
    DWRITE_FONT_PROPERTY_ID_PREFERRED_FAMILY_NAME = 13, //DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FAMILY_NAME,
    DWRITE_FONT_PROPERTY_ID_FAMILY_NAME = 1, //DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FAMILY_NAME,
    DWRITE_FONT_PROPERTY_ID_FACE_NAME = 3 //DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FACE_NAME,
} DWRITE_FONT_PROPERTY_ID;


/// <summary>
/// Font property used for filtering font sets and
/// building a font set with explicit properties.
/// </summary>
typedef struct DWRITE_FONT_PROPERTY
{
    /// <summary>
    /// Specifies the requested font property, such as DWRITE_FONT_PROPERTY_ID_FAMILY_NAME.
    /// </summary>
    DWRITE_FONT_PROPERTY_ID propertyId;

    /// <summary>
    /// Specifies the property value, such as "Segoe UI".
    /// </summary>
    //_Field_z_ WCHAR* propertyValue;
    LongPtr propertyValue;
    /// <summary>
    /// Specifies the language / locale to use, such as "en-US". 
    /// </summary>
    /// <remarks>
    /// When passing property information to AddFontFaceReference, localeName indicates
    /// the language of the property value. BCP 47 language tags should be used. If a
    /// property value is inherently non-linguistic, this can be left empty.
    ///
    /// When used for font set filtering, leave this empty: a match will be found
    /// regardless of language associated with property values.
    /// </remarks>
    //_Field_z_ _Maybenull_ WCHAR* localeName;
    LongPtr localeName;
} DWRITE_FONT_PROPERTY;


/// <summary>
/// Specifies the locality of a resource.
/// </summary>
typedef enum DWRITE_LOCALITY
{
    /// <summary>
    /// The resource is remote, and information is unknown yet, including the file size and date.
    /// Attempting to create a font or file stream will fail until locality becomes at least partial.
    /// </summary>
    DWRITE_LOCALITY_REMOTE,

    /// <summary>
    /// The resource is partially local, meaning you can query the size and date of the file
    /// stream, and you may be able to create a font face and retrieve the particular glyphs
    /// for metrics and drawing, but not all the glyphs will be present.
    /// </summary>
    DWRITE_LOCALITY_PARTIAL,

    /// <summary>
    /// The resource is completely local, and all font functions can be called
    /// without concern of missing data or errors related to network connectivity.
    /// </summary>
    DWRITE_LOCALITY_LOCAL,
} DWRITE_LOCALITY;


/// <summary>
/// Represents a method of rendering glyphs.
/// </summary>
typedef enum DWRITE_RENDERING_MODE1
{
    /// <summary>
    /// Specifies that the rendering mode is determined automatically based on the font and size.
    /// </summary>
    DWRITE_RENDERING_MODE1_DEFAULT = 0, //DWRITE_RENDERING_MODE_DEFAULT,

    /// <summary>
    /// Specifies that no antialiasing is performed. Each pixel is either set to the foreground 
    /// color of the text or retains the color of the background.
    /// </summary>
    DWRITE_RENDERING_MODE1_ALIASED = 1, //DWRITE_RENDERING_MODE_ALIASED,

    /// <summary>
    /// Specifies that antialiasing is performed in the horizontal direction and the appearance
    /// of glyphs is layout-compatible with GDI using CLEARTYPE_QUALITY. Use DWRITE_MEASURING_MODE_GDI_CLASSIC 
    /// to get glyph advances. The antialiasing may be either ClearType or grayscale depending on
    /// the text antialiasing mode.
    /// </summary>
    DWRITE_RENDERING_MODE1_GDI_CLASSIC = 2, //DWRITE_RENDERING_MODE_GDI_CLASSIC,

    /// <summary>
    /// Specifies that antialiasing is performed in the horizontal direction and the appearance
    /// of glyphs is layout-compatible with GDI using CLEARTYPE_NATURAL_QUALITY. Glyph advances
    /// are close to the font design advances, but are still rounded to whole pixels. Use
    /// DWRITE_MEASURING_MODE_GDI_NATURAL to get glyph advances. The antialiasing may be either
    /// ClearType or grayscale depending on the text antialiasing mode.
    /// </summary>
    DWRITE_RENDERING_MODE1_GDI_NATURAL = 3, //DWRITE_RENDERING_MODE_GDI_NATURAL,

    /// <summary>
    /// Specifies that antialiasing is performed in the horizontal direction. This rendering
    /// mode allows glyphs to be positioned with subpixel precision and is therefore suitable
    /// for natural (i.e., resolution-independent) layout. The antialiasing may be either
    /// ClearType or grayscale depending on the text antialiasing mode.
    /// </summary>
    DWRITE_RENDERING_MODE1_NATURAL = 4, //DWRITE_RENDERING_MODE_NATURAL,

    /// <summary>
    /// Similar to natural mode except that antialiasing is performed in both the horizontal
    /// and vertical directions. This is typically used at larger sizes to make curves and
    /// diagonal lines look smoother. The antialiasing may be either ClearType or grayscale
    /// depending on the text antialiasing mode.
    /// </summary>
    DWRITE_RENDERING_MODE1_NATURAL_SYMMETRIC = 5, //DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC,

    /// <summary>
    /// Specifies that rendering should bypass the rasterizer and use the outlines directly. 
    /// This is typically used at very large sizes.
    /// </summary>
    DWRITE_RENDERING_MODE1_OUTLINE = 6, //DWRITE_RENDERING_MODE_OUTLINE,

    /// <summary>
    /// Similar to natural symmetric mode except that when possible, text should be rasterized
    /// in a downsampled form.
    /// </summary>
    DWRITE_RENDERING_MODE1_NATURAL_SYMMETRIC_DOWNSAMPLED,
} DWRITE_RENDERING_MODE1;


/// <summary>
/// The interface that represents text rendering settings for glyph rasterization and filtering.
/// </summary>
[
    odl,
    uuid(B7924BAA-391B-412A-8C5C-E44CC2D867DC) 
]
interface IDWriteRenderingParams3 : IDWriteRenderingParams2
{
    /// <summary>
    /// Gets the rendering mode.
    /// </summary>
    STDMETHOD_(DWRITE_RENDERING_MODE1, GetRenderingMode1)();
};


/// <summary>
/// The root factory interface for all DWrite objects.
/// </summary>
[
    odl,
    uuid(9A1B41C3-D3BB-466A-87FC-FE67556A3B65) 
]
interface IDWriteFactory3 : IDWriteFactory2
{
    /// <summary>
    /// Creates a glyph run analysis object, which encapsulates information
    /// used to render a glyph run.
    /// </summary>
    /// <param name="glyphRun">Structure specifying the properties of the glyph run.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified by the emSize.</param>
    /// <param name="renderingMode">Specifies the rendering mode, which must be one of the raster rendering modes (i.e., not default
    /// and not outline).</param>
    /// <param name="measuringMode">Specifies the method to measure glyphs.</param>
    /// <param name="gridFitMode">How to grid-fit glyph outlines. This must be non-default.</param>
    /// <param name="baselineOriginX">Horizontal position of the baseline origin, in DIPs.</param>
    /// <param name="baselineOriginY">Vertical position of the baseline origin, in DIPs.</param>
    /// <param name="glyphRunAnalysis">Receives a pointer to the newly created object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateGlyphRunAnalysis3)(
        [in] DWRITE_GLYPH_RUN* glyphRun,
        //_In_opt_ DWRITE_MATRIX* transform,
        [in] void* transform,
        [in] DWRITE_RENDERING_MODE1 renderingMode,
        [in] DWRITE_MEASURING_MODE measuringMode,
        [in] DWRITE_GRID_FIT_MODE gridFitMode,
        [in] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode,
        [in] FLOAT baselineOriginX,
        [in] FLOAT baselineOriginY,
        [in, out] IDWriteGlyphRunAnalysis * *glyphRunAnalysis
        );

    //using IDWriteFactory::CreateGlyphRunAnalysis;
    //using IDWriteFactory2::CreateGlyphRunAnalysis;

    /// <summary>
    /// Creates a rendering parameters object with the specified properties.
    /// </summary>
    /// <param name="gamma">The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</param>
    /// <param name="enhancedContrast">The amount of contrast enhancement, zero or greater.</param>
    /// <param name="grayscaleEnhancedContrast">The amount of contrast enhancement to use for grayscale antialiasing, zero or greater.</param>
    /// <param name="clearTypeLevel">The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</param>
    /// <param name="pixelGeometry">The geometry of a device pixel.</param>
    /// <param name="renderingMode">Method of rendering glyphs. In most cases, this should be DWRITE_RENDERING_MODE_DEFAULT to automatically use an appropriate mode.</param>
    /// <param name="gridFitMode">How to grid fit glyph outlines. In most cases, this should be DWRITE_GRID_FIT_DEFAULT to automatically choose an appropriate mode.</param>
    /// <param name="renderingParams">Receives a pointer to the newly created rendering parameters object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateCustomRenderingParams3)(
        [in] FLOAT gamma,
        [in] FLOAT enhancedContrast,
        [in] FLOAT grayscaleEnhancedContrast,
        [in] FLOAT clearTypeLevel,
        [in] DWRITE_PIXEL_GEOMETRY pixelGeometry,
        [in] DWRITE_RENDERING_MODE1 renderingMode,
        [in] DWRITE_GRID_FIT_MODE gridFitMode,
        [in, out] IDWriteRenderingParams3** renderingParams
        );

    //using IDWriteFactory::CreateCustomRenderingParams;
    //using IDWriteFactory1::CreateCustomRenderingParams;
    //using IDWriteFactory2::CreateCustomRenderingParams;
   /// <summary>
    /// Creates a reference to a font given a file.
    /// </summary>
    /// <param name="fontFile">User provided font file representing the font face.</param>
    /// <param name="faceIndex">The zero based index of a font face in cases when the font files contain a collection of font faces.
    ///     If the font files contain a single face, this value should be zero.</param>
    /// <param name="fontSimulations">Font face simulation flags for algorithmic emboldening and italicization.</param>
    /// <param name="fontFaceReference">Receives a pointer to the newly created font face reference object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontFaceReferenceI)(
        [in] IDWriteFontFile* fontFile,
        [in] UINT32 faceIndex,
        [in] DWRITE_FONT_SIMULATIONS fontSimulations,
        [in, out] IDWriteFontFaceReference** fontFaceReference
        );

    /// <summary>
    /// Creates a reference to a font given a full path.
    /// </summary>
    /// <param name="filePath">Absolute file path. Subsequent operations on the constructed object may fail
    ///     if the user provided filePath doesn't correspond to a valid file on the disk.</param>
    /// <param name="lastWriteTime">Last modified time of the input file path. If the parameter is omitted,
    ///     the function will access the font file to obtain its last write time, so the clients are encouraged to specify this value
    ///     to avoid extra disk access. Subsequent operations on the constructed object may fail
    ///     if the user provided lastWriteTime doesn't match the file on the disk.</param>
    /// <param name="faceIndex">The zero based index of a font face in cases when the font files contain a collection of font faces.
    ///     If the font files contain a single face, this value should be zero.</param>
    /// <param name="fontSimulations">Font face simulation flags for algorithmic emboldening and italicization.</param>
    /// <param name="fontFaceReference">Receives a pointer to the newly created font face reference object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontFaceReference)(
        [in] LongPtr filePath,
        //_In_opt_ FILETIME* lastWriteTime,
        [in] void* lastWriteTime,
        [in] UINT32 faceIndex,
        [in] DWRITE_FONT_SIMULATIONS fontSimulations,
        [in, out] IDWriteFontFaceReference** fontFaceReference
        );

 
    /// <summary>
    /// Retrieves the list of system fonts.
    /// </summary>
    /// <param name="fontSet">Receives a pointer to the font set object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSystemFontSet)(
        [in, out] IDWriteFontSet** fontSet
        );

    /// <summary>
    /// Creates an empty font set builder to add font face references
    /// and create a custom font set.
    /// </summary>
    /// <param name="fontSetBuilder">Receives a pointer to the newly created font set builder object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontSetBuilder)(
        [in, out] IDWriteFontSetBuilder** fontSetBuilder
        );

    /// <summary>
    /// Create a weight-stretch-style based collection of families (DWRITE_FONT_FAMILY_MODEL_WEIGHT_STRETCH_STYLE)
    /// from a set of fonts.
    /// </summary>
    /// <param name="fontSet">A set of fonts to use to build the collection.</param>
    /// <param name="fontCollection">Receives a pointer to the newly created font collection object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontCollectionFromFontSet)(
        [in] IDWriteFontSet* fontSet,
        [in, out] IDWriteFontCollection1** fontCollection
        );

    /// <summary>
    /// Retrieves a weight-stretch-style based collection of font families.
    /// </summary>
    /// <param name="includeDownloadableFonts">Include downloadable fonts or only locally installed ones.</param>
    /// <param name="fontCollection">Receives a pointer to the newly created font collection object, or nullptr in
    ///     case of failure.</param>
    /// <param name="checkForUpdates">If this parameter is nonzero, the function performs an immediate check for changes 
    ///     to the set of system fonts. If this parameter is FALSE, the function will still detect changes if the font
    ///     cache service is running, but there may be some latency. For example, an application might specify TRUE if
    ///     it has itself just installed a font and wants to be sure the font collection contains that font.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSystemFontCollection3)(
        [in] BOOL includeDownloadableFonts,
        [in, out] IDWriteFontCollection1** fontCollection,
        [in] BOOL checkForUpdates
        );

    //using IDWriteFactory::GetSystemFontCollection;

    /// <summary>
    /// Gets the font download queue associated with this factory object.
    /// </summary>
    /// <param name="IDWriteFontDownloadQueue">Receives a pointer to the font download queue interface.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontDownloadQueue)(
        [in, out] IDWriteFontDownloadQueue** fontDownloadQueue
        );
};


/// <summary>
/// Set of fonts used for creating font faces, selecting nearest matching fonts, and filtering.
/// Unlike IDWriteFontFamily and IDWriteFontList, which are part of the IDWriteFontCollection heirarchy, font sets
/// are unordered flat lists.
/// </summary>
[
    odl,
    uuid(53585141-D9F8-4095-8321-D73CF6BD116B) 
]
interface IDWriteFontSet : stdole.IUnknown
{
    /// <summary>
    /// Get the number of total fonts in the set.
    /// </summary>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD_(UINT32, GetFontCount)();

/// <summary>
/// Get a reference to the font at this index, which may be local or remote.
/// </summary>
/// <param name="listIndex">Zero-based index of the font.</param>
/// <param name="fontFaceReference">Receives a pointer the font face reference object, or nullptr on failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontFaceReference)(
    [in] UINT32 listIndex,
    [in, out] IDWriteFontFaceReference** fontFaceReference
    );

/// <summary>
/// Gets the index of the matching font face reference in the font set, with the same file, face index, and simulations.
/// </summary>
/// <param name="fontFaceReference">Font face reference object that specifies the physical font.</param>
/// <param name="listIndex">Receives the zero-based index of the matching font if the font was found, or UINT_MAX otherwise.</param>
/// <param name="exists">Receives TRUE if the font exists or FALSE otherwise.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(FindFontFaceReference)(
    [in] IDWriteFontFaceReference* fontFaceReference,
    [in, out] UINT32* listIndex,
    [in, out] BOOL* exists
    );

/// <summary>
/// Gets the index of the matching font face reference in the font set, with the same file, face index, and simulations.
/// </summary>
/// <param name="fontFaceReference">Font face object that specifies the physical font.</param>
/// <param name="listIndex">Receives the zero-based index of the matching font if the font was found, or UINT_MAX otherwise.</param>
/// <param name="exists">Receives TRUE if the font exists or FALSE otherwise.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(FindFontFace)(
    [in] IDWriteFontFace* fontFace,
    [in, out] UINT32* listIndex,
    [in, out] BOOL* exists
    );
/// <summary>
/// Returns all unique property values in the set, which can be used
/// for purposes such as displaying a family list or tag cloud. All values
/// are returned regardless of language, including all localized names.
/// </summary>
/// <param name="propertyID">Font property of interest.</param>
/// <param name="stringsList">Receives a pointer to the newly created strings list.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// For example, suppose the font set includes the Meiryo family, which has both Japanese and English family names.
/// The returned list of distinct family names would include both the Japanese and English names.
/// </remarks>
STDMETHOD(GetPropertyValuesC)(
    [in] DWRITE_FONT_PROPERTY_ID propertyID,
    [in, out] IDWriteStringList** values
    );


/// <summary>
/// Returns all unique property values in the set, which can be used
/// for purposes such as displaying a family list or tag cloud. Values are
/// returned in priority order according to the language list, such that if
/// a font contains more than one localized name, the preferred one will be
/// returned.
/// </summary>
/// <param name="propertyID">Font property of interest.</param>
/// <param name="preferredLocaleNames">List of semicolon delimited language names in preferred
///     order. When a particular string like font family has more than one localized name,
///     the first match is returned.</param>
/// <param name="stringsList">Receives a pointer to the newly created strings list.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// For example, suppose the font set includes the Meiryo family, which has both Japanese and English family names.
/// The returned list of distinct family names would include either the Japanese name (if "ja-jp" was specified as
/// a preferred locale) or the English name (in all other cases).
/// </remarks>
STDMETHOD(GetPropertyValuesB)(
    [in] DWRITE_FONT_PROPERTY_ID propertyID,
    [in] LongPtr preferredLocaleNames,
    [in, out] IDWriteStringList** values
    );

/// <summary>
/// Returns the property values of a specific font item index.
/// </summary>
/// <param name="listIndex">Zero-based index of the font.</param>
/// <param name="propertyID">Font property of interest.</param>
/// <param name="exists">Receives the value TRUE if the font contains the specified property identifier or FALSE if not.</param>
/// <param name="strings">Receives a pointer to the newly created localized strings object, or nullptr on failure or non-existent property.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetPropertyValues)(
    [in] UINT32 listIndex,
    [in] DWRITE_FONT_PROPERTY_ID propertyId,
    [in, out] BOOL* exists,
    [in, out] IDWriteLocalizedStrings** values
    );

/// <summary>
/// Returns how many times a given property value occurs in the set.
/// </summary>
/// <param name="property">Font property of interest.</param>
/// <param name="propertyOccurrenceCount">How many times that property occurs.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// For example, the family name "Segoe UI" may return a count of 12,
/// whereas Harrington only has 1.
/// </remarks>
STDMETHOD(GetPropertyOccurrenceCount)(
    [in] DWRITE_FONT_PROPERTY* property,
    [in, out] UINT32* propertyOccurrenceCount
    );
/// <summary>
/// Returns a list of fonts within the given WWS family prioritized by
/// WWS distance.
/// </summary>
/// <param name="familyName">Neutral or localized family name of font.</param>
/// <param name="fontWeight">Weight of font.</param>
/// <param name="fontStretch">Stretch of font.</param>
/// <param name="fontStyle">Slope of font.</param>
/// <param name="filteredSet">Subset of fonts that match the properties,
///     or nullptr on failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// The returned list can include simulated bold and oblique variants,
/// which would be useful for font fallback selection.
/// </remarks>
STDMETHOD(GetMatchingFontsB)(
    [in] LongPtr familyName,
    [in] DWRITE_FONT_WEIGHT fontWeight,
    [in] DWRITE_FONT_STRETCH fontStretch,
    [in] DWRITE_FONT_STYLE fontStyle,
    [in, out] IDWriteFontSet** filteredSet
    );


/// <summary>
/// Returns a subset of fonts filtered by the given properties.
/// </summary>
/// <param name="properties">List of properties to filter using.</param>
/// <param name="propertyCount">How many properties to filter.</param>
/// <param name="filteredSet">Subset of fonts that match the properties,
///     or nullptr on failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// If no fonts matched the filter, the subset will be empty (GetFontCount
/// returns 0), but the function does not return an error. The subset will
/// always be equal to or less than the original set.
/// </remarks>
STDMETHOD(GetMatchingFonts)(
    [in] DWRITE_FONT_PROPERTY* fproperties,
    [in] UINT32 propertyCount,
    [in, out] IDWriteFontSet** filteredSet
    );
};


/// <summary>
/// Builder interface to add font face references and create a font set.
/// </summary>
[
    odl,
    uuid(2F642AFE-9C68-4F40-B8BE-457401AFCB3D) 
]
interface IDWriteFontSetBuilder : stdole.IUnknown
{
/// <summary>
/// Adds a reference to a font to the set being built. The caller
/// supplies enough information to search on, avoiding the need to open
/// the potentially non-local font. Any properties not supplied by the
/// caller will be missing, and those properties will not be available as
/// filters in GetMatchingFonts. GetPropertyValues for missing properties
/// will return an empty string list. The properties passed should generally
/// be consistent with the actual font contents, but they need not be. You
/// could, for example, alias a font using a different name or unique
/// identifier, or you could set custom tags not present in the actual
/// font.
/// </summary>
/// <param name="fontFaceReference">Reference to the font.</param>
/// <param name="properties">List of properties to associate with the reference.</param>
/// <param name="propertyCount">How many properties are defined.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(AddFontFaceReferenceB)(
    [in] IDWriteFontFaceReference* fontFaceReference,
    [in] DWRITE_FONT_PROPERTY* fproperties,
    [in] UINT32 propertyCount
    );
    /// <summary>
    /// Adds a reference to a font to the set being built. The necessary
    /// metadata will automatically be extracted from the font upon calling
    /// CreateFontSet.
    /// </summary>
    /// <param name="fontFaceReference">Font face reference object to add to the set.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(AddFontFaceReference)(
        [in] IDWriteFontFaceReference * fontFaceReference
        );


/// <summary>
/// Appends an existing font set to the one being built, allowing
/// one to aggregate two sets or to essentially extend an existing one.
/// </summary>
/// <param name="fontSet">Font set to append font face references from.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(AddFontSet)(
    [in] IDWriteFontSet* fontSet
    );

/// <summary>
/// Creates a font set from all the font face references added so
/// far via AddFontFaceReference.
/// </summary>
/// <param name="fontSet">Receives a pointer to the newly created font set object, or nullptr in case of failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// Creating a font set takes less time if the references were added
/// with metadata rather than needing to extract the metadata from the
/// font file.
/// </remarks>
STDMETHOD(CreateFontSet)(
    [in, out] IDWriteFontSet** fontSet
    );
};


[
    odl,
    uuid(53585141-D9F8-4095-8321-D73CF6BD116C) 
]
interface IDWriteFontCollection1 : IDWriteFontCollection
{
    /// <summary>
    /// Get the underlying font set used by this collection.
    /// </summary>
    /// <param name="fontSet">Contains font set used by the collection.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontSet)(
        [in, out] IDWriteFontSet * *fontSet
        );

/// <summary>
/// Creates a font family object given a zero-based font family index.
/// </summary>
/// <param name="index">Zero-based index of the font family.</param>
/// <param name="fontFamily">Receives a pointer the newly created font family object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontFamily1)(
    [in] UINT32 index,
    [in, out] IDWriteFontFamily1** fontFamily
    );

//using IDWriteFontCollection::GetFontFamily;
};


/// <summary>
/// The IDWriteFontFamily interface represents a set of fonts that share the same design but are differentiated
/// by weight, stretch, and style.
/// </summary>
[
    odl,
    uuid(DA20D8EF-812A-4C43-9802-62EC4ABD7ADF) 
]
interface IDWriteFontFamily1 : IDWriteFontFamily
{
    /// <summary>
    /// Gets the current locality of a font given its zero-based index.
    /// </summary>
    /// <param name="listIndex">Zero-based index of the font in the font list.</param>
    /// <remarks>
    /// The locality enumeration. For fully local files, the result will always
    /// be DWRITE_LOCALITY_LOCAL. For downloadable files, the result depends on how
    /// much of the file has been downloaded, and GetFont() fails if the locality
    /// is REMOTE and potentially fails if PARTIAL. The application can explicitly
    /// ask for the font to be enqueued for download via EnqueueFontDownloadRequest
    /// followed by BeginDownload().
    /// </remarks>
    /// <returns>
    /// The locality enumeration.
    /// </returns>
    STDMETHOD_(DWRITE_LOCALITY, GetFontLocality)([in] UINT32 listIndex);

/// <summary>
/// Gets a font given its zero-based index.
/// </summary>
/// <param name="listIndex">Zero-based index of the font in the font list.</param>
/// <param name="font">Receives a pointer to the newly created font object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFont1)(
    [in] UINT32 listIndex,
    [in, out] IDWriteFont3** font
    );

//using IDWriteFontFamily::GetFont;

/// <summary>
/// Gets a font face reference given its zero-based index.
/// </summary>
/// <param name="listIndex">Zero-based index of the font in the font list.</param>
/// <param name="fontFaceReference">Receives a pointer to the newly created font face reference object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontFaceReference)(
    [in] UINT32 listIndex,
    [in, out] IDWriteFontFaceReference** fontFaceReference
    );
};


/// <summary>
/// The IDWriteFontList interface represents a list of fonts.
/// </summary>
[
    odl,
    uuid(DA20D8EF-812A-4C43-9802-62EC4ABD7ADE) 
]
interface IDWriteFontList1 : IDWriteFontList
{
    /// <summary>
    /// Gets the current locality of a font given its zero-based index.
    /// </summary>
    /// <param name="listIndex">Zero-based index of the font in the font list.</param>
    /// <remarks>
    /// The locality enumeration. For fully local files, the result will always
    /// be DWRITE_LOCALITY_LOCAL. For downloadable files, the result depends on how
    /// much of the file has been downloaded, and GetFont() fails if the locality
    /// is REMOTE and potentially fails if PARTIAL. The application can explicitly
    /// ask for the font to be enqueued for download via EnqueueFontDownloadRequest
    /// followed by BeginDownload().
    /// </remarks>
    /// <returns>
    /// The locality enumeration.
    /// </returns>
    STDMETHOD_(DWRITE_LOCALITY, GetFontLocality)([in] UINT32 listIndex);

/// <summary>
/// Gets a font given its zero-based index.
/// </summary>
/// <param name="listIndex">Zero-based index of the font in the font list.</param>
/// <param name="font">Receives a pointer to the newly created font object.</param>
/// <returns>
/// Standard HRESULT error code. The function returns DWRITE_E_REMOTEFONT if it could not construct a remote font.
/// </returns>
STDMETHOD(GetFont1)(
    [in] UINT32 listIndex,
    [in, out] IDWriteFont3** font
    );

//using IDWriteFontList::GetFont;

/// <summary>
/// Gets a font face reference given its zero-based index.
/// </summary>
/// <param name="listIndex">Zero-based index of the font in the font list.</param>
/// <param name="fontFaceReference">Receives a pointer to the newly created font face reference object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontFaceReference)(
    [in] UINT32 listIndex,
    [in, out] IDWriteFontFaceReference** fontFaceReference
    );
};


/// <summary>
/// A uniquely identifying reference to a font, from which you can create a font
/// face to query font metrics and use for rendering. A font face reference
/// consists of a font file, font face index, and font face simulation. The file
/// data may or may not be physically present on the local machine yet.
/// </summary>
[
    odl,
    uuid(5E7FA7CA-DDE3-424C-89F0-9FCD6FED58CD) 
]
interface IDWriteFontFaceReference : stdole.IUnknown
{
    /// <summary>
    /// Creates a font face from the reference for use with layout,
    /// shaping, or rendering.
    /// </summary>
    /// <param name="fontFace">Newly created font face object, or nullptr in the case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This function can fail with DWRITE_E_REMOTEFONT if the font is not local.
    /// </remarks>
    STDMETHOD(CreateFontFace)(
        [in, out] IDWriteFontFace3 * *fontFace
        );

/// <summary>
/// Creates a font face with alternate font simulations, for example, to
/// explicitly simulate a bold font face out of a regular variant.
/// </summary>
/// <param name="fontFaceSimulationFlags">Font face simulation flags for algorithmic emboldening and italicization.</param>
/// <param name="fontFace">Newly created font face object, or nullptr in the case of failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// This function can fail with DWRITE_E_REMOTEFONT if the font is not local.
/// </remarks>
STDMETHOD(CreateFontFaceWithSimulations)(
    [in] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,
    [in, out] IDWriteFontFace3** fontFace
    );

/// <summary>
/// Compares two instances of a font face references for equality.
/// </summary>
STDMETHOD_(BOOL, Equals)([in] IDWriteFontFaceReference* fontFaceReference);

/// <summary>
/// Obtains the zero-based index of the font face in its font file. If the font files contain a single face,
/// the return value is zero.
/// </summary>
STDMETHOD_(UINT32, GetFontFaceIndex)();

/// <summary>
/// Obtains the algorithmic style simulation flags of a font face.
/// </summary>
STDMETHOD_(DWRITE_FONT_SIMULATIONS, GetSimulations)();

/// <summary>
/// Obtains the font file representing a font face.
/// </summary>
STDMETHOD(GetFontFile)(
    [in, out] IDWriteFontFile** fontFile
    );

/// <summary>
/// Get the local size of the font face in bytes.
/// </summary>
/// <remarks> 
/// The value returned by GetLocalFileSize will always be less than or
/// equal to the value returned by GetFullSize. If the locality is remote, 
/// the GetLocalFileSize value is zero. If the locality is local, this 
/// value will equal the value returned by GetFileSize. If the locality is 
/// partial, this value will equal the size of the portions of the font 
/// data that have been downloaded, which will be greater than zero and 
/// less than or equal to the GetFileSize value.
/// </remarks>
STDMETHOD_(UINT64, GetLocalFileSize)();

/// <summary>
/// Get the total size of the font face in bytes.
/// </summary>
/// <remarks>
/// If the locality is remote, this value is unknown and will be zero.
/// If the locality is partial or local, the value is the full size of
/// the font face.
/// </remarks>
STDMETHOD_(UINT64, GetFileSize)();

/// <summary>
/// Get the last modified date.
/// </summary>
/// <remarks>
/// The time may be zero if the font file loader does not expose file time.
/// </remarks>
STDMETHOD(GetFileTime)([in, out] FILETIME* lastWriteTime);

/// <summary>
/// Get the locality of this font face reference. You can always successfully
/// create a font face from a fully local font. Attempting to create a font
/// face on a remote or partially local font may fail with DWRITE_E_REMOTEFONT.
/// This function may change between calls depending on background downloads
/// and whether cached data expires.
/// </summary>
STDMETHOD_(DWRITE_LOCALITY, GetLocality)();

/// <summary>
/// Adds a request to the font download queue (IDWriteFontDownloadQueue).
/// </summary>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(EnqueueFontDownloadRequest)();

/// <summary>
/// Adds a request to the font download queue (IDWriteFontDownloadQueue).
/// </summary>
/// <param name="characters">Array of characters to download.</param>
/// <param name="characterCount">The number of elements in the character array.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// Downloading a character involves downloading every glyph it depends on
/// directly or indirectly, via font tables (cmap, GSUB, COLR, glyf).
/// </remarks>
STDMETHOD(EnqueueCharacterDownloadRequest)(
    [in] LongPtr characters,
    [in] UINT32 characterCount
    );

/// <summary>
/// Adds a request to the font download queue (IDWriteFontDownloadQueue).
/// </summary>
/// <param name="glyphIndices">Array of glyph indices to download.</param>
/// <param name="glyphCount">The number of elements in the glyph index array.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// Downloading a glyph involves downloading any other glyphs it depends on
/// from the font tables (GSUB, COLR, glyf).
/// </remarks>
STDMETHOD(EnqueueGlyphDownloadRequest)(
    [in] UINT16* glyphIndices,
    [in] UINT32 glyphCount
    );

/// <summary>
/// Adds a request to the font download queue (IDWriteFontDownloadQueue).
/// </summary>
/// <param name="fileOffset">Offset of the fragment from the beginning of the font file.</param>
/// <param name="fragmentSize">Size of the fragment in bytes.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(EnqueueFileFragmentDownloadRequest)(
    [in] UINT64 fileOffset,
    [in] UINT64 fragmentSize
    );
};


/// <summary>
/// The IDWriteFont interface represents a font in a font collection.
/// </summary>
[
    odl,
    uuid(29748ED6-8C9C-4A6A-BE0B-D912E8538944) 
]
interface IDWriteFont3 : IDWriteFont1
{
    STDMETHOD_(BOOL, IsColorFont)();

    /// <summary>
    /// Creates a font face object for the font.
    /// </summary>
    /// <param name="fontFace">Receives a pointer to the newly created font face object.</param>
    /// <returns>
    /// Standard HRESULT error code. The function returns DWRITE_E_REMOTEFONT if it could not construct a remote font.
    /// </returns>
    STDMETHOD(CreateFontFace3)(
        [in, out] IDWriteFontFace3 * *fontFace
        );

    //using IDWriteFont::CreateFontFace;

    /// <summary>
    /// Compares two instances of a font references for equality.
    /// </summary>
    STDMETHOD_(BOOL, Equals)([in] IDWriteFont* font);

    /// <summary>
    /// Return a font face reference identifying this font.
    /// </summary>
    /// <param name="fontFaceReference">A uniquely identifying reference to a font face.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFaceReference)(
        [in, out] IDWriteFontFaceReference** fontFaceReference
        );

    /// <summary>
    /// Determines whether the font supports the specified character.
    /// </summary>
    /// <param name="unicodeValue">Unicode (UCS-4) character value.</param>
    /// <returns>
    /// Returns TRUE if the font has the specified character, FALSE if not.
    /// </returns>
    STDMETHOD_(BOOL, HasCharacter3)(
        [in] UINT32 unicodeValue
        );

    //using IDWriteFont::HasCharacter;

    /// <summary>
    /// Gets the current locality of the font.
    /// </summary>
    /// <remarks>
    /// The locality enumeration. For fully local files, the result will always
    /// be DWRITE_LOCALITY_LOCAL. A downloadable file may be any of the states,
    /// and this function may change between calls.
    /// </remarks>
    /// <returns>
    /// The locality enumeration.
    /// </returns>
    STDMETHOD_(DWRITE_LOCALITY, GetLocality)();
};


/// <summary>
/// The interface that represents an absolute reference to a font face.
/// It contains font face type, appropriate file references and face identification data.
/// Various font data such as metrics, names and glyph outlines is obtained from IDWriteFontFace.
/// </summary>
[
    odl,
    uuid(D37D7598-09BE-4222-A236-2081341CC1F2) 
]
interface IDWriteFontFace3 : IDWriteFontFace2
{
    /// <summary>
    /// Return a font face reference identifying this font.
    /// </summary>
    /// <param name="fontFaceReference">A uniquely identifying reference to a font face.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFaceReference)(
        [in, out] IDWriteFontFaceReference * *fontFaceReference
        );

/// <summary>
/// Gets the PANOSE values from the font, used for font selection and
/// matching.
/// </summary>
/// <param name="panose">PANOSE structure to fill in.</param>
/// <remarks>
/// The function does not simulate these, such as substituting a weight or
/// proportion inferred on other values. If the font does not specify them,
/// they are all set to 'any' (0).
/// </remarks>
STDMETHOD_(void, GetPanose)(
    [in, out] DWRITE_PANOSE* panose
    );

/// <summary>
/// Gets the weight of the specified font.
/// </summary>
STDMETHOD_(DWRITE_FONT_WEIGHT, GetWeight)();

/// <summary>
/// Gets the stretch (aka. width) of the specified font.
/// </summary>
STDMETHOD_(DWRITE_FONT_STRETCH, GetStretch)();

/// <summary>
/// Gets the style (aka. slope) of the specified font.
/// </summary>
STDMETHOD_(DWRITE_FONT_STYLE, GetStyle)();

/// <summary>
/// Creates an localized strings object that contains the weight-stretch-style family names for the font family, indexed by locale name.
/// </summary>
/// <param name="names">Receives a pointer to the newly created localized strings object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFamilyNames)(
    [in, out] IDWriteLocalizedStrings** names
    );

/// <summary>
/// Gets a localized strings collection containing the weight-stretch-style face names for the font (e.g., Regular or Bold), indexed by locale name.
/// </summary>
/// <param name="names">Receives a pointer to the newly created localized strings object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFaceNames)(
    [in, out] IDWriteLocalizedStrings** names
    );

/// <summary>
/// Gets a localized strings collection containing the specified informational strings, indexed by locale name.
/// </summary>
/// <param name="informationalStringID">Identifies the string to get.</param>
/// <param name="informationalStrings">Receives a pointer to the newly created localized strings object.</param>
/// <param name="exists">Receives the value TRUE if the font contains the specified string ID or FALSE if not.</param>
/// <returns>
/// Standard HRESULT error code. If the font does not contain the specified string, the return value is S_OK but 
/// informationalStrings receives a NULL pointer and exists receives the value FALSE.
/// </returns>
STDMETHOD(GetInformationalStrings)(
    [in] DWRITE_INFORMATIONAL_STRING_ID informationalStringID,
    [in, out] IDWriteLocalizedStrings** informationalStrings,
    [in, out] BOOL* exists
    );

/// <summary>
/// Determines whether the font supports the specified character.
/// </summary>
/// <param name="unicodeValue">Unicode (UCS-4) character value.</param>
/// <returns>
/// Returns TRUE if the font has the specified character, FALSE if not.
/// </returns>
STDMETHOD_(BOOL, HasCharacter)(
    [in] UINT32 unicodeValue
    );

/// <summary>
/// Determines the recommended text rendering and grid-fit mode to be used based on the
/// font, size, world transform, and measuring mode.
/// </summary>
/// <param name="fontEmSize">Logical font size in DIPs.</param>
/// <param name="dpiX">Number of pixels per logical inch in the horizontal direction.</param>
/// <param name="dpiY">Number of pixels per logical inch in the vertical direction.</param>
/// <param name="transform">Specifies the world transform.</param>
/// <param name="outlineThreshold">Specifies the quality of the graphics system's outline rendering,
/// affects the size threshold above which outline rendering is used.</param>
/// <param name="measuringMode">Specifies the method used to measure during text layout. For proper
/// glyph spacing, the function returns a rendering mode that is compatible with the specified 
/// measuring mode.</param>
/// <param name="renderingParams">Rendering parameters object. This parameter is necessary in case the rendering parameters 
/// object overrides the rendering mode.</param>
/// <param name="renderingMode">Receives the recommended rendering mode.</param>
/// <param name="gridFitMode">Receives the recommended grid-fit mode.</param>
/// <remarks>
/// This method should be used to determine the actual rendering mode in cases where the rendering 
/// mode of the rendering params object is DWRITE_RENDERING_MODE_DEFAULT, and the actual grid-fit
/// mode when the rendering params object is DWRITE_GRID_FIT_MODE_DEFAULT.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetRecommendedRenderingMode3)(
    [in] FLOAT fontEmSize,
    [in] FLOAT dpiX,
    [in] FLOAT dpiY,
    //_In_opt_ DWRITE_MATRIX* transform,
    [in] void* transform,
    [in] BOOL isSideways,
    [in] DWRITE_OUTLINE_THRESHOLD outlineThreshold,
    [in] DWRITE_MEASURING_MODE measuringMode,
    [in] IDWriteRenderingParams* renderingParams,
    [in, out] DWRITE_RENDERING_MODE1* renderingMode,
    [in, out] DWRITE_GRID_FIT_MODE* gridFitMode
    );

//using IDWriteFontFace2::GetRecommendedRenderingMode;

/// <summary>
/// Determines whether the character is locally downloaded from the font.
/// </summary>
/// <param name="unicodeValue">Unicode (UCS-4) character value.</param>
/// <returns>
/// Returns TRUE if the font has the specified character locally available,
/// FALSE if not or if the font does not support that character.
/// </returns>
STDMETHOD_(BOOL, IsCharacterLocal)(
    [in] UINT32 unicodeValue
    );

/// <summary>
/// Determines whether the glyph is locally downloaded from the font.
/// </summary>
/// <param name="glyphId">Glyph identifier.</param>
/// <returns>
/// Returns TRUE if the font has the specified glyph locally available.
/// </returns>
STDMETHOD_(BOOL, IsGlyphLocal)(
    [in] UINT16 glyphId
    );

/// <summary>
/// Determines whether the specified characters are local.
/// </summary>
/// <param name="characters">Array of characters.</param>
/// <param name="characterCount">The number of elements in the character array.</param>
/// <param name="enqueueIfNotLocal">Specifies whether to enqueue a download request
/// if any of the specified characters are not local.</param>
/// <param name="isLocal">Receives TRUE if all of the specified characters are local,
/// FALSE if any of the specified characters are remote.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(AreCharactersLocal)(
    [in] LongPtr characters,
    [in] UINT32 characterCount,
    [in] BOOL enqueueIfNotLocal,
    [in, out] BOOL* isLocal
    );

/// <summary>
/// Determines whether the specified glyphs are local.
/// </summary>
/// <param name="glyphIndices">Array of glyph indices.</param>
/// <param name="glyphCount">The number of elements in the glyph index array.</param>
/// <param name="enqueueIfNotLocal">Specifies whether to enqueue a download request
/// if any of the specified glyphs are not local.</param>
/// <param name="isLocal">Receives TRUE if all of the specified glyphs are local,
/// FALSE if any of the specified glyphs are remote.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(AreGlyphsLocal)(
    [in] UINT16* glyphIndices,
    [in] UINT32 glyphCount,
    [in] BOOL enqueueIfNotLocal,
    [in, out] BOOL* isLocal
    );
};


/// <summary>
/// Represents a collection of strings indexed by number.
/// An IDWriteStringList is otherwise identical to IDWriteLocalizedStrings except
/// for the semantics, where localized strings are indexed on language (each
/// language has one string property) whereas a string list may contain multiple
/// strings of the same language, such as a string list of family names from a
/// font set. You can QueryInterface from an IDWriteLocalizedStrings to an
/// IDWriteStringList.
/// </summary>
[
    odl,
    uuid(CFEE3140-1157-47CA-8B85-31BFCF3F2D0E) 
]
interface IDWriteStringList : stdole.IUnknown
{
    /// <summary>
    /// Gets the number of strings.
    /// </summary>
    STDMETHOD_(UINT32, GetCount)();

/// <summary>
/// Gets the length in characters (not including the null terminator) of the locale name with the specified index.
/// </summary>
/// <param name="listIndex">Zero-based index of the locale name.</param>
/// <param name="length">Receives the length in characters, not including the null terminator.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetLocaleNameLength)(
    [in] UINT32 listIndex,
    [in, out] UINT32* length
    );

/// <summary>
/// Copies the locale name with the specified index to the specified array.
/// </summary>
/// <param name="listIndex">Zero-based index of the locale name.</param>
/// <param name="localeName">Character array that receives the locale name.</param>
/// <param name="size">Size of the array in characters. The size must include space for the terminating
/// null character.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetLocaleName)(
    [in] UINT32 listIndex,
    [in] LongPtr localeName,
    [in] UINT32 size
    );

/// <summary>
/// Gets the length in characters (not including the null terminator) of the string with the specified index.
/// </summary>
/// <param name="listIndex">Zero-based index of the string.</param>
/// <param name="length">Receives the length in characters, not including the null terminator.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetStringLength)(
    [in] UINT32 listIndex,
    [in, out] UINT32* length
    );

/// <summary>
/// Copies the string with the specified index to the specified array.
/// </summary>
/// <param name="listIndex">Zero-based index of the string.</param>
/// <param name="stringBuffer">Character array that receives the string.</param>
/// <param name="size">Size of the array in characters. The size must include space for the terminating
///     null character.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetString)(
    [in] UINT32 listIndex,
    [in] LongPtr stringBuffer,
    [in] UINT32 stringBufferSize
    );
};


/// <summary>
/// Application-defined callback interface that receives notifications from the font 
/// download queue (IDWriteFontDownloadQueue interface). Callbacks will occur on the
/// downloading thread, and objects must be prepared to handle calls on their methods
/// from other threads at any time.
/// </summary>
[
    odl,
    uuid(B06FE5B9-43EC-4393-881B-DBE4DC72FDA7),
    helpstring("WARNING: REDEFINED VOID")
]
interface IDWriteFontDownloadListener : stdole.IUnknown
{
    /// <summary>
    /// The DownloadCompleted method is called back on an arbitrary thread when a
    /// download operation ends.
    /// </summary>
    /// <param name="downloadQueue">Pointer to the download queue interface on which
    /// the BeginDownload method was called.</param>
    /// <param name="context">Optional context object that was passed to BeginDownload.
    /// AddRef is called on the context object by BeginDownload and Release is called
    /// after the DownloadCompleted method returns.</param>
    /// <param name="downloadResult">Result of the download operation.</param>
    //STDMETHOD_(void, DownloadCompleted)(
    //    [in] IDWriteFontDownloadQueue * downloadQueue,
    //    _In_opt_ IUnknown * context,
    //    HRESULT downloadResult
    //    );
        STDMETHOD(DownloadCompleted)(
        [in] IDWriteFontDownloadQueue* downloadQueue,
        [in] IUnknown* context,
        [in] HRESULT downloadResult
        );
};


/// <summary>
/// Interface that enqueues download requests for remote fonts, characters, glyphs, and font fragments.
/// Provides methods to asynchronously execute a download, cancel pending downloads, and be notified of
/// download completion. Callbacks to listeners will occur on the downloading thread, and objects must
/// be must be able to handle calls on their methods from other threads at any time.
/// </summary>
[
    odl,
    uuid(B71E6052-5AEA-4FA3-832E-F60D431F7E91) 
]
interface IDWriteFontDownloadQueue : stdole.IUnknown
{
    /// <summary>
    /// Registers a client-defined listener object that receives download notifications.
    /// All registered listener's DownloadCompleted will be called after BeginDownload
    /// completes.
    /// </summary>
    /// <param name="listener">Listener object to add.</param>
    /// <param name="token">Receives a token value, which the caller must subsequently
    /// pass to RemoveListener.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// An IDWriteFontDownloadListener can also be passed to BeginDownload via the
    /// context parameter, rather than globally registered to the queue.
    /// </remarks>
    STDMETHOD(AddListener)(
        [in] IDWriteFontDownloadListener * listener,
        [in, out] UINT32 * token
        );

/// <summary>
/// Unregisters a notification handler that was previously registered using
/// AddListener.
/// </summary>
/// <param name="token">Token value previously returned by AddListener.</param>
/// <returns>
/// Returns S_OK if successful or E_INVALIDARG if the specified token does not
/// correspond to a registered listener.
/// </returns>
STDMETHOD(RemoveListener)(
    [in] UINT32 token
    );

/// <summary>
/// Determines whether the download queue is empty. Note that the queue does not
/// include requests that are already being downloaded. In other words, BeginDownload
/// clears the queue.
/// </summary>
/// <returns>
/// TRUE if the queue is empty, FALSE if there are requests pending for BeginDownload.
/// </returns>
STDMETHOD_(BOOL, IsEmpty)();

/// <summary>
/// Begins an asynchronous download operation. The download operation executes
/// in the background until it completes or is cancelled by a CancelDownload call.
/// </summary>
/// <param name="context">Optional context object that is passed back to the 
/// download notification handler's DownloadCompleted method. If the context object
/// implements IDWriteFontDownloadListener, its DownloadCompleted will be called
/// when done.</param>
/// <returns>
/// Returns S_OK if a download was successfully begun, S_FALSE if the queue was 
/// empty, or a standard HRESULT error code.
/// </returns>
/// <remarks>
/// BeginDownload removes all download requests from the queue, transferring them
/// to a background download operation. If any previous downloads are still ongoing
/// when BeginDownload is called again, the new download does not complete until
/// the previous downloads have finished. If the queue is empty and no active
/// downloads are pending, the DownloadCompleted callback is called immediately with
/// DWRITE_DOWNLOAD_RESULT_NONE.
/// </remarks>
STDMETHOD(BeginDownload)(
    [in] IUnknown* context
    );

/// <summary>
/// Removes all download requests from the queue and cancels any active download
/// operations. This calls DownloadCompleted with DWRITE_E_DOWNLOADCANCELLED.
/// Applications should call this when shutting down if they started any
/// downloads that have not finished yet with a call to DownloadCompleted.
/// </summary>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(CancelDownload)();

/// <summary>
/// Get the current generation number of the download queue, which is incremented
/// every time after a download completes, whether failed or successful. This cookie
/// comparison value may be used to compared against cached data to know when it is
/// stale.
/// </summary>
/// <returns>
/// The number of download queue generations.
/// </returns>
STDMETHOD_(UINT64, GetGenerationCount)();
};


/// <summary>
/// The GDI interop interface provides interoperability with GDI.
/// </summary>
[
    odl,
    uuid(4556BE70-3ABD-4F70-90BE-421780A6F515) 
]
interface IDWriteGdiInterop1 : IDWriteGdiInterop
{
    /// <summary>
    /// Creates a font object that matches the properties specified by the LOGFONT structure.
    /// </summary>
    /// <param name="logFont">Structure containing a GDI-compatible font description.</param>
    /// <param name="fontCollection">The font collection to search. If NULL, the local system font collection is used.</param>
    /// <param name="font">Receives a newly created font object if successful, or NULL in case of error.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The only fields that matter include: lfFaceName, lfCharSet, lfWeight, lfItalic.
    /// Font size and rendering mode are a rendering time property, not a font property,
    /// and text decorations like underline are drawn separately from the text. If no
    /// font matches the given weight, slope, and character set, the best match within
    /// the given GDI family name will be returned. DWRITE_E_NOFONT is returned if there
    /// is no matching font name using either the GDI family name (e.g. Arial) or the
    /// full font name (e.g. Arial Bold Italic).
    /// </remarks>
    STDMETHOD(CreateFontFromLOGFONT)(
        [in] void* logFont,
        [in] IDWriteFontCollection * fontCollection,
        [in, out] IDWriteFont * *font
        );
/// <summary>
/// Reads the font signature from the given font.
/// </summary>
/// <param name="font">Font to read font signature from.</param>
/// <param name="fontSignature">Font signature from the OS/2 table, ulUnicodeRange and ulCodePageRange.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontSignatureB)(
    [in] IDWriteFontFace* fontFace,
    [in, out] void* fontSignature
    );
/// <summary>
/// Reads the font signature from the given font.
/// </summary>
/// <param name="font">Font to read font signature from.</param>
/// <param name="fontSignature">Font signature from the OS/2 table, ulUnicodeRange and ulCodePageRange.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontSignature)(
    [in] IDWriteFont* font,
    [in, out] void* fontSignature
    );



/// <summary>
/// Get a list of matching fonts based on the LOGFONT values. Only fonts
/// of that family name will be returned.
/// </summary>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetMatchingFontsByLOGFONT1)(
    [in] void* logFont,
    [in] IDWriteFontSet* fontSet,
    [in, out] IDWriteFontSet** filteredSet
    );

//using IDWriteGdiInterop::CreateFontFromLOGFONT;
};

/// <summary>
/// Information about a formatted line of text.
/// </summary>
typedef struct DWRITE_LINE_METRICS1 //: DWRITE_LINE_METRICS
{
    //INHERITED MEMBERS:
    long length;

    long trailingWhitespaceLength;

    long newlineLength;

    single height;

    single baseline;

    long isTrimmed;

    //NEW MEMBERS:

    /// <summary>
    /// White space before the content of the line. This is included in the line height and baseline distances.
    /// If the line is formatted horizontally either with a uniform line spacing or with proportional
    /// line spacing, this value represents the extra space above the content.
    /// </summary>
    FLOAT leadingBefore;

    /// <summary>
    /// White space after the content of the line. This is included in the height of the line.
    /// If the line is formatted horizontally either with a uniform line spacing or with proportional
    /// line spacing, this value represents the extra space below the content.
    /// </summary>
    FLOAT leadingAfter;
} DWRITE_LINE_METRICS1;

/// <summary>
/// Specify whether DWRITE_FONT_METRICS::lineGap value should be part of the line metrics. 
/// </summary>
typedef enum DWRITE_FONT_LINE_GAP_USAGE
{
    /// <summary>
    /// The usage of the font line gap depends on the method used for text layout.
    /// </summary>
    DWRITE_FONT_LINE_GAP_USAGE_DEFAULT,

    /// <summary>
    /// The font line gap is excluded from line spacing
    /// </summary>
    DWRITE_FONT_LINE_GAP_USAGE_DISABLED,

    /// <summary>
    /// The font line gap is included in line spacing
    /// </summary>
    DWRITE_FONT_LINE_GAP_USAGE_ENABLED
} DWRITE_FONT_LINE_GAP_USAGE;

/// <summary>
/// The DWRITE_LINE_SPACING structure specifies the parameters used to specify how to manage space between lines.
/// </summary>
typedef struct DWRITE_LINE_SPACING
{
    /// <summary>
    /// Method used to determine line spacing.
    /// </summary>
    DWRITE_LINE_SPACING_METHOD method;

    /// <summary>
    /// Spacing between lines.
    /// The interpretation of this parameter depends upon the line spacing method, as follows:
    /// - default line spacing: ignored
    /// - uniform line spacing: explicit distance in DIPs between lines
    /// - proportional line spacing: a scaling factor to be applied to the computed line height; 
    ///   for each line, the height of the line is computed as for default line spacing, and the scaling factor is applied to that value.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Distance from top of line to baseline. 
    /// The interpretation of this parameter depends upon the line spacing method, as follows:
    /// - default line spacing: ignored
    /// - uniform line spacing: explicit distance in DIPs from the top of the line to the baseline
    /// - proportional line spacing: a scaling factor applied to the computed baseline; for each line, 
    ///   the baseline distance is computed as for default line spacing, and the scaling factor is applied to that value.
    /// </summary>
    FLOAT baseline;

    /// <summary>
    /// Proportion of the entire leading distributed before the line. The allowed value is between 0 and 1.0. The remaining
    /// leading is distributed after the line. It is ignored for the default and uniform line spacing methods.
    /// The leading that is available to distribute before or after the line depends on the values of the height and
    /// baseline parameters.
    /// </summary>
    FLOAT leadingBefore;

    /// <summary>
    /// Specify whether DWRITE_FONT_METRICS::lineGap value should be part of the line metrics.
    /// </summary>
    DWRITE_FONT_LINE_GAP_USAGE fontLineGapUsage;
} DWRITE_LINE_SPACING;

[
    odl,
    uuid(F67E0EDD-9E3D-4ECC-8C32-4183253DFE70) 
]
interface IDWriteTextFormat2 : IDWriteTextFormat1
{
    /// <summary>
    /// Set line spacing.
    /// </summary>
    /// <param name="lineSpacing">How to manage space between lines.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetLineSpacing2)([in] DWRITE_LINE_SPACING* lineSpacingOptions);

/// <summary>
/// Get line spacing.
/// </summary>
/// <param name="lineSpacing">How to manage space between lines.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetLineSpacing2)([in, out] DWRITE_LINE_SPACING* lineSpacingOptions);
//
//using IDWriteTextFormat1::SetLineSpacing;
//using IDWriteTextFormat1::GetLineSpacing;
};

[
    odl,
    uuid(07DDCD52-020E-4DE8-AC33-6C953D83F92D) 
]
interface IDWriteTextLayout3 : IDWriteTextLayout2
{
    /// <summary>
    /// Invalidates the layout, forcing layout to remeasure before calling the
    /// metrics or drawing functions. This is useful if the locality of a font
    /// changes, and layout should be redrawn, or if the size of a client
    /// implemented IDWriteInlineObject changes.
    /// </summary>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(InvalidateLayout)();

/// <summary>
/// Set line spacing.
/// </summary>
/// <param name="lineSpacing">How to manage space between lines.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetLineSpacing3)([in] DWRITE_LINE_SPACING* lineSpacingOptions);

/// <summary>
/// Get line spacing.
/// </summary>
/// <param name="lineSpacing">How to manage space between lines.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetLineSpacing3)([in, out] DWRITE_LINE_SPACING* lineSpacingOptions);

/// <summary>
/// GetLineMetrics returns properties of each line.
/// </summary>
/// <param name="lineMetrics">The array to fill with line information.</param>
/// <param name="maxLineCount">The maximum size of the lineMetrics array.</param>
/// <param name="actualLineCount">The actual size of the lineMetrics
/// array that is needed.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// If maxLineCount is not large enough E_NOT_SUFFICIENT_BUFFER, 
/// which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),
/// is returned and *actualLineCount is set to the number of lines
/// needed.
/// </remarks>
STDMETHOD(GetLineMetrics3)(
    [in, out] DWRITE_LINE_METRICS1* lineMetrics,
    [in] UINT32 maxLineCount,
    [in, out] UINT32* actualLineCount
    );

//using IDWriteTextLayout2::SetLineSpacing;
//using IDWriteTextLayout2::GetLineSpacing;
//using IDWriteTextLayout2::GetLineMetrics;
};


////////////////////////////////////////////////////////////////////////////////////////////////////

typedef enum DWRITE_GLYPH_IMAGE_FORMATS {
    DWRITE_GLYPH_IMAGE_FORMATS_NONE = 0x00000000,
    DWRITE_GLYPH_IMAGE_FORMATS_TRUETYPE = 0x00000001,
    DWRITE_GLYPH_IMAGE_FORMATS_CFF = 0x00000002,
    DWRITE_GLYPH_IMAGE_FORMATS_COLR = 0x00000004,
    DWRITE_GLYPH_IMAGE_FORMATS_SVG = 0x00000008,
    DWRITE_GLYPH_IMAGE_FORMATS_PNG = 0x00000010,
    DWRITE_GLYPH_IMAGE_FORMATS_JPEG = 0x00000020,
    DWRITE_GLYPH_IMAGE_FORMATS_TIFF = 0x00000040,
    DWRITE_GLYPH_IMAGE_FORMATS_PREMULTIPLIED_B8G8R8A8 = 0x00000080
} DWRITE_GLYPH_IMAGE_FORMATS;
//#if NTDDI_VERSION >= NTDDI_WIN10_RS1


/// <summary>
/// Represents a color glyph run. The IDWriteFactory4::TranslateColorGlyphRun
/// method returns an ordered collection of color glyph runs of varying types
/// depending on what the font supports.
/// </summary>
/// <summary>
/// For runs without any specific color, such as PNG data, the runColor field will be zero.
/// </summary>
typedef struct DWRITE_COLOR_GLYPH_RUN1 //: DWRITE_COLOR_GLYPH_RUN
{
    //INHERITED MEMBERS:
        /// <summary>
    /// Glyph run to render.
    /// </summary>
    DWRITE_GLYPH_RUN glyphRun;

    /// <summary>
    /// Optional glyph run description.
    /// </summary>
    //_Maybenull_ DWRITE_GLYPH_RUN_DESCRIPTION* 
    LongPtr glyphRunDescription;

    /// <summary>
    /// Location at which to draw this glyph run.
    /// </summary>
    FLOAT baselineOriginX;
    FLOAT baselineOriginY;

    /// <summary>
    /// Color to use for this layer, if any. If the paletteIndex member is
    /// DWRITE_NO_PALETTE_INDEX (0xFFFF) then no color is specifed by the font,
    /// this member is set to { 0, 0, 0, 0 }, and the client should use the 
    /// current foreground brush. Otherwise, this member is set to a color from
    /// the font's color palette, i.e., the same color that would be returned
    /// by IDWriteFontFace2::GetPaletteEntries for the current palette index.
    /// </summary>
    DWRITE_COLOR_F runColor;

    /// <summary>
    /// Zero-based index of this layer's color entry in the current color
    /// palette, or DWRITE_NO_PALETTE_INDEX (0xFFFF) if this layer
    /// is to be rendered using the current foreground brush.
    /// </summary>
    UINT16 paletteIndex;

    //NEW MEMBERS:

    /// <summary>
    /// Type of glyph image format for this color run. Exactly one type will be set since
    /// TranslateColorGlyphRun has already broken down the run into separate parts.
    /// </summary>
    DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat;

    /// <summary>
    /// Measuring mode to use for this glyph run.
    /// </summary>
    DWRITE_MEASURING_MODE measuringMode;
} DWRITE_COLOR_GLYPH_RUN1;

typedef struct D2D1_SIZE_U
{
    UINT32 width;
    UINT32 height;

} D2D1_SIZE_U;
typedef struct D2D1_POINT_2L
{
    long x;
    long y;
} D2D1_POINT_2L;
/// <summary>
/// Data for a single glyph from GetGlyphImageData.
/// </summary>
typedef struct DWRITE_GLYPH_IMAGE_DATA
{
    /// <summary>
    /// Pointer to the glyph data, be it SVG, PNG, JPEG, TIFF.
    /// </summary>
    //_Field_size_bytes_(imageDataSize) void* imageData;
    LongPtr imageData;
    /// <summary>
    /// Size of glyph data in bytes.
    /// </summary>
    UINT32 imageDataSize;

    /// <summary>
    /// Unique identifier for the glyph data. Clients may use this to cache a parsed/decompressed
    /// version and tell whether a repeated call to the same font returns the same data.
    /// </summary>
    UINT32 uniqueDataId;

    /// <summary>
    /// Pixels per em of the returned data. For non-scalable raster data (PNG/TIFF/JPG), this can be larger
    /// or smaller than requested from GetGlyphImageData when there isn't an exact match.
    /// For scaling intermediate sizes, use: desired pixels per em * font em size / actual pixels per em.
    /// </summary>
    UINT32 pixelsPerEm;

    /// <summary>
    /// Size of image when the format is pixel data.
    /// </summary>
    D2D1_SIZE_U pixelSize;

    /// <summary>
    /// Left origin along the horizontal Roman baseline.
    /// </summary>
    D2D1_POINT_2L horizontalLeftOrigin;

    /// <summary>
    /// Right origin along the horizontal Roman baseline.
    /// </summary>
    D2D1_POINT_2L horizontalRightOrigin;

    /// <summary>
    /// Top origin along the vertical central baseline.
    /// </summary>
    D2D1_POINT_2L verticalTopOrigin;

    /// <summary>
    /// Bottom origin along vertical central baseline.
    /// </summary>
    D2D1_POINT_2L verticalBottomOrigin;
} DWRITE_GLYPH_IMAGE_DATA;


/// <summary>
/// Enumerator for an ordered collection of color glyph runs.
/// </summary>
[
    odl,
    uuid(7C5F86DA-C7A1-4F05-B8E1-55A179FE5A35) 
]
interface IDWriteColorGlyphRunEnumerator1 : IDWriteColorGlyphRunEnumerator
{
    /// <summary>
    /// Gets the current color glyph run.
    /// </summary>
    /// <param name="colorGlyphRun">Receives a pointer to the color
    /// glyph run. The pointer remains valid until the next call to
    /// MoveNext or until the interface is released.</param>
    /// <returns>
    /// Standard HRESULT error code. An error is returned if there is
    /// no current glyph run, i.e., if MoveNext has not yet been called
    /// or if the end of the sequence has been reached.
    /// </returns>
    STDMETHOD(GetCurrentRun1)(
        /*_Outptr_ DWRITE_COLOR_GLYPH_RUN1 const** colorGlyphRun*/
        [in, out] LongPtr* colorGlyphRun
        );

    //using IDWriteColorGlyphRunEnumerator::GetCurrentRun;
};


/// <summary>
/// The interface that represents an absolute reference to a font face.
/// It contains font face type, appropriate file references and face identification data.
/// Various font data such as metrics, names and glyph outlines is obtained from IDWriteFontFace.
/// </summary>
[
    odl,
    uuid(27F2A904-4EB8-441D-9678-0563F53E3E2F) 
]
interface IDWriteFontFace4 : IDWriteFontFace3
{
 
/// <summary>
/// Gets the available image formats of a specific glyph and ppem. Glyphs often have at least TrueType
/// or CFF outlines, but they may also have SVG outlines, or they may have only bitmaps
/// with no TrueType/CFF outlines. Some image formats, notably the PNG/JPEG ones, are size
/// specific and will return no match when there isn't an entry in that size range.
/// </summary>
/// <remarks>
/// Glyph ids beyond the glyph count return DWRITE_GLYPH_IMAGE_FORMATS_NONE.
/// </remarks>
STDMETHOD(GetGlyphImageFormatsB)(
    [in] UINT16 glyphId,
    [in] UINT32 pixelsPerEmFirst,
    [in] UINT32 pixelsPerEmLast,
    [in, out] DWRITE_GLYPH_IMAGE_FORMATS* glyphImageFormats
    );
   /// <summary>
    /// Gets all the glyph image formats supported by the entire font (SVG, PNG, JPEG, ...).
    /// </summary>
    STDMETHOD_(DWRITE_GLYPH_IMAGE_FORMATS, GetGlyphImageFormats)();

/// <summary>
/// Gets a pointer to the glyph data based on the desired image format.
/// </summary>
/// <remarks>
/// The glyphDataContext must be released via ReleaseGlyphImageData when done if the data is not empty,
/// similar to IDWriteFontFileStream::ReadFileFragment and IDWriteFontFileStream::ReleaseFileFragment.
/// The data pointer is valid so long as the IDWriteFontFace exists and ReleaseGlyphImageData has not
/// been called.
/// </remarks>
/// <remarks>
/// The DWRITE_GLYPH_IMAGE_DATA::uniqueDataId is valuable for caching purposes so that if the same
/// resource is returned more than once, an existing resource can be quickly retrieved rather than
/// needing to reparse or decompress the data.
/// </remarks>
/// <remarks>
/// The function only returns SVG or raster data - requesting TrueType/CFF/COLR data returns
/// DWRITE_E_INVALIDARG. Those must be drawn via DrawGlyphRun or queried using GetGlyphOutline instead.
/// Exactly one format may be requested or else the function returns DWRITE_E_INVALIDARG.
/// If the glyph does not have that format, the call is not an error, but the function returns empty data. 
/// </remarks>
STDMETHOD(GetGlyphImageData)(
    [in] UINT16 glyphId,
    [in] UINT32 pixelsPerEm,
    [in] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,
    [in, out] DWRITE_GLYPH_IMAGE_DATA* glyphData,
    [in, out] LongPtr* glyphDataContext
    );

/// <summary>
/// Releases the table data obtained earlier from ReadGlyphData.
/// </summary>
/// <param name="glyphDataContext">Opaque context from ReadGlyphData.</param>
STDMETHOD_(void, ReleaseGlyphImageData)(
    [in] void* glyphDataContext
    );
};

typedef struct D2D1_POINT_2F
{
    FLOAT x;
    FLOAT y;

} D2D1_POINT_2F;
[
    odl,
    uuid(4B0B5BD3-0797-4549-8AC5-FE915CC53856) 
]
interface IDWriteFactory4 : IDWriteFactory3
{
    /// <summary>
    /// Translates a glyph run to a sequence of color glyph runs, which can be
    /// rendered to produce a color representation of the original "base" run.
    /// </summary>
    /// <param name="baselineOriginX">Horizontal and vertical origin of the base glyph run in
    /// pre-transform coordinates.</param>
    /// <param name="glyphRun">Pointer to the original "base" glyph run.</param>
    /// <param name="glyphRunDescription">Optional glyph run description.</param>
    /// <param name="desiredGlyphImageFormats">Which data formats TranslateColorGlyphRun
    /// should split the runs into.</param>
    /// <param name="measuringMode">Measuring mode, needed to compute the origins
    /// of each glyph.</param>
    /// <param name="worldToDeviceTransform">Matrix converting from the client's
    /// coordinate space to device coordinates (pixels), i.e., the world transform
    /// multiplied by any DPI scaling.</param>
    /// <param name="colorPaletteIndex">Zero-based index of the color palette to use.
    /// Valid indices are less than the number of palettes in the font, as returned
    /// by IDWriteFontFace2::GetColorPaletteCount.</param>
    /// <param name="colorLayers">If the function succeeds, receives a pointer
    /// to an enumerator object that can be used to obtain the color glyph runs.
    /// If the base run has no color glyphs, then the output pointer is NULL
    /// and the method returns DWRITE_E_NOCOLOR.</param>
    /// <returns>
    /// Returns DWRITE_E_NOCOLOR if the font has no color information, the glyph run
    /// does not contain any color glyphs, or the specified color palette index
    /// is out of range. In this case, the client should render the original glyph 
    /// run. Otherwise, returns a standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The old IDWriteFactory2::TranslateColorGlyphRun is equivalent to passing
    /// DWRITE_GLYPH_IMAGE_FORMATS_TRUETYPE|CFF|COLR.
    /// </remarks>
    STDMETHOD(TranslateColorGlyphRun4)(
        //D2D1_POINT_2F baselineOrigin,
        [in] CURRENCY baselineOrigin,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        //_In_opt_ DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
        [in] void* glyphRunDescription,
        [in] DWRITE_GLYPH_IMAGE_FORMATS desiredGlyphImageFormats,
        [in] DWRITE_MEASURING_MODE measuringMode,
        //_In_opt_ DWRITE_MATRIX* worldAndDpiTransform,
        [in] void* worldAndDpiTransform,
        [in] UINT32 colorPaletteIndex,
        [in, out] IDWriteColorGlyphRunEnumerator1 * *colorLayers
        );

    //using IDWriteFactory2::TranslateColorGlyphRun;

    /// <summary>
    /// Converts glyph run placements to glyph origins. This overload is for natural metrics, which
    /// includes SVG, TrueType natural modes, and bitmap placement.
    /// </summary>
    STDMETHOD(ComputeGlyphOriginsB)(
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] CURRENCY baselineOrigin,
        [in,out] D2D1_POINT_2F* glyphOrigins
        );
    /// <summary>
    /// Converts glyph run placements to glyph origins.
    /// </summary>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The transform and DPI have no affect on the origin scaling.
    /// They are solely used to compute glyph advances when not supplied
    /// and align glyphs in pixel aligned measuring modes.
    /// </remarks>
    STDMETHOD(ComputeGlyphOrigins)(
        [in] DWRITE_GLYPH_RUN* glyphRun,
        [in] DWRITE_MEASURING_MODE measuringMode,
        //D2D1_POINT_2F baselineOrigin,
        [in] CURRENCY baselineOrigin,
        //_In_opt_ DWRITE_MATRIX* worldAndDpiTransform,
        [in] void* worldAndDpiTransform,
        [in, out] D2D1_POINT_2F* glyphOrigins
        );

};

//#endif // NTDDI_VERSION >= NTDDI_WIN10_RS1


////////////////////////////////////////////////////////////////////////////////////////////////////


//#if NTDDI_VERSION >= NTDDI_WIN10_RS2

[
    odl,
    uuid(3FF7715F-3CDC-4DC6-9B72-EC5621DCCAFD) 
]
interface IDWriteFontSetBuilder1 : IDWriteFontSetBuilder
{
    /// <summary>
    /// Adds references to all the fonts in the specified font file. The method
    /// parses the font file to determine the fonts and their properties.
    /// </summary>
    /// <param name="fontFile">Font file reference object to add to the set.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(AddFontFile)(
        [in] IDWriteFontFile * fontFile
        );
};

/// <summary>
/// The IDWriteAsyncResult interface represents the result of an asynchronous
/// operation. A client can use the interface to wait for the operation to
/// complete and to get the result.
/// </summary>
[
    odl,
    uuid(CE25F8FD-863B-4D13-9651-C1F88DC73FE2) 
]
interface IDWriteAsyncResult : stdole.IUnknown
{
    /// <summary>
    /// The GetWaitHandleMethod method returns a handle that can be used to wait 
    /// for the asynchronous operation to complete. The handle remains valid
    /// until the interface is released.
    /// </summary>
    STDMETHOD_(HANDLE, GetWaitHandle)();

/// <summary>
/// The GetResult method returns the result of the asynchronous operation.
/// The return value is E_PENDING if the operation has not yet completed.
/// </summary>
STDMETHOD(GetResult)();
};


/// <summary>
/// DWRITE_FILE_FRAGMENT represents a range of bytes in a font file.
/// </summary>
typedef struct DWRITE_FILE_FRAGMENT
{
    /// <summary>
    /// Starting offset of the fragment from the beginning of the file.
    /// </summary>
    UINT64 fileOffset;

    /// <summary>
    /// Size of the file fragment, in bytes.
    /// </summary>
    UINT64 fragmentSize;
} DWRITE_FILE_FRAGMENT;


/// <summary>
/// IDWriteRemoteFontFileStream represents a font file stream parts of which may be 
/// non-local. Non-local data must be downloaded before it can be accessed using 
/// ReadFragment. The interface exposes methods to download font data and query the 
/// locality of font data.
/// </summary>
/// <remarks>
/// For more information, see the description of IDWriteRemoteFontFileLoader.
/// </remarks>
[
    odl,
    uuid(4DB3757A-2C72-4ED9-B2B6-1ABABE1AFF9C) 
]
interface IDWriteRemoteFontFileStream : IDWriteFontFileStream
{
    /// <summary>
    /// GetLocalFileSize returns the number of bytes of the font file that are
    /// currently local, which should always be less than or equal to the full
    /// file size returned by GetFileSize. If the locality is remote, the return
    /// value is zero. If the file is fully local, the return value must be the
    /// same as GetFileSize.
    /// </summary>
    /// <param name="localFileSize">Receives the local size of the file.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLocalFileSize)(
        [in, out] UINT64 * localFileSize
        );

/// <summary>
/// GetFileFragmentLocality returns information about the locality of a byte range (i.e.,
/// font fragment) within the font file stream.
/// </summary>
/// <param name="fileOffset">Offset of the fragment from the beginning of the font file.</param>
/// <param name="fragmentSize">Size of the fragment in bytes.</param>
/// <param name="isLocal">Receives TRUE if the first byte of the fragment is local, FALSE if not.</param>
/// <param name="partialSize">Receives the number of contiguous bytes from the start of the
/// fragment that have the same locality as the first byte.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFileFragmentLocality)(
    [in] UINT64 fileOffset,
    [in] UINT64 fragmentSize,
    [in, out] BOOL* isLocal,
    [in, out] UINT64* partialSize
    );

/// <summary>
/// Gets the current locality of the file.
/// </summary>
/// <returns>
/// Returns the locality enumeration (i.e., remote, partial, or local).
/// </returns>
STDMETHOD_(DWRITE_LOCALITY, GetLocality)();

/// <summary>
/// BeginDownload begins downloading all or part of the font file.
/// </summary>
/// <param name="fileFragments">Array of structures, each specifying a byte
/// range to download.</param>
/// <param name="fragmentCount">Number of elements in the fileFragments array.
/// This can be zero to just download file information, such as the size.</param>
/// <param name="asyncResult">Receives an object that can be used to wait for
/// the asynchronous download to complete and to get the download result upon 
/// completion. The result may be NULL if the download completes synchronously.
/// For example, this can happen if method determines that the requested data
/// is already local.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(BeginDownload)(
    [in] UUID* downloadOperationID,
    [in] DWRITE_FILE_FRAGMENT* fileFragments,
    [in] UINT32 fragmentCount,
    [in, out] IDWriteAsyncResult** asyncResult
    );
};


/// <summary>
/// Specifies the container format of a font resource. A container format is distinct from
/// a font file format (DWRITE_FONT_FILE_TYPE) because the container describes the container
/// in which the underlying font file is packaged.
/// </summary>
typedef enum DWRITE_CONTAINER_TYPE
{
    DWRITE_CONTAINER_TYPE_UNKNOWN,
    DWRITE_CONTAINER_TYPE_WOFF,
    DWRITE_CONTAINER_TYPE_WOFF2
} DWRITE_CONTAINER_TYPE;


/// <summary>
/// The IDWriteRemoteFontFileLoader interface represents a font file loader that can access 
/// remote (i.e., downloadable) fonts. The IDWriteFactory5::CreateHttpFontFileLoader method
/// returns an instance of this interface, or a client can create its own implementation.
/// </summary>
/// <remarks>
/// Calls to a remote file loader or stream should never block waiting for network operations.
/// Any call that cannot succeeded immediately using local (e.g., cached) must should return
/// DWRITE_E_REMOTEFONT. This error signifies to DWrite that it should add requests to the 
/// font download queue.
/// </remarks>
[
    odl,
    uuid(68648C83-6EDE-46C0-AB46-20083A887FDE) 
]
interface IDWriteRemoteFontFileLoader : IDWriteFontFileLoader
{
    /// <summary>
    /// Creates a remote font file stream object that encapsulates an open file resource
    /// and can be used to download remote file data.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the font file resource
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="fontFileStream">Pointer to the newly created font file stream.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Unlike CreateStreamFromKey, this method can be used to create a stream for a remote file. If the file is 
    /// remote, the returned stream's BeginDownload method can be used to download all or part of the font file. 
    /// However, the stream cannot be used to get the file size or access font data unless the file is at least 
    /// partially local.
    /// </remarks>
    STDMETHOD(CreateRemoteStreamFromKey)(
        [in] void* fontFileReferenceKey,
        [in] UINT32 fontFileReferenceKeySize,
        [in, out] IDWriteRemoteFontFileStream * *fontFileStream
        );

/// <summary>
/// Gets the locality of the file resource identified by the unique key.
/// </summary>
/// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the font file resource
/// within the scope of the font loader being used.</param>
/// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
/// <param name="locality">Locality of the file.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetLocalityFromKey)(
    [in] void* fontFileReferenceKey,
    [in] UINT32 fontFileReferenceKeySize,
    [in, out] DWRITE_LOCALITY* locality
    );

/// <summary>
/// Creates a font file reference from a URL if the loader supports this capability.
/// </summary>
/// <param name="factory">Factory used to create the font file reference.</param>
/// <param name="baseUrl">Optional base URL. The base URL is used to resolve the fontFileUrl
/// if it is relative. For example, the baseUrl might be the URL of the referring document
/// that contained the fontFileUrl.</param>
/// <param name="fontFileUrl">URL of the font resource.</param>
/// <param name="fontFile">Receives a pointer to the newly created font file reference.</param>
/// <returns>
/// Standard HRESULT error code, or E_NOTIMPL if the loader does not implement this method.
/// </returns>
STDMETHOD(CreateFontFileReferenceFromUrl)(
    [in] IDWriteFactory* factory,
    [in] LongPtr baseUrl,
    [in] LongPtr fontFileUrl,
    [in, out] IDWriteFontFile** fontFile
    );
};


/// <summary>
/// The IDWriteInMemoryFontFileLoader interface enables clients to reference
/// in-memory fonts without having to implement a custom loader. The 
/// IDWriteFactory5::CreateInMemoryFontFileLoader method returns an instance
/// of this interface, which the client is responsible for registering and
/// unregistering using IDWriteFactory::RegisterFontFileLoader and 
/// IDWriteFactory::UnregisterFontFileLoader.
/// </summary>
[
    odl,
    uuid(DC102F47-A12D-4B1C-822D-9E117E33043F) 
]
interface IDWriteInMemoryFontFileLoader : IDWriteFontFileLoader
{
    /// <summary>
    /// The CreateInMemoryFontFileReference method creates a font file reference
    /// (IDWriteFontFile object) from an array of bytes. The font file reference
    /// is bound to the IDWriteInMemoryFontFileLoader instance with which it was
    /// created and remains valid for as long as that loader is registered with
    /// the factory.
    /// </summary>
    /// <param name="factory">Factory object used to create the font file reference.</param>
    /// <param name="fontData">Pointer to a memory block containing the font data.</param>
    /// <param name="fontDataSize">Size of the font data.</param>
    /// <param name="ownerObject">Optional object that owns the memory specified by
    /// the fontData parameter. If this parameter is not NULL, the method stores a
    /// pointer to the font data and adds a reference to the owner object. The
    /// fontData pointer must remain valid until the owner object is released. If
    /// this parameter is NULL, the method makes a copy of the font data.</param>
    /// <param name="fontFile">Receives a pointer to the newly-created font file
    /// reference.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateInMemoryFontFileReference)(
        [in] IDWriteFactory * factory,
        [in] void* fontData,
        [in] UINT32 fontDataSize,
        [in] IUnknown * ownerObject,
        [in, out] IDWriteFontFile * *fontFile
        );

/// <summary>
/// The GetFileCount method returns the number of font file references that
/// have been created using this loader instance.
/// </summary>
STDMETHOD_(UINT32, GetFileCount)();
};


/// <summary>
/// The root factory interface for all DWrite objects.
/// </summary>
[
    odl,
    uuid(958DB99A-BE2A-4F09-AF7D-65189803D1D3) 
]
interface IDWriteFactory5 : IDWriteFactory4
{
    /// <summary>
    /// Creates an empty font set builder to add font face references
    /// and create a custom font set.
    /// </summary>
    /// <param name="fontSetBuilder">Receives a pointer to the newly created font set builder object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontSetBuilder5)(
        [in, out] IDWriteFontSetBuilder1 * *fontSetBuilder
        );

    //using IDWriteFactory3::CreateFontSetBuilder;

    /// <summary>
    /// The CreateInMemoryFontFileLoader method creates a loader object that can
    /// be used to create font file references to in-memory fonts. The caller is 
    /// responsible for registering and unregistering the loader.
    /// </summary>
    /// <param name="newLoader">Receives a pointer to the newly-created loader object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateInMemoryFontFileLoader)(
        [in, out] IDWriteInMemoryFontFileLoader** newLoader
        );

    /// <summary>
    /// The CreateHttpFontFileLoader function creates a remote font file loader 
    /// that can create font file references from HTTP or HTTPS URLs. The caller
    /// is responsible for registering and unregistering the loader.
    /// </summary>
    /// <param name="referrerUrl">Optional referrer URL for HTTP requests.</param>
    /// <param name="extraHeaders">Optional additional header fields to include 
    /// in HTTP requests. Each header field consists of a name followed by a colon
    /// (":") and the field value, as specified by RFC 2616. Multiple header fields 
    /// may be separated by newlines.</param>
    /// <param name="newLoader">Receives a pointer to the newly-created loader object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateHttpFontFileLoader)(
        [in] LongPtr referrerUrl,
        [in] LongPtr extraHeaders,
        [in, out] IDWriteRemoteFontFileLoader** newLoader
        );

    /// <summary>
    /// The AnalyzeContainerType method analyzes the specified file data to determine
    /// whether it is a known font container format (e.g., WOFF or WOFF2).
    /// </summary>
    /// <returns>
    /// Returns the container type if recognized. DWRITE_CONTAINER_TYPE_UNKOWNN is
    /// returned for all other files, including uncompressed font files.
    /// </returns>
    STDMETHOD_(DWRITE_CONTAINER_TYPE, AnalyzeContainerType)(
        [in] void* fileData,
        [in] UINT32 fileDataSize
        );

    /// <summary>
    /// The UnpackFontFile method unpacks font data from a container file (WOFF or
    /// WOFF2) and returns the unpacked font data in the form of a font file stream.
    /// </summary>
    /// <param name="containerType">Container type returned by AnalyzeContainerType.</param>
    /// <param name="fileData">Pointer to the compressed data.</param>
    /// <param name="fileDataSize">Size of the compressed data, in bytes.</param>
    /// <param name="unpackedFontStream">Receives a pointer to a newly created font
    /// file stream containing the uncompressed data.</param>
    /// <returns>
    /// Standard HRESULT error code. The return value is E_INVALIDARG if the container
    /// type is DWRITE_CONTAINER_TYPE_UNKNOWN.
    /// </returns>
    STDMETHOD(UnpackFontFile)(
        [in] DWRITE_CONTAINER_TYPE containerType,
        [in] void* fileData,
        [in] UINT32 fileDataSize,
        [in, out] IDWriteFontFileStream** unpackedFontStream
        );
};

//#endif // NTDDI_VERSION >= NTDDI_WIN10_RS2


////////////////////////////////////////////////////////////////////////////////////////////////////


//#if NTDDI_VERSION >= NTDDI_WIN10_RS3


interface IDWriteFontResource;
interface IDWriteFontFace5;
interface IDWriteFontFaceReference1;
interface IDWriteFontSet1;
interface IDWriteFontCollection2;
interface IDWriteTextFormat3;
interface IDWriteFontSetBuilder2;


/// <summary>
/// Creates an OpenType tag for a font axis.
/// </summary>
//#define DWRITE_MAKE_FONT_AXIS_TAG(a,b,c,d) (static_cast<DWRITE_FONT_AXIS_TAG>(DWRITE_MAKE_OPENTYPE_TAG(a,b,c,d)))


/// <summary>
/// Four character identifier for a font axis.
/// </summary>
/// <remarks>
/// Use DWRITE_MAKE_FONT_AXIS_TAG() to create a custom one.
/// <remarks>
//typedef enum DWRITE_FONT_AXIS_TAG // : UINT32
//{
//    DWRITE_FONT_AXIS_TAG_WEIGHT = DWRITE_MAKE_FONT_AXIS_TAG('w', 'g', 'h', 't'),
//    DWRITE_FONT_AXIS_TAG_WIDTH = DWRITE_MAKE_FONT_AXIS_TAG('w', 'd', 't', 'h'),
//    DWRITE_FONT_AXIS_TAG_SLANT = DWRITE_MAKE_FONT_AXIS_TAG('s', 'l', 'n', 't'),
//    DWRITE_FONT_AXIS_TAG_OPTICAL_SIZE = DWRITE_MAKE_FONT_AXIS_TAG('o', 'p', 's', 'z'),
//    DWRITE_FONT_AXIS_TAG_ITALIC = DWRITE_MAKE_FONT_AXIS_TAG('i', 't', 'a', 'l'),
//} DWRITE_FONT_AXIS_TAG;
typedef enum DWRITE_FONT_AXIS_TAG {
    DWRITE_FONT_AXIS_TAG_WEIGHT = 0x74686777,
    DWRITE_FONT_AXIS_TAG_WIDTH = 0x68746477,
    DWRITE_FONT_AXIS_TAG_SLANT = 0x746e6c73,
    DWRITE_FONT_AXIS_TAG_OPTICAL_SIZE = 0x7a73706f,
    DWRITE_FONT_AXIS_TAG_ITALIC = 0x6c617469
} DWRITE_FONT_AXIS_TAG;

typedef enum DWriteStdFontAxisCount {
 DWRITE_STANDARD_FONT_AXIS_COUNT = 5
} DWriteStdFontAxisCount;
 

/// <summary>
/// Value for a font axis, used when querying and creating font instances.
/// </summary>
typedef struct DWRITE_FONT_AXIS_VALUE
{
    /// <summary>
    /// Four character identifier of the font axis (weight, width, slant, italic...).
    /// </summary>
    DWRITE_FONT_AXIS_TAG axisTag;

    /// <summary>
    /// Value for the given axis, with the meaning and range depending on the axis semantics.
    /// Certain well known axes have standard ranges and defaults, such as weight (1..1000, default=400),
    /// width (>0, default=100), slant (-90..90, default=-20), and italic (0 or 1).
    /// </summary>
    FLOAT value;
} DWRITE_FONT_AXIS_VALUE;


/// <summary>
/// Minimum and maximum range of a font axis.
/// </summary>
typedef struct DWRITE_FONT_AXIS_RANGE
{
    /// <summary>
    /// Four character identifier of the font axis (weight, width, slant, italic...).
    /// </summary>
    DWRITE_FONT_AXIS_TAG axisTag;

    /// <summary>
    /// Minimum value supported by this axis.
    /// </summary>
    FLOAT minValue;

    /// <summary>
    /// Maximum value supported by this axis. The maximum can equal the minimum.
    /// </summary>
    FLOAT maxValue;
} DWRITE_FONT_AXIS_RANGE;


/// <summary>
/// How font families are grouped together, used by IDWriteFontCollection.
/// </summary>
typedef enum DWRITE_FONT_FAMILY_MODEL
{
    /// <summary>
    /// Families are grouped by the typographic family name preferred by the font author. The family can contain as
    /// many face as the font author wants.
    /// This corresponds to the DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FAMILY_NAME.
    /// </summary>
    DWRITE_FONT_FAMILY_MODEL_TYPOGRAPHIC,

    /// <summary>
    /// Families are grouped by the weight-stretch-style family name, where all faces that differ only by those three
    /// axes are grouped into the same family, but any other axes go into a distinct family. For example, the Sitka
    /// family with six different optical sizes yields six separate families (Sitka Caption, Display, Text, Subheading,
    /// Heading, Banner...). This corresponds to the DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FAMILY_NAME.
    /// </summary>
    DWRITE_FONT_FAMILY_MODEL_WEIGHT_STRETCH_STYLE,
} DWRITE_FONT_FAMILY_MODEL;


/// <summary>
/// Apply certain axes automatically in layout during font selection.
/// </summary>
typedef enum DWRITE_AUTOMATIC_FONT_AXES
{
    /// <summary>
    /// No axes are automatically applied.
    /// </summary>
    DWRITE_AUTOMATIC_FONT_AXES_NONE = 0x0000,

    /// <summary>
    /// Automatically pick an appropriate optical value based on the font size (via SetFontSize) when no value is
    /// specified via DWRITE_FONT_AXIS_TAG_OPTICAL_SIZE. Callers can still explicitly apply the 'opsz' value over
    /// text ranges via SetFontAxisValues, which take priority.
    /// </summary>
    DWRITE_AUTOMATIC_FONT_AXES_OPTICAL_SIZE = 0x0001,
} DWRITE_AUTOMATIC_FONT_AXES;

//#ifdef DEFINE_ENUM_FLAG_OPERATORS
//DEFINE_ENUM_FLAG_OPERATORS(DWRITE_AUTOMATIC_FONT_AXES);
//#endif


/// <summary>
/// Attributes for a font axis.
/// </summary>
typedef enum DWRITE_FONT_AXIS_ATTRIBUTES
{
    /// <summary>
    /// No attributes.
    /// </summary>
    DWRITE_FONT_AXIS_ATTRIBUTES_NONE = 0x0000,

    /// <summary>
    /// This axis is implemented as a variation axis in a variable font, with a continuous range of
    /// values, such as a range of weights from 100..900. Otherwise it is either a static axis that
    /// holds a single point, or it has a range but doesn't vary, such as optical size in the Skia
    /// Heading font which covers a range of points but doesn't interpolate any new glyph outlines.
    /// </summary>
    DWRITE_FONT_AXIS_ATTRIBUTES_VARIABLE = 0x0001,

    /// <summary>
    /// This axis is recommended to be remain hidden in user interfaces. The font developer may
    /// recommend this if an axis is intended to be accessed only programmatically, or is meant for
    /// font-internal or font-developer use only. The axis may be exposed in lower-level font
    /// inspection utilities, but should not be exposed in common or even advanced-mode user
    /// interfaces in content-authoring apps.
    /// </summary>
    DWRITE_FONT_AXIS_ATTRIBUTES_HIDDEN = 0x0002,
} DWRITE_FONT_AXIS_ATTRIBUTES;

//#ifdef DEFINE_ENUM_FLAG_OPERATORS
//DEFINE_ENUM_FLAG_OPERATORS(DWRITE_FONT_AXIS_ATTRIBUTES);
//#endif

[
    odl,
    uuid(F3744D80-21F7-42EB-B35D-995BC72FC223) 
]
interface IDWriteFactory6 : IDWriteFactory5
{
    /// <summary>
    /// Creates a reference to a specific font instance within a file.
    /// </summary>
    /// <param name="fontFile">User provided font file representing the font face.</param>
    /// <param name="faceIndex">The zero based index of a font face in cases when the font files contain a collection of font faces.
    /// If the font files contain a single face, this value should be zero.</param>
    /// <param name="fontSimulations">Font face simulation flags for algorithmic emboldening and italicization.</param>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <param name="fontFaceReference">Receives a pointer to the newly created font face reference object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontFaceReference6)(
        [in] IDWriteFontFile * fontFile,
        [in] UINT32 faceIndex,
        [in] DWRITE_FONT_SIMULATIONS fontSimulations,
        [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount,
        [in, out] IDWriteFontFaceReference1 * *fontFaceReference
        );

    //using IDWriteFactory5::CreateFontFaceReference;

    /// <summary>
    /// Creates a font resource given a font file and face index.
    /// </summary>
    /// <param name="fontFile">User provided font file representing the font face.</param>
    /// <param name="faceIndex">The zero based index of a font face in cases when the font files contain a collection of font faces.
    /// If the font files contain a single face, this value should be zero.</param>
    /// <param name="fontResource">Receives a pointer to the newly created font resource object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontResource)(
        [in] IDWriteFontFile* fontFile,
        [in] UINT32 faceIndex,
        [in, out] IDWriteFontResource** fontResource
        );

    /// <summary>
    /// Retrieves the set of system fonts.
    /// </summary>
    /// <param name="includeDownloadableFonts">Include downloadable fonts or only locally installed ones.</param>
    /// <param name="fontSet">Receives a pointer to the font set object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSystemFontSet6)(
        [in] BOOL includeDownloadableFonts,
        [in, out] IDWriteFontSet1** fontSet
        );

    //using IDWriteFactory3::GetSystemFontSet;

    /// <summary>
    /// Retrieves a collection of fonts grouped into families.
    /// </summary>
    /// <param name="includeDownloadableFonts">Include downloadable fonts or only locally installed ones.</param>
    /// <param name="fontFamilyModel">How to group families in the collection.</param>
    /// <param name="fontCollection">Receives a pointer to the font collection object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSystemFontCollection6)(
        [in] BOOL includeDownloadableFonts,
        [in] DWRITE_FONT_FAMILY_MODEL fontFamilyModel,
        [in, out] IDWriteFontCollection2** fontCollection
        );

    //using IDWriteFactory3::GetSystemFontCollection;

    /// <summary>
    /// Create a collection of fonts grouped into families from a font set.
    /// </summary>
    /// <param name="fontSet">A set of fonts to use to build the collection.</param>
    /// <param name="fontFamilyModel">How to group families in the collection.</param>
    /// <param name="fontCollection">Receives a pointer to the newly created font collection object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontCollectionFromFontSet6)(
        [in] IDWriteFontSet* fontSet,
        [in] DWRITE_FONT_FAMILY_MODEL fontFamilyModel,
        [in, out] IDWriteFontCollection2** fontCollection
        );

    //using IDWriteFactory5::CreateFontCollectionFromFontSet;

    /// <summary>
    /// Creates an empty font set builder to add font instances and create a custom font set.
    /// </summary>
    /// <param name="fontSetBuilder">Receives a pointer to the newly created font set builder object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontSetBuilder6)(
        [in, out] IDWriteFontSetBuilder2** fontSetBuilder
        );

    //using IDWriteFactory3::CreateFontSetBuilder;
    //using IDWriteFactory5::CreateFontSetBuilder;

    /// <summary>
    /// Create a text format object used for text layout.
    /// </summary>
    /// <param name="fontFamilyName">Name of the font family from the collection.</param>
    /// <param name="fontCollection">Font collection, with nullptr indicating the system font collection.</param>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <param name="fontSize">Logical size of the font in DIP units.</param>
    /// <param name="localeName">Locale name (e.g. "ja-JP", "en-US", "ar-EG").</param>
    /// <param name="textFormat">Receives a pointer to the newly created text format object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// If fontCollection is nullptr, the system font collection is used, grouped by typographic family name
    /// (DWRITE_FONT_FAMILY_MODEL_TYPOGRAPHIC) without downloadable fonts.
    /// </remarks>
    STDMETHOD(CreateTextFormat6)(
        [in] LongPtr fontFamilyName,
        [in] IDWriteFontCollection* fontCollection,
        [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount,
        [in] FLOAT fontSize,
        [in] LongPtr localeName,
        [in, out] IDWriteTextFormat3** textFormat
        );

    //using IDWriteFactory::CreateTextFormat;
};

[
    odl,
    uuid(98EFF3A5-B667-479A-B145-E2FA5B9FDC29) 
]
interface IDWriteFontFace5 : IDWriteFontFace4
{
    /// <summary>
    /// Get the number of axes defined by the font. This includes both static and variable axes.
    /// </summary>
    STDMETHOD_(UINT32, GetFontAxisValueCount)();

/// <summary>
/// Get the list of axis values used by the font.
/// </summary>
/// <param name="fontAxisValues">List of font axis values.</param>
/// <param name="fontAxisValueCount">Maximum number of font axis values to write.</param>
/// <returns>
/// Standard HRESULT error code, or E_INVALIDARG if fontAxisValueCount doesn't match GetFontAxisValueCount.
/// </returns>
/// <remarks>
/// The values are returned in the canonical order defined by the font, clamped to the actual range supported,
/// not specifically the same axis value array passed to CreateFontFace.
/// </remarks>
STDMETHOD(GetFontAxisValues)(
    [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
    [in] UINT32 fontAxisValueCount
    );

/// <summary>
/// Whether this font's resource supports any variable axes. When true, at least one DWRITE_FONT_AXIS_RANGE
/// in the font resource has a non-empty range (maximum > minimum).
/// </summary>
STDMETHOD_(BOOL, HasVariations)();

/// <summary>
/// Get the underlying font resource for this font face. A caller can use that to query information on the resource
/// or recreate a new font face instance with different axis values.
/// </summary>
/// <param name="fontResource">Newly created font resource object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontResource)(
    [in, out] IDWriteFontResource** fontResource
    );

/// <summary>
/// Compares two instances of a font face for equality.
/// </summary>
STDMETHOD_(BOOL, Equals)([in] IDWriteFontFace* fontFace);
};


/// <summary>
/// Interface to return axis information for a font resource and create specific font face instances.
/// </summary>
[
    odl,
    uuid(1F803A76-6871-48E8-987F-B975551C50F2)
]
interface IDWriteFontResource : stdole.IUnknown
{
    /// <summary>
    /// Get the font file of the resource.
    /// </summary>
    /// <param name="fontFile">Receives a pointer to the font file.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFile)(
        [in, out] IDWriteFontFile * *fontFile
        );

/// <summary>
/// Obtains the zero-based index of the font face in its font file. If the font files contain a single face,
/// the return value is zero.
/// </summary>
STDMETHOD_(UINT32, GetFontFaceIndex)();

/// <summary>
/// Get the number of axes supported by the font resource. This includes both static and variable axes.
/// </summary>
STDMETHOD_(UINT32, GetFontAxisCount)();

/// <summary>
/// Get the default values for all axes supported by the font resource.
/// </summary>
/// <param name="fontAxisValues">List of font axis values.</param>
/// <param name="fontAxisValueCount">Maximum number of font axis values to write.</param>
/// <remarks>
/// Different font resources may have different defaults.
/// For OpenType 1.8 fonts, these values come from the STAT and fvar tables.
/// For older fonts without a STAT table, weight-width-slant-italic are read from the OS/2 table.
/// </remarks>
/// <returns>
/// Standard HRESULT error code, or E_INVALIDARG if fontAxisValueCount doesn't match GetFontAxisCount.
/// </returns>
STDMETHOD(GetDefaultFontAxisValues)(
    [in, out] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
    [in] UINT32 fontAxisValueCount
    );

/// <summary>
/// Get ranges of each axis.
/// </summary>
/// <param name="fontAxisRanges"></param>
/// <param name="fontAxisRangeCount">Total number of axis ranges</param>
/// <returns>
/// Standard HRESULT error code, or E_INVALIDARG if fontAxisRangeCount doesn't match GetFontAxisCount.
/// </returns>
/// <remarks>
/// Non-varying axes will have empty ranges (minimum==maximum).
/// </remarks>
STDMETHOD(GetFontAxisRanges)(
    [in, out] DWRITE_FONT_AXIS_RANGE* fontAxisRanges,
    [in] UINT32 fontAxisRangeCount
    );

/// <summary>
/// Gets attributes about the given axis, such as whether the font author recommends to hide the axis
/// in user interfaces.
/// </summary>
/// <param name="axisIndex">Font axis, from 0 to GetFontAxisValueCount - 1.</param>
/// <param name="axisAttributes">Receives the attributes for the given axis.</param>
/// <returns>
/// Attributes for a font axis, or NONE if axisIndex is beyond the font count.
/// </returns>
STDMETHOD_(DWRITE_FONT_AXIS_ATTRIBUTES, GetFontAxisAttributes)(
    [in] UINT32 axisIndex
    );

/// <summary>
/// Gets the localized names of a font axis.
/// </summary>
/// <param name="axisIndex">Font axis, from 0 to GetFontAxisCount - 1.</param>
/// <param name="names">Receives a pointer to the newly created localized strings object.</param>
/// <remarks>
/// The font author may not have supplied names for some font axes. The localized strings
/// will be empty in that case.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetAxisNames)(
    [in] UINT32 axisIndex,
    [in, out] IDWriteLocalizedStrings** names
    );

/// <summary>
/// Get the number of named values for a specific axis.
/// </summary>
/// <param name="axisIndex">Font axis, from 0 to GetFontAxisCount - 1.</param>
/// <returns>
/// Number of named values.
/// </returns>
STDMETHOD_(UINT32, GetAxisValueNameCount)(
    [in] UINT32 axisIndex
    );

/// <summary>
/// Gets the localized names of specific values for a font axis.
/// </summary>
/// <param name="axisIndex">Font axis, from 0 to GetFontAxisCount - 1.</param>
/// <param name="axisValueIndex">Value index, from 0 to GetAxisValueNameCount - 1.</param>
/// <param name="fontAxisRange">Range of the named value.</param>
/// <param name="names">Receives a pointer to the newly created localized strings object.</param>
/// <remarks>
/// The font author may not have supplied names for some font axis values. The localized strings
/// will be empty in that case. The range may be a single point, where minimum == maximum.
/// All ranges are in ascending order by axisValueIndex.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetAxisValueNames)(
    [in] UINT32 axisIndex,
    [in] UINT32 axisValueIndex,
    [in, out] DWRITE_FONT_AXIS_RANGE* fontAxisRange,
    [in, out] IDWriteLocalizedStrings** names
    );

/// <summary>
/// Whether this font's resource supports any variable axes. When true, at least one DWRITE_FONT_AXIS_RANGE
/// in the font resource has a non-empty range (maximum > minimum).
/// </summary>
STDMETHOD_(BOOL, HasVariations)();

/// <summary>
/// Creates a font face instance with specific axis values.
/// </summary>
/// <param name="fontSimulations">Font face simulation flags for algorithmic emboldening and italicization.</param>
/// <param name="fontAxisValues">List of font axis values.</param>
/// <param name="fontAxisValueCount">Number of font axis values.</param>
/// <param name="fontFace">Receives a pointer to the newly created font face object, or nullptr on failure.</param>
/// <remarks>
/// The passed input axis values are permitted to be a subset or superset of all the ones actually supported by
/// the font. Any unspecified axes use their default values, values beyond the ranges are clamped, and any
/// non-varying axes have no effect.
/// </remarks>
/// <returns>
/// Standard HRESULT error code, or DWRITE_E_REMOTEFONT if the face is not local.
/// </returns>
STDMETHOD(CreateFontFace)(
    [in] DWRITE_FONT_SIMULATIONS fontSimulations,
    [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
    [in] UINT32 fontAxisValueCount,
    [in, out] IDWriteFontFace5** fontFace
    );

/// <summary>
/// Creates a font face reference with specific axis values.
/// </summary>
/// <param name="fontSimulations">Font face simulation flags for algorithmic emboldening and italicization.</param>
/// <param name="fontAxisValues">List of font axis values.</param>
/// <param name="fontAxisValueCount">Number of font axis values.</param>
/// <param name="fontFaceReference">Receives a pointer to the newly created font face reference object, or nullptr on failure.</param>
/// <remarks>
/// The passed input axis values are permitted to be a subset or superset of all the ones actually supported by
/// the font. Any unspecified axes use their default values, values beyond the ranges are clamped, and any
/// non-varying axes have no effect.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(CreateFontFaceReference)(
    [in] DWRITE_FONT_SIMULATIONS fontSimulations,
    [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
    [in] UINT32 fontAxisValueCount,
    [in, out] IDWriteFontFaceReference1** fontFaceReference
    );
};


[
    odl,
    uuid(C081FE77-2FD1-41AC-A5A3-34983C4BA61A) 
]
interface IDWriteFontFaceReference1 : IDWriteFontFaceReference
{
    /// <summary>
    /// Creates a font face from the reference for use with layout, shaping, or rendering.
    /// </summary>
    /// <param name="fontFace">Newly created font face object, or nullptr in the case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This function can fail with DWRITE_E_REMOTEFONT if the font is not local.
    /// </remarks>
    STDMETHOD(CreateFontFace1)(
        [in, out] IDWriteFontFace5 * *fontFace
        );

    //using IDWriteFontFaceReference::CreateFontFace;

    /// <summary>
    /// Get the number of axes specified by the reference.
    /// </summary>
    STDMETHOD_(UINT32, GetFontAxisValueCount)();

    /// <summary>
    /// Get the list of font axis values specified by the reference.
    /// </summary>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <returns>
    /// Standard HRESULT error code, or E_INVALIDARG if fontAxisValueCount doesn't match GetFontAxisValueCount.
    /// </returns>
    STDMETHOD(GetFontAxisValues)(
        [in, out] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount
        );
};


[
    odl,
    uuid(EE5BA612-B131-463C-8F4F-3189B9401E45) 
]
interface IDWriteFontSetBuilder2 : IDWriteFontSetBuilder1
{
    /// <summary>
    /// Adds a font to the set being built, with the caller supplying enough information to search on
    /// and determine axis ranges, avoiding the need to open the potentially non-local font.
    /// </summary>
    /// <param name="fontFile">Font file reference object to add to the set.</param>
    /// <param name="faceIndex">The zero based index of a font face in a collection.</param>
    /// <param name="fontSimulations">Font face simulation flags for algorithmic emboldening and italicization.</param>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <param name="fontAxisRanges">List of axis ranges.</param>
    /// <param name="fontAxisRangeCount">Number of axis ranges.</param>
    /// <param name="properties">List of properties to associate with the reference.</param>
    /// <param name="propertyCount">How many properties are defined.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The font properties should include at least a family (typographic or weight/style/stretch).
    /// Otherwise the font would be accessible in the IDWriteFontSet only by index, not name.
    /// </returns>
    STDMETHOD(AddFont)(
        [in] IDWriteFontFile * fontFile,
        [in] UINT32 fontFaceIndex,
        [in] DWRITE_FONT_SIMULATIONS fontSimulations,
        [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount,
        [in] DWRITE_FONT_AXIS_RANGE* fontAxisRanges,
        [in] UINT32 fontAxisRangeCount,
        [in] DWRITE_FONT_PROPERTY* fproperties,
        [in] UINT32 propertyCount
        );

/// <summary>
/// Adds references to all the fonts in the specified font file. The method
/// parses the font file to determine the fonts and their properties.
/// </summary>
/// <param name="filePath">Absolute file path to add to the font set.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(AddFontFile2)(
    [in] LongPtr filePath
    );

//using IDWriteFontSetBuilder1::AddFontFile;
};


[
    odl,
    uuid(7E9FDA85-6C92-4053-BC47-7AE3530DB4D3)
]
interface IDWriteFontSet1 : IDWriteFontSet
{
    /// <summary>
    /// Generates a matching font set based on the requested inputs, ordered so that nearer matches are earlier.
    /// </summary>
    /// <param name="property">Font property of interest, such as typographic family or weight/stretch/style family.</param>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <param name="matchingSet">Prioritized list of fonts that match the properties, or nullptr on failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This can yield distinct items that were not in the original font set, including items with simulation flags
    /// (if they would be a closer match to the request) and instances that were not named by the font author.
    /// Items from the same font resources are collapsed into one, the closest possible match.
    /// </remarks>
    STDMETHOD(GetMatchingFonts)(
        //_In_opt_ DWRITE_FONT_PROPERTY* fontProperty,
        [in] void* fontProperty,
        [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount,
        [in, out] IDWriteFontSet1 * *matchingFonts
        );

/// <summary>
/// Returns a font set that contains only the first occurrence of each font resource in the given set.
/// </summary>
/// <param name="fontSet">New font set consisting of single default instances from font resources.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFirstFontResources)(
    [in, out] IDWriteFontSet1** filteredFontSet
    );
/// <summary>
/// Returns a subset of fonts filtered by the given indices.
/// </summary>
/// <param name="indices">Array of indices, each index from [0..GetFontCount() - 1].</param>
/// <param name="indexCount">Number of indices.</param>
/// <param name="filteredSet">Subset of fonts that come from the given indices, or nullptr on failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// The indices can come in any order, meaning this function can produce a new set with items removed, duplicated,
/// or reordered from the original. If zero indices were passed, an empty font set is returned.
/// </remarks>
STDMETHOD(GetFilteredFontsC)(
    [in] UINT32* indices,
    [in] UINT32 indexCount,
    [in, out] IDWriteFontSet1** filteredFontSet
    );
/// <summary>
/// Returns a subset of fonts filtered by the given ranges, endpoint-inclusive.
/// </summary>
/// <param name="fontAxisRanges">List of axis ranges.</param>
/// <param name="fontAxisRangeCount">Number of axis ranges.</param>
/// <param name="selectAnyRange">Select any range rather rather than the intersection of them all.</param>
/// <param name="filteredSet">Subset of fonts that fall within the ranges, or nullptr on failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// If no fonts matched the filter, the subset will be empty (GetFontCount returns 0), but the function does not
/// return an error. The subset will always be equal to or less than the original set.
/// </remarks>
STDMETHOD(GetFilteredFontsB)(
    [in] DWRITE_FONT_AXIS_RANGE* fontAxisRanges,
    [in] UINT32 fontAxisRangeCount,
    [in] BOOL selectAnyRange,
    [in, out] IDWriteFontSet1** filteredFontSet
    );

/// <summary>
/// Returns a subset of fonts filtered by the given properties.
/// </summary>
/// <param name="properties">List of properties to filter using.</param>
/// <param name="propertyCount">How many properties to filter.</param>
/// <param name="selectAnyProperty">Select any property rather rather than the intersection of them all.</param>
/// <param name="filteredSet">Subset of fonts that match the properties, or nullptr on failure.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// If no fonts matched the filter, the returned subset will be empty (GetFontCount returns 0).
/// The subset will always be equal to or less than the original set.
/// </remarks>
STDMETHOD(GetFilteredFonts)(
    [in] DWRITE_FONT_PROPERTY* fproperties,
    [in] UINT32 propertyCount,
    [in] BOOL selectAnyProperty,
    [in, out] IDWriteFontSet1** filteredFontSet
    );


/// <summary>
/// Get all the item indices filtered by the given ranges.
/// </summary>
/// <param name="fontAxisRanges">List of axis ranges.</param>
/// <param name="fontAxisRangeCount">Number of axis ranges.</param>
/// <param name="selectAnyRange">Select any property rather rather than the intersection of them all.</param>
/// <param name="indices">Ascending array of indices [0..GetFontCount() - 1].</param>
/// <param name="indexCount">Number of indices.</param>
/// <param name="actualIndexCount">Actual number of indices written or needed [0..GetFontCount()-1].</param>
/// <returns>
/// E_NOT_SUFFICIENT_BUFFER if the buffer is too small, with actualIndexCount set to the needed size.
/// </returns>
STDMETHOD(GetFilteredFontIndicesB)(
    [in] DWRITE_FONT_AXIS_RANGE* fontAxisRanges,
    [in] UINT32 fontAxisRangeCount,
    [in] BOOL selectAnyRange,
    [in] UINT32* indices,
    [in] UINT32 maxIndexCount,
    [in, out] UINT32* actualIndexCount
    );
/// <summary>
/// Get all the item indices filtered by the given properties.
/// </summary>
/// <param name="properties">List of properties to filter using.</param>
/// <param name="propertyCount">How many properties to filter.</param>
/// <param name="selectAnyProperty">Select any property rather rather than the intersection of them all.</param>
/// <param name="indices">Ascending array of indices [0..GetFontCount() - 1].</param>
/// <param name="indexCount">Number of indices.</param>
/// <param name="actualIndexCount">Actual number of indices written or needed [0..GetFontCount()-1].</param>
/// <returns>
/// E_NOT_SUFFICIENT_BUFFER if the buffer is too small, with actualIndexCount set to the needed size.
/// The actualIndexCount will always be <= IDwriteFontSet::GetFontCount.
/// </returns>
STDMETHOD(GetFilteredFontIndices)(
    [in] DWRITE_FONT_PROPERTY* fproperties,
    [in] UINT32 propertyCount,
    [in] BOOL selectAnyProperty,
    [in, out] UINT32* indices,
    [in] UINT32 maxIndexCount,
    [in, out] UINT32* actualIndexCount
    );


/// <summary>
/// Get the axis ranges of a single item.
/// </summary>
/// <param name="listIndex">Zero-based index of the font in the set.</param>
/// <param name="fontAxisRanges">List of axis ranges.</param>
/// <param name="fontAxisRangeCount">Number of axis ranges.</param>
/// <param name="actualFontAxisRangeCount">Actual number of axis ranges written or needed.</param>
/// <returns>
/// E_NOT_SUFFICIENT_BUFFER if the buffer is too small, with actualFontAxisRangeCount set to the needed size.
/// </returns>
STDMETHOD(GetFontAxisRangesB)(
    [in] UINT32 listIndex,
    [in, out] DWRITE_FONT_AXIS_RANGE* fontAxisRanges,
    [in] UINT32 maxFontAxisRangeCount,
    [in, out] UINT32* actualFontAxisRangeCount
    );

/// <summary>
/// Gets all axis ranges in the font set, the union of all contained items.
/// </summary>
/// <param name="fontAxisRanges">List of axis ranges.</param>
/// <param name="fontAxisRangeCount">Number of axis ranges.</param>
/// <param name="actualFontAxisRangeCount">Actual number of axis ranges written or needed.</param>
/// <returns>
/// E_NOT_SUFFICIENT_BUFFER if the buffer is too small, with actualFontAxisRangeCount set to the needed size.
/// </returns>
STDMETHOD(GetFontAxisRanges)(
    [in, out] DWRITE_FONT_AXIS_RANGE* fontAxisRanges,
    [in] UINT32 maxFontAxisRangeCount,
    [in, out] UINT32* actualFontAxisRangeCount
    );


/// <summary>
/// Get the font face reference of a single item.
/// </summary>
/// <param name="listIndex">Zero-based index of the font item in the set.</param>
/// <param name="fontFaceReference">Receives a pointer to the font face reference.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontFaceReference1)(
    [in] UINT32 listIndex,
    [in, out] IDWriteFontFaceReference1** fontFaceReference
    );

//using IDWriteFontSet::GetFontFaceReference;

/// <summary>
/// Create the font resource of a single item.
/// </summary>
/// <param name="listIndex">Zero-based index of the font item in the set.</param>
/// <param name="fontResource">Receives a pointer to the font resource.</param>
/// <returns>
/// Standard HRESULT error code, or DWRITE_E_REMOTEFONT if the file is not local.
/// </returns>
STDMETHOD(CreateFontResource)(
    [in] UINT32 listIndex,
    [in, out] IDWriteFontResource** fontResource
    );

/// <summary>
/// Create a font face for a single item (rather than going through the font face reference).
/// </summary>
/// <param name="listIndex">Zero-based index of the font item in the set.</param>
/// <param name="fontFile">Receives a pointer to the font face.</param>
/// <returns>
/// Standard HRESULT error code, or DWRITE_E_REMOTEFONT if the file is not local.
/// </returns>
STDMETHOD(CreateFontFace)(
    [in] UINT32 listIndex,
    [in, out] IDWriteFontFace5** fontFace
    );

/// <summary>
/// Return the locality of a single item.
/// </summary>
/// <param name="listIndex">Zero-based index of the font item in the set.</param>
/// <remarks>
/// The locality enumeration. For fully local files, the result will always
/// be DWRITE_LOCALITY_LOCAL. For downloadable files, the result depends on how
/// much of the file has been downloaded.
/// </remarks>
/// <returns>
/// The locality enumeration.
/// </returns>
STDMETHOD_(DWRITE_LOCALITY, GetFontLocality)([in] UINT32 listIndex);
};


[
    odl,
    uuid(C0763A34-77AF-445A-B735-08C37B0A5BF5) 
]
interface IDWriteFontList2 : IDWriteFontList1
{
    /// <summary>
    /// Get the underlying font set used by this list.
    /// </summary>
    /// <param name="fontSet">Contains font set used by the list.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontSet)(
        [in, out] IDWriteFontSet1 * *fontSet
        );
};


[
    odl,
    uuid(3ED49E77-A398-4261-B9CF-C126C2131EF3) 
]
interface IDWriteFontFamily2 : IDWriteFontFamily1
{
    /// <summary>
    /// Gets a list of fonts in the font family ranked in order of how well they match the specified axis values.
    /// </summary>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <param name="matchingFonts">Receives a pointer to the newly created font list object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetMatchingFonts2)(
        [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount,
        [in, out] IDWriteFontList2 * *matchingFonts
        );

   // using IDWriteFontFamily::GetMatchingFonts;

    /// <summary>
    /// Get the underlying font set used by this family.
    /// </summary>
    /// <param name="fontSet">Contains font set used by the family.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontSet)(
        [in, out] IDWriteFontSet1** fontSet
        );
};


[
    odl,
    uuid(514039C6-4617-4064-BF8B-92EA83E506E0) 
]
interface IDWriteFontCollection2 : IDWriteFontCollection1
{
    /// <summary>
    /// Creates a font family object given a zero-based font family index.
    /// </summary>
    /// <param name="index">Zero-based index of the font family.</param>
    /// <param name="fontFamily">Receives a pointer the newly created font family object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFamily2)(
        [in] UINT32 index,
        [in, out] IDWriteFontFamily2 * *fontFamily
        );

/// <summary>
/// Gets a list of fonts in the specified font family ranked in order of how well they match the specified axis values.
/// </summary>
/// <param name="familyName">Name of the font family. The name is not case-sensitive but must otherwise exactly match a family name in the collection.</param>
/// <param name="fontAxisValues">List of font axis values.</param>
/// <param name="fontAxisValueCount">Number of font axis values.</param>
/// <param name="matchingFonts">Receives a pointer to the newly created font list object.</param>
/// <remarks>
/// If no fonts matched, the list will be empty (GetFontCount returns 0),
/// but the function does not return an error.
/// </remarks>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetMatchingFonts)(
    [in] LongPtr familyName,
    [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
    [in] UINT32 fontAxisValueCount,
    [in, out] IDWriteFontList2** fontList
    );

/// <summary>
/// Get the font family model used by the font collection to group families.
/// </summary>
/// <returns>
/// Family model enumeration.
/// </returns>
STDMETHOD_(DWRITE_FONT_FAMILY_MODEL, GetFontFamilyModel)();

/// <summary>
/// Get the underlying font set used by this collection.
/// </summary>
/// <param name="fontSet">Contains font set used by the collection.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontSet2)(
    [in, out] IDWriteFontSet1** fontSet
    );

//using IDWriteFontCollection::GetFontFamily;
//using IDWriteFontCollection1::GetFontFamily;
//using IDWriteFontCollection1::GetFontSet;
};


[
    odl,
    uuid(05A9BF42-223F-4441-B5FB-8263685F55E9) 
]
interface IDWriteTextLayout4 : IDWriteTextLayout3
{
    /// <summary>
    /// Set values for font axes over a range of text.
    /// </summary>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontAxisValues)(
        [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount,
        [in] long textRange_startPosition,
        [in] long textRange_length
        );
//DWRITE_TEXT_RANGE textRange
/// <summary>
/// Get the number of axes set on the text position.
/// </summary>
STDMETHOD_(UINT32, GetFontAxisValueCount)(
    [in] UINT32 currentPosition
    );

/// <summary>
/// Get the list of font axis values on the text position.
/// </summary>
/// <param name="fontAxisValues">List of font axis values.</param>
/// <param name="fontAxisValueCount">Maximum number of font axis values to write.</param>
/// <returns>
/// Standard HRESULT error code, or E_INVALIDARG if fontAxisValueCount doesn't match GetFontAxisValueCount.
/// </returns>
STDMETHOD(GetFontAxisValues)(
    [in] UINT32 currentPosition,
    [in, out] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
    [in] UINT32 fontAxisValueCount,
    //_Out_opt_ DWRITE_TEXT_RANGE* textRange = nullptr
    [in, out] void* textRange
    );

/// <summary>
/// Get the automatic axis options.
/// </summary>
/// <returns>
/// Automatic axis options.
/// </returns>
STDMETHOD_(DWRITE_AUTOMATIC_FONT_AXES, GetAutomaticFontAxes)();

/// <summary>
/// Sets the automatic font axis options.
/// </summary>
/// <param name="automaticFontAxes">Automatic font axis options.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetAutomaticFontAxes)([in] DWRITE_AUTOMATIC_FONT_AXES automaticFontAxes);
};


[
    odl,
    uuid(6D3B5641-E550-430D-A85B-B7BF48A93427) 
]
interface IDWriteTextFormat3 : IDWriteTextFormat2
{
    /// <summary>
    /// Set values for font axes of the format.
    /// </summary>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontAxisValues)(
        [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount
        );

/// <summary>
/// Get the number of axes set on the format.
/// </summary>
STDMETHOD_(UINT32, GetFontAxisValueCount)();

/// <summary>
/// Get the list of font axis values on the format.
/// </summary>
/// <param name="fontAxisValues">List of font axis values.</param>
/// <param name="fontAxisValueCount">Maximum number of font axis values to write.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontAxisValues)(
    [in, out] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
    [in] UINT32 fontAxisValueCount
    );

/// <summary>
/// Get the automatic axis options.
/// </summary>
/// <returns>
/// Automatic axis options.
/// </returns>
STDMETHOD_(DWRITE_AUTOMATIC_FONT_AXES, GetAutomaticFontAxes)();

/// <summary>
/// Sets the automatic font axis options.
/// </summary>
/// <param name="automaticFontAxes">Automatic font axis options.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetAutomaticFontAxes)([in] DWRITE_AUTOMATIC_FONT_AXES automaticFontAxes);
};


[
    odl,
    uuid(2397599D-DD0D-4681-BD6A-F4F31EAADE77) 
]
interface IDWriteFontFallback1 : IDWriteFontFallback
{
    /// <summary>
    /// Determines an appropriate font to use to render the range of text.
    /// </summary>
    /// <param name="source">The text source implementation holds the text and locale.</param>
    /// <param name="textLength">Length of the text to analyze.</param>
    /// <param name="baseFontCollection">Default font collection to use.</param>
    /// <param name="baseFamilyName">Family name of the base font. If you pass nullptr, no matching will be done against
    /// the base family.</param>
    /// <param name="fontAxisValues">List of font axis values.</param>
    /// <param name="fontAxisValueCount">Number of font axis values.</param>
    /// <param name="mappedLength">Length of text mapped to the mapped font. This will always be less or equal to the
    /// input text length and greater than zero (if the text length is non-zero) so that the caller advances at
    /// least one character each call.</param>
    /// <param name="mappedFontFace">The font face that should be used to render the first mappedLength characters of the text.
    /// If it returns null, then no known font can render the text, and mappedLength is the number of unsupported
    /// characters to skip.</param>
    /// <param name="scale">Scale factor to multiply the em size of the returned font by.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(MapCharacters1)(
        [in] IDWriteTextAnalysisSource * analysisSource,
        [in] UINT32 textPosition,
        [in] UINT32 textLength,
        [in] IDWriteFontCollection * baseFontCollection,
        [in] LongPtr baseFamilyName,
        [in] DWRITE_FONT_AXIS_VALUE* fontAxisValues,
        [in] UINT32 fontAxisValueCount,
        [in, out] UINT32 * mappedLength,
        [in, out] FLOAT * scale,
        [in, out] IDWriteFontFace5 * *mappedFontFace
        );

    //using IDWriteFontFallback::MapCharacters;
};

//#endif // NTDDI_VERSION >= NTDDI_WIN10_RS3

//#if NTDDI_VERSION >= NTDDI_WIN10_RS4

[
    odl,
    uuid(DC7EAD19-E54C-43AF-B2DA-4E2B79BA3F7F) 
]
interface IDWriteFontSet2 : IDWriteFontSet1
{
    /// <summary>
    /// Gets the expiration event for the font set, if any. The expiration event is set on a system font set object if
    /// it is out of date due to fonts being installed, uninstalled, or updated. The client should handle the event by
    /// getting a new system font set.
    /// </summary>
    /// <returns>
    /// Returns an event handle if called on the system font set, or nullptr if called on a custom font set.
    /// </returns>
    /// <remarks>
    /// The client must not call CloseHandle on the returned event handle. The handle is owned by the font set 
    /// object, and remains valid as long as the client holds a reference to the font set. The client can wait
    /// on the returned event or use RegisterWaitForSingleObject to request a callback when the event is set.
    /// </remarks>
    STDMETHOD_(HANDLE, GetExpirationEvent)();
};

[
    odl,
    uuid(A4D055A6-F9E3-4E25-93B7-9E309F3AF8E9) 
]
interface IDWriteFontCollection3 : IDWriteFontCollection2
{
    /// <summary>
    /// Gets the expiration event for the font collection, if any. The expiration event is set on a system font 
    /// collection object if it is out of date due to fonts being installed, uninstalled, or updated. The client 
    /// should handle the event by getting a new system font collection.
    /// </summary>
    /// <returns>
    /// Returns an event handle if called on the system font collection, or nullptr if called on a custom font 
    /// collection.
    /// </returns>
    /// <remarks>
    /// The client must not call CloseHandle on the returned event handle. The handle is owned by the font collection 
    /// object, and remains valid as long as the client holds a reference to the font collection. The client can wait
    /// on the returned event or use RegisterWaitForSingleObject to request a callback when the event is set.
    /// </remarks>
    STDMETHOD_(HANDLE, GetExpirationEvent)();
};

[
    odl,
    uuid(35D0E0B3-9076-4D2E-A016-A91B568A06B4)
]
interface  IDWriteFactory7 : IDWriteFactory6
{
    /// <summary>
    /// Retrieves the set of system fonts.
    /// </summary>
    /// <param name="includeDownloadableFonts">Include downloadable fonts or only locally installed ones.</param>
    /// <param name="fontSet">Receives a pointer to the font set object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSystemFontSet7)(
        [in] BOOL includeDownloadableFonts,
        [in, out] IDWriteFontSet2 * *fontSet
        );

    //using IDWriteFactory6::GetSystemFontSet;

    /// <summary>
    /// Retrieves a collection of fonts grouped into families.
    /// </summary>
    /// <param name="includeDownloadableFonts">Include downloadable fonts or only locally installed ones.</param>
    /// <param name="fontFamilyModel">How to group families in the collection.</param>
    /// <param name="fontCollection">Receives a pointer to the font collection object, or nullptr in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSystemFontCollection7)(
        [in] BOOL includeDownloadableFonts,
        [in] DWRITE_FONT_FAMILY_MODEL fontFamilyModel,
        [in, out] IDWriteFontCollection3** fontCollection
        );

   //using IDWriteFactory6::GetSystemFontCollection;
};

//#endif // NTDDI_VERSION >= NTDDI_WIN10_RS4
//
//#if NTDDI_VERSION >= NTDDI_WIN10_RS5

/// <summary>
/// The font source type identifies the mechanism by which a font came to be included in a font set.
/// </summary>
typedef enum DWRITE_FONT_SOURCE_TYPE
{
    /// <summary>
    /// The font source is unknown or is not any of the other defined font source types.
    /// </summary>
    DWRITE_FONT_SOURCE_TYPE_UNKNOWN,

    /// <summary>
    /// The font source is a font file, which is installed for all users on the device.
    /// </summary>
    DWRITE_FONT_SOURCE_TYPE_PER_MACHINE,

    /// <summary>
    /// The font source is a font file, which is installed for the current user.
    /// </summary>
    DWRITE_FONT_SOURCE_TYPE_PER_USER,

    /// <summary>
    /// The font source is an APPX package, which includes one or more font files.
    /// The font source name is the full name of the package.
    /// </summary>
    DWRITE_FONT_SOURCE_TYPE_APPX_PACKAGE,

    /// <summary>
    /// The font source is a font provider for downloadable fonts.
    /// </summary>
    DWRITE_FONT_SOURCE_TYPE_REMOTE_FONT_PROVIDER
} DWRITE_FONT_SOURCE_TYPE;

[
    odl,
    uuid(7C073EF2-A7F4-4045-8C32-8AB8AE640F90) 
]
interface IDWriteFontSet3 : IDWriteFontSet2
{
    /// <summary>
    /// Gets the font source type of the specified font.
    /// </summary>
    /// <param name="listIndex">Zero-based index of the font.</param>
    STDMETHOD_(DWRITE_FONT_SOURCE_TYPE, GetFontSourceType)([in] UINT32 fontIndex);

/// <summary>
/// Gets the length of the font source name for the specified font.
/// </summary>
/// <param name="listIndex">Zero-based index of the font.</param>
STDMETHOD_(UINT32, GetFontSourceNameLength)([in] UINT32 listIndex);

/// <summary>
/// Copies the font source name for the specified font to an output array.
/// </summary>
/// <param name="listIndex">Zero-based index of the font.</param>
/// <param name="stringBuffer">Character array that receives the string.</param>
/// <param name="stringBufferSize">Size of the array in characters. The size must include space for the terminating
/// null character.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(GetFontSourceName)(
    [in] UINT32 listIndex,
    [in] LongPtr stringBuffer,
    [in] UINT32 stringBufferSize
    );
};

//#endif // NTDDI_VERSION >= NTDDI_WIN10_RS5
//
//#if NTDDI_VERSION >= NTDDI_WIN10_MN

[
    odl,
    uuid(C4B1FE1B-6E84-47D5-B54C-A597981B06AD)
]
interface IDWriteFontFace6 : IDWriteFontFace5
{
    /// <summary>
    /// Creates a localized strings object that contains the family names for the font, indexed by locale name.
    /// </summary>
    /// <param name="fontFamilyModel">Specifies how fonts are grouped into families, which affects the family name property.</param>
    /// <param name="names">Receives a pointer to an object to contains the font family names, indexed by locale.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFamilyNames6)(
        [in] DWRITE_FONT_FAMILY_MODEL fontFamilyModel,
        [in, out] IDWriteLocalizedStrings * *names
        );

    //using IDWriteFontFace3::GetFamilyNames;

    /// <summary>
    /// Creates a localized strings object that contains the face names for the font, indexed by locale name.
    /// </summary>
    /// <param name="fontFamilyModel">Specifies how fonts are grouped into families, which affects the face name property.</param>
    /// <param name="names">Receives a pointer to an object to contains the font face names, indexed by locale.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFaceNames6)(
        [in] DWRITE_FONT_FAMILY_MODEL fontFamilyModel,
        [in, out] IDWriteLocalizedStrings** names
        );

    //using IDWriteFontFace3::GetFaceNames;
};

//#endif // NTDDI_VERSION >= NTDDI_WIN10_MN
//
//#if NTDDI_VERSION >= NTDDI_WIN10_NI

[
    odl,
    uuid(EEC175FC-BEA9-4C86-8B53-CCBDD7DF0C82) 
]
interface IDWriteFontSet4 : IDWriteFontSet3
{
    /// <summary>
    /// Computes derived font axis values from the specified font weight, stretch, style, and size.
    /// </summary>
    /// <param name="inputAxisValues">Pointer to an optional array of input axis values. Axes present
    /// in this array are excluded from the output. This is so explicit axis values take precedence over 
    /// derived axis values.</param>
    /// <param name="inputAxisCount">Size of the array of input axis values.</param>
    /// <param name="fontWeight">Font weight, used to compute "wght" axis value.</param>
    /// <param name="fontStretch">Font stretch, used to compute "wdth" axis value.</param>
    /// <param name="fontStyle">Font style, used to compute "slnt" and "ital" axis values.</param>
    /// <param name="fontSize">Font size in DIPs, used to compute "opsz" axis value. If this parameter is zero,
    /// no "opsz" axis value is added to the output array.</param>
    /// <param name="outputAxisValues">Pointer to an output array to which derived axis values are written.
    /// The size of this array must be at least DWRITE_STANDARD_FONT_AXIS_COUNT (5). The return value is 
    /// the actual number of axis values written to this array.</param>
    /// <returns>Returns the actual number of derived axis values written to the output array.</returns>
    /// <remarks>The caller should concatenate the output axis values to the input axis values (if any),
    /// and pass the combined axis values to the GetMatchingFonts method. This does not result in duplicates
    /// because the output does not include any axes present in the inputAxisValues array.
    /// </remarks>
    STDMETHOD_(UINT32, ConvertWeightStretchStyleToFontAxisValues)(
        [in] DWRITE_FONT_AXIS_VALUE* inputAxisValues,
        [in] UINT32 inputAxisCount,
        [in] DWRITE_FONT_WEIGHT fontWeight,
        [in] DWRITE_FONT_STRETCH fontStretch,
        [in] DWRITE_FONT_STYLE fontStyle,
        [in] float fontSize,
        [in, out] DWRITE_FONT_AXIS_VALUE * outputAxisValues
        );

/// <summary>
/// Generates a matching font set based on the requested inputs, ordered so that nearer matches are earlier.
/// </summary>
/// <param name="familyName">Font family name. This can be a typographic family name, weight/stretch/style
/// family name, GDI (RBIZ) family name, or full name.</param>
/// <param name="fontAxisValues">Array of font axis values.</param>
/// <param name="fontAxisValueCount">Number of font axis values.</param>
/// <param name="allowedSimulations">Specifies which simulations (i.e., algorithmic emboldening and/or slant)
/// may be applied to matching fonts to better match the specified axis values. No simulations are applied if
/// this parameter is DWRITE_FONT_SIMULATIONS_NONE (0).</param>
/// <param name="matchingFonts">Receives a pointer to a newly-created font set, which contains a prioritized 
/// list of fonts that match the specified inputs.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// This can yield distinct items that were not in the original font set, including items with simulation flags
/// (if they would be a closer match to the request) and instances that were not named by the font author.
/// Items from the same font resources are collapsed into one, the closest possible match.
/// </remarks>
STDMETHOD(GetMatchingFonts)(
    [in] LongPtr familyName,
    [in]  DWRITE_FONT_AXIS_VALUE* fontAxisValues,
    [in] UINT32 fontAxisValueCount,
    [in] DWRITE_FONT_SIMULATIONS allowedSimulations,
    [in, out] IDWriteFontSet4** matchingFonts
    );
};

//#endif // NTDDI_VERSION >= NTDDI_WIN10_NI
//
//#if NTDDI_VERSION >= NTDDI_WIN10_CU // TODO - set correct DDI version

/// <summary>
/// Contains information about a bitmap associated with an IDWriteBitmapRenderTarget.
/// The bitmap is top-down with 32-bits per pixel and no padding between scan lines.
/// </summary>
typedef struct DWRITE_BITMAP_DATA_BGRA32
{
    UINT32 width;
    UINT32 height;
   // _Field_size_(width* height) UINT32* pixels;
    LongPtr pixels;
} DWRITE_BITMAP_DATA_BGRA32;

/// <summary>
/// Encapsulates a bitmap which can be used for rendering glyphs.
/// </summary>
[
    odl,
    uuid(C553A742-FC01-44DA-A66E-B8B9ED6C3995)
]
interface IDWriteBitmapRenderTarget2 : IDWriteBitmapRenderTarget1
{
    /// <summary>
    /// Gets the demensions and a pointer to the system memory bitmap encapsulated by this
    /// bitmap render target object. The pointer is owned by the render target object, and
    /// remains valid as long as the object exists.
    /// </summary>
    STDMETHOD(GetBitmapData)([in, out] DWRITE_BITMAP_DATA_BGRA32 * bitmapData);
};

/// <summary>
/// Defines known feature level for use with the IDWritePaintReader interface and 
/// related APIs. A feature level represents a level of functionality. For example, it
/// determines what DWRITE_PAINT_TYPE values might be returned.
/// </summary>
/// <remarks>
/// See the DWRITE_PAINT_TYPE enumeration for which paint types are required for each
/// feature level.
/// </remarks>
typedef enum DWRITE_PAINT_FEATURE_LEVEL
{
    /// <summary>
    /// No paint API support.
    /// </summary>
    DWRITE_PAINT_FEATURE_LEVEL_NONE = 0,

    /// <summary>
    /// Specifies a level of functionality corresponding to OpenType COLR version 0.
    /// </summary>
    DWRITE_PAINT_FEATURE_LEVEL_COLR_V0 = 1,

    /// <summary>
    /// Specifies a level of functionality corresponding to OpenType COLR version 1.
    /// </summary>
    DWRITE_PAINT_FEATURE_LEVEL_COLR_V1 = 2
} DWRITE_PAINT_FEATURE_LEVEL;

/// <summary>
/// Combination of flags specifying attributes of a color glyph or of specific color values in
/// a color glyph.
/// </summary>
typedef enum DWRITE_PAINT_ATTRIBUTES
{
    DWRITE_PAINT_ATTRIBUTES_NONE = 0,

    /// <summary>
    /// Specifies that the color value (or any color value in the glyph) comes from the font's
    /// color palette. This means the appearance may depend on the current palette index, which
    /// may be important to clients that cache color glyphs.
    /// </summary>
    DWRITE_PAINT_ATTRIBUTES_USES_PALETTE = 0x01,

    /// <summary>
    /// Specifies that the color value (or any color value in the glyph) comes from the client-specified
    /// text color. This means the appearance may depend on the text color, which may be important to
    /// clients that cache color glyphs.
    /// </summary>
    DWRITE_PAINT_ATTRIBUTES_USES_TEXT_COLOR = 0x02
} DWRITE_PAINT_ATTRIBUTES;
//#ifdef DEFINE_ENUM_FLAG_OPERATORS
//DEFINE_ENUM_FLAG_OPERATORS(DWRITE_PAINT_ATTRIBUTES)
//#endif

/// <summary>
/// Represents a color in a color glyph.
/// </summary>
typedef struct DWRITE_PAINT_COLOR
{
    /// <summary>
    /// Color value (not premultiplied). See the colorAttributes member for information about how
    /// the color is determined.
    /// </summary>
    DWRITE_COLOR_F value;

    /// <summary>
    /// If the colorAttributes member is DWRITE_PAINT_ATTRIBUTES_USES_PALETTE, this member is
    /// the index of a palette entry in the selected color palette. Otherwise, this member is
    /// DWRITE_NO_PALETTE_INDEX (0xFFFF).
    /// </summary>
    UINT16 paletteEntryIndex;

    /// <summary>
    /// Specifies an alpha value multiplier in the range 0 to 1 that was used to compute the color
    /// value. Color glyph descriptions may include alpha values to be multiplied with the alpha
    /// values of palette entries.
    /// </summary>
    float alphaMultiplier;

    /// <summary>
    /// Specifies how the color value is determined. If this member is 
    /// DWRITE_PAINT_ATTRIBUTES_USES_PALETTE, the color value is determined by getting the color at
    /// paletteEntryIndex in the current color palette. The color's alpha value is then multiplied
    /// by alphaMultiplier. If a font has multiple color palettes, a client can set the current color
    /// palette using the IDWritePaintReader::SetColorPaletteIndex method. A client that uses a custom
    /// palette can use the paletteEntryIndex and alphaMultiplier methods to compute the color. If this
    /// member is DWRITE_PAINT_ATTRIBUTES_USES_TEXT_COLOR, the color value is equal to the text 
    /// foreground color, which can be set using the IDWritePaintReader::SetTextColor method.
    /// </summary>
    DWRITE_PAINT_ATTRIBUTES colorAttributes;
} DWRITE_PAINT_COLOR;

/// <summary>
/// Specifies a composite mode for combining source and destination paint elements in a
/// color glyph. These are taken from the W3C Compositing and Blending Level 1 specification.
/// </summary>
typedef enum DWRITE_COLOR_COMPOSITE_MODE
{
    // Porter-Duff modes.
    DWRITE_COLOR_COMPOSITE_CLEAR,
    DWRITE_COLOR_COMPOSITE_SRC,
    DWRITE_COLOR_COMPOSITE_DEST,
    DWRITE_COLOR_COMPOSITE_SRC_OVER,
    DWRITE_COLOR_COMPOSITE_DEST_OVER,
    DWRITE_COLOR_COMPOSITE_SRC_IN,
    DWRITE_COLOR_COMPOSITE_DEST_IN,
    DWRITE_COLOR_COMPOSITE_SRC_OUT,
    DWRITE_COLOR_COMPOSITE_DEST_OUT,
    DWRITE_COLOR_COMPOSITE_SRC_ATOP,
    DWRITE_COLOR_COMPOSITE_DEST_ATOP,
    DWRITE_COLOR_COMPOSITE_XOR,
    DWRITE_COLOR_COMPOSITE_PLUS,

    // Separable color blend modes.
    DWRITE_COLOR_COMPOSITE_SCREEN,
    DWRITE_COLOR_COMPOSITE_OVERLAY,
    DWRITE_COLOR_COMPOSITE_DARKEN,
    DWRITE_COLOR_COMPOSITE_LIGHTEN,
    DWRITE_COLOR_COMPOSITE_COLOR_DODGE,
    DWRITE_COLOR_COMPOSITE_COLOR_BURN,
    DWRITE_COLOR_COMPOSITE_HARD_LIGHT,
    DWRITE_COLOR_COMPOSITE_SOFT_LIGHT,
    DWRITE_COLOR_COMPOSITE_DIFFERENCE,
    DWRITE_COLOR_COMPOSITE_EXCLUSION,
    DWRITE_COLOR_COMPOSITE_MULTIPLY,

    // Non-separable color blend modes.
    DWRITE_COLOR_COMPOSITE_HSL_HUE,
    DWRITE_COLOR_COMPOSITE_HSL_SATURATION,
    DWRITE_COLOR_COMPOSITE_HSL_COLOR,
    DWRITE_COLOR_COMPOSITE_HSL_LUMINOSITY
} DWRITE_COLOR_COMPOSITE_MODE;

/// <summary>
/// Identifies a type of paint element in a color glyph. A color glyph's visual representation
/// is defined by a tree of paint elements. A paint element's properties are specified by a
/// DWRITE_PAINT_ELEMENT structure, which combines a paint type an a union.
/// </summary>
/// <remarks>
/// For more information about each paint type, see DWRITE_PAINT_ELEMENT. 
/// </remarks>
typedef enum DWRITE_PAINT_TYPE
{
    // The following paint types may be returned for color feature levels greater than
    // or equal to DWRITE_PAINT_FEATURE_LEVEL_COLR_V0.
    DWRITE_PAINT_TYPE_NONE,
    DWRITE_PAINT_TYPE_LAYERS,
    DWRITE_PAINT_TYPE_SOLID_GLYPH,

    // The following paint types may be returned for color feature levels greater than
    // or equal to DWRITE_PAINT_FEATURE_LEVEL_COLR_V1.
    DWRITE_PAINT_TYPE_SOLID,
    DWRITE_PAINT_TYPE_LINEAR_GRADIENT,
    DWRITE_PAINT_TYPE_RADIAL_GRADIENT,
    DWRITE_PAINT_TYPE_SWEEP_GRADIENT,
    DWRITE_PAINT_TYPE_GLYPH,
    DWRITE_PAINT_TYPE_COLOR_GLYPH,
    DWRITE_PAINT_TYPE_TRANSFORM,
    DWRITE_PAINT_TYPE_COMPOSITE
} DWRITE_PAINT_TYPE;

/// <summary>
/// Specifies properties of a paint element, which is one node in a visual tree associated
/// with a color glyph. This is passed as an output parameter to various IDWritePaintReader
/// methods.
/// </summary>
/// <remarks>
/// For a detailed description of how paint elements should be rendered, see the OpenType COLR
/// table specification. Comments below reference the COLR paint record formats associated with
/// each paint type.
///
/// Note that this structure (and its size) may differ for different versions of the API, as
/// newer versions may have additional union members for new paint types. For this reason,
/// IDWritePaintReader methods that take a DWRITE_PAINT_ELEMENT output parameter also take a
/// structSize parameter, for which the caller should specify actual size of the structure
/// allocated by the caller, i.e., sizeof(DWRITE_PAINT_ELEMENT). Clients should use caution
/// when passing DWRITE_PAINT_ELEMENT objects between components that may have been compiled
/// against different versions of this header file.
/// </remarks>
typedef struct DWRITE_PAINT_ELEMENT
{
    /// <summary>
    /// Specifies the paint type, and thus which member of the union is valid.
    /// </summary>
    DWRITE_PAINT_TYPE paintType;

    /// <summary>
    /// Specifies type-specific properties of the paint element.
    /// </summary>
    BYTE PAINT_UNION[16];
    //union PAINT_UNION
 /*   {
        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_LAYERS.
        /// Contains one or more child paint elements to be drawn in bottom-up order.
        /// </summary>
        /// <remarks>
        /// This corresponds to a PaintColrLayers record in the OpenType COLR table.
        /// Or it may correspond to a BaseGlyph record defined by COLR version 0.
        /// </remarks>
        struct PAINT_LAYERS
        {
            /// <summary>
            /// Number of child paint elements in bottom-up order. Use the IDWritePaintReader
            /// interface's MoveFirstChild and MoveNextSibling methods to retrieve the child paint
            /// elements. Use the MoveParent method to return to the parent element.
            /// </summary>
            UINT32 childCount;
        } layers;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_SOLID_GLYPH.
        /// Specifies a glyph with a solid color fill.
        /// This paint element has no child elements.
        /// </summary>
        /// <remarks>
        /// This corresponds to a combination of two paint records in the OpenType COLR table:
        /// a PaintGlyph record, which references either a PaintSolid or PaintVarSolid record.
        /// Or it may correspond to a Layer record defined by COLR version 0.
        /// </remarks>
        struct PAINT_SOLID_GLYPH
        {
            /// <summary>
            /// Glyph index defining the shape to be filled.
            /// </summary>
            UINT32 glyphIndex;

            /// <summary>
            /// Glyph color used to fill the glyph shape.
            /// </summary>
            DWRITE_PAINT_COLOR color;
        } solidGlyph;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_SOLID.
        /// Specifies a solid color used to fill the current shape or clip.
        /// This paint element has no child elements.
        /// </summary>
        /// <remarks>
        /// This corresponds to a PaintSolid or PaintVarSolid record in the OpenType COLR table.
        /// </remarks>
        DWRITE_PAINT_COLOR solid;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_LINEAR_GRADIENT.
        /// Specifies a linear gradient used to fill the current shape or clip.
        /// This paint element has no child elements.
        /// </summary>
        /// <remarks>
        /// This corresponds to a PaintLinearGradient or PaintVarLinearGradient record in the OpenType
        /// COLR table.
        /// </remarks>
        struct PAINT_LINEAR_GRADIENT
        {
            /// <summary>
            /// D2D1_EXTEND_MODE value speciying how colors outside the interval are defined.
            /// </summary>
            UINT32 extendMode;

            /// <summary>
            /// Number of gradient stops. Use the IDWritePaintReader::GetGradientStops method to
            /// get the gradient stops.
            /// </summary>
            UINT32 gradientStopCount;

            /// <summary>
            /// X coordinate of the start point of the color line.
            /// </summary>
            float x0;

            /// <summary>
            /// Y coordinate of the start point of the color line.
            /// </summary>
            float y0;

            /// <summary>
            /// X coordinate of the end point of the color line.
            /// </summary>
            float x1;

            /// <summary>
            /// Y coordinate of the end point of the color line.
            /// </summary>
            float y1;

            /// <summary>
            /// X coordinate of the rotation point of the color line.
            /// </summary>
            float x2;

            /// <summary>
            /// Y coordinate of the rotation point of the color line.
            /// </summary>
            float y2;
        } linearGradient;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_RADIAL_GRADIENT.
        /// Specifies a radial gradient used to fill the current shape or clip.
        /// This paint element has no child elements.
        /// </summary>
        /// <remarks>
        /// This corresponds to a PaintRadialGradient or PaintVarRadialGradient record in the OpenType
        /// COLR table.
        /// </remarks>
        struct PAINT_RADIAL_GRADIENT
        {
            /// <summary>
            /// D2D1_EXTEND_MODE value speciying how colors outside the interval are defined.
            /// </summary>
            UINT32 extendMode;

            /// <summary>
            /// Number of gradient stops. Use the IDWritePaintReader::GetGradientStops method to
            /// get the gradient stops.
            /// </summary>
            UINT32 gradientStopCount;

            /// <summary>
            /// Center X coordinate of the start circle.
            /// </summary>
            float x0;

            /// <summary>
            /// Center Y coordinate of the start circle.
            /// </summary>
            float y0;

            /// <summary>
            /// Radius of the start circle.
            /// </summary>
            float radius0;

            /// <summary>
            /// Center X coordinate of the end circle.
            /// </summary>
            float x1;

            /// <summary>
            /// Center Y coordinate of the end circle.
            /// </summary>
            float y1;

            /// <summary>
            /// Radius of the end circle.
            /// </summary>
            float radius1;
        } radialGradient;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_SWEEP_GRADIENT.
        /// Specifies a sweep gradient used to fill the current shape or clip.
        /// This paint element has no child elements.
        /// </summary>
        /// <remarks>
        /// This corresponds to a PaintSweepGradient or PaintVarSweepGradient record in the OpenType
        /// COLR table.
        /// </remarks>
        struct PAINT_SWEEP_GRADIENT
        {
            /// <summary>
            /// D2D1_EXTEND_MODE value speciying how colors outside the interval are defined.
            /// </summary>
            UINT32 extendMode;

            /// <summary>
            /// Number of gradient stops. Use the IDWritePaintReader::GetGradientStops method to
            /// get the gradient stops.
            /// </summary>
            UINT32 gradientStopCount;

            /// <summary>
            /// Center X coordinate.
            /// </summary>
            float centerX;

            /// <summary>
            /// Center Y coordinate.
            /// </summary>
            float centerY;

            /// <summary>
            /// Start of the angular range of the gradient, measured in counter-clockwise degrees
            /// from the direction of the positive x axis.
            /// </summary>
            float startAngle;

            /// <summary>
            /// End of the angular range of the gradient, measured in counter-clockwise degrees
            /// from the direction of the positive x axis.
            /// </summary>
            float endAngle;
        } sweepGradient;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_GLYPH.
        /// Specifies a glyph shape to be filled or, equivalently, a clip region.
        /// This paint element has one child element.
        /// </summary>
        /// <remarks>
        /// The child paint element defines how the glyph shape is filled. The child element can be a single paint
        /// element, such as a linear gradient. Or the child element can be the root of a visual tree to be rendered
        /// with the glyph shape as a clip region.
        /// This corresponds to a PaintGlyph record in the OpenType COLR table.
        /// </remarks>
        struct PAINT_GLYPH
        {
            /// <summary>
            /// Glyph index of the glyph that defines the shape to be filled.
            /// </summary>
            UINT32 glyphIndex;
        } glyph;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_COLOR_GLYPH.
        /// Specifies another color glyph, used as a reusable component.
        /// This paint element has one child element, which is the root paint element of the specified color glyph.
        /// </summary>
        /// <remarks>
        /// This corresponds to a PaintColorGlyph record in the OpenType COLR table.
        /// </remarks>
        struct PAINT_COLOR_GLYPH
        {
            /// <summary>
            /// Glyph index of the referenced color glyph.
            /// </summary>
            UINT32 glyphIndex;

            /// <summary>
            /// Clip box of the referenced color glyph, in ems. This is an empty rectangle of the color glyph does 
            /// not specify a clip box. If it is not an empty rect, the client is required to clip the child content
            /// to this box.
            /// </summary>
            D2D_RECT_F clipBox;
        } colorGlyph;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_TRANSFORM.
        /// Specifies an affine transform to be applied to child content.
        /// This paint element has one child element, which is the transformed content.
        /// </summary>
        /// <remarks>
        /// This corresponds to paint formats 12 through 31 in the OpenType COLR table.
        /// </remarks>
        DWRITE_MATRIX transform;

        /// <summary>
        /// Valid for paint elements of type DWRITE_PAINT_TYPE_COMPOSITE.
        /// Combines the two child paint elements using the specified compositing or blending mode.
        /// This paint element has two child elements. The first child is the paint source. The 
        /// second child is the paint destination (or backdrop).
        /// </summary>
        /// <remarks>
        /// This corresponds to a PaintComposite record in the OpenType COLR table.
        /// </remarks>
        struct PAINT_COMPOSITE
        {
            /// <summary>
            /// Specifies the compositing or blending mode.
            /// </summary>
            DWRITE_COLOR_COMPOSITE_MODE mode;
        } composite;
    } paint;*/
} DWRITE_PAINT_ELEMENT;

//struct D2D1_GRADIENT_STOP;

typedef struct D2D_RECT_F
{
    FLOAT left;
    FLOAT top;
    FLOAT right;
    FLOAT bottom;

} D2D_RECT_F;
typedef struct D2D1_COLOR_F {

    single r;

    single g;

    single b;

    single a;
} D2D1_COLOR_F;

typedef struct D2D1_GRADIENT_STOP {

    single position;

    D2D1_COLOR_F color;
} D2D1_GRADIENT_STOP;


//
///// <summary>
///// Interface used to read color glyph data for a specific font. A color glyph is
///// represented as a visual tree of paint elements.
///// </summary>
[
    odl,
    uuid(8128E912-3B97-42A5-AB6C-24AAD3A86E54)
]
interface IDWritePaintReader : stdole.IUnknown
{
    /// <summary>
    /// Sets the current glyph and positions the reader on the root paint element of the
    /// selected glyph's visual tree.
    /// </summary>
    /// <param name="glyphIndex">Glyph index to get the color glyph representation for.</param>
    /// <param name="paintElement">Receives information about the root paint element of the
    /// glyph's visual tree.</param>
    /// <param name="structSize">Size of the DWRITE_PAINT_ELEMENT structure, in bytes.</param>
    /// <param name="clipBox">Receives a precomputed glyph box (in ems) for the specified glyph,
    /// if one is specified by the font. Otherwise, the glyph box is set to an empty rectangle
    /// (all zeros). If a non-empty clip box is specified, the client must clip the color
    /// glyph's representation to the specified box.</param>
    /// <param name="glyphAttributes">Receives optional paint attributes for the glyph.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// If the specified glyph index is not a color glyph, the method succeeds, but the paintType
    /// member of the DWRITE_PAINT_ELEMENT structure is set to DWRITE_PAINT_TYPE_NONE. In this
    /// case, the application should draw the input glyph as a non-color glyph.
    /// </remarks>
    STDMETHOD(SetCurrentGlyph)(
        [in] UINT32 glyphIndex,
        [in, out] DWRITE_PAINT_ELEMENT * paintElement,
        [in] UINT32 structSize,
        [in, out] D2D_RECT_F * clipBox,
        [in, out] DWRITE_PAINT_ATTRIBUTES * glyphAttributes
        );

//// Inline overload of SetCurrentGlyph, in which structSize is implied.
//HRESULT SetCurrentGlyph(
//    UINT32 glyphIndex,
//    [in, out] DWRITE_PAINT_ELEMENT* paintElement,
//    [in, out] D2D_RECT_F* clipBox,
//    _Out_opt_ DWRITE_PAINT_ATTRIBUTES* glyphAttributes = nullptr
//    )
//{
//    return SetCurrentGlyph(
//        glyphIndex,
//        paintElement,
//        sizeof(DWRITE_PAINT_ELEMENT),
//        clipBox,
//        glyphAttributes
//        );
//}

/// <summary>
/// Sets the client-defined text color. The default value is transparent black. Changing the text color
/// can affect the appearance of a glyph if its definition uses the current text color. If this is the 
/// case, the SetCurrentGlyph method returns the DWRITE_PAINT_ATTRIBUTES_USES_TEXT_COLOR flag via the 
/// glyphAttributes output parameter.
/// </summary>
/// <param name="textColor">Specifies the text color.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetTextColor)(
    [in] DWRITE_COLOR_F* textColor
    );

/// <summary>
/// Sets the current color palette index. The default value is zero. Changing the palette index can affect
/// the appearance of a glyph if its definition references colors in the color palette. If this is the case,
/// the SetCurrentGlyph method returns the DWRITE_PAINT_ATTRIBUTES_USES_PALETTE flag via the glyphAttributes
/// output parameter.
/// </summary>
/// <param name="textColor">Specifies the color palette index.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetColorPaletteIndex)(
    [in] UINT32 colorPaletteIndex
    );

/// <summary>
/// Sets a custom color palette with client-defined palette entries instead of using a font-defined color
/// palette. Changing the color palette can affect the appearance of a glyph if its definition references
/// colors in the color palette. If this is the case, the SetCurrentGlyph method returns the 
/// DWRITE_PAINT_ATTRIBUTES_USES_PALETTE flag via the glyphAttributes output parameter.
/// </summary>
/// <param name="paletteEntries">Array of palette entries for the client-defined color palette.</param>
/// <param name="paletteEntryCount">Size of the paletteEntries array. This must equal the font's palette
/// entry count as returned by IDWriteFontFace2::GetPaletteEntryCount.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(SetCustomColorPalette)(
    [in] DWRITE_COLOR_F* paletteEntries,
    [in] UINT32 paletteEntryCount
    );

/// <summary>
/// Sets the current position in the visual tree to the first child of the current paint element, and returns
/// the newly-selected element's properties via the paintElement output parameter.
/// </summary>
/// <param name="paintElement">Receives the properties of the newly-selected element.</param>
/// <param name="structSize">Size of the DWRITE_PAINT_ELEMENT structure, in bytes.</param>
/// <returns>
/// Standard HRESULT error code. The return value is E_INVALIDARG if the current paint element doesn't have
/// any children.
/// </returns>
/// <remarks>
/// Whether a paint element has children (and how many) can be determined a priori from its paint type and
/// properties. For more information, see DWRITE_PAINT_ELEMENT.
/// </remarks>
STDMETHOD(MoveToFirstChild)(
    [in, out] DWRITE_PAINT_ELEMENT* paintElement,
    [in] UINT32 structSize
    );

/// <summary>
/// Sets the current position in the visual tree to the next sibling of the current paint element, and returns
/// the newly-selected element's properties via the paintElement output parameter.
/// </summary>
/// <param name="paintElement">Receives the properties of the newly-selected element.</param>
/// <param name="structSize">Size of the DWRITE_PAINT_ELEMENT structure, in bytes.</param>
/// <returns>
/// Standard HRESULT error code. The return value is E_INVALIDARG if the current paint element doesn't have
/// a next sibling.
/// </returns>
/// <remarks>
/// Whether a paint element has children (and how many) can be determined a priori from its paint type and
/// properties. For more information, see DWRITE_PAINT_ELEMENT.
/// </remarks>
STDMETHOD(MoveToNextSibling)(
    [in, out] DWRITE_PAINT_ELEMENT* paintElement,
    [in] UINT32 structSize 
    );

/// <summary>
/// Sets the current position in the visual tree to the parent of the current paint element.
/// </summary>
/// <returns>
/// Standard HRESULT error code. The return value is E_INVALIDARG if the current paint element is the root
/// element of the visual tree.
/// </returns>
STDMETHOD(MoveToParent)();

/// <summary>
/// Returns gradient stops of the current paint element.
/// </summary>
/// <param name="firstGradientStopIndex">Index of the first gradient stop to get.</param>
/// <param name="gradientStopCount">Number of gradient stops to get.</param>
/// <param name="gradientStops">Receives the gradient stops.</param>
/// <returns>Standard HRESULT error code.</returns>
/// <remarks>Gradient stops are guaranteed to be in ascending order by position.</remarks>
STDMETHOD(GetGradientStops)(
    [in] UINT32 firstGradientStopIndex,
    [in] UINT32 gradientStopCount,
    [in, out] D2D1_GRADIENT_STOP* gradientStops
    );

/// <summary>
/// Returns color information about each gradient stop, such as palette indices.
/// </summary>
/// <param name="firstGradientStopIndex">Index of the first gradient stop to get.</param>
/// <param name="gradientStopCount">Number of gradient stops to get.</param>
/// <param name="gradientStopColors">Receives the gradient stop colors.</param>
/// <returns>Standard HRESULT error code.</returns>
STDMETHOD(GetGradientStopColors)(
    [in] UINT32 firstGradientStopIndex,
    [in] UINT32 gradientStopCount,
    [in, out] DWRITE_PAINT_COLOR* gradientStopColors
    );
};

[
    odl,
    uuid(3945B85B-BC95-40F7-B72C-8B73BFC7E13B)
]
interface IDWriteFontFace7 : IDWriteFontFace6
{
    /// <summary>
    /// Returns the maximum paint feature level supported for the specified glyph image format.
    /// Possible values are specified by the DWRITE_PAINT_FEATURE_LEVEL enumeration,
    /// but additional feature levels may be added over time.
    /// </summary>
    /// <param name="glyphImageFormat">Glyph image format to get the paint feature level for.
    /// The return value is zero if the image format is not supported by the IDWritePaintReader API,
    /// or if the font doesn't contain image data in that format.</param>
    STDMETHOD_(DWRITE_PAINT_FEATURE_LEVEL, GetPaintFeatureLevel)(
        [in] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat
        );

/// <summary>
/// Creates a paint reader object, which can be used to retrieve vector graphic information
/// for color glyphs in the font.
/// </summary>
/// <param name="glyphImageFormat">Specifies the type of glyph data the reader will obtain. The only
/// glyph image format currently supported by this method is DWRITE_GLYPH_IMAGE_FORMATS_COLR_PAINT_TREE.</param>
/// <param name="paintFeatureLevel">Specifies the maximum paint feature level supported by the client.
/// This affects the types of paint elements that may be returned by the paint reader.</param>
/// <param name="paintReader">Receives a pointer to the newly-created object.</param>
/// <returns>Standard HRESULT error code.</returns>
STDMETHOD(CreatePaintReader)(
    [in] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,
    [in] DWRITE_PAINT_FEATURE_LEVEL paintFeatureLevel,
    [in, out] IDWritePaintReader** paintReader
    );
};

[
    odl,
    uuid(EE0A7FB5-DEF4-4C23-A454-C9C7DC878398)
]
interface IDWriteFactory8  : IDWriteFactory7
{
    /// <summary>
    /// Translates a glyph run to a sequence of color glyph runs, which can be
    /// rendered to produce a color representation of the original "base" run.
    /// </summary>
    /// <param name="baselineOriginX">Horizontal and vertical origin of the base glyph run in
    /// pre-transform coordinates.</param>
    /// <param name="glyphRun">Pointer to the original "base" glyph run.</param>
    /// <param name="glyphRunDescription">Optional glyph run description.</param>
    /// <param name="desiredGlyphImageFormats">Which data formats TranslateColorGlyphRun
    /// should split the runs into.</param>
    /// <param name="paintFeatureLevel">Paint feature level supported by the caller. Used
    /// when desiredGlyphImageFormats includes DWRITE_GLYPH_IMAGE_FORMATS_COLR_PAINT_TREE. See
    /// DWRITE_PAINT_FEATURE_LEVEL for more information.</param>
    /// <param name="measuringMode">Measuring mode, needed to compute the origins
    /// of each glyph.</param>
    /// <param name="worldToDeviceTransform">Matrix converting from the client's
    /// coordinate space to device coordinates (pixels), i.e., the world transform
    /// multiplied by any DPI scaling.</param>
    /// <param name="colorPaletteIndex">Zero-based index of the color palette to use.
    /// Valid indices are less than the number of palettes in the font, as returned
    /// by IDWriteFontFace2::GetColorPaletteCount.</param>
    /// <param name="colorEnumerator">If the function succeeds, receives a pointer
    /// to an enumerator object that can be used to obtain the color glyph runs.
    /// If the base run has no color glyphs, then the output pointer is NULL
    /// and the method returns DWRITE_E_NOCOLOR.</param>
    /// <returns>
    /// Returns DWRITE_E_NOCOLOR if the font has no color information, the glyph run
    /// does not contain any color glyphs, or the specified color palette index
    /// is out of range. In this case, the client should render the original glyph 
    /// run. Otherwise, returns a standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The old IDWriteFactory2::TranslateColorGlyphRun is equivalent to passing
    /// DWRITE_GLYPH_IMAGE_FORMATS_TRUETYPE|CFF|COLR.
    /// </remarks>
    STDMETHOD(TranslateColorGlyphRun)(
        //[in] D2D1_POINT_2F baselineOrigin,
        [in] CURRENCY baselineOrigin,
        [in] DWRITE_GLYPH_RUN* glyphRun,
        //_In_opt_ DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
        [in] void* glyphRunDescription,
        [in] DWRITE_GLYPH_IMAGE_FORMATS desiredGlyphImageFormats,
        [in] DWRITE_PAINT_FEATURE_LEVEL paintFeatureLevel,
        [in] DWRITE_MEASURING_MODE measuringMode,
        //_In_opt_ DWRITE_MATRIX* worldAndDpiTransform,
        [in] void* worldAndDpiTransform,
        [in] UINT32 colorPaletteIndex,
        [in, out] IDWriteColorGlyphRunEnumerator1 * *colorEnumerator
        );
};

/// <summary>
/// Encapsulates a bitmap which can be used for rendering glyphs.
/// </summary>
[
    odl,
    uuid(AEEC37DB-C337-40F1-8E2A-9A41B167B238)
]
interface IDWriteBitmapRenderTarget3 : IDWriteBitmapRenderTarget2
{
    /// <summary>
    /// Returns the paint feature level supported by this render target.
    /// A client can pass the return value of this method to IDWriteFactory8::TranslateColorGlyphRun.
    /// </summary>
    STDMETHOD_(DWRITE_PAINT_FEATURE_LEVEL, GetPaintFeatureLevel)();

/// <summary>
/// Draws a glyph run in a "paint" image format returned by IDWriteColorGlyphRunEnumerator1.
/// </summary>
/// <param name="baselineOriginX">X-coordinate of the baseline.</param>
/// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
/// <param name="measuringMode">Specifies measuring mode for positioning glyphs in the run.</param>
/// <param name="glyphRun">The glyph run to draw.</param>
/// <param name="glyphImageFormat">The image format of the color glyph run, as returned by
/// IDWriteColorGlyphRunEnumerator1. This must be one of the "paint" image formats.</param>
/// <param name="textColor">Foreground color of the text, used in cases where a color glyph
/// uses the text color.</param>
/// <param name="colorPaletteIndex">Zero-based index of the font-defined color palette to use.</param>
/// <param name="blackBoxRect">Optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by 
/// drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
STDMETHOD(DrawPaintGlyphRun)(
    [in] FLOAT baselineOriginX,
    [in] FLOAT baselineOriginY,
    [in] DWRITE_MEASURING_MODE measuringMode,
    [in] DWRITE_GLYPH_RUN* glyphRun,
    [in] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,
    [in] COLORREF textColor,
    [in] UINT32 colorPaletteIndex,
    //_Out_opt_ RECT* blackBoxRect = NULL
    [in, out] void* blackBoxRect
    );

/// <summary>
/// Draws a glyph run, using color representations of glyphs if available in the font.
/// </summary>
/// <param name="baselineOriginX">X-coordinate of the baseline.</param>
/// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
/// <param name="measuringMode">Specifies measuring mode for positioning glyphs in the run.</param>
/// <param name="glyphRun">The glyph run to draw.</param>
/// <param name="renderingParams">Object that controls rendering behavior.</param>
/// <param name="textColor">Foreground color of the text.</param>
/// <param name="colorPaletteIndex">Zero-based index of the font-defined color palette to use.</param>
/// <param name="blackBoxRect">Optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by 
/// drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// This method internally calls TranslateColorGlyphRun and then automatically calls the appropriate
/// lower-level methods to render monochrome or color glyph runs.
/// </remarks>
STDMETHOD(DrawGlyphRunWithColorSupport)(
    [in] FLOAT baselineOriginX,
    [in] FLOAT baselineOriginY,
    [in] DWRITE_MEASURING_MODE measuringMode,
    [in] DWRITE_GLYPH_RUN* glyphRun,
    [in] IDWriteRenderingParams* renderingParams,
    [in] COLORREF textColor,
    [in] UINT32 colorPaletteIndex,
    //_Out_opt_ RECT* blackBoxRect = NULL
    [in, out] void* blackBoxRect
    );
};

//#endif




















/*
//DirectWrite
//Definitions originally from dwvb.tlb by The trick

#define UINT16 short
#define UINT8 unsigned char
#define INT16 short
#define UINT32 long
#define INT32 long
#define UINT64 CURRENCY
#define INT64 CURRENCY
#define __in_bcount(x)
#define __out [out]
#define __in
#define __out_ecount_z(x)
#define __out_ecount(x)
#define __deref_out_bcount(x)
#define __in_ecount(x)
#define __inout
#define __in_z_opt
#define STDMETHOD(method)        HRESULT __stdcall method
#define STDMETHOD_(type,method)  type __stdcall method
#define PURE
#define __in_ecount_opt(x)
#define __in_opt
#define DECLSPEC_NOVTABLE
#define HDC long
#define LOGFONTW void
#define HMONITOR long
#define REFIID UUID*

interface IDWriteFactory;
interface IDWriteGlyphRunAnalysis;
interface IDWriteGdiInterop;
interface IDWriteBitmapRenderTarget;
interface IDWriteTextLayout;
interface IDWriteTextRenderer;
interface IDWritePixelSnapping;
interface IDWriteInlineObject;
interface IDWriteTextAnalyzer;
interface IDWriteTextAnalysisSink;
interface IDWriteTextAnalysisSource;
interface IDWriteNumberSubstitution;
interface IDWriteTypography;
interface IDWriteTextFormat;
interface IDWriteFont;
interface IDWriteFontFamily;
interface IDWriteFontList;
interface IDWriteFontCollection;
interface IDWriteLocalizedStrings;
interface IDWriteFontFileEnumerator;
interface IDWriteFontCollectionLoader;
interface IDWriteFontFace;
interface IDWriteRenderingParams;
interface IDWriteFontFile;
interface IDWriteFontFileStream;
interface IDWriteFontFileLoader;
interface IDWriteLocalFontFileLoader;
interface ID2D1SimplifiedGeometrySink;

typedef ID2D1SimplifiedGeometrySink IDWriteGeometrySink;


/// <summary>
/// The measuring method used for text layout.
/// </summary>
typedef enum DWRITE_MEASURING_MODE
{
    /// <summary>
    /// Text is measured using glyph ideal metrics whose values are independent to the current display resolution.
    /// </summary>
    DWRITE_MEASURING_MODE_NATURAL,

    /// <summary>
    /// Text is measured using glyph display compatible metrics whose values tuned for the current display resolution.
    /// </summary>
    DWRITE_MEASURING_MODE_GDI_CLASSIC,

    /// <summary>
    /// Text is measured using the same glyph display metrics as text measured by GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY.
    /// </summary>
    DWRITE_MEASURING_MODE_GDI_NATURAL

} DWRITE_MEASURING_MODE;

/// <summary>
/// The type of a font represented by a single font file.
/// Font formats that consist of multiple files, e.g. Type 1 .PFM and .PFB, have
/// separate enum values for each of the file type.
/// </summary>
typedef enum DWRITE_FONT_FILE_TYPE
{
    /// <summary>
    /// Font type is not recognized by the DirectWrite font system.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_UNKNOWN,

    /// <summary>
    /// OpenType font with CFF outlines.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_CFF,

    /// <summary>
    /// OpenType font with TrueType outlines.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_TRUETYPE,

    /// <summary>
    /// OpenType font that contains a TrueType collection.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_TRUETYPE_COLLECTION,

    /// <summary>
    /// Type 1 PFM font.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_TYPE1_PFM,

    /// <summary>
    /// Type 1 PFB font.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_TYPE1_PFB,

    /// <summary>
    /// Vector .FON font.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_VECTOR,

    /// <summary>
    /// Bitmap .FON font.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_BITMAP
} DWRITE_FONT_FILE_TYPE;

/// <summary>
/// The file format of a complete font face.
/// Font formats that consist of multiple files, e.g. Type 1 .PFM and .PFB, have
/// a single enum entry.
/// </summary>
typedef enum DWRITE_FONT_FACE_TYPE
{
    /// <summary>
    /// OpenType font face with CFF outlines.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_CFF,

    /// <summary>
    /// OpenType font face with TrueType outlines.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_TRUETYPE,

    /// <summary>
    /// OpenType font face that is a part of a TrueType collection.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_TRUETYPE_COLLECTION,

    /// <summary>
    /// A Type 1 font face.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_TYPE1,

    /// <summary>
    /// A vector .FON format font face.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_VECTOR,

    /// <summary>
    /// A bitmap .FON format font face.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_BITMAP,

    /// <summary>
    /// Font face type is not recognized by the DirectWrite font system.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_UNKNOWN
} DWRITE_FONT_FACE_TYPE;

/// <summary>
/// Specifies algorithmic style simulations to be applied to the font face.
/// Bold and oblique simulations can be combined via bitwise OR operation.
/// </summary>
typedef enum DWRITE_FONT_SIMULATIONS
{
    /// <summary>
    /// No simulations are performed.
    /// </summary>
    DWRITE_FONT_SIMULATIONS_NONE = 0x0000,

    /// <summary>
    /// Algorithmic emboldening is performed.
    /// </summary>
    DWRITE_FONT_SIMULATIONS_BOLD = 0x0001,

    /// <summary>
    /// Algorithmic italicization is performed.
    /// </summary>
    DWRITE_FONT_SIMULATIONS_OBLIQUE = 0x0002
} DWRITE_FONT_SIMULATIONS;

/// <summary>
/// The font weight enumeration describes common values for degree of blackness or thickness of strokes of characters in a font.
/// Font weight values less than 1 or greater than 999 are considered to be invalid, and they are rejected by font API functions.
/// </summary>
typedef enum DWRITE_FONT_WEIGHT
{
    /// <summary>
    /// Predefined font weight : Thin (100).
    /// </summary>
    DWRITE_FONT_WEIGHT_THIN = 100,

    /// <summary>
    /// Predefined font weight : Extra-light (200).
    /// </summary>
    DWRITE_FONT_WEIGHT_EXTRA_LIGHT = 200,

    /// <summary>
    /// Predefined font weight : Ultra-light (200).
    /// </summary>
    DWRITE_FONT_WEIGHT_ULTRA_LIGHT = 200,

    /// <summary>
    /// Predefined font weight : Light (300).
    /// </summary>
    DWRITE_FONT_WEIGHT_LIGHT = 300,

    /// <summary>
    /// Predefined font weight : Normal (400).
    /// </summary>
    DWRITE_FONT_WEIGHT_NORMAL = 400,

    /// <summary>
    /// Predefined font weight : Regular (400).
    /// </summary>
    DWRITE_FONT_WEIGHT_REGULAR = 400,

    /// <summary>
    /// Predefined font weight : Medium (500).
    /// </summary>
    DWRITE_FONT_WEIGHT_MEDIUM = 500,

    /// <summary>
    /// Predefined font weight : Demi-bold (600).
    /// </summary>
    DWRITE_FONT_WEIGHT_DEMI_BOLD = 600,

    /// <summary>
    /// Predefined font weight : Semi-bold (600).
    /// </summary>
    DWRITE_FONT_WEIGHT_SEMI_BOLD = 600,

    /// <summary>
    /// Predefined font weight : Bold (700).
    /// </summary>
    DWRITE_FONT_WEIGHT_BOLD = 700,

    /// <summary>
    /// Predefined font weight : Extra-bold (800).
    /// </summary>
    DWRITE_FONT_WEIGHT_EXTRA_BOLD = 800,

    /// <summary>
    /// Predefined font weight : Ultra-bold (800).
    /// </summary>
    DWRITE_FONT_WEIGHT_ULTRA_BOLD = 800,

    /// <summary>
    /// Predefined font weight : Black (900).
    /// </summary>
    DWRITE_FONT_WEIGHT_BLACK = 900,

    /// <summary>
    /// Predefined font weight : Heavy (900).
    /// </summary>
    DWRITE_FONT_WEIGHT_HEAVY = 900,

    /// <summary>
    /// Predefined font weight : Extra-black (950).
    /// </summary>
    DWRITE_FONT_WEIGHT_EXTRA_BLACK = 950,

    /// <summary>
    /// Predefined font weight : Ultra-black (950).
    /// </summary>
    DWRITE_FONT_WEIGHT_ULTRA_BLACK = 950
} DWRITE_FONT_WEIGHT;

/// <summary>
/// The font stretch enumeration describes relative change from the normal aspect ratio
/// as specified by a font designer for the glyphs in a font.
/// Values less than 1 or greater than 9 are considered to be invalid, and they are rejected by font API functions.
/// </summary>
typedef enum DWRITE_FONT_STRETCH
{
    /// <summary>
    /// Predefined font stretch : Not known (0).
    /// </summary>
    DWRITE_FONT_STRETCH_UNDEFINED = 0,

    /// <summary>
    /// Predefined font stretch : Ultra-condensed (1).
    /// </summary>
    DWRITE_FONT_STRETCH_ULTRA_CONDENSED = 1,

    /// <summary>
    /// Predefined font stretch : Extra-condensed (2).
    /// </summary>
    DWRITE_FONT_STRETCH_EXTRA_CONDENSED = 2,

    /// <summary>
    /// Predefined font stretch : Condensed (3).
    /// </summary>
    DWRITE_FONT_STRETCH_CONDENSED = 3,

    /// <summary>
    /// Predefined font stretch : Semi-condensed (4).
    /// </summary>
    DWRITE_FONT_STRETCH_SEMI_CONDENSED = 4,

    /// <summary>
    /// Predefined font stretch : Normal (5).
    /// </summary>
    DWRITE_FONT_STRETCH_NORMAL = 5,

    /// <summary>
    /// Predefined font stretch : Medium (5).
    /// </summary>
    DWRITE_FONT_STRETCH_MEDIUM = 5,

    /// <summary>
    /// Predefined font stretch : Semi-expanded (6).
    /// </summary>
    DWRITE_FONT_STRETCH_SEMI_EXPANDED = 6,

    /// <summary>
    /// Predefined font stretch : Expanded (7).
    /// </summary>
    DWRITE_FONT_STRETCH_EXPANDED = 7,

    /// <summary>
    /// Predefined font stretch : Extra-expanded (8).
    /// </summary>
    DWRITE_FONT_STRETCH_EXTRA_EXPANDED = 8,

    /// <summary>
    /// Predefined font stretch : Ultra-expanded (9).
    /// </summary>
    DWRITE_FONT_STRETCH_ULTRA_EXPANDED = 9
} DWRITE_FONT_STRETCH;

/// <summary>
/// The font style enumeration describes the slope style of a font face, such as Normal, Italic or Oblique.
/// Values other than the ones defined in the enumeration are considered to be invalid, and they are rejected by font API functions.
/// </summary>
typedef enum DWRITE_FONT_STYLE
{
    /// <summary>
    /// Font slope style : Normal.
    /// </summary>
    DWRITE_FONT_STYLE_NORMAL,

    /// <summary>
    /// Font slope style : Oblique.
    /// </summary>
    DWRITE_FONT_STYLE_OBLIQUE,

    /// <summary>
    /// Font slope style : Italic.
    /// </summary>
    DWRITE_FONT_STYLE_ITALIC

} DWRITE_FONT_STYLE;

/// <summary>
/// The informational string enumeration identifies a string in a font.
/// </summary>
typedef enum DWRITE_INFORMATIONAL_STRING_ID
{
    /// <summary>
    /// Unspecified name ID.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_NONE,

    /// <summary>
    /// Copyright notice provided by the font.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_COPYRIGHT_NOTICE,

    /// <summary>
    /// String containing a version number.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_VERSION_STRINGS,

    /// <summary>
    /// Trademark information provided by the font.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_TRADEMARK,

    /// <summary>
    /// Name of the font manufacturer.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_MANUFACTURER,

    /// <summary>
    /// Name of the font designer.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_DESIGNER,

    /// <summary>
    /// URL of font designer (with protocol, e.g., http://, ftp://).
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_DESIGNER_URL,

    /// <summary>
    /// Description of the font. Can contain revision information, usage recommendations, history, features, etc.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_DESCRIPTION,

    /// <summary>
    /// URL of font vendor (with protocol, e.g., http://, ftp://). If a unique serial number is embedded in the URL, it can be used to register the font.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_FONT_VENDOR_URL,

    /// <summary>
    /// Description of how the font may be legally used, or different example scenarios for licensed use. This field should be written in plain language, not legalese.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_LICENSE_DESCRIPTION,

    /// <summary>
    /// URL where additional licensing information can be found.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_LICENSE_INFO_URL,

    /// <summary>
    /// GDI-compatible family name. Because GDI allows a maximum of four fonts per family, fonts in the same family may have different GDI-compatible family names
    /// (e.g., "Arial", "Arial Narrow", "Arial Black").
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES,

    /// <summary>
    /// GDI-compatible subfamily name.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_WIN32_SUBFAMILY_NAMES,

    /// <summary>
    /// Family name preferred by the designer. This enables font designers to group more than four fonts in a single family without losing compatibility with
    /// GDI. This name is typically only present if it differs from the GDI-compatible family name.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_PREFERRED_FAMILY_NAMES,

    /// <summary>
    /// Subfamily name preferred by the designer. This name is typically only present if it differs from the GDI-compatible subfamily name. 
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_PREFERRED_SUBFAMILY_NAMES,

    /// <summary>
    /// Sample text. This can be the font name or any other text that the designer thinks is the best example to display the font in.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_SAMPLE_TEXT
} DWRITE_INFORMATIONAL_STRING_ID;

/// <summary>
/// Specifies the type of DirectWrite factory object.
/// DirectWrite factory contains internal state such as font loader registration and cached font data.
/// In most cases it is recommended to use the shared factory object, because it allows multiple components
/// that use DirectWrite to share internal DirectWrite state and reduce memory usage.
/// However, there are cases when it is desirable to reduce the impact of a component,
/// such as a plug-in from an untrusted source, on the rest of the process by sandboxing and isolating it
/// from the rest of the process components. In such cases, it is recommended to use an isolated factory for the sandboxed
/// component.
/// </summary>
typedef enum DWRITE_FACTORY_TYPE
{
    /// <summary>
    /// Shared factory allow for re-use of cached font data across multiple in process components.
    /// Such factories also take advantage of cross process font caching components for better performance.
    /// </summary>
    DWRITE_FACTORY_TYPE_SHARED,

    /// <summary>
    /// Objects created from the isolated factory do not interact with internal DirectWrite state from other components.
    /// </summary>
    DWRITE_FACTORY_TYPE_ISOLATED
} DWRITE_FACTORY_TYPE;

/// <summary>
/// Represents the internal structure of a device pixel (i.e., the physical arrangement of red,
/// green, and blue color components) that is assumed for purposes of rendering text.
/// </summary>
typedef enum DWRITE_PIXEL_GEOMETRY
{
    /// <summary>
    /// The red, green, and blue color components of each pixel are assumed to occupy the same point.
    /// </summary>
    DWRITE_PIXEL_GEOMETRY_FLAT,

    /// <summary>
    /// Each pixel comprises three vertical stripes, with red on the left, green in the center, and 
    /// blue on the right. This is the most common pixel geometry for LCD monitors.
    /// </summary>
    DWRITE_PIXEL_GEOMETRY_RGB,

    /// <summary>
    /// Each pixel comprises three vertical stripes, with blue on the left, green in the center, and 
    /// red on the right.
    /// </summary>
    DWRITE_PIXEL_GEOMETRY_BGR
} DWRITE_PIXEL_GEOMETRY;

/// <summary>
/// Represents a method of rendering glyphs.
/// </summary>
typedef enum DWRITE_RENDERING_MODE
{
    /// <summary>
    /// Specifies that the rendering mode is determined automatically based on the font and size.
    /// </summary>
    DWRITE_RENDERING_MODE_DEFAULT,

    /// <summary>
    /// Specifies that no anti-aliasing is performed. Each pixel is either set to the foreground 
    /// color of the text or retains the color of the background.
    /// </summary>
    DWRITE_RENDERING_MODE_ALIASED,

    /// <summary>
    /// Specifies ClearType rendering with the same metrics as aliased text. Glyphs can only
    /// be positioned on whole-pixel boundaries.
    /// </summary>
    DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC,

    /// <summary>
    /// Specifies ClearType rendering with the same metrics as text rendering using GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY. Glyph metrics are closer to their ideal values than 
    /// with aliased text, but glyphs are still positioned on whole-pixel boundaries.
    /// </summary>
    DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL,

    /// <summary>
    /// Specifies ClearType rendering with anti-aliasing in the horizontal dimension only. This is 
    /// typically used with small to medium font sizes (up to 16 ppem).
    /// </summary>
    DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL,

    /// <summary>
    /// Specifies ClearType rendering with anti-aliasing in both horizontal and vertical dimensions. 
    /// This is typically used at larger sizes to makes curves and diagonal lines look smoother, at 
    /// the expense of some softness.
    /// </summary>
    DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC,

    /// <summary>
    /// Specifies that rendering should bypass the rasterizer and use the outlines directly. This is 
    /// typically used at very large sizes.
    /// </summary>
    DWRITE_RENDERING_MODE_OUTLINE
} DWRITE_RENDERING_MODE;

/// <summary>
/// Direction for how reading progresses.
/// </summary>
typedef enum DWRITE_READING_DIRECTION
{
    /// <summary>
    /// Reading progresses from left to right.
    /// </summary>
    DWRITE_READING_DIRECTION_LEFT_TO_RIGHT,

    /// <summary>
    /// Reading progresses from right to left.
    /// </summary>
    DWRITE_READING_DIRECTION_RIGHT_TO_LEFT
} DWRITE_READING_DIRECTION;

/// <summary>
/// Direction for how lines of text are placed relative to one another.
/// </summary>
typedef enum DWRITE_FLOW_DIRECTION
{
    /// <summary>
    /// Text lines are placed from top to bottom.
    /// </summary>
    DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM
} DWRITE_FLOW_DIRECTION;

/// <summary>
/// Alignment of paragraph text along the reading direction axis relative to 
/// the leading and trailing edge of the layout box.
/// </summary>
typedef enum DWRITE_TEXT_ALIGNMENT
{
    /// <summary>
    /// The leading edge of the paragraph text is aligned to the layout box's leading edge.
    /// </summary>
    DWRITE_TEXT_ALIGNMENT_LEADING,

    /// <summary>
    /// The trailing edge of the paragraph text is aligned to the layout box's trailing edge.
    /// </summary>
    DWRITE_TEXT_ALIGNMENT_TRAILING,

    /// <summary>
    /// The center of the paragraph text is aligned to the center of the layout box.
    /// </summary>
    DWRITE_TEXT_ALIGNMENT_CENTER
} DWRITE_TEXT_ALIGNMENT;

/// <summary>
/// Alignment of paragraph text along the flow direction axis relative to the
/// flow's beginning and ending edge of the layout box.
/// </summary>
typedef enum DWRITE_PARAGRAPH_ALIGNMENT
{
    /// <summary>
    /// The first line of paragraph is aligned to the flow's beginning edge of the layout box.
    /// </summary>
    DWRITE_PARAGRAPH_ALIGNMENT_NEAR,

    /// <summary>
    /// The last line of paragraph is aligned to the flow's ending edge of the layout box.
    /// </summary>
    DWRITE_PARAGRAPH_ALIGNMENT_FAR,

    /// <summary>
    /// The center of the paragraph is aligned to the center of the flow of the layout box.
    /// </summary>
    DWRITE_PARAGRAPH_ALIGNMENT_CENTER
} DWRITE_PARAGRAPH_ALIGNMENT;

/// <summary>
/// Word wrapping in multiline paragraph.
/// </summary>
typedef enum DWRITE_WORD_WRAPPING
{
    /// <summary>
    /// Words are broken across lines to avoid text overflowing the layout box.
    /// </summary>
    DWRITE_WORD_WRAPPING_WRAP,

    /// <summary>
    /// Words are kept within the same line even when it overflows the layout box.
    /// This option is often used with scrolling to reveal overflow text. 
    /// </summary>
    DWRITE_WORD_WRAPPING_NO_WRAP
} DWRITE_WORD_WRAPPING;

/// <summary>
/// The method used for line spacing in layout.
/// </summary>
typedef enum DWRITE_LINE_SPACING_METHOD
{
    /// <summary>
    /// Line spacing depends solely on the content, growing to accomodate the size of fonts and inline objects.
    /// </summary>
    DWRITE_LINE_SPACING_METHOD_DEFAULT,

    /// <summary>
    /// Lines are explicitly set to uniform spacing, regardless of contained font sizes.
    /// This can be useful to avoid the uneven appearance that can occur from font fallback.
    /// </summary>
    DWRITE_LINE_SPACING_METHOD_UNIFORM
} DWRITE_LINE_SPACING_METHOD;

/// <summary>
/// Text granularity used to trim text overflowing the layout box.
/// </summary>
typedef enum DWRITE_TRIMMING_GRANULARITY
{
    /// <summary>
    /// No trimming occurs. Text flows beyond the layout width.
    /// </summary>
    DWRITE_TRIMMING_GRANULARITY_NONE,

    /// <summary>
    /// Trimming occurs at character cluster boundary.
    /// </summary>
    DWRITE_TRIMMING_GRANULARITY_CHARACTER,

    /// <summary>
    /// Trimming occurs at word boundary.
    /// </summary>
    DWRITE_TRIMMING_GRANULARITY_WORD
} DWRITE_TRIMMING_GRANULARITY;

/// <summary>
/// Typographic feature of text supplied by the font.
/// </summary>
typedef enum DWRITE_FONT_FEATURE_TAG
{
    DWRITE_FONT_FEATURE_TAG_ALTERNATIVE_FRACTIONS = 0x63726661, // 'afrc'
    DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS_FROM_CAPITALS = 0x63703263, // 'c2pc'
    DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS_FROM_CAPITALS = 0x63733263, // 'c2sc'
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_ALTERNATES = 0x746c6163, // 'calt'
    DWRITE_FONT_FEATURE_TAG_CASE_SENSITIVE_FORMS = 0x65736163, // 'case'
    DWRITE_FONT_FEATURE_TAG_GLYPH_COMPOSITION_DECOMPOSITION = 0x706d6363, // 'ccmp'
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_LIGATURES = 0x67696c63, // 'clig'
    DWRITE_FONT_FEATURE_TAG_CAPITAL_SPACING = 0x70737063, // 'cpsp'
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_SWASH = 0x68777363, // 'cswh'
    DWRITE_FONT_FEATURE_TAG_CURSIVE_POSITIONING = 0x73727563, // 'curs'
    DWRITE_FONT_FEATURE_TAG_DEFAULT = 0x746c6664, // 'dflt'
    DWRITE_FONT_FEATURE_TAG_DISCRETIONARY_LIGATURES = 0x67696c64, // 'dlig'
    DWRITE_FONT_FEATURE_TAG_EXPERT_FORMS = 0x74707865, // 'expt'
    DWRITE_FONT_FEATURE_TAG_FRACTIONS = 0x63617266, // 'frac'
    DWRITE_FONT_FEATURE_TAG_FULL_WIDTH = 0x64697766, // 'fwid'
    DWRITE_FONT_FEATURE_TAG_HALF_FORMS = 0x666c6168, // 'half'
    DWRITE_FONT_FEATURE_TAG_HALANT_FORMS = 0x6e6c6168, // 'haln'
    DWRITE_FONT_FEATURE_TAG_ALTERNATE_HALF_WIDTH = 0x746c6168, // 'halt'
    DWRITE_FONT_FEATURE_TAG_HISTORICAL_FORMS = 0x74736968, // 'hist'
    DWRITE_FONT_FEATURE_TAG_HORIZONTAL_KANA_ALTERNATES = 0x616e6b68, // 'hkna'
    DWRITE_FONT_FEATURE_TAG_HISTORICAL_LIGATURES = 0x67696c68, // 'hlig'
    DWRITE_FONT_FEATURE_TAG_HALF_WIDTH = 0x64697768, // 'hwid'
    DWRITE_FONT_FEATURE_TAG_HOJO_KANJI_FORMS = 0x6f6a6f68, // 'hojo'
    DWRITE_FONT_FEATURE_TAG_JIS04_FORMS = 0x3430706a, // 'jp04'
    DWRITE_FONT_FEATURE_TAG_JIS78_FORMS = 0x3837706a, // 'jp78'
    DWRITE_FONT_FEATURE_TAG_JIS83_FORMS = 0x3338706a, // 'jp83'
    DWRITE_FONT_FEATURE_TAG_JIS90_FORMS = 0x3039706a, // 'jp90'
    DWRITE_FONT_FEATURE_TAG_KERNING = 0x6e72656b, // 'kern'
    DWRITE_FONT_FEATURE_TAG_STANDARD_LIGATURES = 0x6167696c, // 'liga'
    DWRITE_FONT_FEATURE_TAG_LINING_FIGURES = 0x6d756e6c, // 'lnum'
    DWRITE_FONT_FEATURE_TAG_LOCALIZED_FORMS = 0x6c636f6c, // 'locl'
    DWRITE_FONT_FEATURE_TAG_MARK_POSITIONING = 0x6b72616d, // 'mark'
    DWRITE_FONT_FEATURE_TAG_MATHEMATICAL_GREEK = 0x6b72676d, // 'mgrk'
    DWRITE_FONT_FEATURE_TAG_MARK_TO_MARK_POSITIONING = 0x6b6d6b6d, // 'mkmk'
    DWRITE_FONT_FEATURE_TAG_ALTERNATE_ANNOTATION_FORMS = 0x746c616e, // 'nalt'
    DWRITE_FONT_FEATURE_TAG_NLC_KANJI_FORMS = 0x6b636c6e, // 'nlck'
    DWRITE_FONT_FEATURE_TAG_OLD_STYLE_FIGURES = 0x6d756e6f, // 'onum'
    DWRITE_FONT_FEATURE_TAG_ORDINALS = 0x6e64726f, // 'ordn'
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_ALTERNATE_WIDTH = 0x746c6170, // 'palt'
    DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS = 0x70616370, // 'pcap'
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_FIGURES = 0x6d756e70, // 'pnum'
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_WIDTHS = 0x64697770, // 'pwid'
    DWRITE_FONT_FEATURE_TAG_QUARTER_WIDTHS = 0x64697771, // 'qwid'
    DWRITE_FONT_FEATURE_TAG_REQUIRED_LIGATURES = 0x67696c72, // 'rlig'
    DWRITE_FONT_FEATURE_TAG_RUBY_NOTATION_FORMS = 0x79627572, // 'ruby'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_ALTERNATES = 0x746c6173, // 'salt'
    DWRITE_FONT_FEATURE_TAG_SCIENTIFIC_INFERIORS = 0x666e6973, // 'sinf'
    DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS = 0x70636d73, // 'smcp'
    DWRITE_FONT_FEATURE_TAG_SIMPLIFIED_FORMS = 0x6c706d73, // 'smpl'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1 = 0x31307373, // 'ss01'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_2 = 0x32307373, // 'ss02'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_3 = 0x33307373, // 'ss03'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_4 = 0x34307373, // 'ss04'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_5 = 0x35307373, // 'ss05'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_6 = 0x36307373, // 'ss06'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_7 = 0x37307373, // 'ss07'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_8 = 0x38307373, // 'ss08'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_9 = 0x39307373, // 'ss09'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_10 = 0x30317373, // 'ss10'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_11 = 0x31317373, // 'ss11'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_12 = 0x32317373, // 'ss12'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_13 = 0x33317373, // 'ss13'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_14 = 0x34317373, // 'ss14'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_15 = 0x35317373, // 'ss15'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_16 = 0x36317373, // 'ss16'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_17 = 0x37317373, // 'ss17'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_18 = 0x38317373, // 'ss18'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_19 = 0x39317373, // 'ss19'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_20 = 0x30327373, // 'ss20'
    DWRITE_FONT_FEATURE_TAG_SUBSCRIPT = 0x73627573, // 'subs'
    DWRITE_FONT_FEATURE_TAG_SUPERSCRIPT = 0x73707573, // 'sups'
    DWRITE_FONT_FEATURE_TAG_SWASH = 0x68737773, // 'swsh'
    DWRITE_FONT_FEATURE_TAG_TITLING = 0x6c746974, // 'titl'
    DWRITE_FONT_FEATURE_TAG_TRADITIONAL_NAME_FORMS = 0x6d616e74, // 'tnam'
    DWRITE_FONT_FEATURE_TAG_TABULAR_FIGURES = 0x6d756e74, // 'tnum'
    DWRITE_FONT_FEATURE_TAG_TRADITIONAL_FORMS = 0x64617274, // 'trad'
    DWRITE_FONT_FEATURE_TAG_THIRD_WIDTHS = 0x64697774, // 'twid'
    DWRITE_FONT_FEATURE_TAG_UNICASE = 0x63696e75, // 'unic'
    DWRITE_FONT_FEATURE_TAG_SLASHED_ZERO = 0x6f72657a, // 'zero'
} DWRITE_FONT_FEATURE_TAG;

typedef enum DWRITE_SCRIPT_SHAPES
{
    /// <summary>
    /// No additional shaping requirement. Text is shaped with the writing system default behavior.
    /// </summary>
    DWRITE_SCRIPT_SHAPES_DEFAULT = 0,

    /// <summary>
    /// Text should leave no visual on display i.e. control or format control characters.
    /// </summary>
    DWRITE_SCRIPT_SHAPES_NO_VISUAL = 1
} DWRITE_SCRIPT_SHAPES;

/// <summary>
/// Condition at the edges of inline object or text used to determine
/// line-breaking behavior.
/// </summary>
typedef enum DWRITE_BREAK_CONDITION
{
    /// <summary>
    /// Whether a break is allowed is determined by the condition of the
    /// neighboring text span or inline object.
    /// </summary>
    DWRITE_BREAK_CONDITION_NEUTRAL,

    /// <summary>
    /// A break is allowed, unless overruled by the condition of the
    /// neighboring text span or inline object, either prohibited by a
    /// May Not or forced by a Must.
    /// </summary>
    DWRITE_BREAK_CONDITION_CAN_BREAK,

    /// <summary>
    /// There should be no break, unless overruled by a Must condition from
    /// the neighboring text span or inline object.
    /// </summary>
    DWRITE_BREAK_CONDITION_MAY_NOT_BREAK,

    /// <summary>
    /// The break must happen, regardless of the condition of the adjacent
    /// text span or inline object.
    /// </summary>
    DWRITE_BREAK_CONDITION_MUST_BREAK
} DWRITE_BREAK_CONDITION;

/// <summary>
/// How to apply number substitution on digits and related punctuation.
/// </summary>
typedef enum DWRITE_NUMBER_SUBSTITUTION_METHOD
{
    /// <summary>
    /// Specifies that the substitution method should be determined based
    /// on LOCALE_IDIGITSUBSTITUTION value of the specified text culture.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_FROM_CULTURE,

    /// <summary>
    /// If the culture is Arabic or Farsi, specifies that the number shape
    /// depend on the context. Either traditional or nominal number shape
    /// are used depending on the nearest preceding strong character or (if
    /// there is none) the reading direction of the paragraph.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_CONTEXTUAL,

    /// <summary>
    /// Specifies that code points 0x30-0x39 are always rendered as nominal numeral 
    /// shapes (ones of the European number), i.e., no substitution is performed.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE,

    /// <summary>
    /// Specifies that number are rendered using the national number shape 
    /// as specified by the LOCALE_SNATIVEDIGITS value of the specified text culture.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_NATIONAL,

    /// <summary>
    /// Specifies that number are rendered using the traditional shape
    /// for the specified culture. For most cultures, this is the same as
    /// NativeNational. However, NativeNational results in Latin number
    /// for some Arabic cultures, whereas this value results in Arabic
    /// number for all Arabic cultures.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_TRADITIONAL
} DWRITE_NUMBER_SUBSTITUTION_METHOD;

/// <summary>
/// The DWRITE_TEXTURE_TYPE enumeration identifies a type of alpha texture. An alpha texture is a bitmap of alpha values, each
/// representing the darkness (i.e., opacity) of a pixel or subpixel.
/// </summary>
typedef enum DWRITE_TEXTURE_TYPE
{
    /// <summary>
    /// Specifies an alpha texture for aliased text rendering (i.e., bi-level, where each pixel is either fully opaque or fully transparent),
    /// with one byte per pixel.
    /// </summary>
    DWRITE_TEXTURE_ALIASED_1x1,

    /// <summary>
    /// Specifies an alpha texture for ClearType text rendering, with three bytes per pixel in the horizontal dimension and 
    /// one byte per pixel in the vertical dimension.
    /// </summary>
    DWRITE_TEXTURE_CLEARTYPE_3x1
} DWRITE_TEXTURE_TYPE;

typedef enum DWRITE_CLUSTER_METRICS_FLAGS {

    ///// <summary>
    ///// Indicate whether line can be broken right after the cluster.
    ///// </summary>
    canWrapLineAfter = 1,

    ///// <summary>
    ///// Indicate whether the cluster corresponds to whitespace character.
    ///// </summary>
    isWhitespace = 2,

    ///// <summary>
    ///// Indicate whether the cluster corresponds to a newline character.
    ///// </summary>
    isNewline = 4,

    ///// <summary>
    ///// Indicate whether the cluster corresponds to soft hyphen character.
    ///// </summary>
    isSoftHyphen = 8,

    ///// <summary>
    ///// Indicate whether the cluster is read from right to left.
    ///// </summary>
    isRightToLeft = 16
} DWRITE_CLUSTER_METRICS_FLAGS;

typedef enum DWRITE_SHAPING_GLYPH_PROPERTIES_FLAGS {
    isClusterStart = 16,
    isDiacritic = 32,
    isZeroWidthSpace = 64,
    justification_mask = 0x0f
} DWRITE_SHAPING_GLYPH_PROPERTIES_FLAGS;

typedef enum DWRITE_SHAPING_TEXT_PROPERTIES_FLAGS {
    isShapedAlone = 1
} DWRITE_SHAPING_TEXT_PROPERTIES_FLAGS;

typedef enum DWRITE_LINE_BREAKPOINT_FLAGS {
    breakConditionBefore_mask = 0x03,
    breakConditionBefore_shift = 1,
    breakConditionAfter_mask = 0x0c,
    breakConditionAfter_shift = 4,
    lbisWhitespace = 0x10,
    lbisSoftHyphen = 0x20
} DWRITE_LINE_BREAKPOINT_FLAGS;

/// <summary>
/// The DWRITE_FONT_METRICS structure specifies the metrics of a font face that
/// are applicable to all glyphs within the font face.
/// </summary>
typedef struct DWRITE_FONT_METRICS
{
    /// <summary>
    /// The number of font design units per em unit.
    /// Font files use their own coordinate system of font design units.
    /// A font design unit is the smallest measurable unit in the em square,
    /// an imaginary square that is used to size and align glyphs.
    /// The concept of em square is used as a reference scale factor when defining font size and device transformation semantics.
    /// The size of one em square is also commonly used to compute the paragraph identation value.
    /// </summary>
    UINT16 designUnitsPerEm;

    /// <summary>
    /// Ascent value of the font face in font design units.
    /// Ascent is the distance from the top of font character alignment box to English baseline.
    /// </summary>
    UINT16 ascent;

    /// <summary>
    /// Descent value of the font face in font design units.
    /// Descent is the distance from the bottom of font character alignment box to English baseline.
    /// </summary>
    UINT16 descent;

    /// <summary>
    /// Line gap in font design units.
    /// Recommended additional white space to add between lines to improve legibility. The recommended line spacing 
    /// (baseline-to-baseline distance) is thus the sum of ascent, descent, and lineGap. The line gap is usually 
    /// positive or zero but can be negative, in which case the recommended line spacing is less than the height
    /// of the character alignment box.
    /// </summary>
    INT16 lineGap;

    /// <summary>
    /// Cap height value of the font face in font design units.
    /// Cap height is the distance from English baseline to the top of a typical English capital.
    /// Capital "H" is often used as a reference character for the purpose of calculating the cap height value.
    /// </summary>
    UINT16 capHeight;

    /// <summary>
    /// x-height value of the font face in font design units.
    /// x-height is the distance from English baseline to the top of lowercase letter "x", or a similar lowercase character.
    /// </summary>
    UINT16 xHeight;

    /// <summary>
    /// The underline position value of the font face in font design units.
    /// Underline position is the position of underline relative to the English baseline.
    /// The value is usually made negative in order to place the underline below the baseline.
    /// </summary>
    INT16 underlinePosition;

    /// <summary>
    /// The suggested underline thickness value of the font face in font design units.
    /// </summary>
    UINT16 underlineThickness;

    /// <summary>
    /// The strikethrough position value of the font face in font design units.
    /// Strikethrough position is the position of strikethrough relative to the English baseline.
    /// The value is usually made positive in order to place the strikethrough above the baseline.
    /// </summary>
    INT16 strikethroughPosition;

    /// <summary>
    /// The suggested strikethrough thickness value of the font face in font design units.
    /// </summary>
    UINT16 strikethroughThickness;
} DWRITE_FONT_METRICS;

/// <summary>
/// The DWRITE_GLYPH_METRICS structure specifies the metrics of an individual glyph.
/// The units depend on how the metrics are obtained.
/// </summary>
typedef struct DWRITE_GLYPH_METRICS
{
    /// <summary>
    /// Specifies the X offset from the glyph origin to the left edge of the black box.
    /// The glyph origin is the current horizontal writing position.
    /// A negative value means the black box extends to the left of the origin (often true for lowercase italic 'f').
    /// </summary>
    INT32 leftSideBearing;

    /// <summary>
    /// Specifies the X offset from the origin of the current glyph to the origin of the next glyph when writing horizontally.
    /// </summary>
    UINT32 advanceWidth;

    /// <summary>
    /// Specifies the X offset from the right edge of the black box to the origin of the next glyph when writing horizontally.
    /// The value is negative when the right edge of the black box overhangs the layout box.
    /// </summary>
    INT32 rightSideBearing;

    /// <summary>
    /// Specifies the vertical offset from the vertical origin to the top of the black box.
    /// Thus, a positive value adds whitespace whereas a negative value means the glyph overhangs the top of the layout box.
    /// </summary>
    INT32 topSideBearing;

    /// <summary>
    /// Specifies the Y offset from the vertical origin of the current glyph to the vertical origin of the next glyph when writing vertically.
    /// (Note that the term "origin" by itself denotes the horizontal origin. The vertical origin is different.
    /// Its Y coordinate is specified by verticalOriginY value,
    /// and its X coordinate is half the advanceWidth to the right of the horizontal origin).
    /// </summary>
    UINT32 advanceHeight;

    /// <summary>
    /// Specifies the vertical distance from the black box's bottom edge to the advance height.
    /// Positive when the bottom edge of the black box is within the layout box.
    /// Negative when the bottom edge of black box overhangs the layout box.
    /// </summary>
    INT32 bottomSideBearing;

    /// <summary>
    /// Specifies the Y coordinate of a glyph's vertical origin, in the font's design coordinate system.
    /// The y coordinate of a glyph's vertical origin is the sum of the glyph's top side bearing
    /// and the top (i.e. yMax) of the glyph's bounding box.
    /// </summary>
    INT32 verticalOriginY;
} DWRITE_GLYPH_METRICS;

/// <summary>
/// Optional adjustment to a glyph's position. An glyph offset changes the position of a glyph without affecting
/// the pen position. Offsets are in logical, pre-transform units.
/// </summary>
typedef struct DWRITE_GLYPH_OFFSET
{
    /// <summary>
    /// Offset in the advance direction of the run. A positive advance offset moves the glyph to the right
    /// (in pre-transform coordinates) if the run is left-to-right or to the left if the run is right-to-left.
    /// </summary>
    FLOAT advanceOffset;

    /// <summary>
    /// Offset in the ascent direction, i.e., the direction ascenders point. A positive ascender offset moves
    /// the glyph up (in pre-transform coordinates).
    /// </summary>
    FLOAT ascenderOffset;
} DWRITE_GLYPH_OFFSET;

/// <summary>
/// The DWRITE_MATRIX structure specifies the graphics transform to be applied
/// to rendered glyphs.
/// </summary>
typedef struct DWRITE_MATRIX
{
    /// <summary>
    /// Horizontal scaling / cosine of rotation
    /// </summary>
    FLOAT m11;

    /// <summary>
    /// Vertical shear / sine of rotation
    /// </summary>
    FLOAT m12;

    /// <summary>
    /// Horizontal shear / negative sine of rotation
    /// </summary>
    FLOAT m21;

    /// <summary>
    /// Vertical scaling / cosine of rotation
    /// </summary>
    FLOAT m22;

    /// <summary>
    /// Horizontal shift (always orthogonal regardless of rotation)
    /// </summary>
    FLOAT dx;

    /// <summary>
    /// Vertical shift (always orthogonal regardless of rotation)
    /// </summary>
    FLOAT dy;
} DWRITE_MATRIX;

/// <summary>
/// The DWRITE_TEXT_RANGE structure specifies a range of text positions where format is applied.
/// </summary>
typedef struct DWRITE_TEXT_RANGE
{
    /// <summary>
    /// The start text position of the range.
    /// </summary>
    UINT32 startPosition;

    /// <summary>
    /// The number of text positions in the range.
    /// </summary>
    UINT32 length;
} DWRITE_TEXT_RANGE;

/// <summary>
/// The DWRITE_FONT_FEATURE structure specifies properties used to identify and execute typographic feature in the font.
/// </summary>
typedef struct DWRITE_FONT_FEATURE
{
    /// <summary>
    /// The feature OpenType name identifier.
    /// </summary>
    DWRITE_FONT_FEATURE_TAG nameTag;

    /// <summary>
    /// Execution parameter of the feature.
    /// </summary>
    /// <remarks>
    /// The parameter should be non-zero to enable the feature.  Once enabled, a feature can't be disabled again within
    /// the same range.  Features requiring a selector use this value to indicate the selector index. 
    /// </remarks>
    UINT32 parameter;
} DWRITE_FONT_FEATURE;

/// <summary>
/// Defines a set of typographic features to be applied during shaping.
/// Notice the character range which this feature list spans is specified
/// as a separate parameter to GetGlyphs.
/// </summary>
typedef struct DWRITE_TYPOGRAPHIC_FEATURES
{
    /// <summary>
    /// Array of font features.
    /// </summary>
    int* features;

    /// <summary>
    /// The number of features.
    /// </summary>
    UINT32 featureCount;
} DWRITE_TYPOGRAPHIC_FEATURES;

/// <summary>
/// The DWRITE_TRIMMING structure specifies the trimming option for text overflowing the layout box.
/// </summary>
typedef struct DWRITE_TRIMMING
{
    /// <summary>
    /// Text granularity of which trimming applies.
    /// </summary>
    DWRITE_TRIMMING_GRANULARITY granularity;

    /// <summary>
    /// Character code used as the delimiter signaling the beginning of the portion of text to be preserved,
    /// most useful for path ellipsis, where the delimeter would be a slash.
    /// </summary>
    UINT32 delimiter;

    /// <summary>
    /// How many occurences of the delimiter to step back.
    /// </summary>
    UINT32 delimiterCount;
} DWRITE_TRIMMING;

/// <summary>
/// Association of text and its writing system script as well as some display attributes.
/// </summary>
typedef struct DWRITE_SCRIPT_ANALYSIS
{
    /// <summary>
    /// Zero-based index representation of writing system script.
    /// </summary>
    UINT16 script;

    /// <summary>
    /// Additional shaping requirement of text.
    /// </summary>
    DWRITE_SCRIPT_SHAPES shapes;
} DWRITE_SCRIPT_ANALYSIS;

/// <summary>
/// Line breakpoint characteristics of a character.
/// </summary>
typedef struct DWRITE_LINE_BREAKPOINT
{
    /// <summary>
    /// Breaking condition before the character.
    /// </summary>
    //UINT8 breakConditionBefore  : 2;

    ///// <summary>
    ///// Breaking condition after the character.
    ///// </summary>
    //UINT8 breakConditionAfter   : 2;

    ///// <summary>
    ///// The character is some form of whitespace, which may be meaningful
    ///// for justification.
    ///// </summary>
    //UINT8 isWhitespace          : 1;

    ///// <summary>
    ///// The character is a soft hyphen, often used to indicate hyphenation
    ///// points inside words.
    ///// </summary>
    //UINT8 isSoftHyphen          : 1;

    //UINT8 padding               : 2;
    UINT8 flags;
} DWRITE_LINE_BREAKPOINT;

/// <summary>
/// Shaping output properties per input character.
/// </summary>
typedef struct DWRITE_SHAPING_TEXT_PROPERTIES
{
    /// <summary>
    /// This character can be shaped independently from the others
    /// (usually set for the space character).
    /// </summary>
    UINT16  isShapedAlone; //: 1;

    /// <summary>
    /// Reserved for use by shaping engine.
    /// </summary>
    //UINT16  reserved : 15;
} DWRITE_SHAPING_TEXT_PROPERTIES;

/// <summary>
/// Shaping output properties per output glyph.
/// </summary>
typedef struct DWRITE_SHAPING_GLYPH_PROPERTIES
{
    ///// <summary>
    ///// Justification class, whether to use spacing, kashidas, or
    ///// another method. This exists for backwards compatibility
    ///// with Uniscribe's SCRIPT_JUSTIFY enum.
    ///// </summary>
    //UINT16  justification       : 4;

    ///// <summary>
    ///// Indicates glyph is the first of a cluster.
    ///// </summary>
    //UINT16  isClusterStart      : 1;

    ///// <summary>
    ///// Glyph is a diacritic.
    ///// </summary>
    //UINT16  isDiacritic         : 1;

    ///// <summary>
    ///// Glyph has no width, blank, ZWJ, ZWNJ etc.
    ///// </summary>
    //UINT16  isZeroWidthSpace    : 1;

    ///// <summary>
    ///// Reserved for use by shaping engine.
    ///// </summary>
    //UINT16  reserved            : 9;
    UINT16 flags;

} DWRITE_SHAPING_GLYPH_PROPERTIES;

/// <summary>
/// The DWRITE_GLYPH_RUN structure contains the information needed by renderers
/// to draw glyph runs. All coordinates are in device independent pixels (DIPs).
/// </summary>
typedef struct DWRITE_GLYPH_RUN
{
    /// <summary>
    /// The physical font face to draw with.
    /// </summary>
    IDWriteFontFace* fontFace;

    /// <summary>
    /// Logical size of the font in DIPs, not points (equals 1/96 inch).
    /// </summary>
    FLOAT fontEmSize;

    /// <summary>
    /// The number of glyphs.
    /// </summary>
    UINT32 glyphCount;

    /// <summary>
    /// The indices to render.
    /// </summary>    
    int pglyphIndices;

    /// <summary>
    /// Glyph advance widths.
    /// </summary>
    int pglyphAdvances;

    /// <summary>
    /// Glyph offsets.
    /// </summary>
    int pglyphOffsets;

    /// <summary>
    /// If true, specifies that glyphs are rotated 90 degrees to the left and
    /// vertical metrics are used. Vertical writing is achieved by specifying
    /// isSideways = true and rotating the entire run 90 degrees to the right
    /// via a rotate transform.
    /// </summary>
    BOOL isSideways;

    /// <summary>
    /// The implicit resolved bidi level of the run. Odd levels indicate
    /// right-to-left languages like Hebrew and Arabic, while even levels
    /// indicate left-to-right languages like English and Japanese (when
    /// written horizontally). For right-to-left languages, the text origin
    /// is on the right, and text should be drawn to the left.
    /// </summary>
    UINT32 bidiLevel;
} DWRITE_GLYPH_RUN;

/// <summary>
/// The DWRITE_GLYPH_RUN_DESCRIPTION structure contains additional properties
/// related to those in DWRITE_GLYPH_RUN.
/// </summary>
typedef struct DWRITE_GLYPH_RUN_DESCRIPTION
{
    /// <summary>
    /// The locale name associated with this run.
    /// </summary>
    int plocaleName;

    /// <summary>
    /// The text associated with the glyphs.
    /// </summary>
    int pstring;

    /// <summary>
    /// The number of characters (UTF16 code-units).
    /// Note that this may be different than the number of glyphs.
    /// </summary>
    UINT32 stringLength;

    /// <summary>
    /// An array of indices to the glyph indices array, of the first glyphs of
    /// all the glyph clusters of the glyphs to render. 
    /// </summary>
    int pclusterMap;

    /// <summary>
    /// Corresponding text position in the original string
    /// this glyph run came from.
    /// </summary>
    UINT32 textPosition;
} DWRITE_GLYPH_RUN_DESCRIPTION;

/// <summary>
/// The DWRITE_UNDERLINE structure contains about the size and placement of 
/// underlines. All coordinates are in device independent pixels (DIPs).
/// </summary>
typedef struct DWRITE_UNDERLINE
{
    /// <summary>
    /// Width of the underline, measured parallel to the baseline.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// Thickness of the underline, measured perpendicular to the
    /// baseline.
    /// </summary>
    FLOAT thickness;

    /// <summary>
    /// Offset of the underline from the baseline.
    /// A positive offset represents a position below the baseline and
    /// a negative offset is above.
    /// </summary>
    FLOAT offset;

    /// <summary>
    /// Height of the tallest run where the underline applies.
    /// </summary>
    FLOAT runHeight;

    /// <summary>
    /// Reading direction of the text associated with the underline.  This 
    /// value is used to interpret whether the width value runs horizontally 
    /// or vertically.
    /// </summary>
    DWRITE_READING_DIRECTION readingDirection;

    /// <summary>
    /// Flow direction of the text associated with the underline.  This value
    /// is used to interpret whether the thickness value advances top to 
    /// bottom, left to right, or right to left.
    /// </summary>
    DWRITE_FLOW_DIRECTION flowDirection;

    /// <summary>
    /// Locale of the text the underline is being drawn under. Can be
    /// pertinent where the locale affects how the underline is drawn.
    /// For example, in vertical text, the underline belongs on the
    /// left for Chinese but on the right for Japanese.
    /// This choice is completely left up to higher levels.
    /// </summary>
    int plocaleName;

    /// <summary>
    /// The measuring mode can be useful to the renderer to determine how
    /// underlines are rendered, e.g. rounding the thickness to a whole pixel
    /// in GDI-compatible modes.
    /// </summary>
    DWRITE_MEASURING_MODE measuringMode;
} DWRITE_UNDERLINE;

/// <summary>
/// The DWRITE_STRIKETHROUGH structure contains about the size and placement of 
/// strickthroughs. All coordinates are in device independent pixels (DIPs).
/// </summary>
typedef struct DWRITE_STRIKETHROUGH
{
    /// <summary>
    /// Width of the strikethrough, measured parallel to the baseline.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// Thickness of the strikethrough, measured perpendicular to the
    /// baseline.
    /// </summary>
    FLOAT thickness;

    /// <summary>
    /// Offset of the stikethrough from the baseline.
    /// A positive offset represents a position below the baseline and
    /// a negative offset is above.
    /// </summary>
    FLOAT offset;

    /// <summary>
    /// Reading direction of the text associated with the strikethrough.  This
    /// value is used to interpret whether the width value runs horizontally 
    /// or vertically.
    /// </summary>
    DWRITE_READING_DIRECTION readingDirection;

    /// <summary>
    /// Flow direction of the text associated with the strikethrough.  This 
    /// value is used to interpret whether the thickness value advances top to
    /// bottom, left to right, or right to left.
    /// </summary>
    DWRITE_FLOW_DIRECTION flowDirection;

    /// <summary>
    /// Locale of the range. Can be pertinent where the locale affects the style.
    /// </summary>
    int plocaleName;

    /// <summary>
    /// The measuring mode can be useful to the renderer to determine how
    /// underlines are rendered, e.g. rounding the thickness to a whole pixel
    /// in GDI-compatible modes.
    /// </summary>
    DWRITE_MEASURING_MODE measuringMode;
} DWRITE_STRIKETHROUGH;

/// <summary>
/// The DWRITE_LINE_METRICS structure contains information about a formatted
/// line of text.
/// </summary>
typedef struct DWRITE_LINE_METRICS
{
    /// <summary>
    /// The number of total text positions in the line.
    /// This includes any trailing whitespace and newline characters.
    /// </summary>
    UINT32 length;

    /// <summary>
    /// The number of whitespace positions at the end of the line.  Newline
    /// sequences are considered whitespace.
    /// </summary>
    UINT32 trailingWhitespaceLength;

    /// <summary>
    /// The number of characters in the newline sequence at the end of the line.
    /// If the count is zero, then the line was either wrapped or it is the
    /// end of the text.
    /// </summary>
    UINT32 newlineLength;

    /// <summary>
    /// Height of the line as measured from top to bottom.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Distance from the top of the line to its baseline.
    /// </summary>
    FLOAT baseline;

    /// <summary>
    /// The line is trimmed.
    /// </summary>
    BOOL isTrimmed;
} DWRITE_LINE_METRICS;


/// <summary>
/// The DWRITE_CLUSTER_METRICS structure contains information about a glyph cluster.
/// </summary>
typedef struct DWRITE_CLUSTER_METRICS
{
    /// <summary>
    /// The total advance width of all glyphs in the cluster.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// The number of text positions in the cluster.
    /// </summary>
    UINT16 length;

    ///// <summary>
    ///// Indicate whether line can be broken right after the cluster.
    ///// </summary>
    //UINT16 canWrapLineAfter : 1;

    ///// <summary>
    ///// Indicate whether the cluster corresponds to whitespace character.
    ///// </summary>
    //UINT16 isWhitespace : 1;

    ///// <summary>
    ///// Indicate whether the cluster corresponds to a newline character.
    ///// </summary>
    //UINT16 isNewline : 1;

    ///// <summary>
    ///// Indicate whether the cluster corresponds to soft hyphen character.
    ///// </summary>
    //UINT16 isSoftHyphen : 1;

    ///// <summary>
    ///// Indicate whether the cluster is read from right to left.
    ///// </summary>
    //UINT16 isRightToLeft : 1;

    //UINT16 padding : 11;

    UINT16 flags;

} DWRITE_CLUSTER_METRICS;


/// <summary>
/// Overall metrics associated with text after layout.
/// All coordinates are in device independent pixels (DIPs).
/// </summary>
typedef struct DWRITE_TEXT_METRICS
{
    /// <summary>
    /// Left-most point of formatted text relative to layout box
    /// (excluding any glyph overhang).
    /// </summary>
    FLOAT left;

    /// <summary>
    /// Top-most point of formatted text relative to layout box
    /// (excluding any glyph overhang).
    /// </summary>
    FLOAT top;

    /// <summary>
    /// The width of the formatted text ignoring trailing whitespace
    /// at the end of each line.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// The width of the formatted text taking into account the
    /// trailing whitespace at the end of each line.
    /// </summary>
    FLOAT widthIncludingTrailingWhitespace;

    /// <summary>
    /// The height of the formatted text. The height of an empty string
    /// is determined by the size of the default font's line height.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Initial width given to the layout. Depending on whether the text
    /// was wrapped or not, it can be either larger or smaller than the
    /// text content width.
    /// </summary>
    FLOAT layoutWidth;

    /// <summary>
    /// Initial height given to the layout. Depending on the length of the
    /// text, it may be larger or smaller than the text content height.
    /// </summary>
    FLOAT layoutHeight;

    /// <summary>
    /// The maximum reordering count of any line of text, used
    /// to calculate the most number of hit-testing boxes needed.
    /// If the layout has no bidirectional text or no text at all,
    /// the minimum level is 1.
    /// </summary>
    UINT32 maxBidiReorderingDepth;

    /// <summary>
    /// Total number of lines.
    /// </summary>
    UINT32 lineCount;
} DWRITE_TEXT_METRICS;


/// <summary>
/// Properties describing the geometric measurement of an
/// application-defined inline object.
/// </summary>
typedef struct DWRITE_INLINE_OBJECT_METRICS
{
    /// <summary>
    /// Width of the inline object.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// Height of the inline object as measured from top to bottom.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Distance from the top of the object to the baseline where it is lined up with the adjacent text.
    /// If the baseline is at the bottom, baseline simply equals height.
    /// </summary>
    FLOAT baseline;

    /// <summary>
    /// Flag indicating whether the object is to be placed upright or alongside the text baseline
    /// for vertical text.
    /// </summary>
    BOOL  supportsSideways;
} DWRITE_INLINE_OBJECT_METRICS;


/// <summary>
/// The DWRITE_OVERHANG_METRICS structure holds how much any visible pixels
/// (in DIPs) overshoot each side of the layout or inline objects.
/// </summary>
/// <remarks>
/// Positive overhangs indicate that the visible area extends outside the layout
/// box or inline object, while negative values mean there is whitespace inside.
/// The returned values are unaffected by rendering transforms or pixel snapping.
/// Additionally, they may not exactly match final target's pixel bounds after
/// applying grid fitting and hinting.
/// </remarks>
typedef struct DWRITE_OVERHANG_METRICS
{
    /// <summary>
    /// The distance from the left-most visible DIP to its left alignment edge.
    /// </summary>
    FLOAT left;

    /// <summary>
    /// The distance from the top-most visible DIP to its top alignment edge.
    /// </summary>
    FLOAT top;

    /// <summary>
    /// The distance from the right-most visible DIP to its right alignment edge.
    /// </summary>
    FLOAT right;

    /// <summary>
    /// The distance from the bottom-most visible DIP to its bottom alignment edge.
    /// </summary>
    FLOAT bottom;
} DWRITE_OVERHANG_METRICS;


/// <summary>
/// Geometry enclosing of text positions.
/// </summary>
typedef struct DWRITE_HIT_TEST_METRICS
{
    /// <summary>
    /// First text position within the geometry.
    /// </summary>
    UINT32 textPosition;

    /// <summary>
    /// Number of text positions within the geometry.
    /// </summary>
    UINT32 length;

    /// <summary>
    /// Left position of the top-left coordinate of the geometry.
    /// </summary>
    FLOAT left;

    /// <summary>
    /// Top position of the top-left coordinate of the geometry.
    /// </summary>
    FLOAT top;

    /// <summary>
    /// Geometry's width.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// Geometry's height.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Bidi level of text positions enclosed within the geometry.
    /// </summary>
    UINT32 bidiLevel;

    /// <summary>
    /// Geometry encloses text?
    /// </summary>
    BOOL isText;

    /// <summary>
    /// Range is trimmed.
    /// </summary>
    BOOL isTrimmed;
} DWRITE_HIT_TEST_METRICS;


/// <summary>
/// Font file loader interface handles loading font file resources of a particular type from a key.
/// The font file loader interface is recommended to be implemented by a singleton object.
/// IMPORTANT: font file loader implementations must not register themselves with DirectWrite factory
/// inside their constructors and must not unregister themselves in their destructors, because
/// registration and unregistraton operations increment and decrement the object reference count respectively.
/// Instead, registration and unregistration of font file loaders with DirectWrite factory should be performed
/// outside of the font file loader implementation as a separate step.
/// </summary>
[
    odl,
    uuid(727cad4e-d6af-4c9e-8a08-d695b11caa49),
    helpstring("Font file loader interface handles loading font file resources of a particular type from a key.")
]
interface IDWriteFontFileLoader : stdole.IUnknown
{
    /// <summary>
    /// Creates a font file stream object that encapsulates an open file resource.
    /// The resource is closed when the last reference to fontFileStream is released.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the font file resource
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="fontFileStream">Pointer to the newly created font file stream.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a font file stream object that encapsulates an open file resource.")]
    STDMETHOD(CreateStreamFromKey)(
        [in] void* fontFileReferenceKey,
        [in] UINT32 fontFileReferenceKeySize,
        __out IDWriteFontFileStream** fontFileStream
        );

};

/// <summary>
/// A built-in implementation of IDWriteFontFileLoader interface that operates on local font files
/// and exposes local font file information from the font file reference key.
/// Font file references created using CreateFontFileReference use this font file loader.
/// </summary>
[
    odl,
    uuid(b2d9f3ec-c9fe-4a11-a2ec-d86208f7c0a2),
    helpstring("A built-in implementation of IDWriteFontFileLoader interface that operates on local font files and exposes local font file information from the font file reference key.")
]
interface IDWriteLocalFontFileLoader : IDWriteFontFileLoader
{
    /// <summary>
    /// Obtains the length of the absolute file path from the font file reference key.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the local font file
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="filePathLength">Length of the file path string not including the terminated NULL character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Obtains the length of the absolute file path from the font file reference key.")]
    STDMETHOD(GetFilePathLengthFromKey)(
        [in] void* fontFileReferenceKey,
        [in] UINT32 fontFileReferenceKeySize,
        __out UINT32* filePathLength
        );

    /// <summary>
    /// Obtains the absolute font file path from the font file reference key.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the local font file
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="filePath">Character array that receives the local file path.</param>
    /// <param name="filePathSize">Size of the filePath array in character count including the terminated NULL character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Obtains the absolute font file path from the font file reference key.")]
    STDMETHOD(GetFilePathFromKey)(
        [in] void* fontFileReferenceKey,
        [in] UINT32 fontFileReferenceKeySize,
        [out] WCHAR* filePath,
        [in] UINT32 filePathSize
        );

    /// <summary>
    /// Obtains the last write time of the file from the font file reference key.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the local font file
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="lastWriteTime">Last modified time of the font file.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Obtains the last write time of the file from the font file reference key.")]
    STDMETHOD(GetLastWriteTimeFromKey)(
        [in] void* fontFileReferenceKey,
        [in] UINT32 fontFileReferenceKeySize,
        __out FILETIME* lastWriteTime
        );
};

/// <summary>
/// The interface for loading font file data.
/// </summary>
[
    odl,
    uuid(6d4865fe-0ab8-4d91-8f62-5dd6be34a3e0),
    helpstring("The interface for loading font file data.")
]
interface IDWriteFontFileStream : stdole.IUnknown
{
    /// <summary>
    /// Reads a fragment from a file.
    /// </summary>
    /// <param name="fragmentStart">Receives the pointer to the start of the font file fragment.</param>
    /// <param name="fileOffset">Offset of the fragment from the beginning of the font file.</param>
    /// <param name="fragmentSize">Size of the fragment in bytes.</param>
    /// <param name="fragmentContext">The client defined context to be passed to the ReleaseFileFragment.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// IMPORTANT: ReadFileFragment() implementations must check whether the requested file fragment
    /// is within the file bounds. Otherwise, an error should be returned from ReadFileFragment.
    /// </remarks>
    [helpstring("Reads a fragment from a file.")]
    STDMETHOD(ReadFileFragment)(
        [in, out] void* fragmentStart,
        [in] UINT64 fileOffset,
        [in] UINT64 fragmentSize,
        [in, out] void* fragmentContext
        ) PURE;

    /// <summary>
    /// Releases a fragment from a file.
    /// </summary>
    /// <param name="fragmentContext">The client defined context of a font fragment returned from ReadFileFragment.</param>
    [helpstring("Releases a fragment from a file.")]
    STDMETHOD_(void, ReleaseFileFragment)(
        [in, out] void* fragmentContext
        ) PURE;

    /// <summary>
    /// Obtains the total size of a file.
    /// </summary>
    /// <param name="fileSize">Receives the total size of the file.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Implementing GetFileSize() for asynchronously loaded font files may require
    /// downloading the complete file contents, therefore this method should only be used for operations that
    /// either require complete font file to be loaded (e.g., copying a font file) or need to make
    /// decisions based on the value of the file size (e.g., validation against a persisted file size).
    /// </remarks>
    [helpstring("Obtains the total size of a file.")]
    STDMETHOD(GetFileSize)(
        [out, retval] UINT64* fileSize
        ) PURE;

    /// <summary>
    /// Obtains the last modified time of the file. The last modified time is used by DirectWrite font selection algorithms
    /// to determine whether one font resource is more up to date than another one.
    /// </summary>
    /// <param name="lastWriteTime">Receives the last modifed time of the file in the format that represents
    /// the number of 100-nanosecond intervals since January 1, 1601 (UTC).</param>
    /// <returns>
    /// Standard HRESULT error code. For resources that don't have a concept of the last modified time, the implementation of
    /// GetLastWriteTime should return E_NOTIMPL.
    /// </returns>
    [helpstring("Obtains the last modified time of the file. The last modified time is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.")]
    STDMETHOD(GetLastWriteTime)(
        [out, retval] UINT64* lastWriteTime
        ) PURE;
};


/// <summary>
/// The interface that represents a reference to a font file.
/// </summary>
[
    odl,
    uuid(739d886a-cef5-47dc-8769-1a8b41bebbb0),
    helpstring("The interface that represents a reference to a font file.")
]
interface IDWriteFontFile : stdole.IUnknown
{
    /// <summary>
    /// This method obtains the pointer to the reference key of a font file. The pointer is only valid until the object that refers to it is released.
    /// </summary>
    /// <param name="fontFileReferenceKey">Pointer to the font file reference key.
    /// IMPORTANT: The pointer value is valid until the font file reference object it is obtained from is released.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("This method obtains the pointer to the reference key of a font file. The pointer is only valid until the object that refers to it is released.")]
    STDMETHOD(GetReferenceKey)(
        __deref_out_bcount(*fontFileReferenceKeySize) void const** fontFileReferenceKey,
        [out, retval] UINT32* fontFileReferenceKeySize
        ) PURE;

    /// <summary>
    /// Obtains the file loader associated with a font file object.
    /// </summary>
    /// <param name="fontFileLoader">The font file loader associated with the font file object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Obtains the file loader associated with a font file object.")]
    STDMETHOD(GetLoader)(
        [out, retval] IDWriteFontFileLoader** fontFileLoader
        ) PURE;

    /// <summary>
    /// Analyzes a file and returns whether it represents a font, and whether the font type is supported by the font system.
    /// </summary>
    /// <param name="isSupportedFontType">TRUE if the font type is supported by the font system, FALSE otherwise.</param>
    /// <param name="fontFileType">The type of the font file. Note that even if isSupportedFontType is FALSE,
    /// the fontFileType value may be different from DWRITE_FONT_FILE_TYPE_UNKNOWN.</param>
    /// <param name="fontFaceType">The type of the font face that can be constructed from the font file.
    /// Note that even if isSupportedFontType is FALSE, the fontFaceType value may be different from
    /// DWRITE_FONT_FACE_TYPE_UNKNOWN.</param>
    /// <param name="numberOfFaces">Number of font faces contained in the font file.</param>
    /// <returns>
    /// Standard HRESULT error code if there was a processing error during analysis.
    /// </returns>
    /// <remarks>
    /// IMPORTANT: certain font file types are recognized, but not supported by the font system.
    /// For example, the font system will recognize a file as a Type 1 font file,
    /// but will not be able to construct a font face object from it. In such situations, Analyze will set
    /// isSupportedFontType output parameter to FALSE.
    /// </remarks>
    [helpstring("Analyzes a file and returns whether it represents a font, and whether the font type is supported by the font system.")]
    STDMETHOD(Analyze)(
        __out BOOL* isSupportedFontType,
        __out DWRITE_FONT_FILE_TYPE* fontFileType,
        [in, out] DWRITE_FONT_FACE_TYPE* fontFaceType,
        __out UINT32* numberOfFaces
        ) PURE;
};


/// <summary>
/// The interface that represents text rendering settings for glyph rasterization and filtering.
/// </summary>
[
    odl,
    uuid(2f0da53a-2add-47cd-82ee-d9ec34688e75),
    helpstring("The interface that represents text rendering settings for glyph rasterization and filtering.")
]
interface IDWriteRenderingParams : stdole.IUnknown
{
    /// <summary>
    /// Gets the gamma value used for gamma correction. Valid values must be
    /// greater than zero and cannot exceed 256.
    /// </summary>
    [helpstring("Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.")]
    STDMETHOD_(FLOAT, GetGamma)() PURE;

    /// <summary>
    /// Gets the amount of contrast enhancement. Valid values are greater than
    /// or equal to zero.
    /// </summary>
    [helpstring("Gets the amount of contrast enhancement. Valid values are greater than or equal to zero.")]
    STDMETHOD_(FLOAT, GetEnhancedContrast)() PURE;

    /// <summary>
    /// Gets the ClearType level. Valid values range from 0.0f (no ClearType) 
    /// to 1.0f (full ClearType).
    /// </summary>
    [helpstring("Gets the ClearType level. Valid values range from 0.0f (no ClearType) to 1.0f (full ClearType).")]
    STDMETHOD_(FLOAT, GetClearTypeLevel)() PURE;

    /// <summary>
    /// Gets the pixel geometry.
    /// </summary>
    [helpstring("Gets the pixel geometry.")]
    STDMETHOD_(DWRITE_PIXEL_GEOMETRY, GetPixelGeometry)() PURE;

    /// <summary>
    /// Gets the rendering mode.
    /// </summary>
    [helpstring("Gets the rendering mode.")]
    STDMETHOD_(DWRITE_RENDERING_MODE, GetRenderingMode)() PURE;
};

/// <summary>
/// The interface that represents an absolute reference to a font face.
/// It contains font face type, appropriate file references and face identification data.
/// Various font data such as metrics, names and glyph outlines is obtained from IDWriteFontFace.
/// </summary>
[
    odl,
    uuid(5f49804d-7024-4d43-bfa9-d25984f53849),
    helpstring("The interface that represents an absolute reference to a font face.")
]
interface IDWriteFontFace : stdole.IUnknown
{
    /// <summary>
    /// Obtains the file format type of a font face.
    /// </summary>
    [helpstring("Obtains the file format type of a font face.")]
    STDMETHOD_(DWRITE_FONT_FACE_TYPE, GetType)() PURE;

    /// <summary>
    /// Obtains the font files representing a font face.
    /// </summary>
    /// <param name="numberOfFiles">The number of files representing the font face.</param>
    /// <param name="fontFiles">User provided array that stores pointers to font files representing the font face.
    /// This parameter can be NULL if the user is only interested in the number of files representing the font face.
    /// This API increments reference count of the font file pointers returned according to COM conventions, and the client
    /// should release them when finished.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Obtains the font files representing a font face.")]
    STDMETHOD(GetFiles)(
        __inout UINT32* numberOfFiles,
        void* fontFiles
        ) PURE;

    /// <summary>
    /// Obtains the zero-based index of the font face in its font file or files. If the font files contain a single face,
    /// the return value is zero.
    /// </summary>
    [helpstring("Obtains the zero-based index of the font face in its font file or files. If the font files contain a single face, the return value is zero.")]
    STDMETHOD_(UINT32, GetIndex)() PURE;

    /// <summary>
    /// Obtains the algorithmic style simulation flags of a font face.
    /// </summary>
    [helpstring("Obtains the algorithmic style simulation flags of a font face.")]
    STDMETHOD_(DWRITE_FONT_SIMULATIONS, GetSimulations)() PURE;

    /// <summary>
    /// Determines whether the font is a symbol font.
    /// </summary>
    [helpstring("Determines whether the font is a symbol font.")]
    STDMETHOD_(BOOL, IsSymbolFont)() PURE;

    /// <summary>
    /// Obtains design units and common metrics for the font face.
    /// These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.
    /// </summary>
    /// <param name="fontFaceMetrics">Points to a DWRITE_FONT_METRICS structure to fill in.
    /// The metrics returned by this function are in font design units.</param>
    [helpstring("Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.")]
    STDMETHOD_(void, GetMetrics)(
        [out, retval] DWRITE_FONT_METRICS* fontFaceMetrics
        ) PURE;

    /// <summary>
    /// Obtains the number of glyphs in the font face.
    /// </summary>
    [helpstring("Obtains the number of glyphs in the font face.")]
    STDMETHOD_(UINT16, GetGlyphCount)() PURE;

    /// <summary>
    /// Obtains ideal glyph metrics in font design units. Design glyphs metrics are used for glyph positioning.
    /// </summary>
    /// <param name="glyphIndices">An array of glyph indices to compute the metrics for.</param>
    /// <param name="glyphCount">The number of elements in the glyphIndices array.</param>
    /// <param name="glyphMetrics">Array of DWRITE_GLYPH_METRICS structures filled by this function.
    /// The metrics returned by this function are in font design units.</param>
    /// <param name="isSideways">Indicates whether the font is being used in a sideways run.
    /// This can affect the glyph metrics if the font has oblique simulation
    /// because sideways oblique simulation differs from non-sideways oblique simulation.</param>
    /// <returns>
    /// Standard HRESULT error code. If any of the input glyph indices are outside of the valid glyph index range
    /// for the current font face, E_INVALIDARG will be returned.
    /// </returns>
    [helpstring("Obtains ideal glyph metrics in font design units. Design glyphs metrics are used for glyph positioning.")]
    STDMETHOD(GetDesignGlyphMetrics)(
        __in_ecount(glyphCount) void* glyphIndices,
        UINT32 glyphCount,
        __out_ecount(glyphCount) void* glyphMetrics,
        [optional, defaultvalue(FALSE)] BOOL isSideways
        ) PURE;

    /// <summary>
    /// Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table.
    /// Note that this mapping is primarily provided for line layout engines built on top of the physical font API.
    /// Because of OpenType glyph substitution and line layout character substitution, the nominal conversion does not always correspond
    /// to how a Unicode string will map to glyph indices when rendering using a particular font face.
    /// Also, note that Unicode Variant Selectors provide for alternate mappings for character to glyph.
    /// This call will always return the default variant.
    /// </summary>
    /// <param name="codePoints">An array of USC4 code points to obtain nominal glyph indices from.</param>
    /// <param name="codePointCount">The number of elements in the codePoints array.</param>
    /// <param name="glyphIndices">Array of nominal glyph indices filled by this function.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table.")]
    STDMETHOD(GetGlyphIndices)(
        __in_ecount(codePointCount) void* codePoints,
        UINT32 codePointCount,
        __out_ecount(codePointCount) void* glyphIndices
        ) PURE;

    /// <summary>
    /// Finds the specified OpenType font table if it exists and returns a pointer to it.
    /// The function accesses the underling font data via the IDWriteFontStream interface
    /// implemented by the font file loader.
    /// </summary>
    /// <param name="openTypeTableTag">Four character tag of table to find.
    ///     Use the DWRITE_MAKE_OPENTYPE_TAG() macro to create it.
    ///     Unlike GDI, it does not support the special TTCF and null tags to access the whole font.</param>
    /// <param name="tableData">
    ///     Pointer to base of table in memory.
    ///     The pointer is only valid so long as the FontFace used to get the font table still exists
    ///     (not any other FontFace, even if it actually refers to the same physical font).
    /// </param>
    /// <param name="tableSize">Byte size of table.</param>
    /// <param name="tableContext">
    ///     Opaque context which must be freed by calling ReleaseFontTable.
    ///     The context actually comes from the lower level IDWriteFontFileStream,
    ///     which may be implemented by the application or DWrite itself.
    ///     It is possible for a NULL tableContext to be returned, especially if
    ///     the implementation directly memory maps the whole file.
    ///     Nevertheless, always release it later, and do not use it as a test for function success.
    ///     The same table can be queried multiple times,
    ///     but each returned context can be different, so release each separately.
    /// </param>
    /// <param name="exists">True if table exists.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// If a table can not be found, the function will not return an error, but the size will be 0, table NULL, and exists = FALSE.
    /// The context does not need to be freed if the table was not found.
    /// </returns>
    /// <remarks>
    /// The context for the same tag may be different for each call,
    /// so each one must be held and released separately.
    /// </remarks>
    [helpstring("Finds the specified OpenType font table if it exists and returns a pointer to it.")]
    STDMETHOD(TryGetFontTable)(
        __in UINT32 openTypeTableTag,
        __deref_out_bcount(*tableSize) void* tableData,
        UINT32* tableSize,
        void* tableContext,
        BOOL* exists
        ) PURE;

    /// <summary>
    /// Releases the table obtained earlier from TryGetFontTable.
    /// </summary>
    /// <param name="tableContext">Opaque context from TryGetFontTable.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Releases the table obtained earlier from TryGetFontTable.")]
    STDMETHOD_(void, ReleaseFontTable)(
        __in void* tableContext
        ) PURE;

    /// <summary>
    /// Computes the outline of a run of glyphs by calling back to the outline sink interface.
    /// </summary>
    /// <param name="emSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="glyphIndices">Array of glyph indices.</param>
    /// <param name="glyphAdvances">Optional array of glyph advances in DIPs.</param>
    /// <param name="glyphOffsets">Optional array of glyph offsets.</param>
    /// <param name="glyphCount">Number of glyphs.</param>
    /// <param name="isSideways">If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used.
    /// A client can render a vertical run by specifying isSideways = true and rotating the resulting geometry 90 degrees to the
    /// right using a transform. The isSideways and isRightToLeft parameters cannot both be true.</param>
    /// <param name="isRightToLeft">If true, specifies that the advance direction is right to left. By default, the advance direction
    /// is left to right.</param>
    /// <param name="geometrySink">Interface the function calls back to draw each element of the geometry.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Computes the outline of a run of glyphs by calling back to the outline sink interface.")]
    STDMETHOD(GetGlyphRunOutline)(
        FLOAT emSize,
        __in_ecount(glyphCount) void* glyphIndices,
        __in_ecount_opt(glyphCount) void* glyphAdvances,
        __in_ecount_opt(glyphCount) void* glyphOffsets,
        UINT32 glyphCount,
        BOOL isSideways,
        BOOL isRightToLeft,
        IDWriteGeometrySink* geometrySink
        ) PURE;

    /// <summary>
    /// Determines the recommended rendering mode for the font given the specified size and rendering parameters.
    /// </summary>
    /// <param name="emSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this 
    /// value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
    /// <param name="measuringMode">Specifies measuring method that will be used for glyphs in the font.
    /// Renderer implementations may choose different rendering modes for given measuring methods, but
    /// best results are seen when the corresponding modes match:
    /// DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for DWRITE_MEASURING_MODE_NATURAL
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for DWRITE_MEASURING_MODE_GDI_CLASSIC
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for DWRITE_MEASURING_MODE_GDI_NATURAL
    /// </param>
    /// <param name="renderingParams">Rendering parameters object. This parameter is necessary in case the rendering parameters 
    /// object overrides the rendering mode.</param>
    /// <param name="renderingMode">Receives the recommended rendering mode to use.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Determines the recommended rendering mode for the font given the specified size and rendering parameters.")]
    STDMETHOD(GetRecommendedRenderingMode)(
        FLOAT emSize,
        FLOAT pixelsPerDip,
        DWRITE_MEASURING_MODE measuringMode,
        IDWriteRenderingParams* renderingParams,
        [out, retval] DWRITE_RENDERING_MODE* renderingMode
        ) PURE;

    /// <summary>
    /// Obtains design units and common metrics for the font face.
    /// These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.
    /// </summary>
    /// <param name="emSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this 
    /// value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified by the font size and pixelsPerDip.</param>
    /// <param name="fontFaceMetrics">Points to a DWRITE_FONT_METRICS structure to fill in.
    /// The metrics returned by this function are in font design units.</param>
    [helpstring("Obtains design units and common metrics for the font face.")]
    STDMETHOD(GetGdiCompatibleMetrics)(
        FLOAT emSize,
        FLOAT pixelsPerDip,
        __in_opt void* transform,
        [out, retval] DWRITE_FONT_METRICS* fontFaceMetrics
        ) PURE;


    /// <summary>
    /// Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.
    /// Glyphs metrics are used for positioning of individual glyphs.
    /// </summary>
    /// <param name="emSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this 
    /// value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified by the font size and pixelsPerDip.</param>
    /// <param name="useGdiNatural">
    /// When set to FALSE, the metrics are the same as the metrics of GDI aliased text.
    /// When set to TRUE, the metrics are the same as the metrics of text measured by GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY.
    /// </param>
    /// <param name="glyphIndices">An array of glyph indices to compute the metrics for.</param>
    /// <param name="glyphCount">The number of elements in the glyphIndices array.</param>
    /// <param name="glyphMetrics">Array of DWRITE_GLYPH_METRICS structures filled by this function.
    /// The metrics returned by this function are in font design units.</param>
    /// <param name="isSideways">Indicates whether the font is being used in a sideways run.
    /// This can affect the glyph metrics if the font has oblique simulation
    /// because sideways oblique simulation differs from non-sideways oblique simulation.</param>
    /// <returns>
    /// Standard HRESULT error code. If any of the input glyph indices are outside of the valid glyph index range
    /// for the current font face, E_INVALIDARG will be returned.
    /// </returns>
    [helpstring("Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.")]
    STDMETHOD(GetGdiCompatibleGlyphMetrics)(
        FLOAT emSize,
        FLOAT pixelsPerDip,
        void* transform,
        BOOL useGdiNatural,
        __in_ecount(glyphCount) void* glyphIndices,
        UINT32 glyphCount,
        __out_ecount(glyphCount) void* glyphMetrics,
        [optional, defaultvalue(FALSE)]BOOL isSideways
        ) PURE;
};

/// <summary>
/// The font collection loader interface is used to construct a collection of fonts given a particular type of key.
/// The font collection loader interface is recommended to be implemented by a singleton object.
/// IMPORTANT: font collection loader implementations must not register themselves with a DirectWrite factory
/// inside their constructors and must not unregister themselves in their destructors, because
/// registration and unregistraton operations increment and decrement the object reference count respectively.
/// Instead, registration and unregistration of font file loaders with DirectWrite factory should be performed
/// outside of the font file loader implementation as a separate step.
/// </summary>
[
    odl,
    uuid(cca920e4-52f0-492b-bfa8-29c72ee0a468),
    helpstring("The font collection loader interface is used to construct a collection of fonts given a particular type of key.")
]
interface IDWriteFontCollectionLoader : stdole.IUnknown
{
    /// <summary>
    /// Creates a font file enumerator object that encapsulates a collection of font files.
    /// The font system calls back to this interface to create a font collection.
    /// </summary>
    /// <param name="factory">Factory associated with the loader.</param>
    /// <param name="collectionKey">Font collection key that uniquely identifies the collection of font files within
    /// the scope of the font collection loader being used.</param>
    /// <param name="collectionKeySize">Size of the font collection key in bytes.</param>
    /// <param name="fontFileEnumerator">Pointer to the newly created font file enumerator.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a font file enumerator object that encapsulates a collection of font files.")]
    STDMETHOD(CreateEnumeratorFromKey)(
        IDWriteFactory* factory,
        __in_bcount(collectionKeySize) void* collectionKey,
        UINT32 collectionKeySize,
        __out IDWriteFontFileEnumerator** fontFileEnumerator
        ) PURE;
};

/// <summary>
/// The font file enumerator interface encapsulates a collection of font files. The font system uses this interface
/// to enumerate font files when building a font collection.
/// </summary>
[
    odl,
    uuid(72755049-5ff7-435d-8348-4be97cfa6c7c),
    helpstring("The font file enumerator interface encapsulates a collection of font files. The font system uses this interface to enumerate font files when building a font collection.")
]
interface IDWriteFontFileEnumerator : stdole.IUnknown
{
    /// <summary>
    /// Advances to the next font file in the collection. When it is first created, the enumerator is positioned
    /// before the first element of the collection and the first call to MoveNext advances to the first file.
    /// </summary>
    /// <param name="hasCurrentFile">Receives the value TRUE if the enumerator advances to a file, or FALSE if
    /// the enumerator advanced past the last file in the collection.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(MoveNext)(
        [out, retval] BOOL* hasCurrentFile
        ) PURE;

    /// <summary>
    /// Gets a reference to the current font file.
    /// </summary>
    /// <param name="fontFile">Pointer to the newly created font file object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetCurrentFontFile)(
        [out, retval] IDWriteFontFile** fontFile
        ) PURE;
};

/// <summary>
/// Represents a collection of strings indexed by locale name.
/// </summary>
[
    odl,
    uuid(08256209-099a-4b34-b86d-c22b110e7771),
    helpstring("Represents a collection of strings indexed by locale name.")
]
interface IDWriteLocalizedStrings : stdole.IUnknown
{
    /// <summary>
    /// Gets the number of language/string pairs.
    /// </summary>
    [helpstring("Gets the number of language/string pairs.")]
    STDMETHOD_(UINT32, GetCount)() PURE;

    /// <summary>
    /// Gets the index of the item with the specified locale name.
    /// </summary>
    /// <param name="localeName">Locale name to look for.</param>
    /// <param name="index">Receives the zero-based index of the locale name/string pair.</param>
    /// <param name="exists">Receives TRUE if the locale name exists or FALSE if not.</param>
    /// <returns>
    /// Standard HRESULT error code. If the specified locale name does not exist, the return value is S_OK, 
    /// but *index is UINT_MAX and *exists is FALSE.
    /// </returns>
    [helpstring("Gets the index of the item with the specified locale name.")]
    STDMETHOD(FindLocaleName)(
        LPWSTR localeName,
        UINT32* index,
        [out, retval] BOOL* exists
        ) PURE;

    /// <summary>
    /// Gets the length in characters (not including the null terminator) of the locale name with the specified index.
    /// </summary>
    /// <param name="index">Zero-based index of the locale name.</param>
    /// <param name="length">Receives the length in characters, not including the null terminator.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the length in characters (not including the null terminator) of the locale name with the specified index.")]
    STDMETHOD(GetLocaleNameLength)(
        UINT32 index,
        [out, retval] UINT32* length
        ) PURE;

    /// <summary>
    /// Copies the locale name with the specified index to the specified array.
    /// </summary>
    /// <param name="index">Zero-based index of the locale name.</param>
    /// <param name="localeName">Character array that receives the locale name.</param>
    /// <param name="size">Size of the array in characters. The size must include space for the terminating
    /// null character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Copies the locale name with the specified index to the specified array.")]
    STDMETHOD(GetLocaleName)(
        UINT32 index,
        LPWSTR localeName,
        UINT32 size
        ) PURE;

    /// <summary>
    /// Gets the length in characters (not including the null terminator) of the string with the specified index.
    /// </summary>
    /// <param name="index">Zero-based index of the string.</param>
    /// <param name="length">Receives the length in characters, not including the null terminator.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the length in characters (not including the null terminator) of the string with the specified index.")]
    STDMETHOD(GetStringLength)(
        UINT32 index,
        [out, retval] UINT32* length
        ) PURE;

    /// <summary>
    /// Copies the string with the specified index to the specified array.
    /// </summary>
    /// <param name="index">Zero-based index of the string.</param>
    /// <param name="stringBuffer">Character array that receives the string.</param>
    /// <param name="size">Size of the array in characters. The size must include space for the terminating
    /// null character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Copies the string with the specified index to the specified array.")]
    STDMETHOD(GetString)(
        UINT32 index,
        LPWSTR stringBuffer,
        UINT32 size
        ) PURE;
};

/// <summary>
/// The IDWriteFontCollection encapsulates a collection of fonts.
/// </summary>
[
    odl,
    uuid(a84cee02-3eea-4eee-a827-87c1a02a0fcc),
    helpstring("The IDWriteFontCollection encapsulates a collection of fonts.")
]
interface IDWriteFontCollection : stdole.IUnknown
{
    /// <summary>
    /// Gets the number of font families in the collection.
    /// </summary>
    [helpstring("Gets the number of font families in the collection.")]
    STDMETHOD_(UINT32, GetFontFamilyCount)() PURE;

    /// <summary>
    /// Creates a font family object given a zero-based font family index.
    /// </summary>
    /// <param name="index">Zero-based index of the font family.</param>
    /// <param name="fontFamily">Receives a pointer the newly created font family object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a font family object given a zero-based font family index.")]
    STDMETHOD(GetFontFamily)(
        UINT32 index,
        [out, retval] IDWriteFontFamily** fontFamily
        ) PURE;

    /// <summary>
    /// Finds the font family with the specified family name.
    /// </summary>
    /// <param name="familyName">Name of the font family. The name is not case-sensitive but must otherwise exactly match a family name in the collection.</param>
    /// <param name="index">Receives the zero-based index of the matching font family if the family name was found or UINT_MAX otherwise.</param>
    /// <param name="exists">Receives TRUE if the family name exists or FALSE otherwise.</param>
    /// <returns>
    /// Standard HRESULT error code. If the specified family name does not exist, the return value is S_OK, but *index is UINT_MAX and *exists is FALSE.
    /// </returns>
    [helpstring("Finds the font family with the specified family name.")]
    STDMETHOD(FindFamilyName)(
        LPWSTR familyName,
        __out UINT32* index,
        [out, retval] BOOL* exists
        ) PURE;

    /// <summary>
    /// Gets the font object that corresponds to the same physical font as the specified font face object. The specified physical font must belong 
    /// to the font collection.
    /// </summary>
    /// <param name="fontFace">Font face object that specifies the physical font.</param>
    /// <param name="font">Receives a pointer to the newly created font object if successful or NULL otherwise.</param>
    /// <returns>
    /// Standard HRESULT error code. If the specified physical font is not part of the font collection the return value is DWRITE_E_NOFONT.
    /// </returns>
    [helpstring("Gets the font object that corresponds to the same physical font as the specified font face object. The specified physical font must belong to the font collection.")]
    STDMETHOD(GetFontFromFontFace)(
        IDWriteFontFace* fontFace,
        [out, retval] IDWriteFont** font
        ) PURE;
};

/// <summary>
/// The IDWriteFontList interface represents a list of fonts.
/// </summary>
[
    odl,
    uuid(1a0d8438-1d97-4ec1-aef9-a2fb86ed6acb),
    helpstring("The IDWriteFontList interface represents a list of fonts.")
]
interface IDWriteFontList : stdole.IUnknown
{
    /// <summary>
    /// Gets the font collection that contains the fonts.
    /// </summary>
    /// <param name="fontCollection">Receives a pointer to the font collection object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the font collection that contains the fonts.")]
    STDMETHOD(GetFontCollection)(
        [out, retval] IDWriteFontCollection** fontCollection
        ) PURE;

    /// <summary>
    /// Gets the number of fonts in the font list.
    /// </summary>
    [helpstring("Gets the number of fonts in the font list.")]
    STDMETHOD_(UINT32, GetFontCount)() PURE;

    /// <summary>
    /// Gets a font given its zero-based index.
    /// </summary>
    /// <param name="index">Zero-based index of the font in the font list.</param>
    /// <param name="font">Receives a pointer to the newly created font object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets a font given its zero-based index.")]
    STDMETHOD(GetFont)(
        UINT32 index,
        [out, retval] IDWriteFont** font
        ) PURE;
};

/// <summary>
/// The IDWriteFontFamily interface represents a set of fonts that share the same design but are differentiated
/// by weight, stretch, and style.
/// </summary>
[
    odl,
    uuid(da20d8ef-812a-4c43-9802-62ec4abd7add),
    helpstring("The IDWriteFontFamily interface represents a set of fonts that share the same design but are differentiated by weight, stretch, and style.")
]
interface IDWriteFontFamily : IDWriteFontList
{
    /// <summary>
    /// Creates an localized strings object that contains the family names for the font family, indexed by locale name.
    /// </summary>
    /// <param name="names">Receives a pointer to the newly created localized strings object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates an localized strings object that contains the family names for the font family, indexed by locale name.")]
    STDMETHOD(GetFamilyNames)(
        [out, retval] IDWriteLocalizedStrings** names
        ) PURE;

    /// <summary>
    /// Gets the font that best matches the specified properties.
    /// </summary>
    /// <param name="weight">Requested font weight.</param>
    /// <param name="stretch">Requested font stretch.</param>
    /// <param name="style">Requested font style.</param>
    /// <param name="matchingFont">Receives a pointer to the newly created font object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the font that best matches the specified properties.")]
    STDMETHOD(GetFirstMatchingFont)(
        DWRITE_FONT_WEIGHT  weight,
        DWRITE_FONT_STRETCH stretch,
        DWRITE_FONT_STYLE   style,
        [out, retval] IDWriteFont** matchingFont
        ) PURE;

    /// <summary>
    /// Gets a list of fonts in the font family ranked in order of how well they match the specified properties.
    /// </summary>
    /// <param name="weight">Requested font weight.</param>
    /// <param name="stretch">Requested font stretch.</param>
    /// <param name="style">Requested font style.</param>
    /// <param name="matchingFonts">Receives a pointer to the newly created font list object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets a list of fonts in the font family ranked in order of how well they match the specified properties.")]
    STDMETHOD(GetMatchingFonts)(
        DWRITE_FONT_WEIGHT      weight,
        DWRITE_FONT_STRETCH     stretch,
        DWRITE_FONT_STYLE       style,
        [out, retval] IDWriteFontList** matchingFonts
        ) PURE;
};

/// <summary>
/// The IDWriteFont interface represents a physical font in a font collection.
/// </summary>
[
    odl,
    uuid(acd16696-8c14-4f5d-877e-fe3fc1d32737),
    helpstring("The IDWriteFont interface represents a physical font in a font collection.")
]
interface IDWriteFont : stdole.IUnknown
{
    /// <summary>
    /// Gets the font family to which the specified font belongs.
    /// </summary>
    /// <param name="fontFamily">Receives a pointer to the font family object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the font family to which the specified font belongs.")]
    STDMETHOD(GetFontFamily)(
        [out, retval] IDWriteFontFamily** fontFamily
        ) PURE;

    /// <summary>
    /// Gets the weight of the specified font.
    /// </summary>
    [helpstring("Gets the weight of the specified font.")]
    STDMETHOD_(DWRITE_FONT_WEIGHT, GetWeight)() PURE;

    /// <summary>
    /// Gets the stretch (aka. width) of the specified font.
    /// </summary>
    [helpstring("Gets the stretch (aka. width) of the specified font.")]
    STDMETHOD_(DWRITE_FONT_STRETCH, GetStretch)() PURE;

    /// <summary>
    /// Gets the style (aka. slope) of the specified font.
    /// </summary>
    [helpstring("Gets the style (aka. slope) of the specified font.")]
    STDMETHOD_(DWRITE_FONT_STYLE, GetStyle)() PURE;

    /// <summary>
    /// Returns TRUE if the font is a symbol font or FALSE if not.
    /// </summary>
    [helpstring("Returns TRUE if the font is a symbol font or FALSE if not.")]
    STDMETHOD_(BOOL, IsSymbolFont)() PURE;

    /// <summary>
    /// Gets a localized strings collection containing the face names for the font (e.g., Regular or Bold), indexed by locale name.
    /// </summary>
    /// <param name="names">Receives a pointer to the newly created localized strings object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets a localized strings collection containing the face names for the font (e.g., Regular or Bold), indexed by locale name.")]
    STDMETHOD(GetFaceNames)(
        [out, retval] IDWriteLocalizedStrings** names
        ) PURE;

    /// <summary>
    /// Gets a localized strings collection containing the specified informational strings, indexed by locale name.
    /// </summary>
    /// <param name="informationalStringID">Identifies the string to get.</param>
    /// <param name="informationalStrings">Receives a pointer to the newly created localized strings object.</param>
    /// <param name="exists">Receives the value TRUE if the font contains the specified string ID or FALSE if not.</param>
    /// <returns>
    /// Standard HRESULT error code. If the font does not contain the specified string, the return value is S_OK but 
    /// informationalStrings receives a NULL pointer and exists receives the value FALSE.
    /// </returns>
    [helpstring("Gets a localized strings collection containing the specified informational strings, indexed by locale name.")]
    STDMETHOD(GetInformationalStrings)(
        DWRITE_INFORMATIONAL_STRING_ID informationalStringID,
        __out IDWriteLocalizedStrings** informationalStrings,
        [out, retval] BOOL* exists
        ) PURE;

    /// <summary>
    /// Gets a value that indicates what simulation are applied to the specified font.
    /// </summary>
    [helpstring("Gets a value that indicates what simulation are applied to the specified font.")]
    STDMETHOD_(DWRITE_FONT_SIMULATIONS, GetSimulations)() PURE;

    /// <summary>
    /// Gets the metrics for the font.
    /// </summary>
    /// <param name="fontMetrics">Receives the font metrics.</param>
    [helpstring("Gets the metrics for the font.")]
    STDMETHOD_(void, GetMetrics)(
        [out, retval] DWRITE_FONT_METRICS* fontMetrics
        ) PURE;

    /// <summary>
    /// Determines whether the font supports the specified character.
    /// </summary>
    /// <param name="unicodeValue">Unicode (UCS-4) character value.</param>
    /// <param name="exists">Receives the value TRUE if the font supports the specified character or FALSE if not.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Determines whether the font supports the specified character.")]
    STDMETHOD(HasCharacter)(
        UINT32 unicodeValue,
        [out, retval] BOOL* exists
        ) PURE;

    /// <summary>
    /// Creates a font file enumerator object that encapsulates a collection of font files.
    /// </summary>
    /// <param name="fontFace">Receives a pointer to the newly created font face object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a font file enumerator object that encapsulates a collection of font files.")]
    STDMETHOD(CreateFontFace)(
        [out, retval] IDWriteFontFace** fontFace
        ) PURE;
};

/// <summary>
/// The format of text used for text layout purpose.
/// </summary>
/// <remarks>
/// This object may not be thread-safe and it may carry the state of text format change.
/// </remarks>
[
    odl,
    uuid(9c906818-31d7-4fd3-a151-7c5e225db55a),
    helpstring("The format of text used for text layout purpose.")
]
interface IDWriteTextFormat : stdole.IUnknown
{
    /// <summary>
    /// Set alignment option of text relative to layout box's leading and trailing edge.
    /// </summary>
    /// <param name="textAlignment">Text alignment option</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set alignment option of text relative to layout box's leading and trailing edge.")]
    STDMETHOD(SetTextAlignment)(
        DWRITE_TEXT_ALIGNMENT textAlignment
        ) PURE;

    /// <summary>
    /// Set alignment option of paragraph relative to layout box's top and bottom edge.
    /// </summary>
    /// <param name="paragraphAlignment">Paragraph alignment option</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set alignment option of paragraph relative to layout box's top and bottom edge.")]
    STDMETHOD(SetParagraphAlignment)(
        DWRITE_PARAGRAPH_ALIGNMENT paragraphAlignment
        ) PURE;

    /// <summary>
    /// Set word wrapping option.
    /// </summary>
    /// <param name="wordWrapping">Word wrapping option</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set word wrapping option.")]
    STDMETHOD(SetWordWrapping)(
        DWRITE_WORD_WRAPPING wordWrapping
        ) PURE;

    /// <summary>
    /// Set paragraph reading direction.
    /// </summary>
    /// <param name="readingDirection">Text reading direction</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set paragraph reading direction.")]
    STDMETHOD(SetReadingDirection)(
        DWRITE_READING_DIRECTION readingDirection
        ) PURE;

    /// <summary>
    /// Set paragraph flow direction.
    /// </summary>
    /// <param name="flowDirection">Paragraph flow direction</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set paragraph flow direction.")]
    STDMETHOD(SetFlowDirection)(
        DWRITE_FLOW_DIRECTION flowDirection
        ) PURE;

    /// <summary>
    /// Set incremental tab stop position.
    /// </summary>
    /// <param name="incrementalTabStop">The incremental tab stop value</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set incremental tab stop position.")]
    STDMETHOD(SetIncrementalTabStop)(
        FLOAT incrementalTabStop
        ) PURE;

    /// <summary>
    /// Set trimming options for any trailing text exceeding the layout width
    /// or for any far text exceeding the layout height.
    /// </summary>
    /// <param name="trimmingOptions">Text trimming options.</param>
    /// <param name="trimmingSign">Application-defined omission sign. This parameter may be NULL if no trimming sign is desired.</param>
    /// <remarks>
    /// Any inline object can be used for the trimming sign, but CreateEllipsisTrimmingSign
    /// provides a typical ellipsis symbol. Trimming is also useful vertically for hiding
    /// partial lines.
    /// </remarks>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set trimming options for any trailing text exceeding the layout width or for any far text exceeding the layout height.")]
    STDMETHOD(SetTrimming)(
        DWRITE_TRIMMING* trimmingOptions,
        IDWriteInlineObject* trimmingSign
        ) PURE;

    /// <summary>
    /// Set line spacing.
    /// </summary>
    /// <param name="lineSpacingMethod">How to determine line height.</param>
    /// <param name="lineSpacing">The line height, or rather distance between one baseline to another.</param>
    /// <param name="baseline">Distance from top of line to baseline. A reasonable ratio to lineSpacing is 80%.</param>
    /// <remarks>
    /// For the default method, spacing depends solely on the content.
    /// For uniform spacing, the given line height will override the content.
    /// </remarks>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set line spacing.")]
    STDMETHOD(SetLineSpacing)(
        DWRITE_LINE_SPACING_METHOD lineSpacingMethod,
        FLOAT lineSpacing,
        FLOAT baseline
        ) PURE;

    /// <summary>
    /// Get alignment option of text relative to layout box's leading and trailing edge.
    /// </summary>
    [helpstring("Get alignment option of text relative to layout box's leading and trailing edge.")]
    STDMETHOD_(DWRITE_TEXT_ALIGNMENT, GetTextAlignment)() PURE;

    /// <summary>
    /// Get alignment option of paragraph relative to layout box's top and bottom edge.
    /// </summary>
    [helpstring("Get alignment option of paragraph relative to layout box's top and bottom edge.")]
    STDMETHOD_(DWRITE_PARAGRAPH_ALIGNMENT, GetParagraphAlignment)() PURE;

    /// <summary>
    /// Get word wrapping option.
    /// </summary>
    [helpstring("Get word wrapping option.")]
    STDMETHOD_(DWRITE_WORD_WRAPPING, GetWordWrapping)() PURE;

    /// <summary>
    /// Get paragraph reading direction.
    /// </summary>
    [helpstring("Get paragraph reading direction.")]
    STDMETHOD_(DWRITE_READING_DIRECTION, GetReadingDirection)() PURE;

    /// <summary>
    /// Get paragraph flow direction.
    /// </summary>
    [helpstring("Get paragraph flow direction.")]
    STDMETHOD_(DWRITE_FLOW_DIRECTION, GetFlowDirection)() PURE;

    /// <summary>
    /// Get incremental tab stop position.
    /// </summary>
    [helpstring("Get incremental tab stop position.")]
    STDMETHOD_(FLOAT, GetIncrementalTabStop)() PURE;

    /// <summary>
    /// Get trimming options for text overflowing the layout width.
    /// </summary>
    /// <param name="trimmingOptions">Text trimming options.</param>
    /// <param name="trimmingSign">Trimming omission sign. This parameter may be NULL.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get trimming options for text overflowing the layout width.")]
    STDMETHOD(GetTrimming)(
        DWRITE_TRIMMING* trimmingOptions,
        [out, retval] IDWriteInlineObject** trimmingSign
        ) PURE;

    /// <summary>
    /// Get line spacing.
    /// </summary>
    /// <param name="lineSpacingMethod">How line height is determined.</param>
    /// <param name="lineSpacing">The line height, or rather distance between one baseline to another.</param>
    /// <param name="baseline">Distance from top of line to baseline.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get line spacing.")]
    STDMETHOD(GetLineSpacing)(
        DWRITE_LINE_SPACING_METHOD* lineSpacingMethod,
        FLOAT* lineSpacing,
        FLOAT* baseline
        ) PURE;

    /// <summary>
    /// Get the font collection.
    /// </summary>
    /// <param name="fontCollection">The current font collection.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the font collection.")]
    STDMETHOD(GetFontCollection)(
        [in, out] IDWriteFontCollection** fontCollection
        ) PURE;

    /// <summary>
    /// Get the length of the font family name, in characters, not including the terminating NULL character.
    /// </summary>
    [helpstring("Get the length of the font family name, in characters, not including the terminating NULL character.")]
    STDMETHOD_(UINT32, GetFontFamilyNameLength)() PURE;

    /// <summary>
    /// Get a copy of the font family name.
    /// </summary>
    /// <param name="fontFamilyName">Character array that receives the current font family name</param>
    /// <param name="nameSize">Size of the character array in character count including the terminated NULL character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get a copy of the font family name.")]
    STDMETHOD(GetFontFamilyName)(
        LPWSTR fontFamilyName,
        UINT32 nameSize
        ) PURE;

    /// <summary>
    /// Get the font weight.
    /// </summary>
    [helpstring("Get the font weight.")]
    STDMETHOD_(DWRITE_FONT_WEIGHT, GetFontWeight)() PURE;

    /// <summary>
    /// Get the font style.
    /// </summary>
    [helpstring("Get the font style.")]
    STDMETHOD_(DWRITE_FONT_STYLE, GetFontStyle)() PURE;

    /// <summary>
    /// Get the font stretch.
    /// </summary>
    [helpstring("Get the font stretch.")]
    STDMETHOD_(DWRITE_FONT_STRETCH, GetFontStretch)() PURE;

    /// <summary>
    /// Get the font em height.
    /// </summary>
    [helpstring("Get the font em height.")]
    STDMETHOD_(FLOAT, GetFontSize)() PURE;

    /// <summary>
    /// Get the length of the locale name, in characters, not including the terminating NULL character.
    /// </summary>
    [helpstring("Get the length of the locale name, in characters, not including the terminating NULL character.")]
    STDMETHOD_(UINT32, GetLocaleNameLength)() PURE;

    /// <summary>
    /// Get a copy of the locale name.
    /// </summary>
    /// <param name="localeName">Character array that receives the current locale name</param>
    /// <param name="nameSize">Size of the character array in character count including the terminated NULL character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get a copy of the locale name.")]
    STDMETHOD(GetLocaleName)(
        LPWSTR localeName,
        UINT32 nameSize
        ) PURE;
};

/// <summary>
/// Font typography setting.
/// </summary>
[
    odl,
    uuid(55f1112b-1dc2-4b3c-9541-f46894ed85b6),
    helpstring("Font typography setting.")
]
interface IDWriteTypography : stdole.IUnknown
{
    /// <summary>
    /// Add font feature.
    /// </summary>
    /// <param name="fontFeature">The font feature to add.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Add font feature.")]
    STDMETHOD(AddFontFeature)(
        DWRITE_FONT_FEATURE fontFeature
        ) PURE;

    /// <summary>
    /// Get the number of font features.
    /// </summary>
    [helpstring("Get the number of font features.")]
    STDMETHOD_(UINT32, GetFontFeatureCount)() PURE;

    /// <summary>
    /// Get the font feature at the specified index.
    /// </summary>
    /// <param name="fontFeatureIndex">The zero-based index of the font feature to get.</param>
    /// <param name="fontFeature">The font feature.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the font feature at the specified index.")]
    STDMETHOD(GetFontFeature)(
        UINT32 fontFeatureIndex,
        [out, retval] DWRITE_FONT_FEATURE* fontFeature
        ) PURE;
};

/// <summary>
/// Holds the appropriate digits and numeric punctuation for a given locale.
/// </summary>
[
    odl,
    uuid(14885CC9-BAB0-4f90-B6ED-5C366A2CD03D),
    helpstring("Holds the appropriate digits and numeric punctuation for a given locale.")
]
interface IDWriteNumberSubstitution : stdole.IUnknown
{
};

/// <summary>
/// The interface implemented by the text analyzer's client to provide text to
/// the analyzer. It allows the separation between the logical view of text as
/// a continuous stream of characters identifiable by unique text positions,
/// and the actual memory layout of potentially discrete blocks of text in the
/// client's backing store.
///
/// If any of these callbacks returns an error, the analysis functions will
/// stop prematurely and return a callback error. Rather than return E_NOTIMPL,
/// an application should stub the method and return a constant/null and S_OK.
/// </summary>
[
    odl,
    uuid(688e1a58-5094-47c8-adc8-fbcea60ae92b),
    helpstring("The interface implemented by the text analyzer's client to provide text to the analyzer.")
]
interface IDWriteTextAnalysisSource : stdole.IUnknown
{
    /// <summary>
    /// Get a block of text starting at the specified text position.
    /// Returning NULL indicates the end of text - the position is after
    /// the last character. This function is called iteratively for
    /// each consecutive block, tying together several fragmented blocks
    /// in the backing store into a virtual contiguous string.
    /// </summary>
    /// <param name="textPosition">First position of the piece to obtain. All
    ///     positions are in UTF16 code-units, not whole characters, which
    ///     matters when supplementary characters are used.</param>
    /// <param name="textString">Address that receives a pointer to the text block
    ///     at the specified position.</param>
    /// <param name="textLength">Number of UTF16 units of the retrieved chunk.
    ///     The returned length is not the length of the block, but the length
    ///     remaining in the block, from the given position until its end.
    ///     So querying for a position that is 75 positions into a 100
    ///     postition block would return 25.</param>
    /// <returns>Pointer to the first character at the given text position.
    /// NULL indicates no chunk available at the specified position, either
    /// because textPosition >= the entire text content length or because the
    /// queried position is not mapped into the app's backing store.</returns>
    /// <remarks>
    /// Although apps can implement sparse textual content that only maps part of
    /// the backing store, the app must map any text that is in the range passed
    /// to any analysis functions.
    /// </remarks>
    STDMETHOD(GetTextAtPosition)(
        UINT32 textPosition,
        int* textString,
        UINT32* textLength
        ) PURE;

    /// <summary>
    /// Get a block of text immediately preceding the specified position.
    /// </summary>
    /// <param name="textPosition">Position immediately after the last position of the chunk to obtain.</param>
    /// <param name="textString">Address that receives a pointer to the text block
    ///     at the specified position.</param>
    /// <param name="textLength">Number of UTF16 units of the retrieved block.
    ///     The length returned is from the given position to the front of
    ///     the block.</param>
    /// <returns>Pointer to the first character at (textPosition - textLength).
    /// NULL indicates no chunk available at the specified position, either
    /// because textPosition == 0,the textPosition > the entire text content
    /// length, or the queried position is not mapped into the app's backing
    /// store.</returns>
    /// <remarks>
    /// Although apps can implement sparse textual content that only maps part of
    /// the backing store, the app must map any text that is in the range passed
    /// to any analysis functions.
    /// </remarks>
    STDMETHOD(GetTextBeforePosition)(
        UINT32 textPosition,
        int* textString,
        UINT32* textLength
        ) PURE;

    /// <summary>
    /// Get paragraph reading direction.
    /// </summary>
    STDMETHOD_(DWRITE_READING_DIRECTION, GetParagraphReadingDirection)() PURE;

    /// <summary>
    /// Get locale name on the range affected by it.
    /// </summary>
    /// <param name="textPosition">Position to get the locale name of.</param>
    /// <param name="textLength">Receives the length from the given position up to the
    ///     next differing locale.</param>
    /// <param name="localeName">Address that receives a pointer to the locale
    ///     at the specified position.</param>
    /// <remarks>
    /// The localeName pointer must remain valid until the next call or until
    /// the analysis returns.
    /// </remarks>
    STDMETHOD(GetLocaleName)(
        UINT32 textPosition,
        UINT32* textLength,
        int* localeName
        ) PURE;

    /// <summary>
    /// Get number substitution on the range affected by it.
    /// </summary>
    /// <param name="textPosition">Position to get the number substitution of.</param>
    /// <param name="textLength">Receives the length from the given position up to the
    ///     next differing number substitution.</param>
    /// <param name="numberSubstitution">Address that receives a pointer to the number substitution
    ///     at the specified position.</param>
    /// <remarks>
    /// Any implementation should return the number substitution with an
    /// incremented ref count, and the analysis will release when finished
    /// with it (either before the next call or before it returns). However,
    /// the sink callback may hold onto it after that.
    /// </remarks>
    STDMETHOD(GetNumberSubstitution)(
        UINT32 textPosition,
        UINT32* textLength,
        IDWriteNumberSubstitution** numberSubstitution
        ) PURE;
};


/// <summary>
/// The interface implemented by the text analyzer's client to receive the
/// output of a given text analysis. The Text analyzer disregards any current
/// state of the analysis sink, therefore a Set method call on a range
/// overwrites the previously set analysis result of the same range. 
/// </summary>
[
    odl,
    uuid(5810cd44-0ca0-4701-b3fa-bec5182ae4f6),
    helpstring("The interface implemented by the text analyzer's client to receive the output of a given text analysis.")
]
interface DECLSPEC_NOVTABLE IDWriteTextAnalysisSink : stdole.IUnknown
{
    /// <summary>
    /// Report script analysis for the text range.
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF16 units of the reported range.</param>
    /// <param name="scriptAnalysis">Script analysis of characters in range.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    [helpstring("Report script analysis for the text range.")]
    STDMETHOD(SetScriptAnalysis)(
        UINT32 textPosition,
        UINT32 textLength,
        int* scriptAnalysis
        ) PURE;

    /// <summary>
    /// Repport line-break opportunities for each character, starting from
    /// the specified position.
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF16 units of the reported range.</param>
    /// <param name="lineBreakpoints">Breaking conditions for each character.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    [helpstring("Repport line-break opportunities for each character, starting from the specified position.")]
    STDMETHOD(SetLineBreakpoints)(
        UINT32 textPosition,
        UINT32 textLength,
        int* lineBreakpoints
        ) PURE;

    /// <summary>
    /// Set bidirectional level on the range, called once per each
    /// level run change (either explicit or resolved implicit).
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF16 units of the reported range.</param>
    /// <param name="explicitLevel">Explicit level from embedded control codes
    ///     RLE/RLO/LRE/LRO/PDF, determined before any additional rules.</param>
    /// <param name="resolvedLevel">Final implicit level considering the
    ///     explicit level and characters' natural directionality, after all
    ///     Bidi rules have been applied.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    [helpstring("Set bidirectional level on the range, called once per each level run change (either explicit or resolved implicit).")]
    STDMETHOD(SetBidiLevel)(
        UINT32 textPosition,
        UINT32 textLength,
        UINT8 explicitLevel,
        UINT8 resolvedLevel
        ) PURE;

    /// <summary>
    /// Set number substitution on the range.
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF16 units of the reported range.</param>
    /// <param name="numberSubstitution">The number substitution applicable to
    ///     the returned range of text. The sink callback may hold onto it by
    ///     incrementing its ref count.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    /// <remark>
    /// Unlike script and bidi analysis, where every character passed to the
    /// analyzer has a result, this will only be called for those ranges where
    /// substitution is applicable. For any other range, you will simply not
    /// be called.
    /// </remark>
    [helpstring("Set number substitution on the range.")]
    STDMETHOD(SetNumberSubstitution)(
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteNumberSubstitution* numberSubstitution
        ) PURE;
};

/// <summary>
/// Analyzes various text properties for complex script processing.
/// </summary>
[
    odl,
    uuid(b7e6163e-7f46-43b4-84b3-e4e6249c365d),
    helpstring("Analyzes various text properties for complex script processing.")
]
interface IDWriteTextAnalyzer : stdole.IUnknown
{
    /// <summary>
    /// Analyzes a text range for script boundaries, reading text attributes
    /// from the source and reporting the Unicode script ID to the sink 
    /// callback SetScript.
    /// </summary>
    /// <param name="analysisSource">Source object to analyze.</param>
    /// <param name="textPosition">Starting position within the source object.</param>
    /// <param name="textLength">Length to analyze.</param>
    /// <param name="analysisSink">Callback object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Analyzes a text range for script boundaries, reading text attributes from the source and reporting the Unicode script ID to the sink callback SetScript.")]
    STDMETHOD(AnalyzeScript)(
        IDWriteTextAnalysisSource* analysisSource,
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteTextAnalysisSink* analysisSink
        ) PURE;

    /// <summary>
    /// Analyzes a text range for script directionality, reading attributes
    /// from the source and reporting levels to the sink callback SetBidiLevel.
    /// </summary>
    /// <param name="analysisSource">Source object to analyze.</param>
    /// <param name="textPosition">Starting position within the source object.</param>
    /// <param name="textLength">Length to analyze.</param>
    /// <param name="analysisSink">Callback object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// While the function can handle multiple paragraphs, the text range
    /// should not arbitrarily split the middle of paragraphs. Otherwise the
    /// returned levels may be wrong, since the Bidi algorithm is meant to
    /// apply to the paragraph as a whole.
    /// </remarks>
    /// <remarks>
    /// Embedded control codes (LRE/LRO/RLE/RLO/PDF) are taken into account.
    /// </remarks>
    [helpstring("Analyzes a text range for script directionality, reading attributes from the source and reporting levels to the sink callback SetBidiLevel.")]
    STDMETHOD(AnalyzeBidi)(
        IDWriteTextAnalysisSource* analysisSource,
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteTextAnalysisSink* analysisSink
        ) PURE;

    /// <summary>
    /// Analyzes a text range for spans where number substitution is applicable,
    /// reading attributes from the source and reporting substitutable ranges
    /// to the sink callback SetNumberSubstitution.
    /// </summary>
    /// <param name="analysisSource">Source object to analyze.</param>
    /// <param name="textPosition">Starting position within the source object.</param>
    /// <param name="textLength">Length to analyze.</param>
    /// <param name="analysisSink">Callback object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// While the function can handle multiple ranges of differing number
    /// substitutions, the text ranges should not arbitrarily split the
    /// middle of numbers. Otherwise it will treat the numbers separately
    /// and will not translate any intervening punctuation.
    /// </remarks>
    /// <remarks>
    /// Embedded control codes (LRE/LRO/RLE/RLO/PDF) are taken into account.
    /// </remarks>
    [helpstring("Analyzes a text range for spans where number substitution is applicable, reading attributes from the source and reporting substitutable ranges to the sink callback SetNumberSubstitution.")]
    STDMETHOD(AnalyzeNumberSubstitution)(
        IDWriteTextAnalysisSource* analysisSource,
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteTextAnalysisSink* analysisSink
        ) PURE;

    /// <summary>
    /// Analyzes a text range for potential breakpoint opportunities, reading
    /// attributes from the source and reporting breakpoint opportunities to
    /// the sink callback SetLineBreakpoints.
    /// </summary>
    /// <param name="analysisSource">Source object to analyze.</param>
    /// <param name="textPosition">Starting position within the source object.</param>
    /// <param name="textLength">Length to analyze.</param>
    /// <param name="analysisSink">Callback object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// While the function can handle multiple paragraphs, the text range
    /// should not arbitrarily split the middle of paragraphs, unless the
    /// given text span is considered a whole unit. Otherwise the
    /// returned properties for the first and last characters will
    /// inappropriately allow breaks.
    /// </remarks>
    /// <remarks>
    /// Special cases include the first, last, and surrogate characters. Any
    /// text span is treated as if adjacent to inline objects on either side.
    /// So the rules with contingent-break opportunities are used, where the 
    /// edge between text and inline objects is always treated as a potential
    /// break opportunity, dependent on any overriding rules of the adjacent
    /// objects to prohibit or force the break (see Unicode TR #14).
    /// Surrogate pairs never break between.
    /// </remarks>
    [helpstring("Analyzes a text range for potential breakpoint opportunities, reading attributes from the source and reporting breakpoint opportunities to the sink callback SetLineBreakpoints.")]
    STDMETHOD(AnalyzeLineBreakpoints)(
        IDWriteTextAnalysisSource* analysisSource,
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteTextAnalysisSink* analysisSink
        ) PURE;

    /// <summary>
    /// Parses the input text string and maps it to the set of glyphs and associated glyph data
    /// according to the font and the writing system's rendering rules.
    /// </summary>
    /// <param name="textString">The string to convert to glyphs.</param>
    /// <param name="textLength">The length of textString.</param>
    /// <param name="fontFace">The font face to get glyphs from.</param>
    /// <param name="isSideways">Set to true if the text is intended to be
    /// drawn vertically.</param>
    /// <param name="isRightToLeft">Set to TRUE for right-to-left text.</param>
    /// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
    /// <param name="localeName">The locale to use when selecting glyphs.
    /// e.g. the same character may map to different glyphs for ja-jp vs zh-chs.
    /// If this is NULL then the default mapping based on the script is used.</param>
    /// <param name="numberSubstitution">Optional number substitution which
    /// selects the appropriate glyphs for digits and related numeric characters,
    /// depending on the results obtained from AnalyzeNumberSubstitution. Passing
    /// null indicates that no substitution is needed and that the digits should
    /// receive nominal glyphs.</param>
    /// <param name="features">An array of pointers to the sets of typographic 
    /// features to use in each feature range.</param>
    /// <param name="featureRangeLengths">The length of each feature range, in characters.  
    /// The sum of all lengths should be equal to textLength.</param>
    /// <param name="featureRanges">The number of feature ranges.</param>
    /// <param name="maxGlyphCount">The maximum number of glyphs that can be
    /// returned.</param>
    /// <param name="clusterMap">The mapping from character ranges to glyph 
    /// ranges.</param>
    /// <param name="textProps">Per-character output properties.</param>
    /// <param name="glyphIndices">Output glyph indices.</param>
    /// <param name="glyphProps">Per-glyph output properties.</param>
    /// <param name="actualGlyphCount">The actual number of glyphs returned if
    /// the call succeeds.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Note that the mapping from characters to glyphs is, in general, many-
    /// to-many.  The recommended estimate for the per-glyph output buffers is
    /// (3 * textLength / 2 + 16).  This is not guaranteed to be sufficient.
    ///
    /// The value of the actualGlyphCount parameter is only valid if the call
    /// succeeds.  In the event that maxGlyphCount is not big enough
    /// E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),
    /// will be returned.  The application should allocate a larger buffer and try again.
    /// </remarks>
    [helpstring("Parses the input text string and maps it to the set of glyphs and associated glyph data according to the font and the writing system's rendering rules.")]
    STDMETHOD(GetGlyphs)(
        LPWSTR textString,
        UINT32 textLength,
        IDWriteFontFace* fontFace,
        BOOL isSideways,
        BOOL isRightToLeft,
        __in DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,
        __in_z_opt LPWSTR localeName,
        IDWriteNumberSubstitution* numberSubstitution,
        __in_ecount_opt(featureRanges) void* features,
        __in_ecount_opt(featureRanges) void* featureRangeLengths,
        UINT32 featureRanges,
        UINT32 maxGlyphCount,
        __out_ecount(textLength) UINT16* clusterMap,
        __out_ecount(textLength) DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        __out_ecount(maxGlyphCount) UINT16* glyphIndices,
        __out_ecount(maxGlyphCount) DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,
        __out UINT32* actualGlyphCount
        ) PURE;

    /// <summary>
    /// Place glyphs output from the GetGlyphs method according to the font 
    /// and the writing system's rendering rules.
    /// </summary>
    /// <param name="textString">The original string the glyphs came from.</param>
    /// <param name="clusterMap">The mapping from character ranges to glyph 
    /// ranges. Returned by GetGlyphs.</param>
    /// <param name="textProps">Per-character properties. Returned by 
    /// GetGlyphs.</param>
    /// <param name="textLength">The length of textString.</param>
    /// <param name="glyphIndices">Glyph indices. See GetGlyphs</param>
    /// <param name="glyphProps">Per-glyph properties. See GetGlyphs</param>
    /// <param name="glyphCount">The number of glyphs.</param>
    /// <param name="fontFace">The font face the glyphs came from.</param>
    /// <param name="fontEmSize">Logical font size in DIP's.</param>
    /// <param name="isSideways">Set to true if the text is intended to be
    /// drawn vertically.</param>
    /// <param name="isRightToLeft">Set to TRUE for right-to-left text.</param>
    /// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
    /// <param name="localeName">The locale to use when selecting glyphs.
    /// e.g. the same character may map to different glyphs for ja-jp vs zh-chs.
    /// If this is NULL then the default mapping based on the script is used.</param>
    /// <param name="features">An array of pointers to the sets of typographic 
    /// features to use in each feature range.</param>
    /// <param name="featureRangeLengths">The length of each feature range, in characters.  
    /// The sum of all lengths should be equal to textLength.</param>
    /// <param name="featureRanges">The number of feature ranges.</param>
    /// <param name="glyphAdvances">The advance width of each glyph.</param>
    /// <param name="glyphOffsets">The offset of the origin of each glyph.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Place glyphs output from the GetGlyphs method according to the font and the writing system's rendering rules.")]
    STDMETHOD(GetGlyphPlacements)(
        __in_ecount(textLength) LPWSTR textString,
        __in_ecount(textLength) UINT16* clusterMap,
        __in_ecount(textLength) DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        UINT32 textLength,
        __in_ecount(glyphCount) UINT16* glyphIndices,
        __in_ecount(glyphCount) DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,
        UINT32 glyphCount,
        IDWriteFontFace* fontFace,
        FLOAT fontEmSize,
        BOOL isSideways,
        BOOL isRightToLeft,
        __in DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,
        __in_z_opt LPWSTR localeName,
        __in_ecount_opt(featureRanges) void* features,
        __in_ecount_opt(featureRanges) void* featureRangeLengths,
        UINT32 featureRanges,
        __out_ecount(glyphCount) FLOAT* glyphAdvances,
        __out_ecount(glyphCount) DWRITE_GLYPH_OFFSET* glyphOffsets
        ) PURE;

    /// <summary>
    /// Place glyphs output from the GetGlyphs method according to the font 
    /// and the writing system's rendering rules.
    /// </summary>
    /// <param name="textString">The original string the glyphs came from.</param>
    /// <param name="clusterMap">The mapping from character ranges to glyph 
    /// ranges. Returned by GetGlyphs.</param>
    /// <param name="textProps">Per-character properties. Returned by 
    /// GetGlyphs.</param>
    /// <param name="textLength">The length of textString.</param>
    /// <param name="glyphIndices">Glyph indices. See GetGlyphs</param>
    /// <param name="glyphProps">Per-glyph properties. See GetGlyphs</param>
    /// <param name="glyphCount">The number of glyphs.</param>
    /// <param name="fontFace">The font face the glyphs came from.</param>
    /// <param name="fontEmSize">Logical font size in DIP's.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this 
    /// value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified by the font size and pixelsPerDip.</param>
    /// <param name="useGdiNatural">
    /// When set to FALSE, the metrics are the same as the metrics of GDI aliased text.
    /// When set to TRUE, the metrics are the same as the metrics of text measured by GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY.
    /// </param>
    /// <param name="isSideways">Set to true if the text is intended to be
    /// drawn vertically.</param>
    /// <param name="isRightToLeft">Set to TRUE for right-to-left text.</param>
    /// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
    /// <param name="localeName">The locale to use when selecting glyphs.
    /// e.g. the same character may map to different glyphs for ja-jp vs zh-chs.
    /// If this is NULL then the default mapping based on the script is used.</param>
    /// <param name="features">An array of pointers to the sets of typographic 
    /// features to use in each feature range.</param>
    /// <param name="featureRangeLengths">The length of each feature range, in characters.  
    /// The sum of all lengths should be equal to textLength.</param>
    /// <param name="featureRanges">The number of feature ranges.</param>
    /// <param name="glyphAdvances">The advance width of each glyph.</param>
    /// <param name="glyphOffsets">The offset of the origin of each glyph.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Place glyphs output from the GetGlyphs method according to the font and the writing system's rendering rules.")]
    STDMETHOD(GetGdiCompatibleGlyphPlacements)(
        __in_ecount(textLength) LPWSTR textString,
        __in_ecount(textLength) UINT16* clusterMap,
        __in_ecount(textLength) DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        UINT32 textLength,
        __in_ecount(glyphCount) UINT16* glyphIndices,
        __in_ecount(glyphCount) DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,
        UINT32 glyphCount,
        IDWriteFontFace* fontFace,
        FLOAT fontEmSize,
        FLOAT pixelsPerDip,
        __in_opt void* transform,
        BOOL useGdiNatural,
        BOOL isSideways,
        BOOL isRightToLeft,
        __in DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,
        __in_z_opt LPWSTR localeName,
        __in_ecount_opt(featureRanges) void* features,
        __in_ecount_opt(featureRanges) void* featureRangeLengths,
        UINT32 featureRanges,
        __out_ecount(glyphCount) FLOAT* glyphAdvances,
        __out_ecount(glyphCount) DWRITE_GLYPH_OFFSET* glyphOffsets
        ) PURE;
};


/// <summary>
/// The IDWriteInlineObject interface wraps an application defined inline graphic,
/// allowing DWrite to query metrics as if it was a glyph inline with the text.
/// </summary>
[
    odl,
    uuid(8339FDE3-106F-47ab-8373-1C6295EB10B3),
    helpstring("The IDWriteInlineObject interface wraps an application defined inline graphic, allowing DWrite to query metrics as if it was a glyph inline with the text.")
]
interface IDWriteInlineObject : stdole.IUnknown
{
    /// <summary>
    /// The application implemented rendering callback (IDWriteTextRenderer::DrawInlineObject)
    /// can use this to draw the inline object without needing to cast or query the object
    /// type. The text layout does not call this method directly.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="renderer">The renderer passed to IDWriteTextLayout::Draw as the object's containing parent.</param>
    /// <param name="originX">X-coordinate at the top-left corner of the inline object.</param>
    /// <param name="originY">Y-coordinate at the top-left corner of the inline object.</param>
    /// <param name="isSideways">The object should be drawn on its side.</param>
    /// <param name="isRightToLeft">The object is in an right-to-left context and should be drawn flipped.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("The application implemented rendering callback (IDWriteTextRenderer::DrawInlineObject) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly.")]
    STDMETHOD(Draw)(
        void* clientDrawingContext,
        IDWriteTextRenderer* renderer,
        FLOAT originX,
        FLOAT originY,
        BOOL isSideways,
        BOOL isRightToLeft,
        IUnknown* clientDrawingEffect
        ) PURE;

    /// <summary>
    /// TextLayout calls this callback function to get the measurement of the inline object.
    /// </summary>
    /// <param name="metrics">Returned metrics</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("TextLayout calls this callback function to get the measurement of the inline object.")]
    STDMETHOD(GetMetrics)(
        [out, retval] DWRITE_INLINE_OBJECT_METRICS* metrics
        ) PURE;

    /// <summary>
    /// TextLayout calls this callback function to get the visible extents (in DIPs) of the inline object.
    /// In the case of a simple bitmap, with no padding and no overhang, all the overhangs will
    /// simply be zeroes.
    /// </summary>
    /// <param name="overhangs">Overshoot of visible extents (in DIPs) outside the object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The overhangs should be returned relative to the reported size of the object
    /// (DWRITE_INLINE_OBJECT_METRICS::width/height), and should not be baseline
    /// adjusted. If you have an image that is actually 100x100 DIPs, but you want it
    /// slightly inset (perhaps it has a glow) by 20 DIPs on each side, you would
    /// return a width/height of 60x60 and four overhangs of 20 DIPs.
    /// </remarks>
    [helpstring("TextLayout calls this callback function to get the visible extents (in DIPs) of the inline object.")]
    STDMETHOD(GetOverhangMetrics)(
        [out, retval] DWRITE_OVERHANG_METRICS* overhangs
        ) PURE;

    /// <summary>
    /// Layout uses this to determine the line breaking behavior of the inline object
    /// amidst the text.
    /// </summary>
    /// <param name="breakConditionBefore">Line-breaking condition between the object and the content immediately preceding it.</param>
    /// <param name="breakConditionAfter" >Line-breaking condition between the object and the content immediately following it.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Layout uses this to determine the line breaking behavior of the inline object amidst the text.")]
    STDMETHOD(GetBreakConditions)(
        DWRITE_BREAK_CONDITION* breakConditionBefore,
        DWRITE_BREAK_CONDITION* breakConditionAfter
        ) PURE;
};


/// <summary>
/// The IDWritePixelSnapping interface defines the pixel snapping properties of a text renderer.
/// </summary>
[
    odl,
    uuid(eaf3a2da-ecf4-4d24-b644-b34f6842024b),
    helpstring("The IDWritePixelSnapping interface defines the pixel snapping properties of a text renderer.")
]
interface IDWritePixelSnapping : stdole.IUnknown
{
    /// <summary>
    /// Determines whether pixel snapping is disabled. The recommended default is FALSE,
    /// unless doing animation that requires subpixel vertical placement.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="isDisabled">Receives TRUE if pixel snapping is disabled or FALSE if it not.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Determines whether pixel snapping is disabled. The recommended default is FALSE, unless doing animation that requires subpixel vertical placement.")]
    STDMETHOD(IsPixelSnappingDisabled)(
        void* clientDrawingContext,
        [out, retval] BOOL* isDisabled
        ) PURE;

    /// <summary>
    /// Gets the current transform that maps abstract coordinates to DIPs,
    /// which may disable pixel snapping upon any rotation or shear.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="transform">Receives the transform.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the current transform that maps abstract coordinates to DIPs, which may disable pixel snapping upon any rotation or shear.")]
    STDMETHOD(GetCurrentTransform)(
        void* clientDrawingContext,
        [out, retval] DWRITE_MATRIX* transform
        ) PURE;

    /// <summary>
    /// Gets the number of physical pixels per DIP. A DIP (device-independent pixel) is 1/96 inch,
    /// so the pixelsPerDip value is the number of logical pixels per inch divided by 96 (yielding
    /// a value of 1 for 96 DPI and 1.25 for 120).
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="pixelsPerDip">Receives the number of physical pixels per DIP.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the number of physical pixels per DIP. A DIP (device-independent pixel) is 1/96 inch, so the pixelsPerDip value is the number of logical pixels per inch divided by 96 (yieldinga value of 1 for 96 DPI and 1.25 for 120).")]
    STDMETHOD(GetPixelsPerDip)(
        void* clientDrawingContext,
        [out, retval] FLOAT* pixelsPerDip
        ) PURE;
};

/// <summary>
/// The IDWriteTextLayout interface represents a set of application-defined
/// callbacks that perform rendering of text, inline objects, and decorations
/// such as underlines.
/// </summary>
[
    odl,
    uuid(ef8a8135-5cc6-45fe-8825-c5a0724eb819),
    helpstring("The IDWriteTextLayout interface represents a set of application-defined callbacks that perform rendering of text, inline objects, and decorations such as underlines.")
]
interface IDWriteTextRenderer : IDWritePixelSnapping
{
    /// <summary>
    /// IDWriteTextLayout::Draw calls this function to instruct the client to
    /// render a run of glyphs.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to 
    /// IDWriteTextLayout::Draw.</param>
    /// <param name="baselineOriginX">X-coordinate of the baseline.</param>
    /// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
    /// <param name="measuringMode">Specifies measuring method for glyphs in the run.
    /// Renderer implementations may choose different rendering modes for given measuring methods,
    /// but best results are seen when the rendering mode matches the corresponding measuring mode:
    /// DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for DWRITE_MEASURING_MODE_NATURAL
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for DWRITE_MEASURING_MODE_GDI_CLASSIC
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for DWRITE_MEASURING_MODE_GDI_NATURAL
    /// </param>
    /// <param name="glyphRun">The glyph run to draw.</param>
    /// <param name="glyphRunDescription">Properties of the characters 
    /// associated with this run.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    /// IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("IDWriteTextLayout::Draw calls this function to instruct the client to render a run of glyphs.")]
    STDMETHOD(DrawGlyphRun)(
        void* clientDrawingContext,
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        DWRITE_MEASURING_MODE measuringMode,
        __in DWRITE_GLYPH_RUN* glyphRun,
        __in DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,
        IUnknown* clientDrawingEffect
        ) PURE;

    /// <summary>
    /// IDWriteTextLayout::Draw calls this function to instruct the client to draw
    /// an underline.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to 
    /// IDWriteTextLayout::Draw.</param>
    /// <param name="baselineOriginX">X-coordinate of the baseline.</param>
    /// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
    /// <param name="underline">Underline logical information.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    /// IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// A single underline can be broken into multiple calls, depending on
    /// how the formatting changes attributes. If font sizes/styles change
    /// within an underline, the thickness and offset will be averaged
    /// weighted according to characters.
    /// To get the correct top coordinate of the underline rect, add underline::offset
    /// to the baseline's Y. Otherwise the underline will be immediately under the text.
    /// The x coordinate will always be passed as the left side, regardless
    /// of text directionality. This simplifies drawing and reduces the
    /// problem of round-off that could potentially cause gaps or a double
    /// stamped alpha blend. To avoid alpha overlap, round the end points
    /// to the nearest device pixel.
    /// </remarks>
    [helpstring("IDWriteTextLayout::Draw calls this function to instruct the client to draw an underline.")]
    STDMETHOD(DrawUnderline)(
        void* clientDrawingContext,
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        __in DWRITE_UNDERLINE* underline,
        IUnknown* clientDrawingEffect
        ) PURE;

    /// <summary>
    /// IDWriteTextLayout::Draw calls this function to instruct the client to draw
    /// a strikethrough.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to 
    /// IDWriteTextLayout::Draw.</param>
    /// <param name="baselineOriginX">X-coordinate of the baseline.</param>
    /// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
    /// <param name="strikethrough">Strikethrough logical information.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    /// IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// A single strikethrough can be broken into multiple calls, depending on
    /// how the formatting changes attributes. Strikethrough is not averaged
    /// across font sizes/styles changes.
    /// To get the correct top coordinate of the strikethrough rect,
    /// add strikethrough::offset to the baseline's Y.
    /// Like underlines, the x coordinate will always be passed as the left side,
    /// regardless of text directionality.
    /// </remarks>
    [helpstring("IDWriteTextLayout::Draw calls this function to instruct the client to draw a strikethrough.")]
    STDMETHOD(DrawStrikethrough)(
        void* clientDrawingContext,
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        __in DWRITE_STRIKETHROUGH* strikethrough,
        IUnknown* clientDrawingEffect
        ) PURE;

    /// <summary>
    /// IDWriteTextLayout::Draw calls this application callback when it needs to
    /// draw an inline object.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="originX">X-coordinate at the top-left corner of the inline object.</param>
    /// <param name="originY">Y-coordinate at the top-left corner of the inline object.</param>
    /// <param name="inlineObject">The object set using IDWriteTextLayout::SetInlineObject.</param>
    /// <param name="isSideways">The object should be drawn on its side.</param>
    /// <param name="isRightToLeft">The object is in an right-to-left context and should be drawn flipped.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    /// IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The right-to-left flag is a hint for those cases where it would look
    /// strange for the image to be shown normally (like an arrow pointing to
    /// right to indicate a submenu).
    /// </remarks>
    [helpstring("IDWriteTextLayout::Draw calls this application callback when it needs to draw an inline object.")]
    STDMETHOD(DrawInlineObject)(
        void* clientDrawingContext,
        FLOAT originX,
        FLOAT originY,
        IDWriteInlineObject* inlineObject,
        BOOL isSideways,
        BOOL isRightToLeft,
        IUnknown* clientDrawingEffect
        ) PURE;
};


/// <summary>
/// The IDWriteTextLayout interface represents a block of text after it has
/// been fully analyzed and formatted.
///
/// All coordinates are in device independent pixels (DIPs).
/// </summary>
[
    odl,
    uuid(53737037-6d14-410b-9bfe-0b182bb70961),
    helpstring("The IDWriteTextLayout interface represents a block of text after it has been fully analyzed and formatted.")
]
interface IDWriteTextLayout : IDWriteTextFormat
{
    /// <summary>
    /// Set layout maximum width
    /// </summary>
    /// <param name="maxWidth">Layout maximum width</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set layout maximum width")]
    STDMETHOD(SetMaxWidth)(
        FLOAT maxWidth
        ) PURE;

    /// <summary>
    /// Set layout maximum height
    /// </summary>
    /// <param name="maxHeight">Layout maximum height</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set layout maximum height")]
    STDMETHOD(SetMaxHeight)(
        FLOAT maxHeight
        ) PURE;

    /// <summary>
    /// Set the font collection.
    /// </summary>
    /// <param name="fontCollection">The font collection to set</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set the font collection.")]
    STDMETHOD(SetFontCollection)(
        IDWriteFontCollection* fontCollection,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set null-terminated font family name.
    /// </summary>
    /// <param name="fontFamilyName">Font family name</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set null-terminated font family name.")]
    STDMETHOD(SetFontFamilyName)(
        LPWSTR fontFamilyName,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set font weight.
    /// </summary>
    /// <param name="fontWeight">Font weight</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set font weight.")]
    STDMETHOD(SetFontWeight)(
        DWRITE_FONT_WEIGHT fontWeight,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set font style.
    /// </summary>
    /// <param name="fontStyle">Font style</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set font style.")]
    STDMETHOD(SetFontStyle)(
        DWRITE_FONT_STYLE fontStyle,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set font stretch.
    /// </summary>
    /// <param name="fontStretch">font stretch</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set font stretch.")]
    STDMETHOD(SetFontStretch)(
        DWRITE_FONT_STRETCH fontStretch,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set font em height.
    /// </summary>
    /// <param name="fontSize">Font em height</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set font em height.")]
    STDMETHOD(SetFontSize)(
        FLOAT fontSize,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set underline.
    /// </summary>
    /// <param name="hasUnderline">The Boolean flag indicates whether underline takes place</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set underline.")]
    STDMETHOD(SetUnderline)(
        BOOL hasUnderline,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set strikethrough.
    /// </summary>
    /// <param name="hasStrikethrough">The Boolean flag indicates whether strikethrough takes place</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set strikethrough.")]
    STDMETHOD(SetStrikethrough)(
        BOOL hasStrikethrough,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set application-defined drawing effect.
    /// </summary>
    /// <param name="drawingEffect">Pointer to an application-defined drawing effect.</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This drawing effect is associated with the specified range and will be passed back
    /// to the application via the callback when the range is drawn at drawing time.
    /// </remarks>
    [helpstring("Set application-defined drawing effect.")]
    STDMETHOD(SetDrawingEffect)(
        IUnknown* drawingEffect,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set inline object.
    /// </summary>
    /// <param name="inlineObject">Pointer to an application-implemented inline object.</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This inline object applies to the specified range and will be passed back
    /// to the application via the DrawInlineObject callback when the range is drawn.
    /// Any text in that range will be suppressed.
    /// </remarks>
    [helpstring("Set inline object.")]
    STDMETHOD(SetInlineObject)(
        IDWriteInlineObject* inlineObject,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set font typography features.
    /// </summary>
    /// <param name="typography">Pointer to font typography setting.</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set font typography features.")]
    STDMETHOD(SetTypography)(
        IDWriteTypography* typography,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Set locale name.
    /// </summary>
    /// <param name="localeName">Locale name</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Set locale name.")]
    STDMETHOD(SetLocaleName)(
        LPWSTR localeName,
        long textRange_startPosition,
        long textRange_length
        ) PURE;

    /// <summary>
    /// Get layout maximum width
    /// </summary>
    [helpstring("Get layout maximum width.")]
    STDMETHOD_(FLOAT, GetMaxWidth)() PURE;

    /// <summary>
    /// Get layout maximum height
    /// </summary>
    [helpstring("Get layout maximum height.")]
    STDMETHOD_(FLOAT, GetMaxHeight)() PURE;

    /// <summary>
    /// Get the font collection where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontCollection">The current font collection</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the font collection where the current position is at.")]
    STDMETHOD(GetFontCollection)(
        UINT32 currentPosition,
        [out] IDWriteFontCollection** fontCollection,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the length of the font family name where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="nameLength">Size of the character array in character count not including the terminated NULL character.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the length of the font family name where the current position is at.")]
    STDMETHOD(GetFontFamilyNameLength)(
        UINT32 currentPosition,
        UINT32* nameLength,
        void* textRange
        ) PURE;

    /// <summary>
    /// Copy the font family name where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontFamilyName">Character array that receives the current font family name</param>
    /// <param name="nameSize">Size of the character array in character count including the terminated NULL character.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Copy the font family name where the current position is at.")]
    STDMETHOD(GetFontFamilyName)(
        UINT32 currentPosition,
        LPWSTR fontFamilyName,
        UINT32 nameSize,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the font weight where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontWeight">The current font weight</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the font weight where the current position is at.")]
    STDMETHOD(GetFontWeight)(
        UINT32 currentPosition,
        DWRITE_FONT_WEIGHT* fontWeight,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the font style where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontStyle">The current font style</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the font style where the current position is at.")]
    STDMETHOD(GetFontStyle)(
        UINT32 currentPosition,
        DWRITE_FONT_STYLE* fontStyle,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the font stretch where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontStretch">The current font stretch</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the font stretch where the current position is at.")]
    STDMETHOD(GetFontStretch)(
        UINT32 currentPosition,
        DWRITE_FONT_STRETCH* fontStretch,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the font em height where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontSize">The current font em height</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the font em height where the current position is at.")]
    STDMETHOD(GetFontSize)(
        UINT32 currentPosition,
        FLOAT* fontSize,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the underline presence where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="hasUnderline">The Boolean flag indicates whether text is underlined.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the underline presence where the current position is at.")]
    STDMETHOD(GetUnderline)(
        UINT32 currentPosition,
        BOOL* hasUnderline,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the strikethrough presence where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="hasStrikethrough">The Boolean flag indicates whether text has strikethrough.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the strikethrough presence where the current position is at.")]
    STDMETHOD(GetStrikethrough)(
        UINT32 currentPosition,
        BOOL* hasStrikethrough,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the application-defined drawing effect where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="drawingEffect">The current application-defined drawing effect.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the application-defined drawing effect where the current position is at.")]
    STDMETHOD(GetDrawingEffect)(
        UINT32 currentPosition,
        [out] IUnknown** drawingEffect,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the inline object at the given position.
    /// </summary>
    /// <param name="currentPosition">The given text position.</param>
    /// <param name="inlineObject">The inline object.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the inline object at the given position.")]
    STDMETHOD(GetInlineObject)(
        UINT32 currentPosition,
        [out] IDWriteInlineObject** inlineObject,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the typography setting where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="typography">The current typography setting.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the typography setting where the current position is at.")]
    STDMETHOD(GetTypography)(
        UINT32 currentPosition,
        [out] IDWriteTypography** typography,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the length of the locale name where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="nameLength">Size of the character array in character count not including the terminated NULL character.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the length of the locale name where the current position is at.")]
    STDMETHOD(GetLocaleNameLength)(
        UINT32 currentPosition,
        UINT32* nameLength,
        void* textRange
        ) PURE;

    /// <summary>
    /// Get the locale name where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="localeName">Character array that receives the current locale name</param>
    /// <param name="nameSize">Size of the character array in character count including the terminated NULL character.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Get the locale name where the current position is at.")]
    STDMETHOD(GetLocaleName)(
        UINT32 currentPosition,
        LPWSTR localeName,
        UINT32 nameSize,
        void* textRange
        ) PURE;

    /// <summary>
    /// Initiate drawing of the text.
    /// </summary>
    /// <param name="clientDrawingContext">An application defined value
    /// included in rendering callbacks.</param>
    /// <param name="renderer">The set of application-defined callbacks that do
    /// the actual rendering.</param>
    /// <param name="originX">X-coordinate of the layout's left side.</param>
    /// <param name="originY">Y-coordinate of the layout's top side.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Initiate drawing of the text.")]
    STDMETHOD(Draw)(
        void* clientDrawingContext,
        IDWriteTextRenderer* renderer,
        FLOAT originX,
        FLOAT originY
        ) PURE;

    /// <summary>
    /// GetLineMetrics returns properties of each line.
    /// </summary>
    /// <param name="lineMetrics">The array to fill with line information.</param>
    /// <param name="maxLineCount">The maximum size of the lineMetrics array.</param>
    /// <param name="actualLineCount">The actual size of the lineMetrics
    /// array that is needed.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// If maxLineCount is not large enough E_NOT_SUFFICIENT_BUFFER, 
    /// which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),
    /// is returned and *actualLineCount is set to the number of lines
    /// needed.
    /// </remarks>
    [helpstring("GetLineMetrics returns properties of each line.")]
    STDMETHOD(GetLineMetrics)(
        DWRITE_LINE_METRICS* lineMetrics,
        UINT32 maxLineCount,
        [out, retval] UINT32* actualLineCount
        ) PURE;

    /// <summary>
    /// GetMetrics retrieves overall metrics for the formatted string.
    /// </summary>
    /// <param name="textMetrics">The returned metrics.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Drawing effects like underline and strikethrough do not contribute
    /// to the text size, which is essentially the sum of advance widths and
    /// line heights. Additionally, visible swashes and other graphic
    /// adornments may extend outside the returned width and height.
    /// </remarks>
    [helpstring("GetMetrics retrieves overall metrics for the formatted string.")]
    STDMETHOD(GetMetrics)(
        [out, retval] DWRITE_TEXT_METRICS* textMetrics
        ) PURE;

    /// <summary>
    /// GetOverhangMetrics returns the overhangs (in DIPs) of the layout and all
    /// objects contained in it, including text glyphs and inline objects.
    /// </summary>
    /// <param name="overhangs">Overshoots of visible extents (in DIPs) outside the layout.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Any underline and strikethrough do not contribute to the black box
    /// determination, since these are actually drawn by the renderer, which
    /// is allowed to draw them in any variety of styles.
    /// </remarks>
    [helpstring("GetOverhangMetrics returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.")]
    STDMETHOD(GetOverhangMetrics)(
        [out, retval] DWRITE_OVERHANG_METRICS* overhangs
        ) PURE;

    /// <summary>
    /// Retrieve logical properties and measurement of each cluster.
    /// </summary>
    /// <param name="clusterMetrics">The array to fill with cluster information.</param>
    /// <param name="maxClusterCount">The maximum size of the clusterMetrics array.</param>
    /// <param name="actualClusterCount">The actual size of the clusterMetrics array that is needed.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// If maxClusterCount is not large enough E_NOT_SUFFICIENT_BUFFER, 
    /// which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), 
    /// is returned and *actualClusterCount is set to the number of clusters
    /// needed.
    /// </remarks>
    [helpstring("Retrieve logical properties and measurement of each cluster.")]
    STDMETHOD(GetClusterMetrics)(
        DWRITE_CLUSTER_METRICS* clusterMetrics,
        UINT32 maxClusterCount,
        [out, retval] UINT32* actualClusterCount
        ) PURE;

    /// <summary>
    /// Determines the minimum possible width the layout can be set to without
    /// emergency breaking between the characters of whole words.
    /// </summary>
    /// <param name="minWidth">Minimum width.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Determines the minimum possible width the layout can be set to without emergency breaking between the characters of whole words.")]
    STDMETHOD(DetermineMinWidth)(
        [out, retval] FLOAT* minWidth
        ) PURE;

    /// <summary>
    /// Given a coordinate (in DIPs) relative to the top-left of the layout box,
    /// this returns the corresponding hit-test metrics of the text string where
    /// the hit-test has occurred. This is useful for mapping mouse clicks to caret
    /// positions. When the given coordinate is outside the text string, the function
    /// sets the output value *isInside to false but returns the nearest character
    /// position.
    /// </summary>
    /// <param name="pointX">X coordinate to hit-test, relative to the top-left location of the layout box.</param>
    /// <param name="pointY">Y coordinate to hit-test, relative to the top-left location of the layout box.</param>
    /// <param name="isTrailingHit">Output flag indicating whether the hit-test location is at the leading or the trailing
    ///     side of the character. When the output *isInside value is set to false, this value is set according to the output
    ///     *position value to represent the edge closest to the hit-test location. </param>
    /// <param name="isInside">Output flag indicating whether the hit-test location is inside the text string.
    ///     When false, the position nearest the text's edge is returned.</param>
    /// <param name="hitTestMetrics">Output geometry fully enclosing the hit-test location. When the output *isInside value
    ///     is set to false, this structure represents the geometry enclosing the edge closest to the hit-test location.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Given a coordinate (in DIPs) relative to the top-left of the layout box, this returns the corresponding hit-test metrics of the text string where the hit-test has occurred.")]
    STDMETHOD(HitTestPoint)(
        FLOAT pointX,
        FLOAT pointY,
        BOOL* isTrailingHit,
        BOOL* isInside,
        DWRITE_HIT_TEST_METRICS* hitTestMetrics
        ) PURE;

    /// <summary>
    /// Given a text position and whether the caret is on the leading or trailing
    /// edge of that position, this returns the corresponding coordinate (in DIPs)
    /// relative to the top-left of the layout box. This is most useful for drawing
    /// the caret's current position, but it could also be used to anchor an IME to the
    /// typed text or attach a floating menu near the point of interest. It may also be
    /// used to programmatically obtain the geometry of a particular text position
    /// for UI automation.
    /// </summary>
    /// <param name="textPosition">Text position to get the coordinate of.</param>
    /// <param name="isTrailingHit">Flag indicating whether the location is of the leading or the trailing side of the specified text position. </param>
    /// <param name="pointX">Output caret X, relative to the top-left of the layout box.</param>
    /// <param name="pointY">Output caret Y, relative to the top-left of the layout box.</param>
    /// <param name="hitTestMetrics">Output geometry fully enclosing the specified text position.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// When drawing a caret at the returned X,Y, it should should be centered on X
    /// and drawn from the Y coordinate down. The height will be the size of the
    /// hit-tested text (which can vary in size within a line).
    /// Reading direction also affects which side of the character the caret is drawn.
    /// However, the returned X coordinate will be correct for either case.
    /// You can get a text length back that is larger than a single character.
    /// This happens for complex scripts when multiple characters form a single cluster,
    /// when diacritics join their base character, or when you test a surrogate pair.
    /// </remarks>
    [helpstring("Given a text position and whether the caret is on the leading or trailing edge of that position, this returns the corresponding coordinate (in DIPs) relative to the top-left of the layout box.")]
    STDMETHOD(HitTestTextPosition)(
        UINT32 textPosition,
        BOOL isTrailingHit,
        FLOAT* pointX,
        FLOAT* pointY,
        DWRITE_HIT_TEST_METRICS* hitTestMetrics
        ) PURE;

    /// <summary>
    /// The application calls this function to get a set of hit-test metrics
    /// corresponding to a range of text positions. The main usage for this
    /// is to draw highlighted selection of the text string.
    ///
    /// The function returns E_NOT_SUFFICIENT_BUFFER, which is equivalent to 
    /// HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), when the buffer size of
    /// hitTestMetrics is too small to hold all the regions calculated by the
    /// function. In such situation, the function sets the output value
    /// *actualHitTestMetricsCount to the number of geometries calculated.
    /// The application is responsible to allocate a new buffer of greater
    /// size and call the function again.
    ///
    /// A good value to use as an initial value for maxHitTestMetricsCount may
    /// be calculated from the following equation:
    ///     maxHitTestMetricsCount = lineCount * maxBidiReorderingDepth
    ///
    /// where lineCount is obtained from the value of the output argument
    /// *actualLineCount from the function IDWriteTextLayout::GetLineMetrics,
    /// and the maxBidiReorderingDepth value from the DWRITE_TEXT_METRICS
    /// structure of the output argument *textMetrics from the function
    /// IDWriteFactory::CreateTextLayout.
    /// </summary>
    /// <param name="textPosition">First text position of the specified range.</param>
    /// <param name="textLength">Number of positions of the specified range.</param>
    /// <param name="originX">Offset of the X origin (left of the layout box) which is added to each of the hit-test metrics returned.</param>
    /// <param name="originY">Offset of the Y origin (top of the layout box) which is added to each of the hit-test metrics returned.</param>
    /// <param name="hitTestMetrics">Pointer to a buffer of the output geometry fully enclosing the specified position range.</param>
    /// <param name="maxHitTestMetricsCount">Maximum number of distinct metrics it could hold in its buffer memory.</param>
    /// <param name="actualHitTestMetricsCount">Actual number of metrics returned or needed.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// There are no gaps in the returned metrics. While there could be visual gaps,
    /// depending on bidi ordering, each range is contiguous and reports all the text,
    /// including any hidden characters and trimmed text.
    /// The height of each returned range will be the same within each line, regardless
    /// of how the font sizes vary.
    /// </remarks>
    [helpstring("The application calls this function to get a set of hit-test metrics corresponding to a range of text positions.")]
    STDMETHOD(HitTestTextRange)(
        UINT32 textPosition,
        UINT32 textLength,
        FLOAT originX,
        FLOAT originY,
        DWRITE_HIT_TEST_METRICS* hitTestMetrics,
        UINT32 maxHitTestMetricsCount,
        UINT32* actualHitTestMetricsCount
        ) PURE;
};

/// <summary>
/// Encapsulates a 32-bit device independent bitmap and device context, which can be used for rendering glyphs.
/// </summary>
[
    odl,
    uuid(5e5a32a3-8dff-4773-9ff6-0696eab77267),
    helpstring("Encapsulates a 32-bit device independent bitmap and device context, which can be used for rendering glyphs.")
]
interface IDWriteBitmapRenderTarget : stdole.IUnknown
{
    /// <summary>
    /// Draws a run of glyphs to the bitmap.
    /// </summary>
    /// <param name="baselineOriginX">Horizontal position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</param>
    /// <param name="baselineOriginY">Vertical position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</param>
    /// <param name="measuringMode">Specifies measuring method for glyphs in the run.
    /// Renderer implementations may choose different rendering modes for different measuring methods, for example
    /// DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for DWRITE_MEASURING_MODE_NATURAL,
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for DWRITE_MEASURING_MODE_GDI_CLASSIC, and
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for DWRITE_MEASURING_MODE_GDI_NATURAL.
    /// </param>
    /// <param name="glyphRun">Structure containing the properties of the glyph run.</param>
    /// <param name="renderingParams">Object that controls rendering behavior.</param>
    /// <param name="textColor">Specifies the foreground color of the text.</param>
    /// <param name="blackBoxRect">Optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by 
    /// drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Draws a run of glyphs to the bitmap.")]
    STDMETHOD(DrawGlyphRun)(
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        DWRITE_MEASURING_MODE measuringMode,
        __in DWRITE_GLYPH_RUN* glyphRun,
        IDWriteRenderingParams* renderingParams,
        COLORREF textColor,
        void* blackBoxRect
        ) PURE;

    /// <summary>
    /// Gets a handle to the memory device context.
    /// </summary>
    /// <returns>
    /// Returns the device context handle.
    /// </returns>
    /// <remarks>
    /// An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle
    /// (HBITMAP) by calling GetCurrentObject. An application that wants information about the underlying bitmap, including
    /// a pointer to the pixel data, can call GetObject to fill in a DIBSECTION structure. The bitmap is always a 32-bit 
    /// top-down DIB.
    /// </remarks>
    [helpstring("Gets a handle to the memory device context.")]
    STDMETHOD_(HDC, GetMemoryDC)() PURE;

    /// <summary>
    /// Gets the number of bitmap pixels per DIP. A DIP (device-independent pixel) is 1/96 inch so this value is the number
    /// if pixels per inch divided by 96.
    /// </summary>
    /// <returns>
    /// Returns the number of bitmap pixels per DIP.
    /// </returns>
    [helpstring("Gets the number of bitmap pixels per DIP. A DIP (device-independent pixel) is 1/96 inch so this value is the number if pixels per inch divided by 96.")]
    STDMETHOD_(FLOAT, GetPixelsPerDip)() PURE;

    /// <summary>
    /// Sets the number of bitmap pixels per DIP. A DIP (device-independent pixel) is 1/96 inch so this value is the number
    /// if pixels per inch divided by 96.
    /// </summary>
    /// <param name="pixelsPerDip">Specifies the number of pixels per DIP.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Sets the number of bitmap pixels per DIP. A DIP (device-independent pixel) is 1/96 inch so this value is the number if pixels per inch divided by 96.")]
    STDMETHOD(SetPixelsPerDip)(
        FLOAT pixelsPerDip
        ) PURE;

    /// <summary>
    /// Gets the transform that maps abstract coordinate to DIPs. By default this is the identity 
    /// transform. Note that this is unrelated to the world transform of the underlying device
    /// context.
    /// </summary>
    /// <param name="transform">Receives the transform.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the transform that maps abstract coordinate to DIPs. By default this is the identity transform.")]
    STDMETHOD(GetCurrentTransform)(
        [out, retval] DWRITE_MATRIX* transform
        ) PURE;

    /// <summary>
    /// Sets the transform that maps abstract coordinate to DIPs. This does not affect the world
    /// transform of the underlying device context.
    /// </summary>
    /// <param name="transform">Specifies the new transform. This parameter can be NULL, in which
    /// case the identity transform is implied.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Sets the transform that maps abstract coordinate to DIPs. This does not affect the world transform of the underlying device context.")]
    STDMETHOD(SetCurrentTransform)(
        void* transform
        ) PURE;

    /// <summary>
    /// Gets the dimensions of the bitmap.
    /// </summary>
    /// <param name="size">Receives the size of the bitmap in pixels.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the dimensions of the bitmap.")]
    STDMETHOD(GetSize)(
        [out, retval] SIZE* size
        ) PURE;

    /// <summary>
    /// Resizes the bitmap.
    /// </summary>
    /// <param name="width">New bitmap width, in pixels.</param>
    /// <param name="height">New bitmap height, in pixels.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Resizes the bitmap.")]
    STDMETHOD(Resize)(
        UINT32 width,
        UINT32 height
        ) PURE;
};


/// <summary>
/// The GDI interop interface provides interoperability with GDI.
/// </summary>
[
    odl,
    uuid(1edd9491-9853-4299-898f-6432983b6f3a),
    helpstring("The GDI interop interface provides interoperability with GDI.")
]
interface IDWriteGdiInterop : stdole.IUnknown
{
    /// <summary>
    /// Creates a font object that matches the properties specified by the LOGFONT structure.
    /// </summary>
    /// <param name="logFont">Structure containing a GDI-compatible font description.</param>
    /// <param name="font">Receives a newly created font object if successful, or NULL in case of error.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a font object that matches the properties specified by the LOGFONT structure.")]
    STDMETHOD(CreateFontFromLOGFONT)(
        __in LOGFONTW* logFont,
        [out, retval] IDWriteFont** font
        ) PURE;

    /// <summary>
    /// Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font.
    /// </summary>
    /// <param name="font">Specifies a font in the system font collection.</param>
    /// <param name="logFont">Structure that receives a GDI-compatible font description.</param>
    /// <param name="isSystemFont">Contains TRUE if the specified font object is part of the system font collection
    /// or FALSE otherwise.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font.")]
    STDMETHOD(ConvertFontToLOGFONT)(
        IDWriteFont* font,
        LOGFONTW* logFont,
        [out, retval] BOOL* isSystemFont
        ) PURE;

    /// <summary>
    /// Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font.
    /// </summary>
    /// <param name="font">Specifies a font face.</param>
    /// <param name="logFont">Structure that receives a GDI-compatible font description.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font.")]
    STDMETHOD(ConvertFontFaceToLOGFONT)(
        IDWriteFontFace* font,
        LOGFONTW* logFont
        ) PURE;

    /// <summary>
    /// Creates a font face object that corresponds to the currently selected HFONT.
    /// </summary>
    /// <param name="hdc">Handle to a device context into which a font has been selected. It is assumed that the client
    /// has already performed font mapping and that the font selected into the DC is the actual font that would be used 
    /// for rendering glyphs.</param>
    /// <param name="fontFace">Contains the newly created font face object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a font face object that corresponds to the currently selected HFONT.")]
    STDMETHOD(CreateFontFaceFromHdc)(
        HDC hdc,
        [out, retval] IDWriteFontFace** fontFace
        ) PURE;

    /// <summary>
    /// Creates an object that encapsulates a bitmap and memory DC which can be used for rendering glyphs.
    /// </summary>
    /// <param name="hdc">Optional device context used to create a compatible memory DC.</param>
    /// <param name="width">Width of the bitmap.</param>
    /// <param name="height">Height of the bitmap.</param>
    /// <param name="renderTarget">Receives a pointer to the newly created render target.</param>
    [helpstring("Creates an object that encapsulates a bitmap and memory DC which can be used for rendering glyphs.")]
    STDMETHOD(CreateBitmapRenderTarget)(
        __in_opt HDC hdc,
        UINT32 width,
        UINT32 height,
        [out, retval] IDWriteBitmapRenderTarget** renderTarget
        ) PURE;
};


/// <summary>
/// Interface that encapsulates information used to render a glyph run.
/// </summary>
[
    odl,
    uuid(7d97dbf7-e085-42d4-81e3-6a883bded118),
    helpstring("Interface that encapsulates information used to render a glyph run.")
]
interface IDWriteGlyphRunAnalysis : stdole.IUnknown
{
    /// <summary>
    /// Gets the bounding rectangle of the physical pixels affected by the glyph run.
    /// </summary>
    /// <param name="textureType">Specifies the type of texture requested. If a bi-level texture is requested, the
    /// bounding rectangle includes only bi-level glyphs. Otherwise, the bounding rectangle includes only anti-aliased
    /// glyphs.</param>
    /// <param name="textureBounds">Receives the bounding rectangle, or an empty rectangle if there are no glyphs
    /// if the specified type.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets the bounding rectangle of the physical pixels affected by the glyph run.")]
    STDMETHOD(GetAlphaTextureBounds)(
        DWRITE_TEXTURE_TYPE textureType,
        [out, retval] RECT* textureBounds
        ) PURE;

    /// <summary>
    /// Creates an alpha texture of the specified type.
    /// </summary>
    /// <param name="textureType">Specifies the type of texture requested. If a bi-level texture is requested, the
    /// texture contains only bi-level glyphs. Otherwise, the texture contains only anti-aliased glyphs.</param>
    /// <param name="textureBounds">Specifies the bounding rectangle of the texture, which can be different than
    /// the bounding rectangle returned by GetAlphaTextureBounds.</param>
    /// <param name="alphaValues">Receives the array of alpha values.</param>
    /// <param name="bufferSize">Size of the alphaValues array. The minimum size depends on the dimensions of the
    /// rectangle and the type of texture requested.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates an alpha texture of the specified type.")]
    STDMETHOD(CreateAlphaTexture)(
        DWRITE_TEXTURE_TYPE textureType,
        __in RECT* textureBounds,
        void* alphaValues,
        UINT32 bufferSize
        ) PURE;

    /// <summary>
    /// Gets properties required for ClearType blending.
    /// </summary>
    /// <param name="renderingParams">Rendering parameters object. In most cases, the values returned in the output
    /// parameters are based on the properties of this object. The exception is if a GDI-compatible rendering mode
    /// is specified.</param>
    /// <param name="blendGamma">Receives the gamma value to use for gamma correction.</param>
    /// <param name="blendEnhancedContrast">Receives the enhanced contrast value.</param>
    /// <param name="blendClearTypeLevel">Receives the ClearType level.</param>
    [helpstring("Gets properties required for ClearType blending.")]
    STDMETHOD(GetAlphaBlendParams)(
        IDWriteRenderingParams* renderingParams,
        FLOAT* blendGamma,
        FLOAT* blendEnhancedContrast,
        FLOAT* blendClearTypeLevel
        ) PURE;
};

/// <summary>
/// The root factory interface for all DWrite objects.
/// </summary>
[
    odl,
    uuid(b859ee5a-d838-4b5b-a2e8-1adc7d93db48),
    helpstring("The root factory interface for all DWrite objects.")
]
interface IDWriteFactory : stdole.IUnknown
{
    /// <summary>
    /// Gets a font collection representing the set of installed fonts.
    /// </summary>
    /// <param name="fontCollection">Receives a pointer to the system font collection object, or NULL in case of failure.</param>
    /// <param name="checkForUpdates">If this parameter is nonzero, the function performs an immediate check for changes to the set of
    /// installed fonts. If this parameter is FALSE, the function will still detect changes if the font cache service is running, but
    /// there may be some latency. For example, an application might specify TRUE if it has itself just installed a font and wants to 
    /// be sure the font collection contains that font.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Gets a font collection representing the set of installed fonts.")]
    STDMETHOD(GetSystemFontCollection)(
        [out] IDWriteFontCollection** fontCollection,
        [optional, defaultvalue(FALSE)] BOOL checkForUpdates
        ) PURE;

    /// <summary>
    /// Creates a font collection using a custom font collection loader.
    /// </summary>
    /// <param name="collectionLoader">Application-defined font collection loader, which must have been previously
    /// registered using RegisterFontCollectionLoader.</param>
    /// <param name="collectionKey">Key used by the loader to identify a collection of font files.</param>
    /// <param name="collectionKeySize">Size in bytes of the collection key.</param>
    /// <param name="fontCollection">Receives a pointer to the system font collection object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a font collection using a custom font collection loader.")]
    STDMETHOD(CreateCustomFontCollection)(
        IDWriteFontCollectionLoader* collectionLoader,
        void* collectionKey,
        UINT32 collectionKeySize,
        [out, retval] IDWriteFontCollection** fontCollection
        ) PURE;

    /// <summary>
    /// Registers a custom font collection loader with the factory object.
    /// </summary>
    /// <param name="fontCollectionLoader">Application-defined font collection loader.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Registers a custom font collection loader with the factory object.")]
    STDMETHOD(RegisterFontCollectionLoader)(
        IDWriteFontCollectionLoader* fontCollectionLoader
        ) PURE;

    /// <summary>
    /// Unregisters a custom font collection loader that was previously registered using RegisterFontCollectionLoader.
    /// </summary>
    /// <param name="fontCollectionLoader">Application-defined font collection loader.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Unregisters a custom font collection loader that was previously registered using RegisterFontCollectionLoader.")]
    STDMETHOD(UnregisterFontCollectionLoader)(
        IDWriteFontCollectionLoader* fontCollectionLoader
        ) PURE;

    /// <summary>
    /// CreateFontFileReference creates a font file reference object from a local font file.
    /// </summary>
    /// <param name="filePath">Absolute file path. Subsequent operations on the constructed object may fail
    /// if the user provided filePath doesn't correspond to a valid file on the disk.</param>
    /// <param name="lastWriteTime">Last modified time of the input file path. If the parameter is omitted,
    /// the function will access the font file to obtain its last write time, so the clients are encouraged to specify this value
    /// to avoid extra disk access. Subsequent operations on the constructed object may fail
    /// if the user provided lastWriteTime doesn't match the file on the disk.</param>
    /// <param name="fontFile">Contains newly created font file reference object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("CreateFontFileReference creates a font file reference object from a local font file.")]
    STDMETHOD(CreateFontFileReference)(
        LPWSTR filePath,
        __in_opt FILETIME* lastWriteTime,
        [out, retval] IDWriteFontFile** fontFile
        ) PURE;

    /// <summary>
    /// CreateCustomFontFileReference creates a reference to an application specific font file resource.
    /// This function enables an application or a document to use a font without having to install it on the system.
    /// The fontFileReferenceKey has to be unique only in the scope of the fontFileLoader used in this call.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the font file resource
    /// during the lifetime of fontFileLoader.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="fontFileLoader">Font file loader that will be used by the font system to load data from the file identified by
    /// fontFileReferenceKey.</param>
    /// <param name="fontFile">Contains the newly created font file object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This function is provided for cases when an application or a document needs to use a font
    /// without having to install it on the system. fontFileReferenceKey has to be unique only in the scope
    /// of the fontFileLoader used in this call.
    /// </remarks>
    [helpstring("CreateCustomFontFileReference creates a reference to an application specific font file resource.")]
    STDMETHOD(CreateCustomFontFileReference)(
        void* fontFileReferenceKey,
        UINT32 fontFileReferenceKeySize,
        IDWriteFontFileLoader* fontFileLoader,
        [out, retval] IDWriteFontFile** fontFile
        ) PURE;

    /// <summary>
    /// Creates a font face object.
    /// </summary>
    /// <param name="fontFaceType">The file format of the font face.</param>
    /// <param name="numberOfFiles">The number of font files require to represent the font face.</param>
    /// <param name="fontFiles">Font files representing the font face. Since IDWriteFontFace maintains its own references
    /// to the input font file objects, it's OK to release them after this call.</param>
    /// <param name="faceIndex">The zero based index of a font face in cases when the font files contain a collection of font faces.
    /// If the font files contain a single face, this value should be zero.</param>
    /// <param name="fontFaceSimulationFlags">Font face simulation flags for algorithmic emboldening and italicization.</param>
    /// <param name="fontFace">Contains the newly created font face object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a font face object.")]
    STDMETHOD(CreateFontFace)(
        DWRITE_FONT_FACE_TYPE fontFaceType,
        UINT32 numberOfFiles,
        IDWriteFontFile* fontFiles,
        UINT32 faceIndex,
        DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,
        [out, retval] IDWriteFontFace** fontFace
        ) PURE;

    /// <summary>
    /// Creates a rendering parameters object with default settings for the primary monitor.
    /// </summary>
    /// <param name="renderingParams">Holds the newly created rendering parameters object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a rendering parameters object with default settings for the primary monitor.")]
    STDMETHOD(CreateRenderingParams)(
        [out, retval] IDWriteRenderingParams** renderingParams
        ) PURE;

    /// <summary>
    /// Creates a rendering parameters object with default settings for the specified monitor.
    /// </summary>
    /// <param name="monitor">The monitor to read the default values from.</param>
    /// <param name="renderingParams">Holds the newly created rendering parameters object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a rendering parameters object with default settings for the specified monitor.")]
    STDMETHOD(CreateMonitorRenderingParams)(
        HMONITOR monitor,
        [out, retval] IDWriteRenderingParams** renderingParams
        ) PURE;

    /// <summary>
    /// Creates a rendering parameters object with the specified properties.
    /// </summary>
    /// <param name="gamma">The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</param>
    /// <param name="enhancedContrast">The amount of contrast enhancement, zero or greater.</param>
    /// <param name="clearTypeLevel">The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</param>
    /// <param name="pixelGeometry">The geometry of a device pixel.</param>
    /// <param name="renderingMode">Method of rendering glyphs. In most cases, this should be DWRITE_RENDERING_MODE_DEFAULT to automatically use an appropriate mode.</param>
    /// <param name="renderingParams">Holds the newly created rendering parameters object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a rendering parameters object with the specified properties.")]
    STDMETHOD(CreateCustomRenderingParams)(
        FLOAT gamma,
        FLOAT enhancedContrast,
        FLOAT clearTypeLevel,
        DWRITE_PIXEL_GEOMETRY pixelGeometry,
        DWRITE_RENDERING_MODE renderingMode,
        [out, retval] IDWriteRenderingParams** renderingParams
        ) PURE;

    /// <summary>
    /// Registers a font file loader with DirectWrite.
    /// </summary>
    /// <param name="fontFileLoader">Pointer to the implementation of the IDWriteFontFileLoader for a particular file resource type.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This function registers a font file loader with DirectWrite.
    /// Font file loader interface handles loading font file resources of a particular type from a key.
    /// The font file loader interface is recommended to be implemented by a singleton object.
    /// A given instance can only be registered once.
    /// Succeeding attempts will return an error that it has already been registered.
    /// IMPORTANT: font file loader implementations must not register themselves with DirectWrite
    /// inside their constructors and must not unregister themselves in their destructors, because
    /// registration and unregistraton operations increment and decrement the object reference count respectively.
    /// Instead, registration and unregistration of font file loaders with DirectWrite should be performed
    /// outside of the font file loader implementation as a separate step.
    /// </remarks>
    [helpstring("Registers a font file loader with DirectWrite.")]
    STDMETHOD(RegisterFontFileLoader)(
        IDWriteFontFileLoader* fontFileLoader
        ) PURE;

    /// <summary>
    /// Unregisters a font file loader that was previously registered with the DirectWrite font system using RegisterFontFileLoader.
    /// </summary>
    /// <param name="fontFileLoader">Pointer to the file loader that was previously registered with the DirectWrite font system using RegisterFontFileLoader.</param>
    /// <returns>
    /// This function will succeed if the user loader is requested to be removed.
    /// It will fail if the pointer to the file loader identifies a standard DirectWrite loader,
    /// or a loader that is never registered or has already been unregistered.
    /// </returns>
    /// <remarks>
    /// This function unregisters font file loader callbacks with the DirectWrite font system.
    /// The font file loader interface is recommended to be implemented by a singleton object.
    /// IMPORTANT: font file loader implementations must not register themselves with DirectWrite
    /// inside their constructors and must not unregister themselves in their destructors, because
    /// registration and unregistraton operations increment and decrement the object reference count respectively.
    /// Instead, registration and unregistration of font file loaders with DirectWrite should be performed
    /// outside of the font file loader implementation as a separate step.
    /// </remarks>
    [helpstring("Unregisters a font file loader that was previously registered with the DirectWrite font system using RegisterFontFileLoader.")]
    STDMETHOD(UnregisterFontFileLoader)(
        IDWriteFontFileLoader* fontFileLoader
        ) PURE;

    /// <summary>
    /// Create a text format object used for text layout.
    /// </summary>
    /// <param name="fontFamilyName">Name of the font family</param>
    /// <param name="fontCollection">Font collection. NULL indicates the system font collection.</param>
    /// <param name="fontWeight">Font weight</param>
    /// <param name="fontStyle">Font style</param>
    /// <param name="fontStretch">Font stretch</param>
    /// <param name="fontSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="localeName">Locale name</param>
    /// <param name="textFormat">Contains newly created text format object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Create a text format object used for text layout.")]
    STDMETHOD(CreateTextFormat)(
        LPWSTR fontFamilyName,
        IDWriteFontCollection* fontCollection,
        DWRITE_FONT_WEIGHT fontWeight,
        DWRITE_FONT_STYLE fontStyle,
        DWRITE_FONT_STRETCH fontStretch,
        FLOAT fontSize,
        LPWSTR localeName,
        [out, retval] IDWriteTextFormat** textFormat
        ) PURE;

    /// <summary>
    /// Create a typography object used in conjunction with text format for text layout.
    /// </summary>
    /// <param name="typography">Contains newly created typography object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Create a typography object used in conjunction with text format for text layout.")]
    STDMETHOD(CreateTypography)(
        [out, retval] IDWriteTypography** typography
        ) PURE;

    /// <summary>
    /// Create an object used for interoperability with GDI.
    /// </summary>
    /// <param name="gdiInterop">Receives the GDI interop object if successful, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Create an object used for interoperability with GDI.")]
    STDMETHOD(GetGdiInterop)(
        [out, retval] IDWriteGdiInterop** gdiInterop
        ) PURE;

    /// <summary>
    /// CreateTextLayout takes a string, format, and associated constraints
    /// and produces and object representing the fully analyzed
    /// and formatted result.
    /// </summary>
    /// <param name="string">The string to layout.</param>
    /// <param name="stringLength">The length of the string.</param>
    /// <param name="textFormat">The format to apply to the string.</param>
    /// <param name="maxWidth">Width of the layout box.</param>
    /// <param name="maxHeight">Height of the layout box.</param>
    /// <param name="textLayout">The resultant object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("CreateTextLayout takes a string, format, and associated constraints and produces and object representing the fully analyzed and formatted result.")]
    STDMETHOD(CreateTextLayout)(
        LPWSTR string,
        UINT32 stringLength,
        IDWriteTextFormat* textFormat,
        FLOAT maxWidth,
        FLOAT maxHeight,
        [out, retval] IDWriteTextLayout** textLayout
        ) PURE;

    /// <summary>
    /// CreateGdiCompatibleTextLayout takes a string, format, and associated constraints
    /// and produces and object representing the result formatted for a particular display resolution
    /// and measuring method. The resulting text layout should only be used for the intended resolution,
    /// and for cases where text scalability is desired, CreateTextLayout should be used instead.
    /// </summary>
    /// <param name="string">The string to layout.</param>
    /// <param name="stringLength">The length of the string.</param>
    /// <param name="textFormat">The format to apply to the string.</param>
    /// <param name="layoutWidth">Width of the layout box.</param>
    /// <param name="layoutHeight">Height of the layout box.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if rendering onto a 96 DPI device then pixelsPerDip
    /// is 1. If rendering onto a 120 DPI device then pixelsPerDip is 120/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified the font size and pixelsPerDip.</param>
    /// <param name="useGdiNatural">
    /// When set to FALSE, instructs the text layout to use the same metrics as GDI aliased text.
    /// When set to TRUE, instructs the text layout to use the same metrics as text measured by GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY.
    /// </param>
    /// <param name="textLayout">The resultant object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("CreateGdiCompatibleTextLayout takes a string, format, and associated constraints and produces and object representing the result formatted for a particular display resolution and measuring method.")]
    STDMETHOD(CreateGdiCompatibleTextLayout)(
        LPWSTR string,
        UINT32 stringLength,
        IDWriteTextFormat* textFormat,
        FLOAT layoutWidth,
        FLOAT layoutHeight,
        FLOAT pixelsPerDip,
        void* transform,
        BOOL useGdiNatural,
        [out, retval] IDWriteTextLayout** textLayout
        ) PURE;

    /// <summary>
    /// The application may call this function to create an inline object for trimming, using an ellipsis as the omission sign.
    /// The ellipsis will be created using the current settings of the format, including base font, style, and any effects.
    /// Alternate omission signs can be created by the application by implementing IDWriteInlineObject.
    /// </summary>
    /// <param name="textFormat">Text format used as a template for the omission sign.</param>
    /// <param name="trimmingSign">Created omission sign.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("The application may call this function to create an inline object for trimming, using an ellipsis as the omission sign.")]
    STDMETHOD(CreateEllipsisTrimmingSign)(
        IDWriteTextFormat* textFormat,
        [out, retval] IDWriteInlineObject** trimmingSign
        ) PURE;

    /// <summary>
    /// Return an interface to perform text analysis with.
    /// </summary>
    /// <param name="textAnalyzer">The resultant object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Return an interface to perform text analysis with.")]
    STDMETHOD(CreateTextAnalyzer)(
        [out, retval] IDWriteTextAnalyzer** textAnalyzer
        ) PURE;

    /// <summary>
    /// Creates a number substitution object using a locale name,
    /// substitution method, and whether to ignore user overrides (uses NLS
    /// defaults for the given culture instead).
    /// </summary>
    /// <param name="substitutionMethod">Method of number substitution to use.</param>
    /// <param name="localeName">Which locale to obtain the digits from.</param>
    /// <param name="ignoreUserOverride">Ignore the user's settings and use the locale defaults</param>
    /// <param name="numberSubstitution">Receives a pointer to the newly created object.</param>
    [helpstring("Creates a number substitution object using a locale name, substitution method, and whether to ignore user overrides (uses NLS defaults for the given culture instead).")]
    STDMETHOD(CreateNumberSubstitution)(
        __in DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod,
        LPWSTR localeName,
        __in BOOL ignoreUserOverride,
        [out, retval] IDWriteNumberSubstitution** numberSubstitution
        ) PURE;

    /// <summary>
    /// Creates a glyph run analysis object, which encapsulates information
    /// used to render a glyph run.
    /// </summary>
    /// <param name="glyphRun">Structure specifying the properties of the glyph run.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if rendering onto a 96 DPI bitmap then pixelsPerDip
    /// is 1. If rendering onto a 120 DPI bitmap then pixelsPerDip is 120/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified the emSize and pixelsPerDip.</param>
    /// <param name="renderingMode">Specifies the rendering mode, which must be one of the raster rendering modes (i.e., not default
    /// and not outline).</param>
    /// <param name="measuringMode">Specifies the method to measure glyphs.</param>
    /// <param name="baselineOriginX">Horizontal position of the baseline origin, in DIPs.</param>
    /// <param name="baselineOriginY">Vertical position of the baseline origin, in DIPs.</param>
    /// <param name="glyphRunAnalysis">Receives a pointer to the newly created object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    [helpstring("Creates a glyph run analysis object, which encapsulates information used to render a glyph run.")]
    STDMETHOD(CreateGlyphRunAnalysis)(
        __in DWRITE_GLYPH_RUN* glyphRun,
        FLOAT pixelsPerDip,
        void* transform,
        DWRITE_RENDERING_MODE renderingMode,
        DWRITE_MEASURING_MODE measuringMode,
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        [out, retval] IDWriteGlyphRunAnalysis** glyphRunAnalysis
        ) PURE;

}; // interface IDWriteFactory

[dllname("Dwrite.dll")]
module Dwrite{

    #define FACILITY_DWRITE = 0x899;
    #define DWRITE_ERR_BASE = 0x5000;
    #define SEVERITY_ERROR 1

    #define MAKE_HRESULT(sev,fac,code) ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

    #define MAKE_DWRITE_HR(severity, code) MAKE_HRESULT(severity, 0x899, (0x5000 + code))
    #define MAKE_DWRITE_HR_ERR(code) MAKE_DWRITE_HR(1, code)

    const int DWRITE_ALPHA_MAX = 255;

/// <summary>
/// Indicates an error in an input file such as a font file.
/// </summary>
const int DWRITE_E_FILEFORMAT = MAKE_DWRITE_HR_ERR(0x000);

/// <summary>
/// Indicates an error originating in DirectWrite code, which is not expected to occur but is safe to recover from.
/// </summary>
const int DWRITE_E_UNEXPECTED = MAKE_DWRITE_HR_ERR(0x001);

/// <summary>
/// Indicates the specified font does not exist.
/// </summary>
const int DWRITE_E_NOFONT = MAKE_DWRITE_HR_ERR(0x002);

/// <summary>
/// A font file could not be opened because the file, directory, network location, drive, or other storage
/// location does not exist or is unavailable.
/// </summary>
const int DWRITE_E_FILENOTFOUND = MAKE_DWRITE_HR_ERR(0x003);

/// <summary>
/// A font file exists but could not be opened due to access denied, sharing violation, or similar error.
/// </summary>
const int DWRITE_E_FILEACCESS = MAKE_DWRITE_HR_ERR(0x004);

/// <summary>
/// A font collection is obsolete due to changes in the system.
/// </summary>
const int DWRITE_E_FONTCOLLECTIONOBSOLETE = MAKE_DWRITE_HR_ERR(0x005);

/// <summary>
/// The given interface is already registered.
/// </summary>
const int DWRITE_E_ALREADYREGISTERED = MAKE_DWRITE_HR_ERR(0x006);

[entry("DWriteCreateFactory")]
HRESULT DWriteCreateFactory(
DWRITE_FACTORY_TYPE factoryType,
REFIID iid,
[out, retval] IUnknown** factory
);

}
*/

