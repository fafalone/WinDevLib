/* exp_dshow.odl - oleexp DirectShow interfaces
     This file is self-contained and can be removed if not needed.
*/

typedef enum OABOOL {
	OATRUE = (-1),
	OAFALSE = 0x0
} OABOOL;
typedef enum EC_CODES {
	EC_SYSTEMBASE						= 0x00,
	EC_COMPLETE                         = 0x01,
	EC_USERABORT                        = 0x02,
	EC_ERRORABORT                       = 0x03,
	EC_TIME                             = 0x04,
	EC_REPAINT                          = 0x05,
	EC_STREAM_ERROR_STOPPED             = 0x06,
	EC_STREAM_ERROR_STILLPLAYING        = 0x07,
	EC_ERROR_STILLPLAYING               = 0x08,
	EC_PALETTE_CHANGED                  = 0x09,
	EC_VIDEO_SIZE_CHANGED               = 0x0A,
	EC_QUALITY_CHANGE                   = 0x0B,
	EC_SHUTTING_DOWN                    = 0x0C,
	EC_CLOCK_CHANGED                    = 0x0D,
	EC_PAUSED                           = 0x0E,
	EC_OPENING_FILE                     = 0x10,
	EC_BUFFERING_DATA                   = 0x11,
	EC_FULLSCREEN_LOST                  = 0x12,
	EC_ACTIVATE                         = 0x13,
	EC_NEED_RESTART                     = 0x14,
	EC_WINDOW_DESTROYED                 = 0x15,
	EC_DISPLAY_CHANGED                  = 0x16,
	EC_STARVATION                       = 0x17,
	EC_OLE_EVENT                        = 0x18,
	EC_NOTIFY_WINDOW                    = 0x19,
	EC_STREAM_CONTROL_STOPPED           = 0x1A,
	EC_STREAM_CONTROL_STARTED           = 0x1B,
	EC_END_OF_SEGMENT                   = 0x1C,
	EC_SEGMENT_STARTED                  = 0x1D,
	EC_LENGTH_CHANGED                   = 0x1E,
	EC_DEVICE_LOST                      = 0x1f,
	EC_SAMPLE_NEEDED                    = 0x20,
	EC_PROCESSING_LATENCY               = 0x21,
	EC_SAMPLE_LATENCY                   = 0x22,
	EC_SCRUB_TIME                       = 0x23,
	EC_STEP_COMPLETE                    = 0x24,
	EC_TIMECODE_AVAILABLE			    = 0x30,
	EC_EXTDEVICE_MODE_CHANGE			= 0x31,
	EC_STATE_CHANGE                     = 0x32,
	EC_GRAPH_CHANGED                    = 0x50,
	EC_CLOCK_UNSET                      = 0x51,
	EC_VMR_RENDERDEVICE_SET             = 0x53,
	EC_VMR_SURFACE_FLIPPED				= 0x54,
	EC_VMR_RECONNECTION_FAILED			= 0x55,
	EC_PREPROCESS_COMPLETE				= 0x56,
	EC_CODECAPI_EVENT					= 0x57,
	EC_WMT_EVENT_BASE                   = 0x0251,
	EC_WMT_INDEX_EVENT                  = 0x0251,
	EC_WMT_EVENT                        = 0x0252 ,
	EC_BUILT                            = 0x300,
	EC_UNBUILT                          = 0x301,
	EC_SKIP_FRAMES                      = 0x25,
	EC_PLEASE_REOPEN					= 0x40,
	EC_STATUS							= 0x41,
	EC_MARKER_HIT						= 0x42,
	EC_LOADSTATUS						= 0x43,
	EC_FILE_CLOSED						= 0x44,
	EC_ERRORABORTEX						= 0x45,
	EC_NEW_PIN							= 0x20,
	EC_RENDER_FINISHED					= 0x21,
	EC_EOS_SOON							= 0x046,
	EC_CONTENTPROPERTY_CHANGED			= 0x47,
	EC_BANDWIDTHCHANGE					= 0x48,
	EC_VIDEOFRAMEREADY					= 0x49,
	EC_USER								= 0x8000
} EC_CODES;

typedef enum VMR_RENDER_DEVICE_TYPE {
	VMR_RENDER_DEVICE_OVERLAY       = 0x01,
	VMR_RENDER_DEVICE_VIDMEM        = 0x02,
	VMR_RENDER_DEVICE_SYSMEM        = 0x04
} VMR_RENDER_DEVICE_TYPE;

	// status codes for EC_LOADSTATUS....
typedef enum  AM_LOADSTATUS {
	AM_LOADSTATUS_CLOSED	        = 0x0000,
	AM_LOADSTATUS_LOADINGDESCR      = 0x0001,
	AM_LOADSTATUS_LOADINGMCAST      = 0x0002,
	AM_LOADSTATUS_LOCATING		= 0x0003,
	AM_LOADSTATUS_CONNECTING	= 0x0004,
	AM_LOADSTATUS_OPENING		= 0x0005,
	AM_LOADSTATUS_OPEN		= 0x0006
} AM_LOADSTATUS;

	// Sent when a streaming media filter recieves a change in stream description information.
	// the UI is expected to re-query for the changed property in response
typedef enum AM_CONTENTPROPERTY {
	AM_CONTENTPROPERTY_TITLE     = 0x0001,
	AM_CONTENTPROPERTY_AUTHOR    = 0x0002,
	AM_CONTENTPROPERTY_COPYRIGHT = 0x0004,
	AM_CONTENTPROPERTY_DESCRIPTION = 0x0008
} AM_CONTENTPROPERTY;

typedef struct AM_WMT_EVENT_DATA {
	HRESULT hrStatus;        // status code
	long pData;            // event data
} AM_WMT_EVENT_DATA;
//Primary Interfaces; those included in the traditionally used quartz.dll

/*
QUARTZ.DLL ENTRIES
THIS SECTION IS (c) Microsoft and is simply the exact contents of
the quartz.dll typelib
*/
    // Forward declare all types defined in this typelib
    interface IAMCollection;
    interface IMediaControl;
    interface IMediaEvent;
    interface IMediaEventEx;
    interface IMediaPosition;
    interface IBasicAudio;
    interface IVideoWindow;
    interface IBasicVideo;
    interface IBasicVideo2;
    interface IDeferredCommand;
    interface IQueueCommand;
    interface IFilterInfo;
    interface IRegFilterInfo;
    interface IMediaTypeInfo;
    interface IPinInfo;
    interface IAMStats;

//    typedef [public    ,
//    custom({F914481D-9C62-4B43-9340-E9B2E6252E5F}, "1")    
//]
//    long LONG_PTR;

    [
      odl,
      uuid(56A868B9-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("Collection"),
      dual,
      oleautomation
    ]
    interface IAMCollection : IDispatch {
        [id(0x60020000), propget]
        HRESULT Count([out, retval] long* plCount);
        [id(0x60020001)]
        HRESULT Item(
                        [in] long lItem, 
                        [out] IUnknown** ppUnk);
        [id(0x60020002), propget]
        HRESULT _NewEnum([out, retval] IUnknown** ppUnk);
    };

    [
      odl,
      uuid(56A868B1-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IMediaControl interface")//,
      //dual,
      //oleautomation
    ]
    interface IMediaControl : stdole.IDispatch {
        [id(0x60020000)]
        HRESULT Run();
        [id(0x60020001)]
        HRESULT Pause();
        [id(0x60020002)]
        HRESULT Stop();
        [id(0x60020003)]
        HRESULT GetState(
                        [in] long msTimeout, 
                        [out] long* pfs);
        [id(0x60020004)]
        HRESULT RenderFile([in] BSTR strFilename);
        [id(0x60020005)]
        HRESULT AddSourceFilter(
                        [in] BSTR strFilename, 
                        [out] IDispatch** ppUnk);
        [id(0x60020006), propget]
        HRESULT FilterCollection([out, retval] IDispatch** ppUnk);
        [id(0x60020007), propget]
        HRESULT RegFilterCollection([out, retval] IDispatch** ppUnk);
        [id(0x60020008)]
        HRESULT StopWhenReady();
    };

    [
      odl,
      uuid(56A868B6-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IMediaEvent interface")//,
      //dual,
      //oleautomation
    ]
    interface IMediaEvent : stdole.IDispatch {
        [id(0x60020000)]
        HRESULT GetEventHandle([out] LONG_PTR* hEvent);
        [id(0x60020001)]
        HRESULT GetEvent(
                        [out] long* lEventCode, 
                        [out] LONG_PTR* lParam1, 
                        [out] LONG_PTR* lParam2, 
                        [in] long msTimeout);
        [id(0x60020002)]
        HRESULT WaitForCompletion(
                        [in] long msTimeout, 
                        [out] long* pEvCode);
        [id(0x60020003)]
        HRESULT CancelDefaultHandling([in] long lEvCode);
        [id(0x60020004)]
        HRESULT RestoreDefaultHandling([in] long lEvCode);
        [id(0x60020005)]
        HRESULT FreeEventParams(
                        [in] long lEvCode, 
                        [in] LONG_PTR lParam1, 
                        [in] LONG_PTR lParam2);
    };

    [
      odl,
      uuid(56A868C0-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IMediaEventEx interface")
    ]
    interface IMediaEventEx : IMediaEvent {
        HRESULT _stdcall SetNotifyWindow(
                        [in] LONG_PTR hwnd, 
                        [in] long lMsg, 
                        [in] LONG_PTR lInstanceData);
        HRESULT _stdcall SetNotifyFlags([in] long lNoNotifyFlags);
        HRESULT _stdcall GetNotifyFlags([out] long* lplNoNotifyFlags);
    };

    [
      odl,
      uuid(56A868B2-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IMediaPosition interface"),
      dual,
      oleautomation
    ]
    interface IMediaPosition : IDispatch {
        [id(0x60020000), propget]
        HRESULT Duration([out, retval] double* plength);
        [id(0x60020001), propput]
        HRESULT CurrentPosition([in] double pllTime);
        [id(0x60020001), propget]
        HRESULT CurrentPosition([out, retval] double* pllTime);
        [id(0x60020003), propget]
        HRESULT StopTime([out, retval] double* pllTime);
        [id(0x60020003), propput]
        HRESULT StopTime([in] double pllTime);
        [id(0x60020005), propget]
        HRESULT PrerollTime([out, retval] double* pllTime);
        [id(0x60020005), propput]
        HRESULT PrerollTime([in] double pllTime);
        [id(0x60020007), propput]
        HRESULT Rate([in] double pdRate);
        [id(0x60020007), propget]
        HRESULT Rate([out, retval] double* pdRate);
        [id(0x60020009)]
        HRESULT CanSeekForward([out, retval] long* pCanSeekForward);
        [id(0x6002000a)]
        HRESULT CanSeekBackward([out, retval] long* pCanSeekBackward);
    };

    [
      odl,
      uuid(56A868B3-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IBasicAudio interface"),
      dual,
      oleautomation
    ]
    interface IBasicAudio : IDispatch {
        [id(0x60020000), propput]
        HRESULT Volume([in] long plVolume);
        [id(0x60020000), propget]
        HRESULT Volume([out, retval] long* plVolume);
        [id(0x60020002), propput]
        HRESULT Balance([in] long plBalance);
        [id(0x60020002), propget]
        HRESULT Balance([out, retval] long* plBalance);
    };

    [
      odl,
      uuid(56A868B4-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IVideoWindow interface"),
      dual,
      oleautomation
    ]
    interface IVideoWindow : IDispatch {
        [id(0x60020000), propput]
        HRESULT Caption([in] BSTR strCaption);
        [id(0x60020000), propget]
        HRESULT Caption([out, retval] BSTR* strCaption);
        [id(0x60020002), propput]
        HRESULT WindowStyle([in] long WindowStyle);
        [id(0x60020002), propget]
        HRESULT WindowStyle([out, retval] long* WindowStyle);
        [id(0x60020004), propput]
        HRESULT WindowStyleEx([in] long WindowStyleEx);
        [id(0x60020004), propget]
        HRESULT WindowStyleEx([out, retval] long* WindowStyleEx);
        [id(0x60020006), propput]
        HRESULT AutoShow([in] long AutoShow);
        [id(0x60020006), propget]
        HRESULT AutoShow([out, retval] long* AutoShow);
        [id(0x60020008), propput]
        HRESULT WindowState([in] long WindowState);
        [id(0x60020008), propget]
        HRESULT WindowState([out, retval] long* WindowState);
        [id(0x6002000a), propput]
        HRESULT BackgroundPalette([in] long pBackgroundPalette);
        [id(0x6002000a), propget]
        HRESULT BackgroundPalette([out, retval] long* pBackgroundPalette);
        [id(0x6002000c), propput]
        HRESULT Visible([in] long pVisible);
        [id(0x6002000c), propget]
        HRESULT Visible([out, retval] long* pVisible);
        [id(0x6002000e), propput]
        HRESULT Left([in] long pLeft);
        [id(0x6002000e), propget]
        HRESULT Left([out, retval] long* pLeft);
        [id(0x60020010), propput]
        HRESULT Width([in] long pWidth);
        [id(0x60020010), propget]
        HRESULT Width([out, retval] long* pWidth);
        [id(0x60020012), propput]
        HRESULT Top([in] long pTop);
        [id(0x60020012), propget]
        HRESULT Top([out, retval] long* pTop);
        [id(0x60020014), propput]
        HRESULT Height([in] long pHeight);
        [id(0x60020014), propget]
        HRESULT Height([out, retval] long* pHeight);
        [id(0x60020016), propput]
        HRESULT Owner([in] LONG_PTR Owner);
        [id(0x60020016), propget]
        HRESULT Owner([out, retval] LONG_PTR* Owner);
        [id(0x60020018), propput]
        HRESULT MessageDrain([in] LONG_PTR Drain);
        [id(0x60020018), propget]
        HRESULT MessageDrain([out, retval] LONG_PTR* Drain);
        [id(0x6002001a), propget]
        HRESULT BorderColor([out, retval] long* Color);
        [id(0x6002001a), propput]
        HRESULT BorderColor([in] long Color);
        [id(0x6002001c), propget]
        HRESULT FullScreenMode([out, retval] long* FullScreenMode);
        [id(0x6002001c), propput]
        HRESULT FullScreenMode([in] long FullScreenMode);
        [id(0x6002001e)]
        HRESULT SetWindowForeground([in] long Focus);
        [id(0x6002001f)]
        HRESULT NotifyOwnerMessage(
                        [in] LONG_PTR hwnd, 
                        [in] long uMsg, 
                        [in] LONG_PTR wParam, 
                        [in] LONG_PTR lParam);
        [id(0x60020020)]
        HRESULT SetWindowPosition(
                        [in] long Left, 
                        [in] long Top, 
                        [in] long Width, 
                        [in] long Height);
        [id(0x60020021)]
        HRESULT GetWindowPosition(
                        [out] long* pLeft, 
                        [out] long* pTop, 
                        [out] long* pWidth, 
                        [out] long* pHeight);
        [id(0x60020022)]
        HRESULT GetMinIdealImageSize(
                        [out] long* pWidth, 
                        [out] long* pHeight);
        [id(0x60020023)]
        HRESULT GetMaxIdealImageSize(
                        [out] long* pWidth, 
                        [out] long* pHeight);
        [id(0x60020024)]
        HRESULT GetRestorePosition(
                        [out] long* pLeft, 
                        [out] long* pTop, 
                        [out] long* pWidth, 
                        [out] long* pHeight);
        [id(0x60020025)]
        HRESULT HideCursor([in] long HideCursor);
        [id(0x60020026)]
        HRESULT IsCursorHidden([out] long* CursorHidden);
    };

    [
      odl,
      uuid(56A868B5-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IBasicVideo interface"),
      dual,
      oleautomation
    ]
    interface IBasicVideo : IDispatch {
        [id(0x60020000), propget]
        HRESULT AvgTimePerFrame([out, retval] double* pAvgTimePerFrame);
        [id(0x60020001), propget]
        HRESULT BitRate([out, retval] long* pBitRate);
        [id(0x60020002), propget]
        HRESULT BitErrorRate([out, retval] long* pBitErrorRate);
        [id(0x60020003), propget]
        HRESULT VideoWidth([out, retval] long* pVideoWidth);
        [id(0x60020004), propget]
        HRESULT VideoHeight([out, retval] long* pVideoHeight);
        [id(0x60020005), propput]
        HRESULT SourceLeft([in] long pSourceLeft);
        [id(0x60020005), propget]
        HRESULT SourceLeft([out, retval] long* pSourceLeft);
        [id(0x60020007), propput]
        HRESULT SourceWidth([in] long pSourceWidth);
        [id(0x60020007), propget]
        HRESULT SourceWidth([out, retval] long* pSourceWidth);
        [id(0x60020009), propput]
        HRESULT SourceTop([in] long pSourceTop);
        [id(0x60020009), propget]
        HRESULT SourceTop([out, retval] long* pSourceTop);
        [id(0x6002000b), propput]
        HRESULT SourceHeight([in] long pSourceHeight);
        [id(0x6002000b), propget]
        HRESULT SourceHeight([out, retval] long* pSourceHeight);
        [id(0x6002000d), propput]
        HRESULT DestinationLeft([in] long pDestinationLeft);
        [id(0x6002000d), propget]
        HRESULT DestinationLeft([out, retval] long* pDestinationLeft);
        [id(0x6002000f), propput]
        HRESULT DestinationWidth([in] long pDestinationWidth);
        [id(0x6002000f), propget]
        HRESULT DestinationWidth([out, retval] long* pDestinationWidth);
        [id(0x60020011), propput]
        HRESULT DestinationTop([in] long pDestinationTop);
        [id(0x60020011), propget]
        HRESULT DestinationTop([out, retval] long* pDestinationTop);
        [id(0x60020013), propput]
        HRESULT DestinationHeight([in] long pDestinationHeight);
        [id(0x60020013), propget]
        HRESULT DestinationHeight([out, retval] long* pDestinationHeight);
        [id(0x60020015)]
        HRESULT SetSourcePosition(
                        [in] long Left, 
                        [in] long Top, 
                        [in] long Width, 
                        [in] long Height);
        [id(0x60020016)]
        HRESULT GetSourcePosition(
                        [out] long* pLeft, 
                        [out] long* pTop, 
                        [out] long* pWidth, 
                        [out] long* pHeight);
        [id(0x60020017)]
        HRESULT SetDefaultSourcePosition();
        [id(0x60020018)]
        HRESULT SetDestinationPosition(
                        [in] long Left, 
                        [in] long Top, 
                        [in] long Width, 
                        [in] long Height);
        [id(0x60020019)]
        HRESULT GetDestinationPosition(
                        [out] long* pLeft, 
                        [out] long* pTop, 
                        [out] long* pWidth, 
                        [out] long* pHeight);
        [id(0x6002001a)]
        HRESULT SetDefaultDestinationPosition();
        [id(0x6002001b)]
        HRESULT GetVideoSize(
                        [out] long* pWidth, 
                        [out] long* pHeight);
        [id(0x6002001c)]
        HRESULT GetVideoPaletteEntries(
                        [in] long StartIndex, 
                        [in] long Entries, 
                        [out] long* pRetrieved, 
                        [out] long* pPalette);
        [id(0x6002001d)]
        HRESULT GetCurrentImage(
                        [in, out] long* pBufferSize, 
                        [out] long* pDIBImage);
        [id(0x6002001e)]
        HRESULT IsUsingDefaultSource();
        [id(0x6002001f)]
        HRESULT IsUsingDefaultDestination();
    };

    [
      odl,
      uuid(329BB360-F6EA-11D1-9038-00A0C9697298),
      helpstring("IBasicVideo2")
    ]
    interface IBasicVideo2 : IBasicVideo {
        HRESULT _stdcall GetPreferredAspectRatio(
                        [out] long* plAspectX, 
                        [out] long* plAspectY);
    };

    [
      odl,
      uuid(56A868B8-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IDeferredCommand")
    ]
    interface IDeferredCommand : IUnknown {
        HRESULT _stdcall Cancel();
        HRESULT _stdcall Confidence([out] long* pConfidence);
        HRESULT _stdcall Postpone([in] double newtime);
        HRESULT _stdcall GetHResult([out] HRESULT* phrResult);
    };

    [
      odl,
      uuid(56A868B7-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("IQueueCommand")
    ]
    interface IQueueCommand : IUnknown {
        HRESULT _stdcall InvokeAtStreamTime(
                        [out] IDeferredCommand** pCmd, 
                        [in] double time, 
                        [in] GUID* iid, 
                        [in] long dispidMethod, 
                        [in] short wFlags, 
                        [in] long cArgs, 
                        [in] VARIANT* pDispParams, 
                        [in, out] VARIANT* pvarResult, 
                        [out] short* puArgErr);
        HRESULT _stdcall InvokeAtPresentationTime(
                        [out] IDeferredCommand** pCmd, 
                        [in] double time, 
                        [in] GUID* iid, 
                        [in] long dispidMethod, 
                        [in] short wFlags, 
                        [in] long cArgs, 
                        [in] VARIANT* pDispParams, 
                        [in, out] VARIANT* pvarResult, 
                        [out] short* puArgErr);
    };

    [
      uuid(E436EBB3-524F-11CE-9F53-0020AF0BA770),
      helpstring("Filtergraph type info")
    ]
    coclass FilgraphManager {
        [default] interface IMediaControl;
        interface IMediaEvent;
        interface IMediaPosition;
        interface IBasicAudio;
        interface IBasicVideo;
        interface IVideoWindow;
    };

    [
      odl,
      uuid(56A868BA-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("FilterInfo"),
      dual,
      oleautomation
    ]
    interface IFilterInfo : IDispatch {
        [id(0x60020000)]
        HRESULT FindPin(
                        [in] BSTR strPinID, 
                        [out] IDispatch** ppUnk);
        [id(0x60020001), propget]
        HRESULT Name([out, retval] BSTR* strName);
        [id(0x60020002), propget]
        HRESULT VendorInfo([out, retval] BSTR* strVendorInfo);
        [id(0x60020003), propget]
        HRESULT Filter([out, retval] IUnknown** ppUnk);
        [id(0x60020004), propget]
        HRESULT Pins([out, retval] IDispatch** ppUnk);
        [id(0x60020005), propget]
        HRESULT IsFileSource([out, retval] long* pbIsSource);
        [id(0x60020006), propget]
        HRESULT Filename([out, retval] BSTR* pstrFilename);
        [id(0x60020006), propput]
        HRESULT Filename([in] BSTR pstrFilename);
    };

    [
      odl,
      uuid(56A868BB-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("Registry Filter Info"),
      dual,
      oleautomation
    ]
    interface IRegFilterInfo : IDispatch {
        [id(0x60020000), propget]
        HRESULT Name([out, retval] BSTR* strName);
        [id(0x60020001)]
        HRESULT Filter([out] IDispatch** ppUnk);
    };

    [
      odl,
      uuid(56A868BC-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("Media Type"),
      dual,
      oleautomation
    ]
    interface IMediaTypeInfo : IDispatch {
        [id(0x60020000), propget]
        HRESULT Type([out, retval] BSTR* strType);
        [id(0x60020001), propget]
        HRESULT Subtype([out, retval] BSTR* strType);
    };

    [
      odl,
      uuid(56A868BD-0AD4-11CE-B03A-0020AF0BA770),
      helpstring("Pin Info"),
      dual,
      oleautomation
    ]
    interface IPinInfo : IDispatch {
        [id(0x60020000), propget]
        HRESULT Pin([out, retval] IUnknown** ppUnk);
        [id(0x60020001), propget]
        HRESULT ConnectedTo([out, retval] IDispatch** ppUnk);
        [id(0x60020002), propget]
        HRESULT ConnectionMediaType([out, retval] IDispatch** ppUnk);
        [id(0x60020003), propget]
        HRESULT FilterInfo([out, retval] IDispatch** ppUnk);
        [id(0x60020004), propget]
        HRESULT Name([out, retval] BSTR* ppUnk);
        [id(0x60020005), propget]
        HRESULT Direction([out, retval] long* ppDirection);
        [id(0x60020006), propget]
        HRESULT PinID([out, retval] BSTR* strPinID);
        [id(0x60020007), propget]
        HRESULT MediaTypes([out, retval] IDispatch** ppUnk);
        [id(0x60020008)]
        HRESULT Connect([in] IUnknown* pPin);
        [id(0x60020009)]
        HRESULT ConnectDirect([in] IUnknown* pPin);
        [id(0x6002000a)]
        HRESULT ConnectWithType(
                        [in] IUnknown* pPin, 
                        [in] IDispatch* pMediaType);
        [id(0x6002000b)]
        HRESULT Disconnect();
        [id(0x6002000c)]
        HRESULT Render();
    };

    [
      odl,
      uuid(BC9BCF80-DCD2-11D2-ABF6-00A0C905F375),
      helpstring("Statistics"),
      dual,
      oleautomation
    ]
    interface IAMStats : IDispatch {
        [id(0x60020000)]
        HRESULT Reset();
        [id(0x60020001), propget]
        HRESULT Count([out, retval] long* plCount);
        [id(0x60020002)]
        HRESULT GetValueByIndex(
                        [in] long lIndex, 
                        [out] BSTR* szName, 
                        [out] long* lCount, 
                        [out] double* dLast, 
                        [out] double* dAverage, 
                        [out] double* dStdDev, 
                        [out] double* dMin, 
                        [out] double* dMax);
        [id(0x60020003)]
        HRESULT GetValueByName(
                        [in] BSTR szName, 
                        [out] long* lIndex, 
                        [out] long* lCount, 
                        [out] double* dLast, 
                        [out] double* dAverage, 
                        [out] double* dStdDev, 
                        [out] double* dMin, 
                        [out] double* dMax);
        [id(0x60020004)]
        HRESULT GetIndex(
                        [in] BSTR szName, 
                        [in] long lCreate, 
                        [out] long* plIndex);
        [id(0x60020005)]
        HRESULT AddValue(
                        [in] long lIndex, 
                        [in] double dValue);
    };

/*
END QUARTZ.DLL SECTION
*/
typedef enum FILTER_STATE {	
	State_Stopped	= 0,
	State_Paused	= 1,
	State_Running	= 2
} FILTER_STATE;
//typedef CURRENCY REFERENCE_TIME;
typedef struct AM_MEDIA_TYPE
{
    UUID majortype;
    UUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    UUID formattype;
    LONG pUnk; //IUnknown *pUnk;
    ULONG cbFormat;
	LONG pbFormat; //BYTE *pbFormat;
} AM_MEDIA_TYPE;

typedef enum PIN_DIRECTION
{
	PINDIR_INPUT	= 0,
	PINDIR_OUTPUT	= 1 
} PIN_DIRECTION;

typedef struct PIN_INFO
{
    LONG pFilter; //IBaseFilter *pFilter;
    PIN_DIRECTION dir;
    WCHAR achName[128];
} PIN_INFO;
typedef struct FILTER_INFO
{
    WCHAR achName[128];
    LONG pGraph;
} FILTER_INFO;


[
	odl,
	uuid(89c31040-846b-11ce-97d3-00aa0055595a)
]	
interface IEnumMediaTypes : stdole.IUnknown
{
        long Next([in] ULONG cMediaTypes,
                  [out] AM_MEDIA_TYPE *ppMediaTypes,
                  [out] ULONG *pcFetched);
        
        long Skip([in] ULONG cMediaTypes);
        
        long Reset(void);
        
        long Clone([out] IEnumMediaTypes **ppEnum);
        
};

[
	odl,
	uuid(56a86891-0ad4-11ce-b03a-0020af0ba770)
]
interface IPin : stdole.IUnknown
{

    long Connect( 
        [in] IPin *pReceivePin,
        [in] AM_MEDIA_TYPE *pmt);
    
    long ReceiveConnection( 
        [in] IPin *pConnector,
        [in] AM_MEDIA_TYPE *pmt);
    
    long Disconnect(void);
    
    long ConnectedTo( 
        [out] IPin **pPin);
    
    long ConnectionMediaType( 
        [out] AM_MEDIA_TYPE *pmt);
    
    long QueryPinInfo( 
        [out] PIN_INFO *pInfo);
    
    long QueryDirection( 
        [out] PIN_DIRECTION *pPinDir);
    
    long QueryId( 
        [out] LONG *Id); //LPWSTR
    
    long QueryAccept( 
        [in] AM_MEDIA_TYPE *pmt);
    
    long EnumMediaTypes( 
        [out] IEnumMediaTypes **ppEnum);
    
    long QueryInternalConnections( 
        [out] IPin **apPin,
        [in,out] ULONG *nPin);
    
    long EndOfStream( void);
    
    long BeginFlush( void);
    
    long EndFlush( void);
    
    long NewSegment( 
        [in] REFERENCE_TIME tStart,
        [in] REFERENCE_TIME tStop,
        [in] double dRate);
    
};
[
	odl,
	uuid(56a86892-0ad4-11ce-b03a-0020af0ba770)
]
interface IEnumPins : stdole.IUnknown
{
        long Next([in] ULONG cPins,
                  [out] IPin **ppPins,
                  [out] ULONG *pcFetched);
        
        long Skip([in] ULONG cPins);
        
        long Reset(void);
        
        long Clone([out] IEnumPins **ppEnum);
};

[
	odl,
	uuid(56a86897-0ad4-11ce-b03a-0020af0ba770)
]
interface IReferenceClock : stdole.IUnknown
{
    long GetTime( 
        [out] REFERENCE_TIME *pTime);
    
    long AdviseTime( 
        [in] REFERENCE_TIME baseTime,
        [in] REFERENCE_TIME streamTime,
        [in] HEVENT hEvent,
        [out] DWORD *pdwAdviseCookie);
    
    long AdvisePeriodic( 
        [in] REFERENCE_TIME startTime,
        [in] REFERENCE_TIME periodTime,
        [in] HSEMAPHORE hSemaphore,
        [out] DWORD_PTR *pdwAdviseCookie);
    
    long Unadvise( 
        [in] DWORD_PTR dwAdviseCookie);
    
};
[
	odl,
	uuid(56a86899-0ad4-11ce-b03a-0020af0ba770)
]
interface IMediaFilter : IPersist
{
    long Stop(void);
    
    long Pause(void);
    
    long Run([in] REFERENCE_TIME tStart);
    
    long GetState( 
        [in] DWORD dwMilliSecsTimeout,
        [out] FILTER_STATE *State);
    
    long SetSyncSource( 
        [in] IReferenceClock *pClock);
    
    long GetSyncSource( 
        [out] IReferenceClock **pClock);
    
};


interface IFilterGraph;


[
	odl,
	uuid(56a86895-0ad4-11ce-b03a-0020af0ba770)
]
interface IBaseFilter : IMediaFilter
{
    long EnumPins( 
        [out] IEnumPins **ppEnum);
    
    long FindPin( 
        [in] long lpszId,
        [out] IPin **ppPin);
    
    long QueryFilterInfo( 
        [out] FILTER_INFO *pInfo);
    
    long JoinFilterGraph( 
        [in] IFilterGraph *pGraph,
        [in] LONG pName);
    
    long QueryVendorInfo( 
        [out] LONG *pVendorInfo); //LPWSTR
    
};

[
	odl,
	uuid(56a86893-0ad4-11ce-b03a-0020af0ba770)
]
interface IEnumFilters : stdole.IUnknown
{
    long Next( 
        [in] ULONG cFilters,
		[out] IBaseFilter **ppFilter,
        [out] ULONG *pcFetched);
    
    long Skip( 
        [in] ULONG cFilters);
    
    long Reset( void);
    
    long Clone([out] IEnumFilters **ppEnum);
    
};
[
	odl,
	uuid(56a8689f-0ad4-11ce-b03a-0020af0ba770)
]
interface IFilterGraph : stdole.IUnknown
{
        long AddFilter([in] IBaseFilter *pFilter,
					   [in] LONG pName);
            // [string][in]  LPCWSTR pName);
        
        long RemoveFilter( 
            [in] IBaseFilter *pFilter);
        
        long EnumFilters([out] IEnumFilters **ppEnum);
        
        long FindFilterByName( 
            [in] LONG pName,
            [out] IBaseFilter **ppFilter);
        
        long ConnectDirect( 
            [in] IPin *ppinOut,
            [in] IPin *ppinIn,
            [in] AM_MEDIA_TYPE *pmt);
        
        long Reconnect( 
            [in] IPin *ppin);
        
        long Disconnect( 
            [in] IPin *ppin);
        
        long SetDefaultSyncSource( void);
        
 };


[
	odl,
	uuid(a2104830-7c70-11cf-8bce-00aa00a3f1a6)
]
interface IFileSinkFilter : stdole.IUnknown
    {
        long SetFileName( 
            [in] long pszFileName,
            [in] AM_MEDIA_TYPE *pmt);
        
        long GetCurFile( 
            [out] long *ppszFileName,             
            [out] AM_MEDIA_TYPE *pmt);
        
};
[
	odl,
	uuid(670d1d20-a068-11d0-b3f0-00aa003761c5)
]
interface IAMCopyCaptureFileProgress : stdole.IUnknown
{
        HRESULT Progress([in] int iProgress);
        
};

[
	odl,
	uuid(56a868a9-0ad4-11ce-b03a-0020af0ba770)
]
interface IGraphBuilder : IFilterGraph
{
        long Connect( 
            [in] IPin *ppinOut,
            [in] IPin *ppinIn);
        
        long Render( 
            [in] IPin *ppinOut);
        
        long RenderFile( 
            [in] LONG lpcwstrFile,
            [in] LONG lpcwstrPlayList);
        
        long AddSourceFilter( 
            [in] LPCWSTR lpcwstrFileName,
            [in] LONG lpcwstrFilterName,
            [out] IBaseFilter **ppFilter);
        
        long SetLogFile( 
            [in] DWORD_PTR hFile);
        
        long Abort( void);
        
        long ShouldOperationContinue( void);
        
};

typedef enum AM_RENSDEREXFLAGS
{
	AM_RENDEREX_RENDERTOEXISTINGRENDERERS = 0x1
} AM_RENSDEREXFLAGS;
[
	odl,
	uuid(36b73882-c2c8-11cf-8b46-00805f6cef60)
]
interface IFilterGraph2 : IGraphBuilder
{
	long AddSourceFilterForMoniker(
		[in] IMoniker *pMoniker,
		[in] IBindCtx *pCtx,
		[in] LONG lpcwstrFilterName,
		[out] IBaseFilter **ppFilter);

	long ReconnectEx([in] IPin *ppin, [in] long pmt); //For pmt, use VarPtr to AM_MEDIA_TYPE struct, or supply 0& to use current type

	long RenderEx([in] IPin *ppin, [in] AM_RENSDEREXFLAGS dwFlags, [in] DWORD *pvContext);
	
};

[
	odl,
	uuid(aaf38154-b80b-422f-91e6-b66467509a07)
]
interface IFilterGraph3 : IFilterGraph2
{
	long SetSyncSourceEx(
		[in] IReferenceClock *pClockForMostOfFilterGraph,
		[in] IReferenceClock *pClockForFilter,
		[in] IBaseFilter *pFilter);
};

[
	odl,
	uuid(bf87b6e0-8c27-11d0-b3f0-00aa003761c5)
]
interface ICaptureGraphBuilder : stdole.IUnknown
    {
        long SetFiltergraph( 
            [in] IGraphBuilder *pfg);
        
        long GetFiltergraph(
            [out] IGraphBuilder **ppfg);
        
        long SetOutputFileName( 
            [in] UUID *pType,
            [in] long lpstrFile,             
            [out] IBaseFilter **ppf,             
            [out] IFileSinkFilter **ppSink);
        
        long FindInterface( 
            [in] UUID *pCategory,
            [in] IBaseFilter *pf,
            [in] UUID *riid,             
            [out] LPVOID ppint);
        
        long RenderStream( 
            [in] UUID *pCategory,
            [in] IUnknown *pSource,
            [in] IBaseFilter *pfCompressor,
            [in] IBaseFilter *pfRenderer);
        
        long ControlStream( 
            [in] UUID *pCategory,
            [in] IBaseFilter *pFilter,
            [in] REFERENCE_TIME *pstart,
            [in] REFERENCE_TIME *pstop,
            [in] WORD wStartCookie,
            [in] WORD wStopCookie);
        
        long AllocCapFile( 
            [in] long lpstr,
            [in] DWORDLONG dwlSize);
        
        long CopyCaptureFile(  
            [in] long lpwstrOld,
            [in] long lpwstrNew,
            [in] int fAllowEscAbort,
            [in] IAMCopyCaptureFileProgress *pCallback);
        
};

[
	odl,
	uuid(93E5A4E0-2D50-11d2-ABFA-00A0C9C6E38D)
]
interface ICaptureGraphBuilder2 : stdole.IUnknown
    {
        long SetFiltergraph( 
            [in] IGraphBuilder *pfg);
        
        long GetFiltergraph( 
            [out] IGraphBuilder **ppfg);
        
        long SetOutputFileName( 
            [in] UUID *pType,
            [in] long lpstrFile,
            [out] IBaseFilter **ppf,
            [out] IFileSinkFilter **ppSink);
        
        long FindInterface( 
            [in] UUID *pCategory,
            [in] UUID *pType,
            [in] IBaseFilter *pf,
            [in] UUID *riid,
            [out] LPVOID ppint);
        
        long RenderStream( 
            [in] UUID *pCategory,
            [in] UUID *pType,
            [in] IUnknown *pSource,
            [in] IBaseFilter *pfCompressor,
            [in] IBaseFilter *pfRenderer);
        
        long ControlStream( 
            [in] UUID *pCategory,
            [in] UUID *pType,
            [in] IBaseFilter *pFilter,
            [in] REFERENCE_TIME *pstart,
            [in] REFERENCE_TIME *pstop,
            [in] WORD wStartCookie,
            [in] WORD wStopCookie);
        
        long AllocCapFile( 
            [in] long lpstr,
            [in] DWORDLONG dwlSize);
        
        long CopyCaptureFile( 
            [in] long lpwstrOld,
            [in] long lpwstrNew,
            [in] int fAllowEscAbort,
            [in] IAMCopyCaptureFileProgress *pCallback);
        
        long FindPin( 
            [in] IUnknown *pSource,
            [in] PIN_DIRECTION pindir,
            [in] UUID *pCategory,
            [in] UUID *pType,
            [in] BOOL fUnconnected,
            [in] int num,
            [out] IPin **ppPin);
};


typedef enum AMExtendedSeekingCapabilities
{
    None = 0,
    CanSeek = 1,
    CanScan = 2,
    MarkerSeek = 4,
    ScanWithoutClock = 8,
    NoStandardRepaint = 16,
    Buffering = 32,
    SendsVideoFrameReady = 64
} AMExtendedSeekingCapabilities;

[
	odl,
	uuid(FA2AA8F1-8B62-11D0-A520-000000000000)
]
interface IAMNetShowConfig : IDispatch
{

    int get_BufferingTime([out] double *pBufferingTime);
    int put_BufferingTime([in] double BufferingTime);
    int get_UseFixedUDPPort([out] BOOL *pUseFixedUDPPort);
    int put_UseFixedUDPPort([in] BOOL UseFixedUDPPort);
    int get_FixedUDPPort([out] int *pFixedUDPPort);
    int put_FixedUDPPort([in] int FixedUDPPort);
    int get_UseHTTPProxy([out] BOOL *pUseHTTPProxy);
    int put_UseHTTPProxy([in] BOOL UseHTTPProxy);
    int get_EnableAutoProxy([out] BOOL *pEnableAutoProxy);
    int put_EnableAutoProxy([in] BOOL EnableAutoProxy);
    int get_HTTPProxyHost([out] BSTR *pbstrHTTPProxyHost);
    int put_HTTPProxyHost([in] BSTR bstrHTTPProxyHost);
    int get_HTTPProxyPort([out] int *pHTTPProxyPort);
    int put_HTTPProxyPort([in] int HTTPProxyPort);
    int get_EnableMulticast([out] BOOL *pEnableMulticast);
    int put_EnableMulticast([in] BOOL EnableMulticast);
    int get_EnableUDP([out] BOOL *pEnableUDP);
    int put_EnableUDP([in] BOOL EnableUDP);
    int get_EnableTCP([out] BOOL *pEnableTCP);
    int put_EnableTCP([in] BOOL EnableTCP);
    int get_EnableHTTP([out] BOOL *pEnableHTTP);
    int put_EnableHTTP([in] BOOL EnableHTTP);
}

[
	odl,
	uuid(FA2AA8F2-8B62-11D0-A520-000000000000)
]
interface IAMChannelInfo : IDispatch
{
    int get_ChannelName([out] BSTR *pbstrChannelName);
    int get_ChannelDescription([out] BSTR *pbstrChannelDescription);
    int get_ChannelURL([out] BSTR *pbstrChannelURL);
    int get_ContactAddress([out] BSTR *pbstrContactAddress);
    int get_ContactPhone([out] BSTR *pbstrContactPhone);
    int get_ContactEmail([out] BSTR *pbstrContactEmail);

}

[
	odl,
	uuid(FA2AA8F3-8B62-11D0-A520-000000000000)
]
interface IAMNetworkStatus : IDispatch
{
    int get_ReceivedPackets([out] long *pReceivedPackets);
    int get_RecoveredPackets([out] long *pRecoveredPackets);
    int get_LostPackets([out] long *pLostPackets);
    int get_ReceptionQuality([out] long *pReceptionQuality);
    int get_BufferingCount([out] long *pBufferingCount);
    int get_IsBroadcast([out] BOOL *pIsBroadcast);
    int get_BufferingProgress([out] long *pBufferingProgress);
}

[
	odl,
    uuid(FA2AA8F5-8B62-11D0-A520-000000000000)
]
interface IAMNetShowExProps : IDispatch
{
    int get_SourceProtocol([out] long *pSourceProtocol);
    int get_Bandwidth([out] long *pBandwidth);
    int get_ErrorCorrection([out] BSTR *pbstrErrorCorrection);
    int get_CodecCount([out] long *pCodecCount);
    int GetCodecInstalled([out] long *CodecNum, [out] BOOL *pCodecInstalled);
    int GetCodecDescription([out] long *CodecNum, [out] BSTR *pbstrCodecDescription);
    int GetCodecURL([out] long *CodecNum, [out] BSTR *pbstrCodecURL);
    int get_CreationDate([out] double *pCreationDate);
    int get_SourceLink([out] BSTR *pbstrSourceLink);

}

[
	odl,
	uuid(FA2AA8F6-8B62-11D0-A520-000000000000)
]
interface IAMExtendedErrorInfo : IDispatch
{
    int get_HasError([out] BOOL *pHasError);
    int get_ErrorDescription([out] BSTR *pbstrErrorDescription);
    int get_ErrorCode([out] long *pErrorCode);

}

[
	odl,
	uuid(AAE7E4E2-6388-11D1-8D93-006097C9A2B2)
]
interface IAMNetShowPreroll : IDispatch
{

    int put_Preroll([in] BOOL fPreroll);
    int get_Preroll([out] BOOL *pfPreroll);

}

[
	odl,
	uuid(4746B7C8-700E-11D1-BECC-00C04FB6E937)
]
interface IDShowPlugin : IUnknown
{

    int get_URL([out] BSTR *pURL);
    int get_UserAgent([out] BSTR *pUserAgent);

}

[
	odl,
	uuid(FA2AA8F4-8B62-11D0-A520-000000000000)
]
interface IAMMediaContent : IDispatch
{
    int get_AuthorName([out] BSTR *pbstrAuthorName);
    int get_Title([out] BSTR *pbstrTitle);
    int get_Rating([out] BSTR *pbstrRating);
    int get_Description([out] BSTR *pbstrDescription);
    int get_Copyright([out] BSTR *pbstrCopyright);
    int get_BaseURL([out] BSTR *pbstrBaseURL);
    int get_LogoURL([out] BSTR *pbstrLogoURL);
    int get_LogoIconURL([out] BSTR *pbstrLogoURL);
    int get_WatermarkURL([out] BSTR *pbstrWatermarkURL);
    int get_MoreInfoURL([out] BSTR *pbstrMoreInfoURL);
    int get_MoreInfoBannerImage([out] BSTR *pbstrMoreInfoBannerImage);
    int get_MoreInfoBannerURL([out] BSTR *pbstrMoreInfoBannerURL);
    int get_MoreInfoText([out] BSTR *pbstrMoreInfoText);

}

[
	odl,
	uuid(FA2AA8F9-8B62-11D0-A520-000000000000)
]
interface IAMExtendedSeeking : IDispatch
{
    int get_ExSeekCapabilities([out] AMExtendedSeekingCapabilities *pExCapabilities);
    int get_MarkerCount([out] long *pMarkerCount);
    int get_CurrentMarker([out] long *pCurrentMarker);
    int GetMarkerTime([in] long MarkerNum, [out] double *pMarkerTime);
    int GetMarkerName(
        [in] int MarkerNum,
        [out] BSTR *pbstrMarkerName
        );
    int put_PlaybackSpeed([in] double Speed);
    int get_PlaybackSpeed([out] double *pSpeed);

}

[
	odl,
	uuid(CE8F78C1-74D9-11D2-B09D-00A0C9A81117)
]
interface IAMMediaContent2 : IDispatch
{

    int get_MediaParameter([in] long EntryNum, [in] BSTR bstrName, [out] BSTR *pbstrValue);
    int get_MediaParameterName([in] long EntryNum, [in] long Index, [out] BSTR *pbstrName);
    int get_PlaylistCount([out] long *pNumberEntries);

};

//
//
//
//==============================================================

[
	odl,
	uuid(C6E13350-30AC-11d0-A18C-00A0C9118956)
]
interface IAMAnalogVideoDecoder : stdole.IUnknown
    {
        long get_AvailableTVFormats([out] long *lAnalogVideoStandard);
        
        long put_TVFormat( 
            [in] long lAnalogVideoStandard);
        
        long get_TVFormat([out] long *plAnalogVideoStandard);
        
        long get_HorizontalLocked([out] long *plLocked);
        
        long put_VCRHorizontalLocking( 
            [in] long lVCRHorizontalLocking);
        
        long get_VCRHorizontalLocking([out] long *plVCRHorizontalLocking);
        
        long get_NumberOfLines([out] long *plNumberOfLines);
        
        long put_OutputEnable( 
            [in] long lOutputEnable);
        
        long get_OutputEnable([out] long *plOutputEnable);
        
    };

[
	odl,
	uuid(cf7b26fc-9a00-485b-8147-3e789d5e8f67)
]
interface IAMAsyncReaderTimestampScaling : stdole.IUnknown
{
    long GetTimestampMode([out] BOOL *pfRaw);
    
    long SetTimestampMode( 
        [in] BOOL fRaw);
    
};

[
	odl,
	uuid(54C39221-8380-11d0-B3F0-00AA003761C5)
]
interface IAMAudioInputMixer : stdole.IUnknown
{
    long put_Enable( 
        [in] BOOL fEnable);
    
    long get_Enable([out] BOOL *pfEnable);
    
    long put_Mono( 
        [in] BOOL fMono);
    
    long get_Mono([out] BOOL *pfMono);
    
    long put_MixLevel( 
        [in] double Level);
    
    long get_MixLevel([out] double *pLevel);
    
    long put_Pan( 
        [in] double Pan);
    
    long get_Pan([out] double *pPan);
    
    long put_Loudness( 
        [in] BOOL fLoudness);
    
    long get_Loudness([out] BOOL *pfLoudness);
    
    long put_Treble( 
        [in] double Treble);
    
    long get_Treble([out] double *pTreble);
    
    long get_TrebleRange([out] double *pRange);
    
    long put_Bass( 
        [in] double Bass);
    
    long get_Bass([out] double *pBass);
    
    long get_BassRange([out] double *pRange);
    
};

[
	odl,
	uuid(22320CB2-D41A-11d2-BF7C-D7CB9DF0BF93)
]
interface IAMAudioRendererStats : stdole.IUnknown
{
    long GetStatParam( 
        [in] DWORD dwParam,
        [out] DWORD *pdwParam1,
        [out] DWORD *pdwParam2);
    
};

typedef struct ALLOCATOR_PROPERTIES
{
	long cBuffers;
	long cbBuffer;
	long cbAlign;
	long cbPrefix;
} 	ALLOCATOR_PROPERTIES;

[
	odl,
	uuid(56ED71A0-AF5F-11D0-B3F0-00AA003761C5)
]
interface IAMBufferNegotiation : stdole.IUnknown
{
    long SuggestAllocatorProperties( 
        [in] ALLOCATOR_PROPERTIES *pprop);
    
    long GetAllocatorProperties( 
        [out] ALLOCATOR_PROPERTIES *pprop);
    
};

[
	odl,
	uuid(C6E13370-30AC-11d0-A18C-00A0C9118956)
]
interface IAMCameraControl : stdole.IUnknown
{
    long GetRange( 
        [in] long Property,
        [out] long *pMin,
        [out] long *pMax,
        [out] long *pSteppingDelta,
        [out] long *pDefault,
        [out] long *pCapsFlags);
    
    [helpstring("ccSet renamed from Set; VB keywords can't be function names.")]
    long ccSet( 
        [in] long Property,
        [in] long lValue,
        [in] long Flags);
    
    [helpstring("ccGet renamed from Get; VB keywords can't be function names.")]
    long ccGet( 
        [in] long Property,
        [out] long *lValue,
        [out] long *Flags);
    
};
typedef struct AMCOPPSignature
{
    BYTE Signature[256];
} AMCOPPSignature;

typedef struct AMCOPPCommand
{
    UUID macKDI;
    UUID guidCommandID;
    DWORD dwSequence;
    DWORD cbSizeData;
    BYTE CommandData[4056];
} AMCOPPCommand;
typedef struct AMCOPPStatusInput
{
    UUID rApp;
    UUID guidStatusRequestID;
    DWORD dwSequence;
    DWORD cbSizeData;
    BYTE StatusData[4056];
} AMCOPPStatusInput;

typedef struct AMCOPPStatusOutput
{
    UUID macKDI;
    DWORD cbSizeData;
    BYTE COPPStatus[4076];
} AMCOPPStatusOutput;

[
	odl,
	uuid(6feded3e-0ff1-4901-a2f1-43f7012c8515)
]
interface IAMCertifiedOutputProtection : stdole.IUnknown
{
    long KeyExchange( 
        [out] UUID *pRandom,
        [out] long *VarLenCertGH,
        [out] DWORD *pdwLengthCertGH); //2nd param BYTE ** to pointer
    
    long SessionSequenceStart( 
        [in] AMCOPPSignature *pSig);
    
    long ProtectionCommand( 
        [in] AMCOPPCommand *cmd);
    
    long ProtectionStatus( 
        [in] AMCOPPStatusInput *pStatusInput,
        [out] AMCOPPStatusOutput *pStatusOutput);
    
};

[
	odl,
	uuid(4d5466b0-a49c-11d1-abe8-00a0c905f375)
]
interface IAMClockAdjust : stdole.IUnknown
{
    long SetClockDelta( 
        [in] REFERENCE_TIME rtDelta);
    
};
[
	odl,
	uuid(9FD52741-176D-4b36-8F51-CA8F933223BE)
]
interface IAMClockSlave : stdole.IUnknown
{
    long SetErrorTolerance( 
        [in] DWORD dwTolerance);
    
    long GetErrorTolerance( 
        [out] DWORD *pdwTolerance);
    
};

[
	odl,
	uuid(C6E13380-30AC-11d0-A18C-00A0C9118956)
]
interface IAMCrossbar : stdole.IUnknown
{
    long get_PinCounts( 
        [out] long *OutputPinCount,
        [out] long *InputPinCount);
    
    long CanRoute( 
        [in] long OutputPinIndex,
        [in] long InputPinIndex);
    
    long Route( 
        [in] long OutputPinIndex,
        [in] long InputPinIndex);
    
    long get_IsRoutedTo( 
        [in] long OutputPinIndex,
        [out] long *InputPinIndex);
    
    long get_CrossbarPinInfo( 
        [in] BOOL IsInputPin,
        [in] long PinIndex,
        [out] long *PinIndexRelated,
        [out] long *PhysicalType);
    
};

[
	odl,
	uuid(c0dff467-d499-4986-972b-e1d9090fa941)
]
interface IAMDecoderCaps : stdole.IUnknown
{
    long GetDecoderCaps( 
        [in] DWORD dwCapIndex,
        [out] DWORD *lpdwCap);
    
};

[
	odl,
	uuid(56a8689a-0ad4-11ce-b03a-0020af0ba770)
]
interface IMediaSample : stdole.IUnknown
{
	long GetPointer([out] long* pBuffer); //BYTE ** array - use CopyMemory
	long GetSize(void);
	long GetTime([out] REFERENCE_TIME *pTimeStart, [out] REFERENCE_TIME *pTimeEnd);
	long SetTime([in] REFERENCE_TIME *pTimeStart, [in] REFERENCE_TIME *pTimeEnd);
	long IsSyncPoint(void);
	long SetSyncPoint([in] BOOL bIsSyncPoint);
	long IsPreroll(void);
	long SetPreroll([in] BOOL bIsPreroll);
	long GetActualDataLength(void);
	long SetActualDataLength([in] long MIDL__IMediaSample0000);
	long GetMediaType([out] AM_MEDIA_TYPE *ppMediaType);
	long SetMediaType([in] AM_MEDIA_TYPE *pMediaType);
	long IsDiscontinuity(void);
	long SetDiscontinuity([in] BOOL bDiscontinuity);
	long GetMediaTime([out] REFERENCE_TIME *pTimeStart, [out] REFERENCE_TIME *pTimeEnd);
	long SetMediaTime([in] REFERENCE_TIME *pTimeStart, [in] REFERENCE_TIME *pTimeEnd);
};

typedef enum AM_SAMPLE_PROPERTY_FLAGS
{
	AM_SAMPLE_SPLICEPOINT = 0x1,
	AM_SAMPLE_PREROLL = 0x2,
	AM_SAMPLE_DATADISCONTINUITY = 0x4,
	AM_SAMPLE_TYPECHANGED = 0x8,
	AM_SAMPLE_TIMEVALID = 0x10,
	AM_SAMPLE_TIMEDISCONTINUITY = 0x40,
	AM_SAMPLE_FLUSH_ON_PAUSE = 0x80,
	AM_SAMPLE_STOPVALID = 0x100,
	AM_SAMPLE_ENDOFSTREAM = 0x200,
	AM_STREAM_MEDIA = 0,
	AM_STREAM_CONTROL = 1
} AM_SAMPLE_PROPERTY_FLAGS;
typedef struct AM_SAMPLE2_PROPERTIES
{
	DWORD cbData;
	DWORD dwTypeSpecificFlags;
	AM_SAMPLE_PROPERTY_FLAGS dwSampleFlags;
	LONG lActual;
	REFERENCE_TIME tStart;
	REFERENCE_TIME tStop;
	DWORD dwStreamId;
	LONG pMediaType; // was AM_MEDIA_TYPE *pMediaType; VB6 can't do that, so instead, pass the pointer from VarPtr
	LONG pbBuffer; // was BYTE *pbBuffer; same issue as above
	LONG cbBuffer;
} AM_SAMPLE2_PROPERTIES;

[
	odl,
	uuid(36b73884-c2c8-11cf-8b46-00805f6cef60)
]
interface IMediaSample2 : IMediaSample
{
	long GetProperties([in] DWORD cbProperties, [in] BYTE *pbProperties);
	long SetProperties([in] DWORD cbProperties, [in] BYTE *pbProperties);
};

[
	odl,
	uuid(68961E68-832B-41ea-BC91-63593F3E70E3)
]
interface IMediaSample2Config : stdole.IUnknown
{
	HRESULT GetSurface([out] IUnknown **ppDirect3DSurface9);
}


[
	odl,
	uuid(56a8689c-0ad4-11ce-b03a-0020af0ba770)
]
interface IMemAllocator : stdole.IUnknown
{
	HRESULT SetProperties([in] ALLOCATOR_PROPERTIES *pRequest,
						  [out] ALLOCATOR_PROPERTIES *pActual);

	HRESULT GetProperties([out] ALLOCATOR_PROPERTIES *pProps);

	HRESULT Commit(void);

	HRESULT Decommit(void);

	HRESULT GetBuffer([out] IMediaSample **ppBuffer,
		[in] REFERENCE_TIME *pStartTime,
		[in] REFERENCE_TIME *pEndTime);

	HRESULT ReleaseBuffer([in] IMediaSample *pBuffer);
}


[
	odl,
	uuid(0579154a-2b53-4994-b0d0-e773148eff85)
]
interface ISampleGrabberCB : stdole.IUnknown
{
	HRESULT SampleCB([in] double SampleTime, [in] IMediaSample *pSample);
	HRESULT BufferCB([in] double SampleTime, [in] unsigned char* pBuffer, [in] long BufferLen);
};

[
	odl,
	uuid(6B652FFF-11FE-4fce-92AD-0266B5D7C78F)
]
interface ISampleGrabber : stdole.IUnknown
{
	HRESULT SetOneShot([in] BOOL OneShot);
	HRESULT SetMediaType([in] AM_MEDIA_TYPE *pType);
	HRESULT GetConnectedMediaType([out] AM_MEDIA_TYPE *pType);
	HRESULT SetBufferSamples([in] BOOL BufferThem);
	HRESULT GetCurrentBuffer([out] long *pBufferSize, [out] void *pBuffer);
	HRESULT GetCurrentSample([out] IMediaSample **ppSample);
	HRESULT SetCallback([in] ISampleGrabberCB *pCallback, [in] long WhichMethodToCallback);
};

//Callback interface method by TheTrick
[
	odl,
	uuid(7FA864F8-EBEF-4d07-97E8-A410D7CEEDEB),
	helpstring("User callback object interface")
]
interface ISampleGrabberBuffer : ISampleGrabberCB {

	[helpstring("Reset current time of sample")]
	HRESULT Reset();
	[helpstring("Calculate offset (in bytes) by specified time of sample")]
	long GetOffsetByTime([in] double SampleTime);

}

[
	helpstring("SampleGrabber"),
	uuid(c1f400a0-3f08-11d3-9f0b-006008039e37)
] coclass SampleGrabber { [default] interface ISampleGrabber; };



//[
//	helpstring("Filter Graph"),
//	//threading(both),
//	uuid(e436ebb3-524f-11ce-9f53-0020af0ba770)
//]
//coclass FilterGraph { interface IFilterGraph2; }
//duplicate UUID in quartz dll; this interface or parent not included
//but valid. Use CoCreateInstance; CLSID_FilterGraph is in mDirectShow

typedef CURRENCY STREAM_TIME;

typedef UUID MSPID;
typedef REFGUID REFMSPID;

typedef enum DDS_DDS_STREAM_TYPE {
    STREAMTYPE_READ = 0,
    STREAMTYPE_WRITE = 1,
    STREAMTYPE_TRANSFORM = 2
} DDS_STREAM_TYPE;

typedef enum DDS_DDS_STREAM_STATE {
    STREAMSTATE_STOP = 0,
    STREAMSTATE_RUN = 1
} DDS_STREAM_STATE;


typedef enum COMPLETION_STATUS_FLAGS {
    COMPSTAT_NOUPDATEOK = 0x00000001,
    COMPSTAT_WAIT = 0x00000002,
    COMPSTAT_ABORT = 0x00000004
} COMPLETION_STATUS_FLAGS;

//  Flags for GetInformation
typedef enum MMSTRM_INFO_FLAGS {
    MMSSF_HASCLOCK = 0x00000001,
    MMSSF_SUPPORTSEEK = 0x00000002,
    MMSSF_ASYNCHRONOUS = 0x00000004
} MMSTRM_INFO_FLAGS;

//  Flags for StreamSample::Update
typedef enum SSUPDATE_FLAGS {
    SSUPDATE_ASYNC = 0x00000001,
    SSUPDATE_CONTINUOUS = 0x00000002
} SSUPDATE_FLAGS;

interface IMultiMediaStream;
interface IMediaStream;
interface IStreamSample;

// IMultiMediaStream interface
[
    odl,
    uuid(B502D1BC-9A57-11d0-8FDE-00C04FD9189D)
]
interface IMultiMediaStream : stdole.IUnknown {

    HRESULT GetInformation(
        [out]  MMSTRM_INFO_FLAGS* pdwFlags,
        [out]  DDS_STREAM_TYPE* pStreamType);

    HRESULT GetMediaStream(
        [in] REFMSPID idPurpose,
        [out] IMediaStream** ppMediaStream);

    HRESULT EnumMediaStreams(
        [in] long Index,
        [out] IMediaStream** ppMediaStream);

    HRESULT GetState(
        [out] DDS_STREAM_STATE* pCurrentState);

    HRESULT SetState(
        [in] DDS_STREAM_STATE NewState);

    HRESULT GetTime(
        [out] STREAM_TIME* pCurrentTime);

    HRESULT GetDuration(
        [out] STREAM_TIME* pDuration);

    HRESULT Seek(
        [in] STREAM_TIME SeekTime);

    HRESULT GetEndOfStreamEventHandle(
        [out] LongPtr* phEOS);
};


// IMediaStream interface
[
    odl,
    uuid(B502D1BD-9A57-11d0-8FDE-00C04FD9189D)
]
interface IMediaStream : stdole.IUnknown {

    HRESULT GetMultiMediaStream(
        [out] IMultiMediaStream** ppMultiMediaStream);

    HRESULT GetInformation(
        [out]  MSPID* pPurposeId,
        [out]  DDS_STREAM_TYPE* pType);

    HRESULT SetSameFormat(
        [in] IMediaStream* pStreamThatHasDesiredFormat,
        [in] DWORD dwFlags);

    HRESULT AllocateSample(
        [in]  DWORD dwFlags,
        [out] IStreamSample** ppSample);


    HRESULT CreateSharedSample(
        [in]  IStreamSample* pExistingSample,
        [in]  DWORD dwFlags,
        [out] IStreamSample** ppNewSample);

    HRESULT SendEndOfStream([in] DWORD dwFlags);
};


// IStreamSample interface
[
    odl,
    uuid(B502D1BE-9A57-11d0-8FDE-00C04FD9189D)
]
interface IStreamSample : stdole.IUnknown {

    HRESULT GetMediaStream(
        [in] IMediaStream** ppMediaStream);

    HRESULT GetSampleTimes(
        [out]  STREAM_TIME* pStartTime,
        [out]  STREAM_TIME* pEndTime,
        [out]  STREAM_TIME* pCurrentTime);

    HRESULT SetSampleTimes(
        [in]  STREAM_TIME* pStartTime,
        [in]  STREAM_TIME* pEndTime);

    HRESULT Update(
        [in]  SSUPDATE_FLAGS dwFlags,
        [in]  LongPtr hEvent,
        [in]  LongPtr pfnAPC,
        [in]  LongPtr dwAPCData);

    HRESULT CompletionStatus(
        [in] COMPLETION_STATUS_FLAGS dwFlags,
        [in] DWORD dwMilliseconds);
};


interface IAMMultiMediaStream;
interface IAMMediaStream;
interface IMediaStreamFilter;
interface IDirectDraw;
interface IDirectDrawSurface;
interface IAMMediaTypeStream;
interface IAMMediaTypeSample;

//  Flags definitions for IAMMultiMediaStream::Initialize
typedef enum AMMSF_FLAGS {
    AMMSF_NOGRAPHTHREAD = 0x00000001
} AMMSF_FLAGS;

//  Flags definitions for AddMediaStream and IAMMediaStream::Initialize
typedef enum AMS_INIT_FLAGS {
    //  Don't add a stream - create a default renderer instead
    //  for the supplied purpose id
    AMMSF_ADDDEFAULTRENDERER = 0x00000001,
    AMMSF_CREATEPEER = 0x00000002,

    //  If no samples are created when we run or the last sample
    //  is deleted then terminate this stream
    AMMSF_STOPIFNOSAMPLES = 0x00000004,

    //  If Update is not called keep going
    AMMSF_NOSTALL = 0x00000008
} AMS_INIT_FLAGS;


//  Flag definitions for OpenFile and OpenMoniker
typedef enum AMMSF_RENDERFLAGS {
    AMMSF_RENDERTYPEMASK = 0x00000003,
    AMMSF_RENDERTOEXISTING = 0x00000000,
    AMMSF_RENDERALLSTREAMS = 0x00000001,
    AMMSF_NORENDER = 0x00000002,

    AMMSF_NOCLOCK = 0x00000004,
    AMMSF_RUN = 0x00000008
} AMMSF_RENDERFLAGS;


typedef enum AMMSF_OUTPUT_STATE {
    ammsfosDisabled = 0,
    ammsfosReadData = 1,
    ammsfosRenderData = 2
} AMMSF_OUTPUT_STATE;


// IAMMultiMediaStream interface
[
    odl,
    uuid(BEBE595C-9A6F-11d0-8FDE-00C04FD9189D)
]
interface IAMMultiMediaStream : IMultiMediaStream
{
    HRESULT Initialize(
        [in] DDS_STREAM_TYPE StreamType,
        [in] AMMSF_FLAGS dwFlags,
        [in]  IGraphBuilder* pFilterGraph);

    HRESULT GetFilterGraph(
        [out] IGraphBuilder** ppGraphBuilder);

    HRESULT GetFilter(
        [out] IMediaStreamFilter** ppFilter);

    HRESULT AddMediaStream(
        [in]  stdole.IUnknown* pStreamObject,
        [in]  MSPID* PurposeId,
        [in]  DWORD dwFlags,
        [out] IMediaStream** ppNewStream);

    HRESULT OpenFile(
        [in] LongPtr pszFileName,
        [in] AMMSF_RENDERFLAGS dwFlags);

    HRESULT OpenMoniker(
        [in] IBindCtx* pCtx,
        [in] IMoniker* pMoniker,
        [in] AMMSF_RENDERFLAGS dwFlags);

    HRESULT Render(
        [in] AMMSF_RENDERFLAGS dwFlags);
}


// IAMMediaStream interface
[
    odl,
    uuid(BEBE595D-9A6F-11d0-8FDE-00C04FD9189D)
]
interface IAMMediaStream : IMediaStream
{
    HRESULT Initialize(
        [in]  stdole.IUnknown* pSourceObject,
        [in] AMS_INIT_FLAGS dwFlags,
        [in] REFMSPID PurposeId,
        [in] DDS_STREAM_TYPE StreamType);

    HRESULT SetState(
        [in] FILTER_STATE State);

    HRESULT JoinAMMultiMediaStream(
        [in] IAMMultiMediaStream* pAMMultiMediaStream);

    HRESULT JoinFilter(
        [in] IMediaStreamFilter* pMediaStreamFilter);

    HRESULT JoinFilterGraph(
        [in] IFilterGraph* pFilterGraph);
};




// IMediaStreamFilter interface
[
    odl,
    uuid(BEBE595E-9A6F-11d0-8FDE-00C04FD9189D)
]
interface IMediaStreamFilter : IBaseFilter
{
    HRESULT AddMediaStream(
        [in] IAMMediaStream* pAMMediaStream);

    HRESULT GetMediaStream(
        [in] REFMSPID idPurpose,
        [out] IMediaStream** ppMediaStream);

    HRESULT EnumMediaStreams(
        [in] long Index,
        [out] IMediaStream** ppMediaStream);

    HRESULT SupportSeeking(
        [in] BOOL bRenderer);

    HRESULT ReferenceTimeToStreamTime(
        [in, out] REFERENCE_TIME* pTime);

    HRESULT GetCurrentStreamTime(
        [out] REFERENCE_TIME* pCurrentStreamTime);

    HRESULT WaitUntil(
        [in]  REFERENCE_TIME WaitStreamTime);

    HRESULT Flush(
        [in] BOOL bCancelEOS);

    HRESULT EndOfStream();
};



[
    odl,
    uuid(AB6B4AFC-F6E4-11d0-900D-00C04FD9189D)
]
interface IDirectDrawMediaSampleAllocator : stdole.IUnknown
{
    HRESULT GetDirectDraw([out] stdole.IUnknown** ppDirectDraw);
};


[
    odl,
    uuid(AB6B4AFE-F6E4-11d0-900D-00C04FD9189D)
]
interface IDirectDrawMediaSample : stdole.IUnknown
{
    HRESULT GetSurfaceAndReleaseLock(
        [out] stdole.IUnknown** ppDirectDrawSurface,
        [out] RECT* pRect);
    HRESULT LockMediaSamplePointer(void);
};





[
    odl,
    uuid(AB6B4AFA-F6E4-11d0-900D-00C04FD9189D)
]

interface IAMMediaTypeStream : IMediaStream
{
    HRESULT GetFormat(
        [out]   AM_MEDIA_TYPE* pMediaType,
        [in]    DWORD dwFlags);

    HRESULT SetFormat(
        [in]    AM_MEDIA_TYPE* pMediaType,
        [in]    DWORD dwFlags);

    HRESULT CreateSample(
        [in]  long lSampleSize,
        [in]  BYTE* pbBuffer,
        [in]  DWORD dwFlags,
        [in]  stdole.IUnknown* pUnkOuter,
        [out] IAMMediaTypeSample** ppAMMediaTypeSample);

    HRESULT GetStreamAllocatorRequirements(
        [out] ALLOCATOR_PROPERTIES* pProps);

    HRESULT SetStreamAllocatorRequirements(
        [in]  ALLOCATOR_PROPERTIES* pProps);
};


[
    odl,
    uuid(AB6B4AFB-F6E4-11d0-900D-00C04FD9189D)
]
interface IAMMediaTypeSample : IStreamSample
{
    //
    //  Unique methods for IAMMediaTypeSample
    //
    HRESULT SetPointer([in] BYTE* pBuffer, [in] long lSize);

    //
    //  Mirror of IMediaSample
    //
    HRESULT GetPointer([out] BYTE** ppBuffer);
    long GetSize(void);
    HRESULT GetTime([out] REFERENCE_TIME* pTimeStart, [out] REFERENCE_TIME* pTimeEnd);
    HRESULT SetTime([in] REFERENCE_TIME* pTimeStart, [in] REFERENCE_TIME* pTimeEnd);
    HRESULT IsSyncPoint(void);
    HRESULT SetSyncPoint([in] BOOL bIsSyncPoint);
    HRESULT IsPreroll(void);
    HRESULT SetPreroll([in] BOOL bIsPreroll);
    long GetActualDataLength(void);
    HRESULT SetActualDataLength([in] long value);
    HRESULT GetMediaType([out] AM_MEDIA_TYPE** ppMediaType);
    HRESULT SetMediaType([in] AM_MEDIA_TYPE* pMediaType);
    HRESULT IsDiscontinuity(void);
    HRESULT SetDiscontinuity([in] BOOL bDiscontinuity);
    HRESULT GetMediaTime([out] LONGLONG* pTimeStart, [out] LONGLONG* pTimeEnd);
    HRESULT SetMediaTime([in] LONGLONG* pTimeStart, [in] LONGLONG* pTimeEnd);
};

interface IAudioMediaStream;
interface IAudioStreamSample;
interface IMemoryData;
interface IAudioData;

//  IAudioMediaStream


[
    odl,
    uuid(f7537560-a3be-11d0-8212-00c04fc32c45)
]
interface IAudioMediaStream : IMediaStream
{

    HRESULT GetFormat(
        [out]  WAVEFORMATEX* pWaveFormatCurrent
    );

    HRESULT SetFormat(
        [in] WAVEFORMATEX* lpWaveFormat);

    HRESULT CreateSample(
        [in] IAudioData* pAudioData,
        [in] DWORD dwFlags,
        [out] IAudioStreamSample** ppSample
    );
}

[
    odl,
    uuid(345fee00-aba5-11d0-8212-00c04fc32c45)
]
interface IAudioStreamSample : IStreamSample
{
    HRESULT GetAudioData(
        [out] IAudioData** ppAudio
    );
}


[
    odl,
    uuid(327fc560-af60-11d0-8212-00c04fc32c45)
]
interface IMemoryData : stdole.IUnknown
{
    HRESULT SetBuffer(
        [in] DWORD cbSize,
        [in] BYTE* pbData,
        [in] DWORD dwFlags
    );

    HRESULT GetInfo(
        [out] DWORD* pdwLength,
        [out] LongPtr* ppbData,
        [out] DWORD* pcbActualData
    );
    HRESULT SetActual(
        [in] DWORD cbDataValid
    );
}

[
    odl,
    uuid(54c719c0-af60-11d0-8212-00c04fc32c45)
]
interface IAudioData : IMemoryData
{
    HRESULT GetFormat(
        [out]  WAVEFORMATEX* pWaveFormatCurrent
    );

    HRESULT SetFormat(
        [in] WAVEFORMATEX* lpWaveFormat
    );
}

typedef enum DDSFF_CS_FLAGS {
    DDSFF_PROGRESSIVERENDER = 0x00000001
} DDSFF_CS_FLAGS;

//interface IDirectDraw;
//interface IDirectDrawSurface;
//interface IDirectDrawPalette;
//
//interface IDirectDrawMediaStream;
//interface IDirectDrawStreamSample;

typedef struct DDCOLORKEY
{
    DWORD       dwColorSpaceLowValue;   // low boundary of color space that is to
                                        // be treated as Color Key, inclusive
    DWORD       dwColorSpaceHighValue;  // high boundary of color space that is
                                        // to be treated as Color Key, inclusive
} DDCOLORKEY;
typedef enum DDPixelFormatFlags {
    /*
    *The surface has alpha channel information in the pixel format.
    */
    DDPF_ALPHAPIXELS                        = 0x00000001,

    /*
     * The pixel format contains alpha only information
     */
    DDPF_ALPHA                              = 0x00000002,

     /*
      * The FourCC code is valid.
      */
    DDPF_FOURCC                             = 0x00000004,

      /*
       * The surface is 4-bit color indexed.
       */
    DDPF_PALETTEINDEXED4                    = 0x00000008,

       /*
        * The surface is indexed into a palette which stores indices
        * into the destination surface's 8-bit palette.
        */
    DDPF_PALETTEINDEXEDTO8                  = 0x00000010,

        /*
         * The surface is 8-bit color indexed.
         */
    DDPF_PALETTEINDEXED8                    = 0x00000020,

         /*
          * The RGB data in the pixel format structure is valid.
          */
    DDPF_RGB                                = 0x00000040,

          /*
           * The surface will accept pixel data in the format specified
           * and compress it during the write.
           */
    DDPF_COMPRESSED                         = 0x00000080,

           /*
            * The surface will accept RGB data and translate it during
            * the write to YUV data.  The format of the data to be written
            * will be contained in the pixel format structure.  The DDPF_RGB
            * flag will be set.
            */
    DDPF_RGBTOYUV                           = 0x00000100,

            /*
             * pixel format is YUV - YUV data in pixel format struct is valid
             */
    DDPF_YUV                                = 0x00000200,

             /*
              * pixel format is a z buffer only surface
              */
    DDPF_ZBUFFER                            = 0x00000400,

              /*
               * The surface is 1-bit color indexed.
               */
    DDPF_PALETTEINDEXED1                    = 0x00000800,

               /*
                * The surface is 2-bit color indexed.
                */
    DDPF_PALETTEINDEXED2                    = 0x00001000,

                /*
                 * The surface contains Z information in the pixels
                 */
    DDPF_ZPIXELS                            = 0x00002000,

                 /*
                  * The surface contains stencil information along with Z
                  */
    DDPF_STENCILBUFFER                      = 0x00004000,

                  /*
                   * Premultiplied alpha format -- the color components have been
                   * premultiplied by the alpha component.
                   */
    DDPF_ALPHAPREMULT                       = 0x00008000,


                   /*
                    * Luminance data in the pixel format is valid.
                    * Use this flag for luminance-only or luminance+alpha surfaces,
                    * the bit depth is then ddpf.dwLuminanceBitCount.
                    */
    DDPF_LUMINANCE                          = 0x00020000,

                    /*
                     * Luminance data in the pixel format is valid.
                     * Use this flag when hanging luminance off bumpmap surfaces,
                     * the bit mask for the luminance portion of the pixel is then
                     * ddpf.dwBumpLuminanceBitMask
                     */
    DDPF_BUMPLUMINANCE                      = 0x00040000,

                     /*
                      * Bump map dUdV data in the pixel format is valid.
                      */
    DDPF_BUMPDUDV                           = 0x00080000

} DDPixelFormatFlags;

typedef struct DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DDPixelFormatFlags       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    //union
    //{
    //    DWORD   dwRGBBitCount;          // how many bits per pixel
    //    DWORD   dwYUVBitCount;          // how many bits per pixel
    //    DWORD   dwZBufferBitDepth;      // how many total bits/pixel in z buffer (including any stencil bits)
    //    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels
    //    DWORD   dwLuminanceBitCount;    // how many bits per pixel
    //    DWORD   dwBumpBitCount;         // how many bits per "buxel", total
    //    DWORD   dwPrivateFormatBitCount;// Bits per pixel of private driver formats. Only valid in texture
    //                                    // format list and if DDPF_D3DFORMAT is set
    //} DUMMYUNIONNAMEN(1);
    DWORD BitCount;
    //union
    //{
    //    DWORD   dwRBitMask;             // mask for red bit
    //    DWORD   dwYBitMask;             // mask for Y bits
    //    DWORD   dwStencilBitDepth;      // how many stencil bits (note: dwZBufferBitDepth-dwStencilBitDepth is total Z-only bits)
    //    DWORD   dwLuminanceBitMask;     // mask for luminance bits
    //    DWORD   dwBumpDuBitMask;        // mask for bump map U delta bits
    //    DWORD   dwOperations;           // DDPF_D3DFORMAT Operations
    //} DUMMYUNIONNAMEN(2);
    DWORD RYSLUOpsBits;
    //union
    //{
    //    DWORD   dwGBitMask;             // mask for green bits
    //    DWORD   dwUBitMask;             // mask for U bits
    //    DWORD   dwZBitMask;             // mask for Z bits
    //    DWORD   dwBumpDvBitMask;        // mask for bump map V delta bits
    //    struct
    //    {
    //        WORD    wFlipMSTypes;       // Multisample methods supported via flip for this D3DFORMAT
    //        WORD    wBltMSTypes;        // Multisample methods supported via blt for this D3DFORMAT
    //    } MultiSampleCaps;

    //} DUMMYUNIONNAMEN(3);
    DWORD GUZVBits;
    //union
    //{
    //    DWORD   dwBBitMask;             // mask for blue bits
    //    DWORD   dwVBitMask;             // mask for V bits
    //    DWORD   dwStencilBitMask;       // mask for stencil bits
    //    DWORD   dwBumpLuminanceBitMask; // mask for luminance in bump map
    //} DUMMYUNIONNAMEN(4);
    DWORD BVSBBits;
    //union
    //{
    //    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
    //    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
    //    DWORD   dwLuminanceAlphaBitMask;// mask for alpha channel
    //    DWORD   dwRGBZBitMask;          // mask for Z channel
    //    DWORD   dwYUVZBitMask;          // mask for Z channel
    //} DUMMYUNIONNAMEN(5);
    DWORD AlphaOrZ;
} DDPIXELFORMAT;

typedef enum DDSCAP_FLAGS
{
    /*
     * This bit is reserved. It should not be specified.
     */
    DDSCAPS_RESERVED1                       = 0x00000001,

     /*
      * Indicates that this surface contains alpha-only information.
      * (To determine if a surface is RGBA/YUVA, the pixel format must be
      * interrogated.)
      */
    DDSCAPS_ALPHA                           = 0x00000002,

      /*
       * Indicates that this surface is a backbuffer.  It is generally
       * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
       * It indicates that this surface is THE back buffer of a surface
       * flipping structure.  DirectDraw supports N surfaces in a
       * surface flipping structure.  Only the surface that immediately
       * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
       * The other surfaces are identified as back buffers by the presence
       * of the DDSCAPS_FLIP capability, their attachment order, and the
       * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
       * capabilities.  The bit is sent to CreateSurface when a standalone
       * back buffer is being created.  This surface could be attached to
       * a front buffer and/or back buffers to form a flipping surface
       * structure after the CreateSurface call.  See AddAttachments for
       * a detailed description of the behaviors in this case.
       */
    DDSCAPS_BACKBUFFER                      = 0x00000004,

       /*
        * Indicates a complex surface structure is being described.  A
        * complex surface structure results in the creation of more than
        * one surface.  The additional surfaces are attached to the root
        * surface.  The complex structure can only be destroyed by
        * destroying the root.
        */
    DDSCAPS_COMPLEX                         = 0x00000008,

        /*
         * Indicates that this surface is a part of a surface flipping structure.
         * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
         * DDSCAP_BACKBUFFER bits are not set.  They are set by CreateSurface
         * on the resulting creations.  The dwBackBufferCount field in the
         * DDSURFACEDESC structure must be set to at least 1 in order for
         * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
         * must always be set with creating multiple surfaces through CreateSurface.
         */
    DDSCAPS_FLIP                            = 0x00000010,

         /*
          * Indicates that this surface is THE front buffer of a surface flipping
          * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
          * capability bit is set.
          * If this capability is sent to CreateSurface then a standalonw front buffer
          * is created.  This surface will not have the DDSCAPS_FLIP capability.
          * It can be attached to other back buffers to form a flipping structure.
          * See AddAttachments for a detailed description of the behaviors in this
          * case.
          */
    DDSCAPS_FRONTBUFFER                     = 0x00000020,

          /*
           * Indicates that this surface is any offscreen surface that is not an overlay,
           * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
           * to identify plain vanilla surfaces.
           */
    DDSCAPS_OFFSCREENPLAIN                  = 0x00000040,

           /*
            * Indicates that this surface is an overlay.  It may or may not be directly visible
            * depending on whether or not it is currently being overlayed onto the primary
            * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
            * overlayed at the moment.
            */
    DDSCAPS_OVERLAY                         = 0x00000080,

            /*
             * Indicates that unique DirectDrawPalette objects can be created and
             * attached to this surface.
             */
    DDSCAPS_PALETTE                         = 0x00000100,

             /*
              * Indicates that this surface is the primary surface.  The primary
              * surface represents what the user is seeing at the moment.
              */
    DDSCAPS_PRIMARYSURFACE                  = 0x00000200,


              /*
               * This flag used to be DDSCAPS_PRIMARYSURFACELEFT, which is now
               * obsolete.
               */
    DDSCAPS_RESERVED3               = 0x00000400,
    DDSCAPS_PRIMARYSURFACELEFT              = 0x00000000,

               /*
                * Indicates that this surface memory was allocated in system memory
                */
    DDSCAPS_SYSTEMMEMORY                    = 0x00000800,

                /*
                 * Indicates that this surface can be used as a 3D texture.  It does not
                 * indicate whether or not the surface is being used for that purpose.
                 */
    DDSCAPS_TEXTURE                         = 0x00001000,

                 /*
                  * Indicates that a surface may be a destination for 3D rendering.  This
                  * bit must be set in order to query for a Direct3D Device Interface
                  * from this surface.
                  */
    DDSCAPS_3DDEVICE                        = 0x00002000,

                  /*
                   * Indicates that this surface exists in video memory.
                   */
    DDSCAPS_VIDEOMEMORY                     = 0x00004000,

                   /*
                    * Indicates that changes made to this surface are immediately visible.
                    * It is always set for the primary surface and is set for overlays while
                    * they are being overlayed and texture maps while they are being textured.
                    */
    DDSCAPS_VISIBLE                         = 0x00008000,

                    /*
                     * Indicates that only writes are permitted to the surface.  Read accesses
                     * from the surface may or may not generate a protection fault, but the
                     * results of a read from this surface will not be meaningful.  READ ONLY.
                     */
    DDSCAPS_WRITEONLY                       = 0x00010000,

                     /*
                      * Indicates that this surface is a z buffer. A z buffer does not contain
                      * displayable information.  Instead it contains bit depth information that is
                      * used to determine which pixels are visible and which are obscured.
                      */
    DDSCAPS_ZBUFFER                         = 0x00020000,

                      /*
                       * Indicates surface will have a DC associated long term
                       */
    DDSCAPS_OWNDC                           = 0x00040000,

                       /*
                        * Indicates surface should be able to receive live video
                        */
    DDSCAPS_LIVEVIDEO                       = 0x00080000,

                        /*
                         * Indicates surface should be able to have a stream decompressed
                         * to it by the hardware.
                         */
    DDSCAPS_HWCODEC                         = 0x00100000,

                         /*
                          * Surface is a ModeX surface.
                          *
                          */
    DDSCAPS_MODEX                           = 0x00200000,

                          /*
                           * Indicates surface is one level of a mip-map. This surface will
                           * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
                           * This can be done explicitly, by creating a number of surfaces and
                           * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
                           * If this bit is set then DDSCAPS_TEXTURE must also be set.
                           */
    DDSCAPS_MIPMAP                          = 0x00400000,

                           /*
                            * This bit is reserved. It should not be specified.
                            */
    DDSCAPS_RESERVED2                       = 0x00800000,


                            /*
                             * Indicates that memory for the surface is not allocated until the surface
                             * is loaded (via the Direct3D texture Load() function).
                             */
    DDSCAPS_ALLOCONLOAD                     = 0x04000000,

                             /*
                              * Indicates that the surface will recieve data from a video port.
                              */
    DDSCAPS_VIDEOPORT                       = 0x08000000,

                              /*
                               * Indicates that a video memory surface is resident in true, local video
                               * memory rather than non-local video memory. If this flag is specified then
                               * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
                               * DDSCAPS_NONLOCALVIDMEM.
                               */
    DDSCAPS_LOCALVIDMEM                     = 0x10000000,

                               /*
                                * Indicates that a video memory surface is resident in non-local video
                                * memory rather than true, local video memory. If this flag is specified
                                * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
                                * DDSCAPS_LOCALVIDMEM.
                                */
    DDSCAPS_NONLOCALVIDMEM                  = 0x20000000,

                                /*
                                 * Indicates that this surface is a standard VGA mode surface, and not a
                                 * ModeX surface. (This flag will never be set in combination with the
                                 * DDSCAPS_MODEX flag).
                                 */
    DDSCAPS_STANDARDVGAMODE                 = 0x40000000,

                                 /*
                                  * Indicates that this surface will be an optimized surface. This flag is
                                  * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
                                  * will be created without any underlying video memory until loaded.
                                  */
    DDSCAPS_OPTIMIZED                       = 0x80000000,

} DDSCAP_FLAGS;

typedef struct DDSCAPS
{
    DDSCAP_FLAGS       dwCaps;         // capabilities of surface wanted
} DDSCAPS;

typedef enum DDSD_FLAGS
{
    DDSD_CAPS               = 0x00000001,     // default

    /*
     * dwHeight field is valid.
     */
    DDSD_HEIGHT             = 0x00000002,

     /*
      * dwWidth field is valid.
      */
    DDSD_WIDTH              = 0x00000004,

      /*
       * lPitch is valid.
       */
    DDSD_PITCH              = 0x00000008,

       /*
        * dwBackBufferCount is valid.
        */
    DDSD_BACKBUFFERCOUNT    = 0x00000020,

        /*
         * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
         */
    DDSD_ZBUFFERBITDEPTH    = 0x00000040,

         /*
          * dwAlphaBitDepth is valid.
          */
    DDSD_ALPHABITDEPTH      = 0x00000080,


          /*
           * lpSurface is valid.
           */
    DDSD_LPSURFACE          = 0x00000800,

           /*
            * ddpfPixelFormat is valid.
            */
    DDSD_PIXELFORMAT        = 0x00001000,

            /*
             * ddckCKDestOverlay is valid.
             */
    DDSD_CKDESTOVERLAY      = 0x00002000,

             /*
              * ddckCKDestBlt is valid.
              */
    DDSD_CKDESTBLT          = 0x00004000,

              /*
               * ddckCKSrcOverlay is valid.
               */
    DDSD_CKSRCOVERLAY       = 0x00008000,

               /*
                * ddckCKSrcBlt is valid.
                */
    DDSD_CKSRCBLT           = 0x00010000,

                /*
                 * dwMipMapCount is valid.
                 */
    DDSD_MIPMAPCOUNT        = 0x00020000,

                 /*
                  * dwRefreshRate is valid
                  */
    DDSD_REFRESHRATE        = 0x00040000,

                  /*
                   * dwLinearSize is valid
                   */
    DDSD_LINEARSIZE         = 0x00080000,

                   /*
                    * dwTextureStage is valid
                    */
    DDSD_TEXTURESTAGE       = 0x00100000,
                    /*
                     * dwFVF is valid
                     */
    DDSD_FVF                = 0x00200000,
                     /*
                      * dwSrcVBHandle is valid
                      */
    DDSD_SRCVBHANDLE        = 0x00400000,

                      /*
                       * dwDepth is valid
                       */
    DDSD_DEPTH              = 0x00800000,

                       /*
                        * All input fields are valid.
                        */
    DDSD_ALL              =  0x00fff9ee
} DDSD_FLAGS;
typedef struct DDSURFACEDESC
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DDSD_FLAGS               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    //union
    //{
    //    LONG            lPitch;                 // distance to start of next line (return value only)
    //    DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    //} DUMMYUNIONNAMEN(1);
    //DWORD               dwBackBufferCount;      // number of back buffers requested
    //union
    //{
    //    DWORD           dwMipMapCount;          // number of mip-map levels requested
    //    DWORD           dwZBufferBitDepth;      // depth of Z buffer requested
    //    DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
    //} DUMMYUNIONNAMEN(2);
    DWORD PitchOrLinearSize;
    DWORD MipmapzDeptchOrRefreshRate;
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
    DWORD               dwReserved;             // reserved
    LongPtr             lpSurface;              // pointer to the associated surface memory
    DDCOLORKEY          ddckCKDestOverlay;      // color key for destination overlay use
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    DDPIXELFORMAT       ddpfPixelFormat;        // pixel format description of the surface
    DDSCAPS             ddsCaps;                // direct draw surface capabilities
} DDSURFACEDESC;

// IDirectDrawMediaStream
[
    odl,
    uuid(F4104FCE-9A70-11d0-8FDE-00C04FD9189D)
]
interface IDirectDrawMediaStream : IMediaStream
{
    HRESULT GetFormat(
        [out]  DDSURFACEDESC* pDDSDCurrent,
        [out]  stdole.IUnknown** ppDirectDrawPalette,
        [out]  DDSURFACEDESC* pDDSDDesired,
        [out]  DDSD_FLAGS* pdwFlags);

    HRESULT SetFormat(
        [in]  DDSURFACEDESC* pDDSurfaceDesc,
        [in]  stdole.IUnknown* pDirectDrawPalette);

    HRESULT GetDirectDraw(
        [out] stdole.IUnknown** ppDirectDraw);

    HRESULT SetDirectDraw(
        [in] stdole.IUnknown* pDirectDraw);

    HRESULT CreateSample(
        [in]  stdole.IUnknown* pSurface,
        [in]  RECT* pRect,
        [in]  DDSFF_CS_FLAGS dwFlags,
        [out] stdole.IUnknown** ppSample);

    HRESULT GetTimePerFrame(
        [out] STREAM_TIME* pFrameTime);
};


// IDirectDrawStreamSample
[
    odl,
    uuid(F4104FCF-9A70-11d0-8FDE-00C04FD9189D)
]
interface IDirectDrawStreamSample : IStreamSample
{
    HRESULT GetSurface(
        [out]  stdole.IUnknown** ppDirectDrawSurface,
        [out]  RECT* pRect);

    HRESULT SetRect(
        [in] RECT* pRect);

};

//cpp_quote("DEFINE_GUID(CLSID_AMMultiMediaStream, /* 49c47ce5-9ba4-11d0-8212-00c04fc32c45 */")
//cpp_quote("0x49c47ce5, 0x9ba4, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);")
//cpp_quote("DEFINE_GUID(CLSID_AMDirectDrawStream, /* 49c47ce4-9ba4-11d0-8212-00c04fc32c45 */")
//cpp_quote("0x49c47ce4, 0x9ba4, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);")
//cpp_quote("DEFINE_GUID(CLSID_AMAudioStream, /* 8496e040-af4c-11d0-8212-00c04fc32c45 */")
//cpp_quote("0x8496e040, 0xaf4c, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);")
//cpp_quote("DEFINE_GUID(CLSID_AMAudioData, /* f2468580-af8a-11d0-8212-00c04fc32c45 */")
//cpp_quote("0xf2468580, 0xaf8a, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);")
//cpp_quote("DEFINE_GUID(CLSID_AMMediaTypeStream, /* CF0F2F7C-F7BF-11d0-900D-00C04FD9189D */")
//cpp_quote("0xcf0f2f7c, 0xf7bf, 0x11d0, 0x90, 0xd, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);")




//CLSID_AMMultiMediaStream, /* 49c47ce5-9ba4-11d0-8212-00c04fc32c45 *
[ uuid(49c47ce5-9ba4-11d0-8212-00c04fc32c45) ]
coclass AMMultiMediaStream
{
    [default] interface IAMMultiMediaStream;
    interface IAMMediaTypeStream;
    interface IAMMediaStream;
}

//CLSID_AMDirectDrawStream, /* 49c47ce4-9ba4-11d0-8212-00c04fc32c45 */
[ uuid(49c47ce4-9ba4-11d0-8212-00c04fc32c45) ]
coclass AMDirectDrawStream
{
    [default] interface IDirectDrawMediaStream;
    interface IAMMediaStream;
    interface IMediaStream;
        
};

//CLSID_AMAudioStream, /* 8496e040-af4c-11d0-8212-00c04fc32c45 */
[ uuid(8496e040-af4c-11d0-8212-00c04fc32c45) ]
coclass AMAudioStream
{
    [default] interface IAudioMediaStream;
};

//CLSID_AMAudioData, /* f2468580-af8a-11d0-8212-00c04fc32c45 */
[ uuid(f2468580-af8a-11d0-8212-00c04fc32c45) ]
coclass AMAudioData
{
    [default] interface IAudioData;
};

//CLSID_AMMediaTypeStream, /* CF0F2F7C-F7BF-11d0-900D-00C04FD9189D */"
[ uuid(CF0F2F7C-F7BF-11d0-900D-00C04FD9189D) ]
coclass AMMediaTypeStream
{
    [default] interface IAMMediaStream;
    interface IMediaStream;
    interface IPin;
};



[
	helpstring("File Source Filter"),
	//threading(both),
	uuid(e436ebb5-524f-11ce-9f53-0020af0ba770)
]
coclass AsyncReader { interface IBaseFilter; }

[
	helpstring("AVI Splitter"),
	//threading(both),
	uuid(1b544c20-fd0b-11ce-8c63-00aa0044b51e)
]
coclass AviSplitter { interface IBaseFilter; }

[
	helpstring("MPEG-I Stream Splitter"),
	//threading(both),
	uuid(336475d0-942a-11ce-a870-00aa002feab5)
]
coclass MPEG1Splitter { interface IBaseFilter; }

[
	helpstring("AVI Decompressor"),
	//threading(both),
	uuid(cf49d4e0-1115-11ce-b03a-0020af0ba770)
]
coclass AVIDec { interface IBaseFilter; }

[
	helpstring("DirectSound Audio Renderer"),
	//threading(both),
	uuid(79376820-07d0-11cf-a24d-0020afd79767)
]
coclass DSoundRender { interface IBaseFilter; }

[
	helpstring("Wave Audio Renderer"),
	//threading(both),
	uuid(e30629d1-27e5-11ce-875d-00608cb78066)
]
coclass AudioRender { interface IBaseFilter; }

[
	helpstring("Null Renderer"),
	//threading(both),
	uuid(c1f400a4-3f08-11d3-9f0b-006008039e37)
]
coclass NullRenderer { interface IBaseFilter; }

[
	helpstring("Video Renderer"),
	//threading(both),
	uuid(70e102b0-5556-11ce-97c0-00aa0055595a)
]
coclass VideoRenderer { interface IBaseFilter; }

[
	helpstring("Default Video Renderer"),
	//threading(both),
	uuid(6bc1cffa-8fc1-4261-ac22-cfb4cc38db50)
]
coclass VideoRendererDefault { interface IBaseFilter; }

[
	helpstring("ACM wrapper"),
	//threading(both),
	uuid(6a08cf80-0e18-11cf-a24d-0020afd79767)
]
coclass ACMWrapper { interface IBaseFilter; }

[
	helpstring("Wave Parser"),
	//threading(both),
	uuid(d51bd5a1-7548-11cf-a520-0080c77ef58a)
]
coclass WAVEParser { interface IBaseFilter; }

[
	helpstring("Video Mixing Renderer"),
	//threading(both),
	uuid(b87beb7b-8d29-423f-ae4d-6582c10175ac)
]
coclass VideoMixingRenderer { interface IBaseFilter; }

[
	helpstring("Video Mixing Renderer 9"),
	//threading(both),
	uuid(51b4abf3-748f-4e3b-a276-c828330e926a)
]
coclass VideoMixingRenderer9 { interface IBaseFilter; }