//Microsoft Media Foundations
//
//Main interfaces below courtesy of The_trick
//Additional interfaces by fafalone


// Forward declare all types defined in this typelib

interface IMFSourceResolver;
interface IMFByteStream;
interface IMFAsyncCallback;
interface IMFAsyncResult;
interface IMFAttributes;
interface IMFMediaEventGenerator;
interface IMFMediaEvent;
interface IMFMediaSource;
interface IMFPresentationDescriptor;
interface IMFStreamDescriptor;
interface IMFMediaTypeHandler;
interface IMFMediaType;
interface IMFSourceReader;
interface IMFSample;
interface IMFMediaBuffer;

interface IMFTopology;
interface IMFClock;
interface IMFPresentationTimeSource;

typedef Uint64 TOPOID;

typedef enum MF_ATTRIBUTE_SERIALIZE_OPTIONS {
	MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF = 0x00000001,
} MF_ATTRIBUTE_SERIALIZE_OPTIONS;


typedef enum MFSESSION_SETTOPOLOGY_FLAGS
{
	MFSESSION_SETTOPOLOGY_IMMEDIATE = 0x1,
	MFSESSION_SETTOPOLOGY_NORESOLUTION = 0x2,
	MFSESSION_SETTOPOLOGY_CLEAR_CURRENT = 0x4
}   MFSESSION_SETTOPOLOGY_FLAGS;

typedef enum MFSESSION_GETFULLTOPOLOGY_FLAGS
{
	MFSESSION_GETFULLTOPOLOGY_CURRENT = 0x1

}   MFSESSION_GETFULLTOPOLOGY_FLAGS;

typedef enum {
	MEUnknown = 0,
	MEError = 1,
	MEExtendedType = 2,
	MENonFatalError = 3,
	MEGenericV1Anchor = 3,
	MESessionUnknown = 100,
	MESessionTopologySet = 101,
	MESessionTopologiesCleared = 102,
	MESessionStarted = 103,
	MESessionPaused = 104,
	MESessionStopped = 105,
	MESessionClosed = 106,
	MESessionEnded = 107,
	MESessionRateChanged = 108,
	MESessionScrubSampleComplete = 109,
	MESessionCapabilitiesChanged = 110,
	MESessionTopologyStatus = 111,
	MESessionNotifyPresentationTime = 112,
	MENewPresentation = 113,
	MELicenseAcquisitionStart = 114,
	MELicenseAcquisitionCompleted = 115,
	MEIndividualizationStart = 116,
	MEIndividualizationCompleted = 117,
	MEEnablerProgress = 118,
	MEEnablerCompleted = 119,
	MEPolicyError = 120,
	MEPolicyReport = 121,
	MEBufferingStarted = 122,
	MEBufferingStopped = 123,
	MEConnectStart = 124,
	MEConnectEnd = 125,
	MEReconnectStart = 126,
	MEReconnectEnd = 127,
	MERendererEvent = 128,
	MESessionStreamSinkFormatChanged = 129,
	MESessionV1Anchor = 129,
	MESourceUnknown = 200,
	MESourceStarted = 201,
	MEStreamStarted = 202,
	MESourceSeeked = 203,
	MEStreamSeeked = 204,
	MENewStream = 205,
	MEUpdatedStream = 206,
	MESourceStopped = 207,
	MEStreamStopped = 208,
	MESourcePaused = 209,
	MEStreamPaused = 210,
	MEEndOfPresentation = 211,
	MEEndOfStream = 212,
	MEMediaSample = 213,
	MEStreamTick = 214,
	MEStreamThinMode = 215,
	MEStreamFormatChanged = 216,
	MESourceRateChanged = 217,
	MEEndOfPresentationSegment = 218,
	MESourceCharacteristicsChanged = 219,
	MESourceRateChangeRequested = 220,
	MESourceMetadataChanged = 221,
	MESequencerSourceTopologyUpdated = 222,
	MESourceV1Anchor = 222,
	MESinkUnknown = 300,
	MEStreamSinkStarted = 301,
	MEStreamSinkStopped = 302,
	MEStreamSinkPaused = 303,
	MEStreamSinkRateChanged = 304,
	MEStreamSinkRequestSample = 305,
	MEStreamSinkMarker = 306,
	MEStreamSinkPrerolled = 307,
	MEStreamSinkScrubSampleComplete = 308,
	MEStreamSinkFormatChanged = 309,
	MEStreamSinkDeviceChanged = 310,
	MEQualityNotify = 311,
	MESinkInvalidated = 312,
	MEAudioSessionNameChanged = 313,
	MEAudioSessionVolumeChanged = 314,
	MEAudioSessionDeviceRemoved = 315,
	MEAudioSessionServerShutdown = 316,
	MEAudioSessionGroupingParamChanged = 317,
	MEAudioSessionIconChanged = 318,
	MEAudioSessionFormatChanged = 319,
	MEAudioSessionDisconnected = 320,
	MEAudioSessionExclusiveModeOverride = 321,
	MESinkV1Anchor = 321,
	METrustUnknown = 400,
	MEPolicyChanged = 401,
	MEContentProtectionMessage = 402,
	MEPolicySet = 403,
	METrustV1Anchor = 403,
	MEWMDRMLicenseBackupCompleted = 500,
	MEWMDRMLicenseBackupProgress = 501,
	MEWMDRMLicenseRestoreCompleted = 502,
	MEWMDRMLicenseRestoreProgress = 503,
	MEWMDRMLicenseAcquisitionCompleted = 506,
	MEWMDRMIndividualizationCompleted = 508,
	MEWMDRMIndividualizationProgress = 513,
	MEWMDRMProximityCompleted = 514,
	MEWMDRMLicenseStoreCleaned = 515,
	MEWMDRMRevocationDownloadCompleted = 516,
	MEWMDRMV1Anchor = 516,
	METransformUnknown = 600,
	METransformNeedInput = 601,
	METransformHaveOutput = 602,
	METransformDrainComplete = 603,
	METransformMarker = 604,
	MEReservedMax = 10000
} MediaEventType;

[
	odl,
		uuid(2CD0BD52-BCD5-4B89-B62C-EADC0C031E7D)
]
interface IMFMediaEventGenerator : stdole.IUnknown
{
	HRESULT _stdcall GetEvent(
	[in] long dwFlags,
		[out, retval] IMFMediaEvent * *ppEvent);
HRESULT _stdcall BeginGetEvent(
	[in] IMFAsyncCallback* pCallback,
	[in] stdole.IUnknown* punkState);
HRESULT _stdcall EndGetEvent(
	[in] IMFAsyncResult* pResult,
	[out, retval] IMFMediaEvent** ppEvent);
HRESULT _stdcall QueueEvent(
	[in] MediaEventType met,
	[in] UUID* guidExtendedType,
	[in] long hrStatus,
	[in] void* pvValue);
};

[
	odl,
	uuid(90377834-21D0-4dee-8214-BA2E3E6C1127),
]

interface IMFMediaSession : IMFMediaEventGenerator
{
	HRESULT SetTopology(
		[in] DWORD dwSetTopologyFlags,
		[in] IMFTopology* pTopology);

	HRESULT ClearTopologies(void);

	HRESULT Start(
		[in] UUID *pguidTimeFormat,
		[in] VARIANT *pvarStartPosition);

	HRESULT Pause(void);

	HRESULT Stop(void);

	HRESULT Close(void);

	HRESULT Shutdown(void);

	HRESULT GetClock([out] IMFClock** ppClock);

	HRESULT GetSessionCapabilities(
		[out] DWORD *pdwCaps);

	HRESULT GetFullTopology(
		[in] DWORD dwGetFullTopologyFlags,
		[in] TOPOID TopoId,
		[out] IMFTopology** ppFullTopology);
};


typedef enum MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS
{
	MF_TOPOLOGY_RESOLUTION_SUCCEEDED = 0x00000000,
	MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE = 0x00000001,
	MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS = 0x00000002,
} MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS;



typedef enum MF_RESOLUTION
{
	//
	// Object type requested
	//
	MF_RESOLUTION_MEDIASOURCE = 0x00000001,  // Attempt to return a MediaSource object
	MF_RESOLUTION_BYTESTREAM = 0x00000002,  // Attempt to return a ByteStream object (not currently supported)
	MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE = 0x00000010,
	MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL = 0x00000020,
	MF_RESOLUTION_DISABLE_LOCAL_PLUGINS = 0x00000040,
	MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY = 0x00000080,
	MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY = 0x00000100,
	MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE = 0x00000200,
	MF_RESOLUTION_ENABLE_STORE_PLUGINS = 0x00000400,
	MF_RESOLUTION_READ = 0x00010000,
	MF_RESOLUTION_WRITE = 0x00020000
} MF_RESOLUTION;

typedef enum {
	MFVideoInterlace_Unknown = 0,
	MFVideoInterlace_Progressive = 2,
	MFVideoInterlace_FieldInterleavedUpperFirst = 3,
	MFVideoInterlace_FieldInterleavedLowerFirst = 4,
	MFVideoInterlace_FieldSingleUpper = 5,
	MFVideoInterlace_FieldSingleLower = 6,
	MFVideoInterlace_MixedInterlaceOrProgressive = 7,
	MFVideoInterlace_Last = 8,
	MFVideoInterlace_ForceDWORD = 0x7fffffff
} MFVideoInterlaceMode;


typedef enum {
	MF_OBJECT_MEDIASOURCE = 0,
	MF_OBJECT_BYTESTREAM = 1,
	MF_OBJECT_INVALID = 2
} MF_OBJECT_TYPE;

typedef enum {
	MF_ATTRIBUTE_UINT32 = 19,
	MF_ATTRIBUTE_UINT64 = 21,
	MF_ATTRIBUTE_DOUBLE = 5,
	MF_ATTRIBUTE_GUID = 72,
	MF_ATTRIBUTE_STRING = 31,
	MF_ATTRIBUTE_BLOB = 4113,
	MF_ATTRIBUTE_IUNKNOWN = 13
} MF_ATTRIBUTE_TYPE;

typedef enum {
	MF_ATTRIBUTES_MATCH_OUR_ITEMS = 0,
	MF_ATTRIBUTES_MATCH_THEIR_ITEMS = 1,
	MF_ATTRIBUTES_MATCH_ALL_ITEMS = 2,
	MF_ATTRIBUTES_MATCH_INTERSECTION = 3,
	MF_ATTRIBUTES_MATCH_SMALLER = 4
} MF_ATTRIBUTES_MATCH_TYPE;

[
	odl,
	uuid(FBE5A32D-A497-4B61-BB85-97B1A848A6E3)
]
interface IMFSourceResolver : stdole.IUnknown {
	HRESULT _stdcall CreateObjectFromURL(
		[in] long pwszURL,
		[in] long dwFlags,
		[in] IPropertyStore* pProps,
		[in, out] MF_OBJECT_TYPE* pObjectType,
		[out, retval] IUnknown** ppObject);
	HRESULT _stdcall CreateObjectFromByteStream(
		[in] IMFByteStream* pByteStream,
		[in] long pwszURL,
		[in] long dwFlags,
		[in] IPropertyStore* pProps,
		[in, out] MF_OBJECT_TYPE* pObjectType,
		[out, retval] IUnknown** ppObject);
	HRESULT _stdcall BeginCreateObjectFromURL(
		[in] long pwszURL,
		[in] long dwFlags,
		[in] IPropertyStore* pProps,
		[in, out] IUnknown** ppIUnknownCancelCookie,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState);
	HRESULT _stdcall EndCreateObjectFromURL(
		[in] IMFAsyncResult* pResult,
		[in, out] MF_OBJECT_TYPE* pObjectType,
		[out, retval] IUnknown** ppObject);
	HRESULT _stdcall BeginCreateObjectFromByteStream(
		[in] IMFByteStream* pByteStream,
		[in] long pwszURL,
		[in] long dwFlags,
		[in] IPropertyStore* pProps,
		[in, out] IUnknown** ppIUnknownCancelCookie,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState);
	HRESULT _stdcall EndCreateObjectFromByteStream(
		[in] IMFAsyncResult* pResult,
		[in, out] MF_OBJECT_TYPE* pObjectType,
		[out, retval] IUnknown** ppObject);
	HRESULT _stdcall CancelObjectCreation([in] stdole.IUnknown* pIUnknownCancelCookie);
};

typedef enum {
	msoBegin = 0,
	msoCurrent = 1
} MFBYTESTREAM_SEEK_ORIGIN;

[
	odl,
	uuid(AD4C1B00-4BF7-422F-9175-756693D9130D)
]
interface IMFByteStream : stdole.IUnknown {
	HRESULT _stdcall GetCapabilities([out, retval] long* pdwCapabilities);
	HRESULT _stdcall GetLength([out, retval] CURRENCY* pqwLength);
	HRESULT _stdcall SetLength([in] CURRENCY qwLength);
	HRESULT _stdcall GetCurrentPosition([out, retval] CURRENCY* pqwPosition);
	HRESULT _stdcall SetCurrentPosition([in] CURRENCY qwPosition);
	HRESULT _stdcall IsEndOfStream([out, retval] long* pfEndOfStream);
	HRESULT _stdcall Read(
		[in] void* pb,
		[in] long cb,
		[out, retval] long* pcbRead);
	HRESULT _stdcall BeginRead(
		[in] void* pb,
		[in] long cb,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState);
	HRESULT _stdcall EndRead(
		[in] IMFAsyncResult* pResult,
		[out, retval] long* pcbRead);
	HRESULT _stdcall Write(
		[in] void* pb,
		[in] long cb,
		[out, retval] long* pcbWritten);
	HRESULT _stdcall BeginWrite(
		[in] void* pb,
		[in] long cb,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState);
	HRESULT _stdcall EndWrite(
		[in] IMFAsyncResult* pResult,
		[out, retval] long* pcbWritten);
	HRESULT _stdcall Seek(
		[in] MFBYTESTREAM_SEEK_ORIGIN SeekOrigin,
		[in] CURRENCY llSeekOffset,
		[in] long dwSeekFlags,
		[out, retval] CURRENCY* pqwCurrentPosition);
	HRESULT _stdcall Flush();
	HRESULT _stdcall Close();
};

[
	odl,
	uuid(A27003CF-2354-4F2A-8D6A-AB7CFF15437E)
]
interface IMFAsyncCallback : stdole.IUnknown {
	HRESULT _stdcall GetParameters(
		[in, out] long* pdwFlags,
		[in, out] long* pdwQueue);
	HRESULT _stdcall Invoke([in] IMFAsyncResult* pAsyncResult);
};

[
	odl,
	uuid(AC6B7889-0740-4D51-8619-905994A55CC6)
]
interface IMFAsyncResult : stdole.IUnknown {
	HRESULT _stdcall GetState([out, retval] IUnknown** ppunkState);
	long _stdcall GetStatus();
	HRESULT _stdcall SetStatus([in] long hrStatus);
	HRESULT _stdcall GetObject([out, retval] IUnknown** ppObject);
	IUnknown* _stdcall GetStateNoAddRef();
};

[
	odl,
	uuid(2CD2D921-C447-44A7-A13C-4ADABFC247E3)
]
interface IMFAttributes : stdole.IUnknown {
	HRESULT _stdcall GetItem(
		[in] UUID* guidKey,
		[in] void* pValue);
	HRESULT _stdcall GetItemType(
		[in] UUID* guidKey,
		[out, retval] MF_ATTRIBUTE_TYPE* pType);
	HRESULT _stdcall CompareItem(
		[in] UUID* guidKey,
		[in] VARIANT* Value,
		[out, retval] long* pbResult);
	HRESULT _stdcall Compare(
		[in] IMFAttributes* pTheirs,
		[in] MF_ATTRIBUTES_MATCH_TYPE MatchType,
		[out, retval] long* pbResult);
	HRESULT _stdcall GetUINT32(
		[in] UUID* guidKey,
		[out, retval] long* punValue);
	HRESULT _stdcall GetUINT64(
		[in] UUID* guidKey,
		[out, retval] CURRENCY* punValue);
	HRESULT _stdcall GetDouble(
		[in] UUID* guidKey,
		[out, retval] double* pfValue);
	HRESULT _stdcall GetGUID(
		[in] UUID* guidKey,
		[out, retval] UUID* pguidValue);
	HRESULT _stdcall GetStringLength(
		[in] UUID* guidKey,
		[out, retval] long* pcchLength);
	HRESULT _stdcall GetString(
		[in] UUID* guidKey,
		[in] long pwszValue,
		[in] long cchBufSize,
		[out, retval] long* pcchLength);
	HRESULT _stdcall GetAllocatedString(
		[in] UUID* guidKey,
		[in] void* ppwszValue,
		[out, retval] long* pcchLength);
	HRESULT _stdcall GetBlobSize(
		[in] UUID* guidKey,
		[out, retval] long* pcbBlobSize);
	HRESULT _stdcall GetBlob(
		[in] UUID* guidKey,
		[in] void* pBuf,
		[in] long cbBufSize,
		[out, retval] long* pcbBlobSize);
	HRESULT _stdcall GetAllocatedBlob(
		[in] UUID* guidKey,
		[in] void* ppBuf,
		[out, retval] long* pcbSize);
	HRESULT _stdcall GetUnknown(
		[in] UUID* guidKey,
		[in] UUID* riid,
		[out, retval] IUnknown** ppv);
	HRESULT _stdcall SetItem(
		[in] UUID* guidKey,
		[in] VARIANT* Value);
	HRESULT _stdcall DeleteItem([in] UUID* guidKey);
	HRESULT _stdcall DeleteAllItems();
	HRESULT _stdcall SetUINT32(
		[in] UUID* guidKey,
		[in] long unValue);
	HRESULT _stdcall SetUINT64(
		[in] UUID* guidKey,
		[in] CURRENCY unValue);
	HRESULT _stdcall SetDouble(
		[in] UUID* guidKey,
		[in] double fValue);
	HRESULT _stdcall SetGUID(
		[in] UUID* guidKey,
		[in] UUID* guidValue);
	HRESULT _stdcall SetString(
		[in] UUID* guidKey,
		[in] long wszValue);
	HRESULT _stdcall SetBlob(
		[in] UUID* guidKey,
		[in] void* pBuf,
		[in] long cbBufSize);
	HRESULT _stdcall SetUnknown(
		[in] UUID* guidKey,
		[in] stdole.IUnknown* pUnknown);
	HRESULT _stdcall LockStore();
	HRESULT _stdcall UnlockStore();
	HRESULT _stdcall GetCount([out, retval] long* pcItems);
	HRESULT _stdcall GetItemByIndex(
		[in] long unIndex,
		[in] UUID* pguidKey,
		[in] void* pValue);
	HRESULT _stdcall CopyAllItems([in] IMFAttributes* pDest);
};






[
	odl,
	uuid(DF598932-F10C-4E39-BBA2-C308F101DAA3)
]
interface IMFMediaEvent : IMFAttributes {
	HRESULT _stdcall GetType([out, retval] MediaEventType* pmet);
	HRESULT _stdcall GetExtendedType([out, retval] UUID* pguidExtendedType);
	HRESULT _stdcall GetStatus([out, retval] long* phrStatus);
	HRESULT _stdcall GetValue([out, retval] VARIANT* pvValue);
};

[
	odl,
	uuid(E7FE2E12-661C-40DA-92F9-4F002AB67627)
]
interface IMFReadWriteClassFactory : stdole.IUnknown
{
	HRESULT CreateInstanceFromURL(
		[in] REFCLSID clsid,
		[in] LongPtr pwszURL,
		[in] IMFAttributes* pAttributes,
		[in] REFIID riid,
		[out] LPVOID ppvObject);

	HRESULT CreateInstanceFromObject(
		[in] REFCLSID clsid,
		[in] IUnknown* punkObject,
		[in] IMFAttributes* pAttributes,
		[in] REFIID riid,
		[out] LPVOID ppvObject);
};

[
	odl,
	uuid(279A808D-AEC7-40C8-9C6B-A6B492C78A66)
]
interface IMFMediaSource : IMFMediaEventGenerator {
	HRESULT _stdcall GetCharacteristics([out, retval] long* pdwCharacteristics);
	HRESULT _stdcall CreatePresentationDescriptor([out, retval] IMFPresentationDescriptor** ppPresentationDescriptor);
	HRESULT _stdcall Start(
		[in] IMFPresentationDescriptor* pPresentationDescriptor,
		[in] void* pguidTimeFormat,
		[in] void* pvarStartPosition);
	HRESULT _stdcall Stop();
	HRESULT _stdcall Pause();
	HRESULT _stdcall Shutdown();
};

[
	odl,
	uuid(03CB2711-24D7-4DB6-A17F-F3A7A479A536)
]
interface IMFPresentationDescriptor : IMFAttributes {
	HRESULT _stdcall GetStreamDescriptorCount([out, retval] long* pdwDescriptorCount);
	HRESULT _stdcall GetStreamDescriptorByIndex(
		[in] long dwIndex,
		[in, out] long* pfSelected,
		[out, retval] IMFStreamDescriptor** ppDescriptor);
	HRESULT _stdcall SelectStream([in] long dwDescriptorIndex);
	HRESULT _stdcall DeselectStream([in] long dwDescriptorIndex);
	HRESULT _stdcall Clone([out, retval] IMFPresentationDescriptor** ppPresentationDescriptor);
};

[
	odl,
	uuid(56C03D9C-9DBB-45F5-AB4B-D80F47C05938)
]
interface IMFStreamDescriptor : IMFAttributes {
	HRESULT _stdcall GetStreamIdentifier([out, retval] long* pdwStreamIdentifier);
	HRESULT _stdcall GetMediaTypeHandler([out, retval] IMFMediaTypeHandler** ppMediaTypeHandler);
};

[
	odl,
	uuid(E93DCF6C-4B07-4E1E-8123-AA16ED6EADF5)
]
interface IMFMediaTypeHandler : stdole.IUnknown {
	HRESULT _stdcall IsMediaTypeSupported(
		[in] IMFMediaType* pMediaType,
		[out, retval] IMFMediaType** ppMediaType);
	HRESULT _stdcall GetMediaTypeCount([out, retval] long* pdwTypeCount);
	HRESULT _stdcall GetMediaTypeByIndex(
		[in] long dwIndex,
		[out, retval] IMFMediaType** ppType);
	HRESULT _stdcall SetCurrentMediaType([in] IMFMediaType* pMediaType);
	HRESULT _stdcall GetCurrentMediaType([out, retval] IMFMediaType** ppMediaType);
	HRESULT _stdcall GetMajorType([out, retval] UUID* pguidMajorType);
};

[
	odl,
	uuid(44AE0FA8-EA31-4109-8D2E-4CAE4997C555)
]
interface IMFMediaType : IMFAttributes {
	HRESULT _stdcall GetMajorType([out, retval] UUID* pguidMajorType);
	HRESULT _stdcall IsCompressedFormat([out, retval] long* pfCompressed);
	HRESULT _stdcall IsEqual(
		[in] IMFMediaType* pIMediaType,
		[out, retval] long* pdwFlags);
	HRESULT _stdcall GetRepresentation(
		[in] long guidRepresentation1, [in] long guidRepresentation2, [in] long guidRepresentation3, [in] long guidRepresentation4,
		[in, out] void* ppvRepresentation);
	HRESULT _stdcall FreeRepresentation(
		[in] long guidRepresentation1, [in] long guidRepresentation2, [in] long guidRepresentation3, [in] long guidRepresentation4,
		[in] void* pvRepresentation);
};

[
	odl,
	uuid(70AE66F2-C809-4E4F-8915-BDCB406B7993)
]
interface IMFSourceReader : stdole.IUnknown {
	HRESULT _stdcall GetStreamSelection(
		[in] long dwStreamIndex,
		[out, retval] long* pfSelected);
	HRESULT _stdcall SetStreamSelection(
		[in] long dwStreamIndex,
		[in] long fSelected);
	HRESULT _stdcall GetNativeMediaType(
		[in] long dwStreamIndex,
		[in] long dwMediaTypeIndex,
		[out, retval] IMFMediaType** ppMediaType);
	HRESULT _stdcall GetCurrentMediaType(
		[in] long dwStreamIndex,
		[out, retval] IMFMediaType** ppMediaType);
	HRESULT _stdcall SetCurrentMediaType(
		[in] long dwStreamIndex,
		[in] long pdwReserved,
		[in] IMFMediaType* pMediaType);
	HRESULT _stdcall SetCurrentPosition(
		[in] UUID* guidTimeFormat,
		[in] VARIANT* varPosition);
	HRESULT _stdcall ReadSample(
		[in] long dwStreamIndex,
		[in] long dwControlFlags,
		[in, out] long* pdwActualStreamIndex,
		[in, out] long* pdwStreamFlags,
		[in, out] CURRENCY* pllTimestamp,
		[out, retval] IMFSample** ppSample);
	HRESULT _stdcall Flush([in] long dwStreamIndex);
	HRESULT _stdcall GetServiceForStream(
		[in] long dwStreamIndex,
		[in] UUID* guidService,
		[in] UUID* riid,
		[in] void* ppvObject);
	HRESULT _stdcall GetPresentationAttribute(
		[in] long dwStreamIndex,
		[in] UUID* guidAttribute,
		[out, retval] VARIANT* pvarAttribute);
};



interface IMFTransform;

[
	odl,
	uuid(7b981cf0-560e-4116-9875-b099895f23d7)
]
/// <summary>
///     This interface exposes additional functionality available from Source Reader
///     The application obtains this interface via QueryInterface on IMFSourceReader
/// </summary>
interface IMFSourceReaderEx : IMFSourceReader
{
	/// <summary>
	///     Allows the application to force a particular media type on the media
	///     source that Source Reader is using. The media type must be supported
	///     directly (without any conversions) by the media source.
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index for which the source media type is to be set.
	/// </param>
	/// <param name="pTransform">
	///     A pointer to the media type to set.
	/// </param>
	HRESULT SetNativeMediaType(
		[in] DWORD dwStreamIndex,
		[in] IMFMediaType* pMediaType,
		[out] DWORD* pdwStreamFlags);

	/// <summary>
	///     Function to add a transform to the end of the chain for a 
	///     particular stream.
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index for which the transform is to be added.
	/// </param>
	/// <param name="pTransform">
	///     A pointer that can be QI'ed for either:
	///         IMFTransform interface of the transform to be added
	///         IMFActivate interface of the transform activate
	/// </param>
	HRESULT AddTransformForStream([in] DWORD dwStreamIndex,
		[in] IUnknown* pTransformOrActivate);

	/// <summary>
	///     Function to remove all added transforms for a particular stream.
	///     NOTE: Automatically inserted transforms (such as the decoder) are
	///           not removed via this API.
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index for which all transforms are removed.
	/// </param>
	HRESULT RemoveAllTransformsForStream([in] DWORD dwStreamIndex);

	/// <summary>
	///     Returns the transform at a particular index in Source Reader's internal
	///     processing chain for a stream.
	///     Applications can use this function if they require direct access to the
	///     transforms (for configuration purposes, etc)
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index.
	/// </param>
	/// <param name="dwTransformIndex">
	///     Specifies a 0-based index for which the application wants to retrieve the
	///     transform. Transform at index 0 is the transform closest to the Media Source
	///     (typically the decoder).
	/// </param>
	/// <param name="pGuidCategory">
	///     On return, receives the category GUID (see MFT_CATEGORY)
	/// </param>
	/// <param name="ppTransform">
	///     On return, receives a pointer to IMFTransform interface of the transform
	///     at a given index for a given stream.
	/// </param>
	HRESULT GetTransformForStream(
		[in] DWORD dwStreamIndex,
		[in] DWORD dwTransformIndex,
		[out] UUID* pGuidCategory,
		[out] IMFTransform** ppTransform);
};

[
	odl,
	uuid(deec8d99-fa1d-4d82-84c2-2c8969944867)
]
/// <summary>
///     This interface is used as the callback mechanism for when the
///     MF Source Reader is used in asynchronous mode.  The application
///     passes in an instance of an object that implements this
///     callback interface as an attribute when creating the source
///     reader instance.
/// </summary>
interface IMFSourceReaderCallback : stdole.IUnknown
{
	/// <summary>
	///     Callback function that completes an asynchronous request for the
	///     next available sample.
	/// </summary>
	/// <param name="hrStatus">
	///     Specifies the error code if an error occurred while processing
	///     the sample request.
	/// </param>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index for the sample.
	/// </param>
	/// <param name="dwStreamFlags">
	///     Specifies the accumulated flags for the stream.
	///     See: section above on MF Source Reader Flags
	/// </param>
	/// <param name="llTimestamp">
	///     Contains the presentation time of the sample.
	///     If MF_SOURCE_READERF_STREAM_TICK is set for the stream flags,
	///     then this contains the timestamp for the stream tick.
	/// </param>
	/// <param name="pSample">
	///     Contains the next sample for the stream.  It is possible for
	///     this parameter to be NULL, so the application should 
	///     explicitly check for NULL before dereferencing the sample.
	/// </param>
	HRESULT OnReadSample(
		[in] HRESULT hrStatus,
		[in] DWORD dwStreamIndex,
		[in] DWORD dwStreamFlags,
		[in] LONGLONG llTimestamp,
		[in] IMFSample* pSample);

	/// <summary>
	///     Callback function that completes an asynchronous request to
	///     flush a particular stream or all the streams.
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index that was flushed or MF_SOURCE_READER_ALL_STREAMS
	/// </param>
	HRESULT OnFlush(
		[in] DWORD dwStreamIndex);

	/// <summary>
	///     Callback function that notifies the application when
	///     certain events occur.
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index associated with the event.
	///     For events from the media source, this will be set to
	///     MF_SOURCE_READER_MEDIASOURCE.
	/// </param>
	/// <param name="pEvent">
	///     Contains the event object.
	/// </param>
	HRESULT OnEvent(
		[in] DWORD dwStreamIndex,
		[in] IMFMediaEvent* pEvent);
};

// 
// This interface extends IMFSourceReaderCallback and is used as the callback mechanism 
// for asynchronously notifying the caller when the transform chain changes, and 
// when an MFT in the chain raises an error event. 
// 
[
	odl,
	uuid(CF839FE6-8C2A-4DD2-B6EA-C22D6961AF05)
]
interface IMFSourceReaderCallback2 : IMFSourceReaderCallback
{
	// 
	// Callback function that is triggered when the transform chain in the SourceReader is built or 
	// modified. 
	// 
	HRESULT OnTransformChange(void);

	// 
	//    - dwStreamIndex specifies the stream of the transform that raised the async error 
	//    - hrStatus specifies the async error raised by the transform 
	// 
	HRESULT OnStreamError(
		[in] DWORD dwStreamIndex,
		[in] HRESULT hrStatus);

};




//////////////////////////////////////////////////////////////////////////////
//
// MF Sink Writer
//
/////////////////////////////////////////////////////////////////////////////

//
// MF Sink Writer attributes
//

// MF_SINK_WRITER_ASYNC_CALLBACK
// Data type: stdole.IUnknown
// If the MF_SINK_WRITER_ASYNC_CALLBACK attribute is set, then the
// Sink Writer will not block during the call to Finalize(), but instead
// will trigger a callback when the operation completes.
// This attribute should be set to the IUnknown interface of an
// object that implements the IMFSinkWriterCallback interface.


typedef enum MF_SINK_WRITER_TAGS
{
	MF_SINK_WRITER_INVALID_STREAM_INDEX = 0xFFFFFFFF,
	MF_SINK_WRITER_ALL_STREAMS = 0xFFFFFFFE,
	MF_SINK_WRITER_MEDIASINK = 0xFFFFFFFF,
} MF_SINK_WRITER_TAGS;

//
// MF Sink Writer Statistics
//


typedef struct MF_SINK_WRITER_STATISTICS
{
	//
	// Set to the size of the structure.  Used so that future releases
	// can support additional statistics without having to rev the interface.
	//
	DWORD cb;

	LONGLONG llLastTimestampReceived;
	LONGLONG llLastTimestampEncoded;
	LONGLONG llLastTimestampProcessed;
	LONGLONG llLastStreamTickReceived;
	LONGLONG llLastSinkSampleRequest;

	QWORD qwNumSamplesReceived;
	QWORD qwNumSamplesEncoded;
	QWORD qwNumSamplesProcessed;
	QWORD qwNumStreamTicksReceived;

	DWORD dwByteCountQueued;
	QWORD qwByteCountProcessed;

	DWORD dwNumOutstandingSinkSampleRequests;

	DWORD dwAverageSampleRateReceived;
	DWORD dwAverageSampleRateEncoded;
	DWORD dwAverageSampleRateProcessed;

} MF_SINK_WRITER_STATISTICS;

//
// MF Sink Writer Interface
//
[
	odl,
	uuid(3137f1cd-fe5e-4805-a5d8-fb477448cb3d)
]
interface IMFSinkWriter : stdole.IUnknown
{
	//
	// Adds a stream to the writer.
	//     - pTargetMediaType specifies the target format of the media samples
	//       for the stream.  This is the format of the samples as they will
	//       be written out to the storage medium.
	//     - pdwStreamIndex receives the stream index associated with the
	//       new stream.
	//
	HRESULT AddStream(
		[in] IMFMediaType* pTargetMediaType,
		[out] DWORD* pdwStreamIndex);

	//
	// Specifies the format of the media samples that will be passed to the
	// Sink Writer for a particular stream if different from the target
	// format.  This method is used to identify the encoder to be used
	// for the stream.
	//
	//     - dwStreamIndex specifies the index of the stream to configure.
	//     - pInputMediaType specifies the format of the media samples that
	//       will be passed to the Sink Writer for this stream.
	//     - pEncodingParameters is used to specify additional attributes used
	//       to configure the encoder.
	//
	// Note: This can called at any time to dynamically change the format
	//       of the input samples for the stream.  Since a format change
	//       is queued on the stream, and may fail during processing, calling
	//       SetInputMediaType will immediately test the MFT to see if the new
	//       type is supported, and only then will it queue the format change.
	//
	HRESULT SetInputMediaType(
		[in] DWORD dwStreamIndex,
		[in] IMFMediaType* pInputMediaType,
		[in] IMFAttributes* pEncodingParameters);

	//
	// Called after all streams are configured, but before
	// writing out any samples.
	//
	HRESULT BeginWriting(void);

	//
	// Called to pass in a new sample to the writer.
	//
	// Note: By default calls to WriteSample may block for a period of time
	//       to throttle the rate at which samples are processed.  The
	//       application can disable this throttling by configuring the writer 
	//       with the MF_SINK_WRITER_DISABLE_THROTTLING attribute.
	//
	HRESULT WriteSample(
		[in] DWORD dwStreamIndex,
		[in] IMFSample* pSample);

	//
	// Called to notify that there is a gap in the stream.
	//
	HRESULT SendStreamTick(
		[in] DWORD dwStreamIndex,
		[in] LONGLONG llTimestamp);

	//
	// Called to request a callback after the Sink Writer has processed
	// all samples in the specified stream.
	//
	//     - dwStreamIndex specifies the stream to request a callback for.
	//     - pvContext will be passed back to the application when the 
	//       callback is triggered.
	//
	// Note: In order for PlaceMarker to work, the application must
	//       configure the Sink Writer with the async callback interface
	//       IMFSinkWriterCallback.
	//
	HRESULT PlaceMarker(
		[in] DWORD dwStreamIndex,
		[in] LPVOID pvContext);

	//
	// Called to notify that the stream has reached the end of a segment.
	//
	//     - dwStreamIndex can either specify a single stream or can be set to
	//       MF_SINK_WRITER_ALL_STREAMS
	//
	HRESULT NotifyEndOfSegment(
		[in] DWORD dwStreamIndex);

	//
	// Called to flush all samples that are queued to be encoded
	// or have not yet been sent to the sink.
	//
	//     - dwStreamIndex can either specify a single stream or can be set to
	//       MF_SINK_WRITER_ALL_STREAMS to flush all stream.
	//
	HRESULT Flush(
		[in] DWORD dwStreamIndex);

	//
	// Called after all samples have been passed to the writer.
	//
	// Note: By default, this call will block until the content generation
	//       has completed, which may take some time.
	//       The app can choose to make Finalize() return immediately and
	//       trigger a callback when the operation completes by configuring
	//       the Sink Writer with an IMFSinkWriterCallback interface set on
	//       the attribute store during Sink Writer creation.
	//
	HRESULT Finalize(void);

	//
	// Allows access to a service or interface from the encoder MFTs
	// or the media sink.
	//
	//     - dwStreamIndex specifies which stream to query for the 
	//       service/interface. MF_SINK_WRITER_MEDIASINK can be specified
	//       instead to get the service/interface from the media sink.
	//     - guidService specifies the service identifier.  This can be set to
	//       GUID_NULL in order to query directory for a specific interface
	//       instead of a service.
	//     - riid specifies the interface identifer to query for.
	//     - ppvObject receives the requested interface.
	//
	HRESULT GetServiceForStream(
		[in] DWORD dwStreamIndex,
		[in] REFGUID guidService,
		[in] REFIID riid,
		[out] LPVOID* ppvObject);

	//
	// Returns various statistics about the performance of the sink writer.
	//
	//     - dwStreamIndex can either specify a single stream or can be set to
	//       MF_SINK_WRITER_ALL_STREAMS to return aggregated statistics for all
	//       streams.
	//     - pStats receives the statistics.
	//
	HRESULT GetStatistics(
		[in] DWORD dwStreamIndex,
		[out] MF_SINK_WRITER_STATISTICS* pStats);
};


[
	odl,
	uuid(588d72ab-5Bc1-496a-8714-b70617141b25)
]
/// <summary>
///     This interface exposes additional functionality available from Sink Writer
///     The application obtains this interface via QueryInterface on IMFSinkWriter
/// </summary>
interface IMFSinkWriterEx : IMFSinkWriter
{
	/// <summary>
	///     Returns the transform at a particular index in Sink Writer's internal
	///     processing chain for a stream.
	///     Applications can use this function if they require direct access to the
	///     transforms (for configuration purposes, etc)
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index.
	/// </param>
	/// <param name="dwTransformIndex">
	///     Specifies a 0-based index for which the application wants to retrieve the
	///     transform. Transform at index 0 is the transform closest to the start of the
	///     chain (i.e. the transform that will be the first to process samples fed to
	///     Sink Writer - e.g. a video processor for video streams)
	/// </param>
	/// <param name="pGuidCategory">
	///     On return, receives the category GUID (see MFT_CATEGORY)
	/// </param>
	/// <param name="ppTransform">
	///     On return, receives a pointer to IMFTransform interface of the transform
	///     at a given index for a given stream.
	/// </param>
	HRESULT GetTransformForStream(
		[in] DWORD dwStreamIndex,
		[in] DWORD dwTransformIndex,
		[out] UUID* pGuidCategory,
		[out] IMFTransform** ppTransform);
};

[
	odl,
	uuid(17C3779E-3CDE-4EDE-8C60-3899F5F53AD6)
]
/// <summary>
///     This interface exposes additional encoder configuration functionality available from Sink Writer
///     The application obtains this interface via QueryInterface on IMFSinkWriter
/// </summary>
interface IMFSinkWriterEncoderConfig : stdole.IUnknown
{
	/// <summary>
	///     Dynamically changes the target media type that Sink Writer is encoding to.
	///     The new media type must be supported by the media sink being used and by
	///     the encoder MFTs installed on the system.
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index.
	/// </param>
	/// <param name="pTargetMediaType">
	///     The new media format to encode to.
	/// </param>
	/// <param name="pEncodingParameters">
	///     A new set of encoding parameters to configure the encoder with.
	///     If not specified, previously provided parameters will be used.
	/// </param>
	HRESULT SetTargetMediaType(
		[in] DWORD dwStreamIndex,
		[in] IMFMediaType* pTargetMediaType,
		[in] IMFAttributes* pEncodingParameters);

	/// <summary>
	///     Dynamically updates the encoder configuration with a collection of new encoder settings.
	///     The settings are applied on the encoder "in-band" with previously provided media samples.
	/// </summary>
	/// <param name="dwStreamIndex">
	///     Specifies the stream index.
	/// </param>
	/// <param name="pEncodingParameters">
	///     A set of encoding parameters to configure the encoder with.
	///     Encoder will be configured with these settings after all previously queued input media samples
	///     have been provided to it via IMFTransform::ProcessInput
	/// </param>
	HRESULT PlaceEncodingParameters(
		[in] DWORD dwStreamIndex,
		[in] IMFAttributes* pEncodingParameters);
};


//
// This interface is used as the callback mechanism for when the
// MF Sink Writer is configured to finalize content generation
// asynchronously.
//
[
	odl,
	uuid(666f76de-33d2-41b9-a458-29ed0a972c58)
]
interface IMFSinkWriterCallback : stdole.IUnknown
{
	//
	// Callback function that completes the asynchronous Finalize()
	// operation.
	//
	//   - hrStatus specifies the result of the Finalize() operation.
	//
	HRESULT OnFinalize(
		[in] HRESULT hrStatus);

	//
	// Callback function that is triggered after all samples have been
	// processed for a specific stream and the application had requested
	// a callback using the IMFSinkWriter::PlaceMarker method.
	//
	//    - dwStreamIndex specifies the stream of the transform that sent the async error
	//    - hrStatus specifies the async error fired by the transform
	//
	HRESULT OnMarker(
		[in] DWORD dwStreamIndex,
		[in] LPVOID pvContext);

};


// 
// This interface extends IMFSinkWriterCallback and is used as the callback mechanism 
// for asynchronously notifying the caller when the transform chain changes, and 
// when an MFT in the chain raises an error event. 
// 
[
	odl,,
	uuid(2456BD58-C067-4513-84FE-8D0C88FFDC61)
]
interface IMFSinkWriterCallback2 : stdole.IUnknown
{
	HRESULT OnFinalize(
		[in] HRESULT hrStatus);

	//
	// Callback function that is triggered after all samples have been
	// processed for a specific stream and the application had requested
	// a callback using the IMFSinkWriter::PlaceMarker method.
	//
	//    - dwStreamIndex specifies the stream of the transform that sent the async error
	//    - hrStatus specifies the async error fired by the transform
	//
	HRESULT OnMarker(
		[in] DWORD dwStreamIndex,
		[in] LPVOID pvContext);




	// 
	// Callback function that is triggered when the transform chain in the SinkWriter is built or 
	// modified. 
	// 
	HRESULT OnTransformChange(void);

	// 
	//    - dwStreamIndex specifies the stream of the transform that raised the async error 
	//    - hrStatus specifies the async error raised by the transform 
	// 
	HRESULT OnStreamError(
		[in] DWORD dwStreamIndex,
		[in] HRESULT hrStatus);

};



//
// MF Read/Write common attributes
//







[
	odl,
	uuid(C40A00F2-B93A-4D80-AE8C-5A1C634F58E4)
]
interface IMFSample : IMFAttributes {
	HRESULT _stdcall GetSampleFlags([out, retval] long* pdwSampleFlags);
	HRESULT _stdcall SetSampleFlags([in] long dwSampleFlags);
	HRESULT _stdcall GetSampleTime([out, retval] CURRENCY* phnsSampleTime);
	HRESULT _stdcall SetSampleTime([in] CURRENCY hnsSampleTime);
	HRESULT _stdcall GetSampleDuration([out, retval] CURRENCY* phnsSampleDuration);
	HRESULT _stdcall SetSampleDuration([in] CURRENCY hnsSampleDuration);
	HRESULT _stdcall GetBufferCount([out, retval] long* pdwBufferCount);
	HRESULT _stdcall GetBufferByIndex(
		[in] long dwIndex,
		[out, retval] IMFMediaBuffer** ppBuffer);
	HRESULT _stdcall ConvertToContiguousBuffer([out, retval] IMFMediaBuffer** ppBuffer);
	HRESULT _stdcall AddBuffer([in] IMFMediaBuffer* pBuffer);
	HRESULT _stdcall RemoveBufferByIndex([in] long dwIndex);
	HRESULT _stdcall RemoveAllBuffers();
	HRESULT _stdcall GetTotalLength([out, retval] long* pcbTotalLength);
	HRESULT _stdcall CopyToBuffer([in] IMFMediaBuffer* pBuffer);
};



[
	odl,
	uuid(045FA593-8799-42B8-BC8D-8968C6453507)
]
interface IMFMediaBuffer : stdole.IUnknown {
	HRESULT _stdcall Lock(
		[in, out] void* ppbBuffer,
		[in, out] long* pcbMaxLength,
		[in, out] long* pcbCurrentLength);
	HRESULT _stdcall Unlock();
	HRESULT _stdcall GetCurrentLength([out, retval] long* pcbCurrentLength);
	HRESULT _stdcall SetCurrentLength([in] long cbCurrentLength);
	HRESULT _stdcall GetMaxLength([out, retval] long* pcbMaxLength);
};


typedef CURRENCY  MFTIME;


/// <summary>
///     Bit flags for the clock characteristics returned by
///     IMFClock::GetClockCharacteristics
/// </summary>
typedef enum MFCLOCK_CHARACTERISTICS_FLAGS
{
	/// <member name="MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ">
	///     If set, clock times given in IMFClock::GetCorrelatedTime
	///     are in standard MFTIME (100ns) units.
	///     The dwClockFrequency member of the MFCLOCK_PROPERTIES structure
	///     returned from IMFClock::GetProperties must be set to
	///     MFCLOCK_FREQUENCY_HNS in this case.
	/// </member>
	MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ = 0x2,

	/// <member name="MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING">
	///     If set, the clock will always be in the MFCLOCK_STATE_RUNNING
	///     state.
	/// </member>
	MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING = 0x4,

	/// <member name="MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK">
	///     If set, then this clock is running according to system time.
	///     Therefore, the clock time returned from
	///     IMFClock::GetCorrelation can be used without any further
	///     calculations.
	/// </member>
	MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK = 0x8

}   MFCLOCK_CHARACTERISTICS_FLAGS;


/// <summary>
///     Enumerated type describing the state of a clock.
///     Obtained from IMFClock::GetState.
/// </summary>
typedef enum MFCLOCK_STATE
{
	/// <member name="MFCLOCK_STATE_INVALID">
	///     Clock is currently invalid.
	///     If the clock uses an underlying device, this could mean that
	///     there is no device.
	/// </member>
	MFCLOCK_STATE_INVALID,

	/// <member name="MFCLOCK_STATE_RUNNING">
	///     Clock is currently running (started).
	/// </member>
	MFCLOCK_STATE_RUNNING,

	/// <member name="MFCLOCK_STATE_STOPPED">
	///     Clock is currently stopped and reporting a time of 0.
	/// </member>
	MFCLOCK_STATE_STOPPED,

	/// <member name="MFCLOCK_STATE_PAUSED">
	///     Clock is currently paused, and the time it reports is frozen.
	/// </member>
	MFCLOCK_STATE_PAUSED

}   MFCLOCK_STATE;


/// <summary>
///     Bit flags for the dwClockFlags member of MFCLOCK_PROPERTIES
/// </summary>
typedef enum MFCLOCK_RELATIONAL_FLAGS
{
	/// <member name="MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD">
	///     If set, this bit indicates that jitter values are always negative.
	///     That is, the clock time returned by IMFClock::GetCorrelatedTime()
	///     will never jitter to times ahead; only to times behind.
	/// </member>
	MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD = 0x1

}   MFCLOCK_RELATIONAL_FLAGS;


/// <summary>
///     Properties structure describing how the clock retrieves and reports
///     time.
///     Obtained from IMFClock::GetProperties
/// </summary>
//cpp_quote("#if defined(_MSC_VER) && (_MSC_VER >= 1600)")
//cpp_quote("#pragma warning(push)")
//cpp_quote("#pragma warning(disable:4820) // Disable C4820: padding after data member")
//cpp_quote("#endif")
typedef struct MFCLOCK_PROPERTIES
{
	/// <member name="qwCorrelationRate">
	///     The nominal rate at which the clock is correlated to MF system time.
	///     A value of 0 means that the correlation is made during the
	///     IMFClock::GetCorrelatedTime call.
	/// </member>
	CURRENCY qwCorrelationRate;

	/// <member name="guidClockId">
	///     Uniquely identifies the clocking device (source crystal).
	///     If two clocks have the same guidClockId, then they are based
	///     on the same clocking device.
	///     A value of GUID_NULL indicates that this clock is not similar
	///     to any other clock.
	/// </member>
	GUID        guidClockId;

	/// <member name="dwClockFlags">
	///     Bit flags describing this clock.
	///     See enumerated type MFCLOCK_RELATIONAL_FLAGS.
	/// </member>
	DWORD       dwClockFlags;

	/// <member name="qwClockFrequency">
	///     Fixed frequency in Hz at which the clock operates.
	///     A value of MFCLOCK_FREQUENCY_HNS means that the clock has
	///     a frequency of 10MHz, which is standard MFTIME units (100ns).
	///     If the bit flag MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ
	///     is set in the characteristics returned by
	///     IMFClock::GetClockCharacteristics, then this value must be equal
	///     to MFCLOCK_FREQUENCY_HNS.
	/// </member>
	CURRENCY qwClockFrequency;

	/// <member name="dwClockTolerance">
	///     Amount of inaccuracy in parts-per-billion that may be present
	///     on the clock.
	///     Implementations that do not know the clock tolerance should
	///     set this value to MFCLOCK_TOLERANCE_UNKNOWN, which is the
	///     value typical in crystal specifications.
	/// </member>
	DWORD       dwClockTolerance;

	/// <member name="dwClockJitter">
	///     Amount of jitter in 100ns units that may be present on this
	///     clock due to sampling (this does not include the inaccuracies
	///     accounted for in dwClockTolerance).
	///     For single-device clocks, this is the inverse of frequency.
	///     For frequencies greater than or equal to 10MHz on single-device
	///     clocks, this value should be 1.
	///     When this clock belongs to a capture device that is not directly
	///     timestamping the incoming data, the correlation cannot be made
	///     until the driver's interrupt service routine runs.
	///     If this is the case,
	///     then these values should be included in the expected jitter:
	///     <para>
	///         MFCLOCK_JITTER_ISR:
	///             Jitter due to timestamping during
	///             the device driver's interrupt service routine.
	///     </para>
	///     <para>
	///         MFCLOCK_JITTER_DPC:
	///             Jitter due to timestampind during
	///             the device driver's deferred procedure call processing.
	///     </para>
	///     <para>
	///         MFCLOCK_JITTER_PASSIVE:
	///             Jitter due to dropping to
	///             passive level (normal thread execution) before timestamping.
	///     </para>
	/// </member>
	DWORD       dwClockJitter;

}   MFCLOCK_PROPERTIES;
//cpp_quote("#if defined(_MSC_VER) && (_MSC_VER >= 1600)")
//cpp_quote("#pragma warning(pop)")
//cpp_quote("#endif")


///// <summary>
/////     Constants used in MFCLOCK_PROPERTIES fields.
/////     See CMFCLOCK_PROPERTIES comments.
///// </summary>
//cpp_quote("#define MFCLOCK_FREQUENCY_HNS       10000000")
//cpp_quote("#define MFCLOCK_TOLERANCE_UNKNOWN   50000")
//cpp_quote("#define MFCLOCK_JITTER_ISR          1000")
//cpp_quote("#define MFCLOCK_JITTER_DPC          4000")
//cpp_quote("#define MFCLOCK_JITTER_PASSIVE      10000")

/// <summary>
///     IMFClock is the basic interface for any object providing a time.
/// </summary>
[
	odl,
	uuid(2eb1e945-18b8-4139-9b1a-d5d584818530),
]
interface IMFClock : stdole.IUnknown
{
	/// <summary>
	///     Gets the characteristics of this clock.
	/// </summary>
	/// <param name="pdwCharacteristics">
	///     Pointer to a variable that will receive the
	///     MFCLOCK_CHARACTERISTICS_FLAGS bit flags.
	/// </param>
	HRESULT GetClockCharacteristics(
		[out] DWORD *pdwCharacteristics);

	/// <summary>
	///     Gets the last known clock time, as correlated to MF system time
	///     (QueryPerformanceCounter time).
	/// </summary>
	/// <param name="dwReserved">
	///     Reserved: Must be 0.
	/// </param>
	/// <param name="pllClockTime">
	///     Pointer to a variable that will be set to the clock time,
	///     in clock's frequency units, at the last
	///     correlation to system time.
	/// </param>
	/// <param name="phnsSystemTime">
	///     Pointer to a variable that will be set to the system time
	///     in 100ns units at which the clock was at *pllClockTime.
	/// </param>
	/// <remarks>
	///     Clock providers should make this correlation as accurate
	///     as possible by raising the driver to the highest IRQL
	///     level to sample device time and system time.
	/// </remarks>
	HRESULT GetCorrelatedTime(
		[in] DWORD dwReserved,
		[out] CURRENCY *pllClockTime,
		[out] MFTIME *phnsSystemTime);

	/// <summary>
	///     IMFClock::GetContinuityKey is not used in this version of
	///     Media Foundation.  Clocks must return 0 in *pdwContinuityKey.
	/// </summary>
	HRESULT GetContinuityKey(
		[out] DWORD *pdwContinuityKey);

	/// <summary>
	///     Gets the current state of the clock.
	/// </summary>
	/// <param name="dwReserved">
	///     Reserved: Must be 0.
	/// </param>
	/// <param name="peClockState">
	///     Pointer to a variable that will receive the current state
	///     of the clock.
	/// </param>
	HRESULT GetState(
		[in] DWORD dwReserved,
		[out] MFCLOCK_STATE *peClockState);

	/// <summary>
	///     Retrieves advanced properties of the clock.
	/// </summary>
	/// <param name="pClockProperties">
	///     Pointer to an MFCLOCK_PROPERTIES that will be filled in
	///     with the advanced properties of this clock.
	/// </param>
	/// <remark>
	///     Please see comments for MFCLOCK_PROPERTIES structure to see
	///     what information can be obtained through the properties.
	/// </remark>
	HRESULT GetProperties(
		[out] MFCLOCK_PROPERTIES *pClockProperties);
};


[
	odl,
	uuid(5BC8A76B-869A-46a3-9B03-FA218A66AEBE)
]
interface IMFCollection : stdole.IUnknown
{
	HRESULT GetElementCount(
		[out]   DWORD* pcElements
		);

	HRESULT GetElement(
		[in]    DWORD dwElementIndex,
		[out]   stdole.IUnknown** ppUnkElement
		);

	HRESULT AddElement(
		[in]    stdole.IUnknown* pUnkElement
		);

	HRESULT RemoveElement(
		[in]    DWORD dwElementIndex,
		[out]   stdole.IUnknown **ppUnkElement
		);

	HRESULT InsertElementAt(
		[in] DWORD dwIndex, [in]
		stdole.IUnknown* pUnknown);

	HRESULT RemoveAllElements();
};

[
	odl,
	uuid(7dc9d5f9-9ed9-44ec-9bbf-0600bb589fbb)
]
interface IMF2DBuffer : stdole.IUnknown
{
	HRESULT Lock2D([in, out] void* pbScanline0, [out] LONG *plPitch);
	HRESULT Unlock2D();
	HRESULT GetScanline0AndPitch([in, out] void* pbScanline0, [out] LONG *plPitch);
	HRESULT IsContiguousFormat([out] BOOL *pfIsContiguous);
	HRESULT GetContiguousLength([out] DWORD *pcbLength);
	HRESULT ContiguousCopyTo([out] BYTE *pbDestBuffer, [in] DWORD cbDestBuffer);
	HRESULT ContiguousCopyFrom([in, out] void* pbSrcBuffer, [in] DWORD cbSrcBuffer);
}

typedef enum MF2DBuffer_LockFlags
{
	MF2DBuffer_LockFlags_LockTypeMask = 0x3, //0x1 | 0x2 | 0x3,
	MF2DBuffer_LockFlags_Read = 0x1,
	MF2DBuffer_LockFlags_Write = 0x2,
	MF2DBuffer_LockFlags_ReadWrite = 0x3,
	MF2DBuffer_LockFlags_ForceDWORD = 0x7fffffff
} MF2DBuffer_LockFlags;

[
	odl,
	uuid(33ae5ea6-4316-436f-8ddd-d73d22f829ec)
]
interface IMF2DBuffer2 : IMF2DBuffer
{
	HRESULT Lock2DSize(
		[in] MF2DBuffer_LockFlags flags,
		[out] BYTE **scanline0,
		[out] LONG *pitch,
		[out] BYTE **buffer_start,
		[out] DWORD *buffer_length);

	HRESULT Copy2DTo([in] IMF2DBuffer2 *dest_buffer);
}

[
	odl,
	uuid(e7174cfa-1c9e-48b1-8866-626226bfc258)
]
interface IMFDXGIBuffer : stdole.IUnknown
{
	HRESULT GetResource(
		[in] UUID* riid,
		[out] LPVOID object
		);

	HRESULT GetSubresourceIndex(
		[out] UINT *index
		);

	HRESULT GetUnknown(
		[in] UUID* guid,
		[in] UUID* riid,
		[out] LPVOID object
		);

	HRESULT SetUnknown(
		[in] UUID* guid,
		[in] stdole.IUnknown *data
		);
}

typedef enum MFTOPOLOGY_DXVA_MODE
{
	/// <summary>
	///     Default DXVA handling for MF v1.  The D3DManager will be set on
	///     decoders inserted by the topoloader only.
	/// </summary>
	MFTOPOLOGY_DXVA_DEFAULT = 0,

	/// <summary>
	///     No DXVA.  No transforms will get the D3DManager.  This allows
	///     software processing even on DXVA-enabled machines
	/// </summary>
	MFTOPOLOGY_DXVA_NONE = 1,

	/// <summary>
	///     Full DXVA.  The D3DManager will be set on any chain of D3D-aware
	///     nodes upstream from a D3D-aware renderer.
	MFTOPOLOGY_DXVA_FULL = 2,

}   MFTOPOLOGY_DXVA_MODE;

typedef enum MFTOPOLOGY_HARDWARE_MODE
{
	/// <summary>
	///     Default hardware handling for MF v1.  Hardware MFTs will
	///     not be inserted.
	/// </summary>
	MFTOPOLOGY_HWMODE_SOFTWARE_ONLY = 0,

	/// <summary>
	///     If hardware MFTs are available, the topoloader will insert
	///     them.  If not, the topoloader will fall back to a software
	///     MFT to perform the task.
	/// </summary>
	MFTOPOLOGY_HWMODE_USE_HARDWARE = 1,

	/// <summary>
	///     If hardware MFTs are available, the topoloader will insert
	///     them.  If not, the connection will fail.
	/// </summary>
	MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE = 2,

} MFTOPOLOGY_HARDWARE_MODE;

typedef enum MF_TOPOLOGY_TYPE
{
	/// <member name="MF_TOPOLOGY_OUTPUT_NODE">
	///     It represents the output topolgy node. The object contained in the output node could be a media sink object or an sink activator object.
	/// </member>
	MF_TOPOLOGY_OUTPUT_NODE,

	/// <member name="MF_TOPOLOGY_SOURCESTREAM_NODE">
	///     It represents the source topology node. The node of this type implements IMFSourceStreamTopologyNode.
	/// </member>
	MF_TOPOLOGY_SOURCESTREAM_NODE,

	/// <member name="MF_TOPOLOGY_TRANSFORM_NODE">
	///     It represents a media foundation transform object. The node of this type contains an IMFTransform object.
	/// </member>
	MF_TOPOLOGY_TRANSFORM_NODE,

	/// <member name="MF_TOPOLOGY_TEE_NODE">
	///     represents a TEE node. It doesn't hold any real object. The node will be useful in scenarios like preview & archive.
	/// </member>
	MF_TOPOLOGY_TEE_NODE,

	MF_TOPOLOGY_MAX = 0xffffffff
} MF_TOPOLOGY_TYPE;

[
	odl,
	uuid(83CF873A-F6DA-4bc8-823F-BACFD55DC430),
]
interface IMFTopologyNode : IMFAttributes
{
	/// <summary>
	/// Allows the application to set the object pointer.
	/// </summary>
	/// <remarks>
	///
	/// Set the object associated with the node;
	///
	/// For MF_TOPOLOGY_TRANSFORM_NODE node, the object needs to implement IMFTransform or IMFActivate
	/// For MF_TOPOLOGY_OUTPUT_NODE node, the object needs to implement IMFStreamSink or IMFActivate.
	///
	/// </remarks>
	/// <param name="pObject">The pointer to the object that will be associated with the node</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT SetObject([in] stdole.IUnknown* pObject);

	/// <summary>
	/// Allows the application to get the object pointer.
	/// </summary>
	/// <remarks>
	///
	/// Get the object associated with the node;
	///
	/// For MF_TOPOLOGY_TRANSFORM_NODE node, it returns the IMFTransform object. With PMP process is involved, the object we give out is a proxy of the actual object.
	/// For MF_TOPOLOGY_OUTPUT_NODE node, the object it returns the object implements IMFStreamSink or IMFActivate.
	///
	/// </remarks>
	/// <param name="ppObject">The pointer to the object that is associated with the topology node</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetObject([out] IUnknown** ppObject);


	/// <summary>
	/// Returns the node type
	/// </summary>
	/// <remarks>
	///
	/// </remarks>
	/// <param name="pType">pointer to a variable where the node type is returned. See MF_TOPOLOGY_TYPE for a list of topolgy node types</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetNodeType([out] MF_TOPOLOGY_TYPE* pType);


	/// <summary>
	/// Return the unique identifier for the node.
	/// </summary>
	/// <remarks>
	/// This ID is set when the topology node is created,
	/// and stays the same no matter what object is set in the node's SetObject.
	/// This unique ID is used by the Topoloader find a node in the previous full topology for object reuse.
	/// </remarks>
	/// <param name="pID">pointer to a variable where TOPOID is returned</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetTopoNodeID([out] TOPOID* pID);

	/// Sets the unique identifier for the node.
	/// </summary>
	HRESULT SetTopoNodeID([in] TOPOID ullTopoID);


	/// <summary>
	/// Return the number of inputs currently available on this topology node.
	/// This might not be the same as the number of input connection of this topology node.
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="pcInputs">pointer to a variable where the input count is returned</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetInputCount([out] DWORD* pcInputs);


	/// <summary>
	/// Return the number of outputs currently available on this topology node.
	/// This might not be the same as the number of output connection of this topology node.
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="pcOutputs">pointer to a  variable where the output count is returned</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetOutputCount([out] DWORD* pcOutputs);


	/// <summary>
	/// Move to topology interface
	/// Connect this node's output to another node's input.
	/// If this output node stream is already connected, it is unlinked first.
	/// </summary>
	/// <param name="dwOutputIndex">
	///     The 0-based index of the output to connect
	/// </param>
	/// <param name="pDownstreamNode">
	///     The downstream node to which to connect
	/// </param>
	/// <param name="dwInputIndexOnDownstreamNode">
	///     The 0-based index of the input to which to connect on
	///     pDownstreamNode
	/// </param>
	/// <remarks>
	///     Input/output index values are meant to be sequential 0-based values.
	///     If a new value dwIndex is used, then new input/output connections
	///     are created for that node so that connections 0 through dwIndex
	///     will exist.
	/// </remarks>
	/// <returns>
	/// </returns>
	//[local]
	HRESULT ConnectOutput([in] DWORD dwOutputIndex,
		[in] IMFTopologyNode* pDownstreamNode,
		[in] DWORD dwInputIndexOnDownstreamNode);


	/// <summary>
	/// Disconnects this node's output from another node's input.
	/// </summary>
	//[local]
	HRESULT DisconnectOutput([in] DWORD dwOutputIndex);


	/// <summary>
	///     Query what node is connected to the given input of this node.
	/// </summary>
	/// <remarks>
	///     Source stream nodes have no inputs and will fail this call.
	/// </remarks>
	/// <param name="dwInputIndex">
	///     The 0-based index of the input connection to query
	/// </param>
	/// <param name="ppUpstreamNode">
	///     Pointer to a variable that will receive the IMFTopologyNode *
	///     that is connected to this input, if any
	/// </param>
	/// <param name="pdwOutputIndexOnUpstreamNode">
	///     Pointer to a variable that will receive the 0-based index
	///     of the output connection on *ppUpstreamNode, if it exists.
	/// </param>
	HRESULT GetInput([in] DWORD dwInputIndex,
		[out] IMFTopologyNode** ppUpstreamNode,
		[out] DWORD* pdwOutputIndexOnUpstreamNode);


	/// <summary>
	///     Query what node is connected to the given output of this node.
	/// </summary>
	/// <remarks>
	///     Output nodes have no outputs and will fail this call
	/// </remarks>
	/// <param name="dwOutputIndex">
	///     The 0-based index of the output connection to query
	/// </param>
	/// <param name="ppDownstreamNode">
	///     Pointer to a variable that will receive the IMFTopologyNode *
	///     that is connected to this output, if any
	/// </param>
	/// <param name="pdwInputIndexOnDownstreamNode">
	///     Pointer to a variable that will receive the 0-based index
	///     of the input connection on *ppDownstreamNode, if it exists.
	/// </param>
	HRESULT GetOutput([in] DWORD dwOutputIndex,
		[out] IMFTopologyNode** ppDownstreamNode,
		[out] DWORD* pdwInputIndexOnDownstreamNode);


	/// <summary>
	///     Set the output preferred type
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="dwOutputIndex">
	///     0-based output index.
	/// </param>
	/// <param name="pType">
	///     Media type to set
	/// </param>
	/// <returns>
	///     Input/output index values are meant to be sequential 0-based values.
	///     If a new value dwIndex is used, then new input/output connections
	///     are created for that node so that connections 0 through dwIndex
	///     will exist.
	/// </returns>
	//[local]
	HRESULT SetOutputPrefType([in] DWORD dwOutputIndex,
		[in] IMFMediaType* pType);


	/// <summary>
	///     Get the output preferred type
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="dwOutputIndex">
	///     0-based output index
	/// </param>
	/// <param name="ppType">
	///     Pointer to IMFMediaType* where the media type is returned
	/// </param>
	/// <returns>
	///     If the index is out of range, we will return E_INVALIDARG.
	/// </returns>
	 HRESULT GetOutputPrefType(
		[in] DWORD dwOutputIndex,
		[out] IMFMediaType** ppType);

	//[call_as(GetOutputPrefType)] HRESULT RemoteGetOutputPrefType(
	//	[in] DWORD dwOutputIndex,
	//	[out] DWORD * pcbData,
	//	[out, size_is(, *pcbData)] BYTE ** ppbData);

	/// <summary>
	///     Set the input preferred type
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="dwInputIndex">
	///     0-based input index
	/// </param>
	/// <param name="pType">
	///     Specifies the media type to set
	/// </param>
	/// <returns>
	/// <returns>
	///     Input/output index values are meant to be sequential 0-based values.
	///     If a new value dwIndex is used, then new input/output connections
	///     are created for that node so that connections 0 through dwIndex
	///     will exist.
	/// </returns>
	//[local]
	HRESULT SetInputPrefType([in] DWORD dwInputIndex,
		[in] IMFMediaType* pType);


	/// <summary>
	///     Get the input preferred type
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="dwInputIndex">
	///     0-based input index
	/// </param>
	/// <param name="ppType">
	///     Pointer to a variable where the media type is returned
	/// </param>
	/// <returns>
	/// If the index is out of range, we will return E_INVALIDARG.
	/// </returns>
	//[local]
	HRESULT GetInputPrefType([in] DWORD dwInputIndex,
		[out] IMFMediaType** ppType);


	/// Makes current node a copy of the node that is passed in as input
	/// </summary>
	/// <remarks>
	/// The two nodes will share the same topology node id and underlying object pointer
	/// </remarks>
	/// <param name="pNode">the input node to clone from</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT CloneFrom([in] IMFTopologyNode* pNode);

};

[
	odl,
	uuid(83CF873A-F6DA-4bc8-823F-BACFD55DC433),
]
interface IMFTopology : IMFAttributes
{
	/// <summary>
	/// It returns the identifier for the whole topology.
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="pID">Pointer to a variable where the identifier of the topology is returned</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetTopologyID([out] TOPOID* pID);


	/// <summary>
	/// Add a node to the topology
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="pNode">The pointer to the topology node to be added</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	//[local]
	HRESULT AddNode([in] IMFTopologyNode* pNode);

	/// <summary>
	/// Remove a node from the topology
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="pNode">the pointer to the topology node to be removed</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	//[local]
	HRESULT RemoveNode([in] IMFTopologyNode* pNode);

	/// <summary>
	/// Return the count of nodes in the topology
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="pwNodes">The pointer of a WORD variable where the node count will be returned.</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetNodeCount([out] WORD* pwNodes);

	/// <summary>
	/// Retreives the node at position wIndex
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="wIndex">the index of the node to return</param>
	/// <param name="ppNode">the node to return</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetNode([in] WORD wIndex,
		[out] IMFTopologyNode** ppNode);


	/// <summary>
	/// Removes all nodes
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	//[local]
	HRESULT Clear(void);

	/// <summary>
	/// Makes the current topology a copy of the topology passed in as pTopology
	/// </summary>
	/// <remarks>
	/// It simplies calls IMFTopologyNode::CloneFrom on each topology node in the topology
	/// </remarks>
	/// <param name="pTopology">The topology to clone from</param>
	/// <returns>
	/// If the method succeeds, the return value is S_OK.
	/// If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT CloneFrom([in] IMFTopology* pTopology);

	/// <summary>
	/// Finds topology node by ID
	/// </summary>
	/// <returns>
	///     <para>
	///         MF_E_NOT_FOUND:
	///             No node with the specific node ID exist in the topology.
	///     </para>
	/// </returns>
	HRESULT GetNodeByID(
		[in] TOPOID qwTopoNodeID,
		[out] IMFTopologyNode **ppNode);

	/// <summary>
	///     Used by MF components or application to discover all the source
	///     nodes in current topology.
	///     This is a helper function to save caller from having to enumerate
	///     through the whole topology.
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="ppCollection">
	///     The collection of the topology source nodes
	/// </param>
	/// <returns>
	///     If the method succeeds, the return value is S_OK.
	///     If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetSourceNodeCollection(
		[out] IMFCollection** ppCollection);

	/// <summary>
	///     Used by MF components or application to discover all the output
	///     nodes.
	///     This is a helper function to save caller from having to enumerate
	///     through the whole topology.
	/// </summary>
	/// <remarks>
	/// </remarks>
	/// <param name="ppCollection">
	///     The collection of the topology output nodes
	/// </param>
	/// <returns>
	///     If the method succeeds, the return value is S_OK.
	///     If the method fails, the return value will be some failure code.
	/// </returns>
	HRESULT GetOutputNodeCollection(
		[out] IMFCollection** ppCollection);
};

typedef enum MFMEDIASOURCE_CHARACTERISTICS
{
	MFMEDIASOURCE_IS_LIVE = 0x1,
	MFMEDIASOURCE_CAN_SEEK = 0x2,
	MFMEDIASOURCE_CAN_PAUSE = 0x4,
	MFMEDIASOURCE_HAS_SLOW_SEEK = 0x8,
	MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS = 0x10,
	MFMEDIASOURCE_CAN_SKIPFORWARD = 0x20,
	MFMEDIASOURCE_CAN_SKIPBACKWARD = 0x40,
	MFMEDIASOURCE_DOES_NOT_USE_NETWORK = 0x80
} 	MFMEDIASOURCE_CHARACTERISTICS;

typedef enum MF_SOURCE_READER_CONTROL_FLAG {
	MF_SOURCE_READER_CONTROLF_DRAIN = 1
} MF_SOURCE_READER_CONTROL_FLAG;

typedef enum MF_SOURCE_READER_FLAG
{
	MF_SOURCE_READERF_ERROR = 0x1,
	MF_SOURCE_READERF_ENDOFSTREAM = 0x2,
	MF_SOURCE_READERF_NEWSTREAM = 0x4,
	MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED = 0x10,
	MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED = 0x20,
	MF_SOURCE_READERF_STREAMTICK = 0x100,
	MF_SOURCE_READERF_ALLEFFECTSREMOVED = 0x200
} 	MF_SOURCE_READER_FLAG;
































typedef struct DMOMediaType {
	GUID     majortype;
	GUID     subtype;
	BOOL     bFixedSizeSamples;
	BOOL     bTemporalCompression;
	ULONG    lSampleSize;
	GUID     formattype;
	IUnknown* pUnk;
	ULONG    cbFormat;
	LongPtr  pbFormat;
} DMO_MEDIA_TYPE;

typedef enum DMO_INPUT_DATA_BUFFER_FLAGS {
	DMO_INPUT_DATA_BUFFERF_SYNCPOINT = 0x00000001,
	DMO_INPUT_DATA_BUFFERF_TIME = 0x00000002,
	DMO_INPUT_DATA_BUFFERF_TIMELENGTH = 0x00000004,
	DMO_INPUT_DATA_BUFFERF_DISCONTINUITY = 0x00000008
} DMO_INPUT_DATA_BUFFER_FLAGS;

// Per-buffer flags that apply to output buffers.
typedef enum DMO_OUTPUT_DATA_BUFFER_FLAGS {
	DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT = 0x00000001,
	DMO_OUTPUT_DATA_BUFFERF_TIME = 0x00000002,
	DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH = 0x00000004,
	DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY = 0x00000008,

	//
	// This flag means the object could have generated more data for this
	// output stream, even with no additional input from any input stream,
	// but the output buffer did not have sufficient room.
	//
	DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE = 0x01000000

} DMO_OUTPUT_DATA_BUFFER_FLAGS;

// Flags returned by GetInputStatus()
typedef enum DMO_INPUT_STATUS_FLAGS {
	//
	// ACCEPT_DATA indicates that the input stream is ready to accept
	// new data via ProcessInput().
	//
	DMO_INPUT_STATUSF_ACCEPT_DATA = 0x00000001
} DMO_INPUT_STATUS_FLAGS;

// Flags returned by GetInputStreamInfo()
typedef enum DMO_INPUT_STREAM_INFO_FLAGS {
	DMO_INPUT_STREAMF_WHOLE_SAMPLES = 0x00000001,
	DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = 0x00000002,
	DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE = 0x00000004,
	DMO_INPUT_STREAMF_HOLDS_BUFFERS = 0x00000008
} DMO_INPUT_STREAM_INFO_FLAGS;

// Flags returned by GetOutputStreamInfo()
typedef enum DMO_OUTPUT_STREAM_INFO_FLAGS {
	DMO_OUTPUT_STREAMF_WHOLE_SAMPLES = 0x00000001,
	DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = 0x00000002,
	DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE = 0x00000004,
	DMO_OUTPUT_STREAMF_DISCARDABLE = 0x00000008,
	DMO_OUTPUT_STREAMF_OPTIONAL = 0x00000010
} DMO_OUTPUT_STREAM_INFO_FLAGS;

//  SetType flags
typedef enum DMO_SET_TYPE_FLAGS {
	DMO_SET_TYPEF_TEST_ONLY = 0x00000001,// check but don't set
	DMO_SET_TYPEF_CLEAR = 0x00000002 // unset
} DMO_SET_TYPE_FLAGS;

//  Process Output Flags
typedef enum DMO_PROCESS_OUTPUT_FLAGS {
	DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = 0x00000001 //  Discard
}  DMO_PROCESS_OUTPUT_FLAGS;

[
	odl,
	uuid(59eff8b9-938c-4a26-82f2-95cb84cdc837)
]
interface IMediaBuffer : stdole.IUnknown
{
	HRESULT SetLength(
		[in] DWORD cbLength
	);
	HRESULT GetMaxLength(
		[out] DWORD* pcbMaxLength
	);
	HRESULT GetBufferAndLength(
		[out] LongPtr *ppBuffer,  // not filled if NULL
		[out] DWORD* pcbLength // not filled if NULL
	);
}

//
// Output buffer info structure: one of these must be passed in for each
// output stream with every ProcessOutput() call
// All [out] fields should be
// assumed undefined if ProcessOutput() failed
//
typedef struct DMO_OUTPUT_DATA_BUFFER {

	IMediaBuffer* pBuffer; // [in] can be NULL

	// ProcessOutput() must set any appropriate flags and zero out the rest.
	DWORD dwStatus; // [out] DMO_OUTPUT_DATA_BUFFERF_XXX (INCOMPLETE, etc.)

	//
	// Each of these is valid if the corresponding flag is set in dwStatus
	//
	REFERENCE_TIME rtTimestamp; // [out]
	REFERENCE_TIME rtTimelength; // [out]
} DMO_OUTPUT_DATA_BUFFER;
typedef DMO_OUTPUT_DATA_BUFFER* PDMO_OUTPUT_DATA_BUFFER;

//  Interface supported by media objects
[
	odl,
	uuid(d8ad0f58-5494-4102-97c5-ec798e59bcf4)
]
interface IMediaObject : stdole.IUnknown
{

	//
	// Stream enumeration
	//
	HRESULT GetStreamCount(
		[out] DWORD* pcInputStreams,
		[out] DWORD* pcOutputStreams
	);
	HRESULT GetInputStreamInfo(
		[in] DWORD dwInputStreamIndex, // 0-based
		[out] DWORD* pdwFlags // HOLDS_BUFFERS
	);
	HRESULT GetOutputStreamInfo(
		[in] DWORD dwOutputStreamIndex, // 0-based
		[out] DWORD* pdwFlags      // Media object sets to 0
	);

	//
	// Mediatypes
	//
			//
			// GetType - iterate through media types supported by a stream.
			// Returns S_FALSE if the type index is out of range ("no more types").
			//
	HRESULT GetInputType(
		[in] DWORD dwInputStreamIndex,
		[in] DWORD dwTypeIndex, // 0-based
		[out] DMO_MEDIA_TYPE* pmt
	);
	HRESULT GetOutputType(
		[in ]DWORD dwOutputStreamIndex,
		[in] DWORD dwTypeIndex, // 0-based
		[out] DMO_MEDIA_TYPE* pmt
	);

	//
	// SetType - tell the object the type of data it will work with.
	//
	HRESULT SetInputType(
		[in] DWORD dwInputStreamIndex,
		[in] DMO_MEDIA_TYPE* pmt,
		[in] DWORD dwFlags // test only
	);
	HRESULT SetOutputType(
		[in] DWORD dwOutputStreamIndex,
		[in]  DMO_MEDIA_TYPE* pmt,
		[in] DWORD dwFlags // test only
	);

	//
	// GetCurrentType - get the last mediatype supplied via SetType.
	// Returns S_FALSE if SetType has not been called.
	//
	HRESULT GetInputCurrentType(
		[in] DWORD dwInputStreamIndex,
		[out] DMO_MEDIA_TYPE* pmt
	);
	HRESULT GetOutputCurrentType(
		[in] DWORD dwOutputStreamIndex,
		[out] DMO_MEDIA_TYPE* pmt
	);

	//
	// SizeInfo
	//
			//
			// GetSizeInfo - Get buffer size requirementes of a stream.
			//
			// If buffer size depends on the media type used, the object should
			// base its response on the most recent media type set for this stream.
			// If no mediatype has been set, the object may return an error.
			//
	HRESULT GetInputSizeInfo(
		[in] DWORD dwInputStreamIndex,
		[out] DWORD* pcbSize, // size of input 'quantum'
		[out] DWORD* pcbMaxLookahead, // max total bytes held
		[out] DWORD* pcbAlignment  // buffer alignment requirement
	);
	HRESULT GetOutputSizeInfo(
		[in] DWORD dwOutputStreamIndex,
		[out] DWORD* pcbSize, // size of output 'quantum'
		[out] DWORD* pcbAlignment  // buffer alignment requirement
	);

	//
	// Latency methods
	//
	HRESULT GetInputMaxLatency(
		[in] DWORD dwInputStreamIndex,
		[out] REFERENCE_TIME* prtMaxLatency
	);
	HRESULT SetInputMaxLatency(
		[in] DWORD dwInputStreamIndex,
		[in] REFERENCE_TIME rtMaxLatency
	);

	//
	// Streaming / state methods
	//
			//
			// Flush() - discard any buffered data.
			//
	HRESULT Flush();

	//
	// Send a discontinuity to an input stream.  The object will not
	// accept any more data on this input stream until the discontinuity
	// has been completely processed, which may involve multiple
	// ProcessOutput() calls.
	//
	HRESULT Discontinuity([in] DWORD dwInputStreamIndex);

	//
	// If a streaming object needs to perform any time consuming
	// initialization before it can stream data, it should do it inside
	// AllocateStreamingResources() rather than during the first process
	// call.
	//
	// This method is NOT guaranteed to be called before streaming
	// starts.  If it is not called, the object should perform any
	// required initialization during a process call.
	//
	HRESULT AllocateStreamingResources();

	// Free anything allocated in AllocateStreamingResources().
	HRESULT FreeStreamingResources();

	// GetInputStatus - the only flag defined right now is ACCEPT_DATA.
	HRESULT GetInputStatus(
		[in] DWORD dwInputStreamIndex,
		[out] DWORD* dwFlags // ACCEPT_DATA
	);

	//
	// Pass one new buffer to an input stream
	//
	HRESULT ProcessInput(
		[in] DWORD dwInputStreamIndex,
		[in] IMediaBuffer* pBuffer, // must not be NULL
		[in] DWORD dwFlags, // DMO_INPUT_DATA_BUFFERF_XXX (syncpoint, etc.)
		[in] REFERENCE_TIME rtTimestamp, // valid if flag set
		[in] REFERENCE_TIME rtTimelength // valid if flag set
	);

	//
	// ProcessOutput() - generate output for current input buffers
	//
	// Output stream specific status information is returned in the
	// dwStatus member of each buffer wrapper structure.
	//
	HRESULT ProcessOutput(
		[in] DWORD dwFlags, // DMO_PROCESS_OUTPUT_FLAGS
		[in] DWORD cOutputBufferCount, // # returned by GetStreamCount()
		[in, out] DMO_OUTPUT_DATA_BUFFER* pOutputBuffers, // one per stream
		[out] DWORD* pdwStatus  // TBD, must be set to 0
		);

	//  Locking - lock if bLock is TRUE, otherwise unlock
	HRESULT Lock([in] LONG bLock);
};


//
// Interface returned by the DMO enumeration API
//
[
	odl,
	uuid(2c3cd98a-2bfa-4a53-9c27-5249ba64ba0f)
]
interface IEnumDMO : stdole.IUnknown {
	HRESULT Next(
		[in] DWORD cItemsToFetch,
		[out] CLSID* pCLSID,
		[out] LongPtr* Names,
		[out] DWORD* pcItemsFetched
	);
	HRESULT Skip(
		[in] DWORD cItemsToSkip
	);
	HRESULT Reset(void);
	HRESULT Clone(
		[out] IEnumDMO** ppEnum
	);
}


// Flags for IMediaObjectInPlace::Process
typedef enum DMO_INPLACE_PROCESS_FLAGS {
	DMO_INPLACE_NORMAL = 0x00000000,
	DMO_INPLACE_ZERO = 0x00000001
} DMO_INPLACE_PROCESS_FLAGS;

[
	odl,
	uuid(651b9ad0-0fc7-4aa9-9538-d89931010741)
]
interface IMediaObjectInPlace : stdole.IUnknown {

	// Proces - Given a buffer of size ulSize, put the output
	// of the DMO into the same buffer.
	HRESULT Process(
		[in] ULONG ulSize,
		[in, out] BYTE* pData,
		[in] REFERENCE_TIME refTimeStart,
		[in] DWORD dwFlags
	);

	// Create a copy of the In-Place Media Object. This allows
	// for very fast initialization of a number of In-Place objects
	// in a known state.
	HRESULT Clone(
		[out] IMediaObjectInPlace** ppMediaObject
	);

	// GetLatency - Returns a REFERENCE_TIME value
	// (1 tick = 100ns) which corresponds to the latency time
	// processing this effect will add to the graph. This assumes
	// the effect cost per buffer is a constant.
	HRESULT GetLatency(
		[out] REFERENCE_TIME* pLatencyTime
	);
}

// Quality control status flags
typedef enum DMO_QUALITY_STATUS_FLAGS {
	DMO_QUALITY_STATUS_ENABLED = 0x00000001
} DMO_QUALITY_STATUS_FLAGS;

[
	odl,
	uuid(65abea96-cf36-453f-af8a-705e98f16260)
]
interface IDMOQualityControl : stdole.IUnknown {
	HRESULT SetNow(
		[in] REFERENCE_TIME rtNow
	);
	HRESULT SetStatus(
		[in] DWORD dwFlags
	);
	HRESULT GetStatus(
		[out] DWORD* pdwFlags
	);
}

// Flags for IVideoOutputOptimizations
typedef enum DMO_VIDEO_OUTPUT_STREAM_FLAGS {
	DMO_VOSF_NEEDS_PREVIOUS_SAMPLE = 0x00000001
} DMO_VIDEO_OUTPUT_STREAM_FLAGS;

[
	odl,
	uuid(be8f4f4e-5b16-4d29-b350-7f6b5d9298ac)
]
interface IDMOVideoOutputOptimizations : stdole.IUnknown {
	HRESULT QueryOperationModePreferences(
		[in] ULONG ulOutputStreamIndex,
		[out] DWORD* pdwRequestedCapabilities
	);
	HRESULT SetOperationMode(
		[in] ULONG ulOutputStreamIndex,
		[in] DWORD dwEnabledFeatures
	);
	HRESULT GetCurrentOperationMode(
		[in] ULONG ulOutputStreamIndex,
		[out] DWORD* pdwEnabledFeatures
	);
	HRESULT GetCurrentSampleRequirements(
		[in] ULONG ulOutputStreamIndex,
		[out] DWORD* pdwRequestedFeatures
	);
}



[
	odl,
	uuid(26a0adc3-ce26-4672-9304-69552edd3faf)
]
interface IMFAudioMediaType : IMFMediaType
{
	//
	// This method has been deprecated, and its use should be avoided.
	// There are no guarantees about how long the memory pointed to by the
	// return value will be valid.
	// Applications are advised to use MFCreateWaveFormatExFromMFMediaType()
	// instead.
	//
	WAVEFORMATEX* GetAudioFormat(void);
};


typedef DWORD RGBQUAD;

typedef struct BITMAPINFOHEADER
{

	DWORD      biSize;
	LONG       biWidth;
	LONG       biHeight;
	WORD       biPlanes;
	WORD       biBitCount;
	DWORD      biCompression;
	DWORD      biSizeImage;
	LONG       biXPelsPerMeter;
	LONG       biYPelsPerMeter;
	DWORD      biClrUsed;
	DWORD      biClrImportant;

} BITMAPINFOHEADER;

typedef struct BITMAPINFO
{
	BITMAPINFOHEADER    bmiHeader;
	RGBQUAD             bmiColors[1];

} BITMAPINFO;

typedef struct MFT_REGISTER_TYPE_INFO
{
	GUID    guidMajorType;
	GUID    guidSubtype;
} MFT_REGISTER_TYPE_INFO;

typedef enum MFVideoTransferFunction
{
	MFVideoTransFunc_Unknown = 0,
	MFVideoTransFunc_10 = 1,
	MFVideoTransFunc_18 = 2,
	MFVideoTransFunc_20 = 3,
	MFVideoTransFunc_22 = 4,
	MFVideoTransFunc_709 = 5, // 1361
	MFVideoTransFunc_240M = 6,
	MFVideoTransFunc_sRGB = 7,
	MFVideoTransFunc_28 = 8,
#if (WINVER >= _WIN32_WINNT_WIN7)
	MFVideoTransFunc_Log_100 = 9,
	MFVideoTransFunc_Log_316 = 10,
	MFVideoTransFunc_709_sym = 11, // symmetric 709
#endif // (WINVER >= _WIN32_WINNT_WIN7)

#if (WINVER >= _WIN32_WINNT_WINBLUE)
	MFVideoTransFunc_2020_const = 12,  // also: BT2246
	MFVideoTransFunc_2020 = 13,
	MFVideoTransFunc_26 = 14,
#endif // (WINVER >= _WIN32_WINNT_WINBLUE)

	MFVideoTransFunc_Last,
	MFVideoTransFunc_ForceDWORD = 0x7FFFFFFF
} MFVideoTransferFunction;

typedef enum MFVideoPrimaries
{
	MFVideoPrimaries_Unknown = 0,
	MFVideoPrimaries_reserved = 1,
	MFVideoPrimaries_BT709 = 2,
	MFVideoPrimaries_BT470_2_SysM = 3,
	MFVideoPrimaries_BT470_2_SysBG = 4,
	MFVideoPrimaries_SMPTE170M = 5,      // includes BT. 601-5
	MFVideoPrimaries_SMPTE240M = 6,
	MFVideoPrimaries_EBU3213 = 7,
	MFVideoPrimaries_SMPTE_C = 8,

#if (WINVER >= _WIN32_WINNT_WINBLUE)
	MFVideoPrimaries_BT2020 = 9,
	MFVideoPrimaries_XYZ = 10,
#endif // (WINVER >= _WIN32_WINNT_WINBLUE)

	MFVideoPrimaries_Last,
	MFVideoPrimaries_ForceDWORD = 0x7FFFFFFF
} MFVideoPrimaries;

typedef enum MFVideoLighting
{
	MFVideoLighting_Unknown = 0,
	MFVideoLighting_bright = 1,
	MFVideoLighting_office = 2,
	MFVideoLighting_dim = 3,
	MFVideoLighting_dark = 4,

	MFVideoLighting_Last,
	MFVideoLighting_ForceDWORD = 0x7FFFFFFF
} MFVideoLighting;

typedef enum MFVideoTransferMatrix
{
	MFVideoTransferMatrix_Unknown = 0,
	MFVideoTransferMatrix_BT709 = 1,
	MFVideoTransferMatrix_BT601 = 2,
	MFVideoTransferMatrix_SMPTE240M = 3,

#//if (WINVER >= _WIN32_WINNT_WINBLUE)
	MFVideoTransferMatrix_BT2020_10 = 4,
	MFVideoTransferMatrix_BT2020_12 = 5,
//#endif // (WINVER >= _WIN32_WINNT_WINBLUE)

	MFVideoTransferMatrix_Last,
	MFVideoTransferMatrix_ForceDWORD = 0x7FFFFFFF,
} MFVideoTransferMatrix;

typedef enum MFVideoChromaSubsampling
{
	MFVideoChromaSubsampling_Unknown = 0,
	MFVideoChromaSubsampling_ProgressiveChroma = 0x8,
	MFVideoChromaSubsampling_Horizontally_Cosited = 0x4, // bit 2
	MFVideoChromaSubsampling_Vertically_Cosited = 0x2,   // bit 1
	MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes = 0x1, // bit 0, can only be 0 if vertically cosited

	// 4:2:0 variations
	MFVideoChromaSubsampling_MPEG2 = 5, //MFVideoChromaSubsampling_Horizontally_Cosited |	MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes,

	MFVideoChromaSubsampling_MPEG1 = 1, //MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes,

	MFVideoChromaSubsampling_DV_PAL = 6, // MFVideoChromaSubsampling_Horizontally_Cosited |	MFVideoChromaSubsampling_Vertically_Cosited,
	// 4:4:4, 4:2:2, 4:1:1
	MFVideoChromaSubsampling_Cosited = 7, //MFVideoChromaSubsampling_Horizontally_Cosited |	MFVideoChromaSubsampling_Vertically_Cosited |	MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes,

	MFVideoChromaSubsampling_Last =3, // MFVideoChromaSubsampling_Cosited + 1,
	MFVideoChromaSubsampling_ForceDWORD = 0x7FFFFFFF
} MFVideoChromaSubsampling;

typedef enum MFNominalRange
{
	MFNominalRange_Unknown = 0,
	MFNominalRange_Normal = 1,
	MFNominalRange_Wide = 2,

	// explicit range forms
	MFNominalRange_0_255 = 1,
	MFNominalRange_16_235 = 2,
	MFNominalRange_48_208 = 3,
//#if (WINVER >= _WIN32_WINNT_WIN7)
	MFNominalRange_64_127 = 4,
//#endif // (WINVER >= _WIN32_WINNT_WIN7)

	MFNominalRange_Last,
	MFNominalRange_ForceDWORD = 0x7FFFFFFF
} MFNominalRange;

typedef enum MFVideoFlags {
	// static flags
	MFVideoFlag_PAD_TO_Mask = 3, //0x0001 | 0x0002,
	MFVideoFlag_PAD_TO_None = 0, // 0 * 0x0001,
	MFVideoFlag_PAD_TO_4x3 = 1, //1 * 0x0001,
	MFVideoFlag_PAD_TO_16x9 = 2, //2 * 0x0001,

	MFVideoFlag_SrcContentHintMask = 0x001C, // 0x0004 | 0x0008 | 0x0010,
	MFVideoFlag_SrcContentHintNone = 0, // 0 * 0x0004,
	MFVideoFlag_SrcContentHint16x9 = 4, //1 * 0x0004,
	MFVideoFlag_SrcContentHint235_1 = 8, //2 * 0x0004,

	// static/dynamic flags
	MFVideoFlag_AnalogProtected = 0x0020,
	MFVideoFlag_DigitallyProtected = 0x0040,

	// dynamic flags
	MFVideoFlag_ProgressiveContent = 0x0080,
	MFVideoFlag_FieldRepeatCountMask = 0x0700, // 0x0100 | 0x0200 | 0x0400,
	MFVideoFlag_FieldRepeatCountShift = 8,
	MFVideoFlag_ProgressiveSeqReset = 0x0800,
	MFVideoFlag_PanScanEnabled = 0x20000,
	MFVideoFlag_LowerFieldFirst = 0x40000,
	MFVideoFlag_BottomUpLinearRep = 0x80000,

	// ******************************************
	// static surface creation flags - UNAPPROVED
	// --------------- DO NOT USE ---------------
	// ******************************************
	MFVideoFlags_DXVASurface = 0x100000,
	MFVideoFlags_RenderTargetSurface = 0x400000,

	MFVideoFlags_ForceQWORD = 0x7FFFFFFF
} MFVideoFlags;

typedef struct MFRatio
{
	DWORD                   Numerator;
	DWORD                   Denominator;
} MFRatio;

// number = value + fract/65535f
typedef struct MFOffset {
	WORD  fract;
	short value;
} MFOffset;

typedef struct MFVideoArea
{
	MFOffset                OffsetX;
	MFOffset                OffsetY;
	SIZE                    Area;
} MFVideoArea;

typedef struct MFVideoInfo
{
	DWORD                   dwWidth;
	DWORD                   dwHeight;

	MFRatio                 PixelAspectRatio;
	MFVideoChromaSubsampling SourceChromaSubsampling;
	MFVideoInterlaceMode    InterlaceMode;
	MFVideoTransferFunction TransferFunction;
	MFVideoPrimaries        ColorPrimaries;
	MFVideoTransferMatrix   TransferMatrix;
	MFVideoLighting         SourceLighting;
	MFRatio                 FramesPerSecond;
	MFNominalRange          NominalRange;
	MFVideoArea             GeometricAperture;
	MFVideoArea             MinimumDisplayAperture;
	MFVideoArea             PanScanAperture;
	CURRENCY                VideoFlags;
} MFVideoInfo;

typedef struct MFAYUVSample {
	BYTE bCrValue;
	BYTE bCbValue;
	BYTE bYValue;
	BYTE bSampleAlpha8;
} MFAYUVSample;

typedef struct MFARGB
{
	BYTE rgbBlue;
	BYTE rgbGreen;
	BYTE rgbRed;
	BYTE rgbAlpha;
} MFARGB;

typedef struct MFPaletteEntry {
	//MFARGB      ARGB;
	//MFAYUVSample    AYCbCr;
	long ColorUnion;
} MFPaletteEntry;

typedef struct MFVideoSurfaceInfo
{
	DWORD           Format;
	DWORD           PaletteEntries;
	MFPaletteEntry  Palette[256];
} MFVideoSurfaceInfo;

typedef struct MFVideoCompressedInfo
{
	LONGLONG              AvgBitrate;
	LONGLONG              AvgBitErrorRate;
	DWORD                 MaxKeyFrameSpacing;
} MFVideoCompressedInfo;

typedef struct MFVIDEOFORMAT
{
	DWORD                   dwSize;             // includes palette
	MFVideoInfo             videoInfo;

	GUID                    guidFormat;         // compressed (4CC & other) & uncompressed (4CC/D3DFMT)
												// compressed if surfaceInfo.Format = 0
												// If uncompressed, then guidFormat.Data1 is mirrored in surfaceInfo.Format
	MFVideoCompressedInfo   compressedInfo;
	MFVideoSurfaceInfo      surfaceInfo;
	// optional Palette[256] (in surfaceInfo)
} MFVIDEOFORMAT;

typedef enum MFStandardVideoFormat
{
	MFStdVideoFormat_reserved = 0,
	MFStdVideoFormat_NTSC,
	MFStdVideoFormat_PAL,
	MFStdVideoFormat_DVD_NTSC,
	MFStdVideoFormat_DVD_PAL,
	MFStdVideoFormat_DV_PAL,
	MFStdVideoFormat_DV_NTSC,
	MFStdVideoFormat_ATSC_SD480i,
	MFStdVideoFormat_ATSC_HD1080i,
	MFStdVideoFormat_ATSC_HD720p,
} MFStandardVideoFormat;


[
	odl,
	uuid(b99f381f-a8f9-47a2-a5af-ca3a225a3890)
]
interface IMFVideoMediaType : IMFMediaType
{
	//
	// This method has been deprecated, and its use should be avoided.
	// There are no guarantees about how long the memory pointed to by the
	// return value will be valid.
	// Applications are advised to use MFCreateMFVideoFormatFromMFMediaType()
	// instead.
	//
	MFVIDEOFORMAT* GetVideoFormat();

	// translation service to other formats such as FORMAT_VideoInfo
	HRESULT GetVideoRepresentation(
		[in] long guidRepresentation1, [in] long guidRepresentation2, [in] long guidRepresentation3, [in] long guidRepresentation4,
		[out] LPVOID ppvRepresentation,
		[in] LONG lStride
	);
};

[
	odl,
	uuid(c7a4dca1-f5f0-47b6-b92b-bf0106d25791)
]
/// <summary>
///     This interface is used to return logging information about the object.
//      It is primarily for async callbacks to return an ID of the parent object that they are associated with
/// </summary>
interface IMFAsyncCallbackLogging : stdole.IUnknown //IMFAsyncCallback
{
	HRESULT GetParameters(
		[out] DWORD* pdwFlags,
		[out] DWORD* pdwQueue
	);

	/// <summary>
	///     The Invoke method is called to indicate that the asynchronous operation has completed,
	///     and to give the callback implementer the result object which can be used to retrieve the output data via a call to EndXXX.
	/// </summary>
	/// <param name="pAsyncResult">
	///     Pointer to an async result object
	/// </param>
	HRESULT Invoke(
		[in] IMFAsyncResult* pAsyncResult
	);



	HRESULT GetObjectPointer();
	HRESULT GetObjectTag();
}

[
	odl,
	uuid(a6b43f84-5c0a-42e8-a44d-b1857a76992f)
]
interface IMFByteStreamProxyClassFactory : stdole.IUnknown
{
	HRESULT CreateByteStreamProxy([in] IMFByteStream* pByteStream,
		[in] IMFAttributes* pAttributes,
		[in] REFIID riid,
		[out] LPVOID* ppvObject);
};


typedef enum MF_FILE_ACCESSMODE
{
	MF_ACCESSMODE_READ = 1,
	MF_ACCESSMODE_WRITE = 2,
	MF_ACCESSMODE_READWRITE = 3,
}   MF_FILE_ACCESSMODE;

typedef enum MF_FILE_OPENMODE
{
	MF_OPENMODE_FAIL_IF_NOT_EXIST = 0,
	MF_OPENMODE_FAIL_IF_EXIST = 1,
	MF_OPENMODE_RESET_IF_EXIST = 2,
	MF_OPENMODE_APPEND_IF_EXIST = 3,
	MF_OPENMODE_DELETE_IF_EXIST = 4,
}   MF_FILE_OPENMODE;

typedef enum v
{
	MF_FILEFLAGS_NONE = 0x00000000,
	MF_FILEFLAGS_NOBUFFERING = 0x00000001,
//#if (WINVER >= _WIN32_WINNT_WIN7)
	MF_FILEFLAGS_ALLOW_WRITE_SHARING = 0x00000002,
//#endif // (WINVER >= _WIN32_WINNT_WIN7)
}   MF_FILE_FLAGS;


[
	odl,
	uuid(8feed468-6f7e-440d-869a-49bdd283ad0d),
]
interface IMFSampleOutputStream : stdole.IUnknown
{
	/// <summary>
	///     Begin async write operation.
	/// </summary>
	HRESULT BeginWriteSample(
		[in] IMFSample* pSample,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState
	);

	/// <summary>
	///     Complete async write operation.
	/// </summary>
	HRESULT EndWriteSample(
		[in] IMFAsyncResult* pResult
	);

	HRESULT Close();
};

/// <summary>
///     MFCreateEventQueue instantiates an object that implements this 
///     interface.  This object can be used by components that need to
///     provide IMFMediaEventGenerator functionality to help with the
///     mechanics of event-queueing.
///     When the caller makes an IMFMediaEventGenerator call, the component
///     should just forward that call to the appropriate method of the 
///     Media Event Queue object.
///     When the component wishes to send an event to the caller, it can 
///     do so using the QueueEventXXX methods on the Media Event Queue object.
/// </summary>
[
	odl,
	uuid(36f846fc-2256-48b6-b58e-e2b638316581)
]
interface IMFMediaEventQueue : stdole.IUnknown
{
	/// <summary>
	///     Media Event Generator components that use the Media Event Queue
	///     object should just forward IMFMediaEventGenerator::GetEvent
	///     calls to this method on the Media Event Queue.
	///     See IMFMediaEventGenerator::GetEvent parameter descriptions.
	/// </summary>
	HRESULT GetEvent(
		[in] DWORD dwFlags,
		[out] IMFMediaEvent** ppEvent
	);

	/// <summary>
	///     Media Event Generator components that use the Media Event Queue
	///     object should just forward IMFMediaEventGenerator::BeginGetEvent
	///     calls to this method on the Media Event Queue.
	///     See IMFMediaEventGenerator::BeginGetEvent parameter descriptions.
	/// </summary>
	HRESULT BeginGetEvent(
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState
	);

	/// <summary>
	///     Media Event Generator components that use the Media Event Queue
	///     object should just forward IMFMediaEventGenerator::EndGetEvent
	///     calls to this method on the Media Event Queue.
	///     See IMFMediaEventGenerator::EndGetEvent parameter descriptions.
	/// </summary>
	HRESULT EndGetEvent(
		[in] IMFAsyncResult* pResult,
		[out] IMFMediaEvent** ppEvent
	);

	/// <summary>
	///     Queues the specified event on the Media Event Queue object.
	///     This event will be retrievable using Begin/EndGetEvent or 
	///     GetEvent
	/// </summary>
	/// <param name="pEvent">
	///     Pointer to the Media Event object to queue
	/// </param>
	HRESULT QueueEvent(
		[in] IMFMediaEvent* pEvent);

	/// <summary>
	///     Queues an event with the specified event data on the Media Event 
	///     Queue object.
	///     This event will be retrievable using Begin/EndGetEvent or 
	///     GetEvent
	/// </summary>
	/// <param name="met">
	///     Event type
	/// </param>
	/// <param name="guidExtendedType">
	///     Extended event type
	/// </param>
	/// <param name="hrStatus">
	///     Event status
	/// </param>
	/// <param name="pvValue">
	///     Event value
	/// </param>
	HRESULT QueueEventParamVar(
		[in] MediaEventType met,
		[in] REFGUID guidExtendedType,
		[in] long hrStatus,
		[in] VARIANT* pvValue);

	/// <summary>
	///     Queues an event with the specified event data on the Media Event 
	///     Queue object.
	///     This event will be retrievable using Begin/EndGetEvent or 
	///     GetEvent
	/// </summary>
	/// <param name="met">
	///     Event type
	/// </param>
	/// <param name="guidExtendedType">
	///     Extended event type
	/// </param>
	/// <param name="hrStatus">
	///     Event status
	/// </param>
	/// <param name="pUnk">
	///     Event value, specified as an IUnknown *
	/// </param>
	HRESULT QueueEventParamUnk(
		[in] MediaEventType met,
		[in] REFGUID guidExtendedType,
		[in] long hrStatus,
		[in] stdole.IUnknown* pUnk);

	/// <summary>
	///     Shutdown must be called when the component is done using the
	///     Media Event Queue object to break circular references and 
	///     prevent memory leaks.
	/// </summary>
	HRESULT Shutdown();
};

/// <summary>
/// The IMFActivate interface is a base interface for Activate objects.
/// An Activate object is a helper object which creates and keeps a pointer to the real object.
/// MF pipeline uses activate objects instead of real objects in partial topologies.
/// The ActivateObject(...) method should always return the same instance of the object until either
/// ShutdownObject() or DetachObject() is called, then it can create a new instance.
/// </summary>
[
	odl,
	uuid(7FEE9E9A-4A89-47a6-899C-B6A53A70FB67),
	helpstring("IMFActivate Interface")
]

interface IMFActivate : IMFAttributes
{
	/// <summary>
	///     Creates the object that this activate represents.
	///     The ActivateObject(...) method should always return the same instance of the object
	///     until either ShutdownObject() or DetachObject() is called.
	/// </summary>
	/// <param name="riid">
	///     The interface ID that the requested object will be QI'ed for
	/// </param>
	/// <param name="ppv">
	///     Will contain the requested interface
	/// </param>
	HRESULT ActivateObject(
		[in] REFIID riid,
		[out] LPVOID ppv);

	/// <summary>
	///     Shuts down the internal represented object
	///     (that is returned on ActivateObject(...))
	///     and then releases all references to it.
	/// </summary>
	HRESULT ShutdownObject();

	/// <summary>
	///     Releases all references to the internal represented
	///     object (without shutting it down.)
	///     If this action is not supported, E_NOTIMPL should be returned.
	/// </summary>
	HRESULT DetachObject();
};

typedef enum MF_Plugin_Type {
	MF_Plugin_Type_MFT = 0,
	MF_Plugin_Type_MediaSource = 1,
	MF_Plugin_Type_MFT_MatchOutputType = 2,
	MF_Plugin_Type_Other = -1,
} MF_Plugin_Type;
/// <summary>
///    The IMFPluginControl interface returns information about preferred and 'don't use' objects
//     The preferred/don't use status of objects can be added to or overridden
/// </summary>
[
	odl,
	uuid(5c6c44bf-1db6-435b-9249-e8cd10fdec96),
	helpstring("IMFPluginControl Interface")
]
interface IMFPluginControl : stdole.IUnknown
{
	/// <summary>
	///    Gets the CLSID of an object given a particular selection string (CLSID or file extension or mime type)
	/// </summary>
	/// <param name="ListId">
	///    ID of list being searched
	/// </param>
	/// <param name="pSelector">
	///    String representing selector being used to find object
	/// </param>
	/// <param name="clsid">
	///    Class ID of object meeting selection criteria
	/// </param>
	/// <returns>
	///    S_OK - entry found
	///    HRESULT_FROM_WIN32(ERROR_NOT_FOUND) - entry not present
	///    Other failure code - something failed when checking the list
	/// </returns>
	HRESULT GetPreferredClsid(
		[in] DWORD pluginType,
		[in] LongPtr selector,
		[out] CLSID* clsid
	);


	/// <summary>
	///    Gets the selector by index in the list
	/// </summary>
	/// <param name="ListId">
	///    ID of list being searched
	/// </param>
	/// <param name="Index">
	///    0-based index
	/// </param>
	/// <param name="ppSelector">
	///    String representing selector being used to find object
	/// </param>
	/// <param name="pclsid">
	///    Class ID of object meeting selectionc criteria
	/// </param>
	HRESULT GetPreferredClsidByIndex(
		[in] DWORD pluginType,
		[in] DWORD index,
		[out]  LongPtr* selector,
		[out]  CLSID* clsid
	);

	/// <summary>
	///    Sets the CLSID of an object given a particular selection string (CLSID or file extension or mime type)
	/// </summary>
	/// <param name="pluginType">
	///    ID of list being searched
	/// </param>
	/// <param name="selector">
	///    String representing selector being used to find object
	/// </param>
	/// <param name="clsid">
	///    Class ID of object to set preferred - NULL if no preference is to be set for the selector
	/// </param>
	HRESULT SetPreferredClsid(
		[in] DWORD pluginType,
		[in] LongPtr selector,
		[in] CLSID* clsid
	);

	/// <summary>
	///    Checks if the CLSID is present in the list
	/// </summary>
	/// <param name="pluginType">
	///    Plugin type
	/// </param>
	/// <param name="clsid">
	///    Class ID to search for
	/// </param>
	/// <returns>
	///     S_OK - clsid is disabled
	///     HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) - off end of list
	///     HRESULT_FROM_WIN32(ERROR_NOT_FOUND) - not disabled
	///     Other failure code - failed
	/// </returns>
	HRESULT IsDisabled(
		[in] DWORD pluginType,
		[in] REFCLSID clsid
	);

	/// <summary>
	///    Checks if the CLSID is present in the list
	/// </summary>
	/// <param name="ListId">
	///    ID of list being searched
	/// </param>
	/// <param name="clsid">
	///    Disabled Class ID 
	/// </param>
	/// <returns>
	///    S_OK - entry found - returned clsid is disabled
	///
	/// </returns>
	HRESULT GetDisabledByIndex(
		[in] DWORD pluginType,
		[in] DWORD index,
		[out] CLSID* clsid
	);

	/// <summary>
	///    Sets the disabled state for a CLSID
	/// </summary>
	/// <param name="ListId">
	///    ID of list being searched
	/// </param>
	/// <param name="clsid">
	///    Class ID to search for
	/// </param>
	/// <param name="disabled">
	///    TRUE to disable, FALSE to enable
	/// </param>
	HRESULT SetDisabled(
		[in] DWORD pluginType,
		[in] REFCLSID clsid,
		[in] BOOL disabled
	);
}

typedef enum MF_PLUGIN_CONTROL_POLICY
{
	MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS = 0,
	MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS = 1,
	MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS = 2,
	MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE = 3
} MF_PLUGIN_CONTROL_POLICY;

[
	odl,
	uuid(C6982083-3DDC-45CB-AF5E-0F7A8CE4DE77),
	helpstring("IMFPluginControl2 Interface")
]
interface IMFPluginControl2 : IMFPluginControl
{
	HRESULT SetPolicy(
		[in] MF_PLUGIN_CONTROL_POLICY policy
	);
}

[
	odl,
	uuid(eb533d5d-2db6-40f8-97a9-494692014f07),
	helpstring("IMFDXGIDeviceManager Interface")
]
/// <summary>
///    The IMFDXGIDeviceManager interface
/// </summary>
interface IMFDXGIDeviceManager : stdole.IUnknown
{
	HRESULT CloseDeviceHandle(
		[in]  HANDLE hDevice
	);
	HRESULT GetVideoService(
		[in]   HANDLE hDevice,
		[in]   REFIID riid,
		[out]  LPVOID ppService
	);
	HRESULT LockDevice(
		[in]   HANDLE hDevice,
		[in]   REFIID riid,
		[out]  LPVOID ppUnkDevice,
		[in]   BOOL fBlock
	);
	HRESULT OpenDeviceHandle(
		[out]  HANDLE* phDevice
	);
	HRESULT ResetDevice(
		[in]  IUnknown* pUnkDevice,
		[in]  UINT resetToken
	);
	HRESULT TestDevice(
		[in]  HANDLE hDevice
	);
	HRESULT UnlockDevice(
		[in]  HANDLE hDevice,
		[in]  BOOL fSaveState
	);
};

typedef enum MFT_INPUT_DATA_BUFFER_FLAGS {
	//
	// Not carried over from DMO (IMediaObject), but should be
	// reserved so no new MFT flag clashes with them:
	//
	// DMO_INPUT_DATA_BUFFER_SYNCPOINT       = 0x00000001,
	// DMO_INPUT_DATA_BUFFER_TIME            = 0x00000002,
	// DMO_INPUT_DATA_BUFFER_TIMELENGTH      = 0x00000004

	MFT_INPUT_DATA_BUFFER_PLACEHOLDER = 0xFFFFFFFF // right now there are no flags defined
} MFT_INPUT_DATA_BUFFER_FLAGS;

// Per-buffer flags that apply to output buffers.
typedef enum MFT_OUTPUT_DATA_BUFFER_FLAGS {
	//
	// Not carried over from DMO (IMediaObject), but should be
	// reserved so no new MFT flag clashes with them:
	//
	// DMO_OUTPUT_DATA_BUFFER_SYNCPOINT        = 0x00000001,
	// DMO_OUTPUT_DATA_BUFFER_TIME             = 0x00000002,
	// DMO_OUTPUT_DATA_BUFFER_TIMELENGTH       = 0x00000004,

	//
	// This flag means the object can produce more samples without any more input.
	//
	MFT_OUTPUT_DATA_BUFFER_INCOMPLETE = 0x01000000,

	//
	// New for MFT
	//
	MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE = 0x00000100,
	MFT_OUTPUT_DATA_BUFFER_STREAM_END = 0x00000200,
	MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE = 0x00000300

} MFT_OUTPUT_DATA_BUFFER_FLAGS;

// Flags returned by GetInputStatusFlags()
typedef enum MFT_INPUT_STATUS_FLAGS {
	//
	// Carried over from DMO (IMediaObject)
	//

	//
	// ACCEPT_DATA indicates that the input stream is ready to accept
	// new data via ProcessInput().
	//
	MFT_INPUT_STATUS_ACCEPT_DATA = 0x00000001
} MFT_INPUT_STATUS_FLAGS;

// Flags returned by GetOutputStatusFlags()
typedef enum MFT_OUTPUT_STATUS_FLAGS {
	//
	// New for MFT
	//

	//
	// SAMPLE_READY indicates that a sample is available on at least one
	// of the output streams, and a call to ProcessOutput will
	// retrieve it.
	//
	MFT_OUTPUT_STATUS_SAMPLE_READY = 0x00000001
} MFT_OUTPUT_STATUS_FLAGS;

// Flags returned by GetInputStreamInfo()
typedef enum MFT_INPUT_STREAM_INFO_FLAGS {
	//
	// Carried over from DMO (IMediaObject)
	//
	MFT_INPUT_STREAM_WHOLE_SAMPLES = 0x00000001,
	MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = 0x00000002,
	MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE = 0x00000004,
	MFT_INPUT_STREAM_HOLDS_BUFFERS = 0x00000008,

	//
	// New for MFT
	//
	MFT_INPUT_STREAM_DOES_NOT_ADDREF = 0x00000100,
	MFT_INPUT_STREAM_REMOVABLE = 0x00000200,
	MFT_INPUT_STREAM_OPTIONAL = 0x00000400,
	MFT_INPUT_STREAM_PROCESSES_IN_PLACE = 0x00000800
} MFT_INPUT_STREAM_INFO_FLAGS;

// Flags returned by GetOutputStreamInfo()
typedef enum MFT_OUTPUT_STREAM_INFO_FLAGS {
	//
	// Carried over from DMO (IMediaObject)
	//
	MFT_OUTPUT_STREAM_WHOLE_SAMPLES = 0x00000001,
	MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = 0x00000002,
	MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE = 0x00000004,
	MFT_OUTPUT_STREAM_DISCARDABLE = 0x00000008,
	MFT_OUTPUT_STREAM_OPTIONAL = 0x00000010,

	//
	// New for MFT
	//
	MFT_OUTPUT_STREAM_PROVIDES_SAMPLES = 0x00000100,
	MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES = 0x00000200,
	MFT_OUTPUT_STREAM_LAZY_READ = 0x00000400,
	MFT_OUTPUT_STREAM_REMOVABLE = 0x00000800
} MFT_OUTPUT_STREAM_INFO_FLAGS;

//  SetType flags
typedef enum MFT_SET_TYPE_FLAGS {
	//
	// Carried over from DMO (IMediaObject)
	//
	MFT_SET_TYPE_TEST_ONLY = 0x00000001,// check but don't set

	//
	// not carried over from DMO - use NULL type to unset.
	//
	//MFT_SET_TYPE_CLEAR       = 0x00000002 // unset
} MFT_SET_TYPE_FLAGS;

//
//  ProcessOutput() dwFlags (signals from caller to MFT)
//
typedef enum MFT_PROCESS_OUTPUT_FLAGS {
	//
	// Carried over from DMO (IMediaObject)
	//
	MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = 0x00000001, // discard this sample if pSample ptr is NULL.

	// New flags for MFTs
	MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT = 0x00000002
} MFT_PROCESS_OUTPUT_FLAGS;

//
// ProcessOutput() pdwStatus (output from MFT to caller)
//
typedef enum MFT_PROCESS_OUTPUT_STATUS {
	//
	// new for MFT
	//
	MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS = 0x00000100 // Output flag
} MFT_PROCESS_OUTPUT_STATUS;

typedef enum MFT_DRAIN_TYPE {
	MFT_DRAIN_PRODUCE_TAILS = 0x00000000,
	MFT_DRAIN_NO_TAILS = 0x00000001
} MFT_DRAIN_TYPE;


typedef enum MFT_MESSAGE_TYPE {
	//
	// commands - must be acted on
	//
	MFT_MESSAGE_COMMAND_FLUSH = 0x00000000,
	MFT_MESSAGE_COMMAND_DRAIN = 0x00000001,
	MFT_MESSAGE_SET_D3D_MANAGER = 0x00000002,
//#if (WINVER >= _WIN32_WINNT_WIN7)
	MFT_MESSAGE_DROP_SAMPLES = 0x00000003,
//#endif // (WINVER >= _WIN32_WINNT_WIN7)
//#if (WINVER >= _WIN32_WINNT_WIN8)
	MFT_MESSAGE_COMMAND_TICK = 0x00000004,
//#endif // (WINVER >= _WIN32_WINNT_WIN8)

	//
	// notifications - no action required; effect is transform-dependent
	//
	MFT_MESSAGE_NOTIFY_BEGIN_STREAMING = 0x10000000,
	MFT_MESSAGE_NOTIFY_END_STREAMING = 0x10000001,
	MFT_MESSAGE_NOTIFY_END_OF_STREAM = 0x10000002,

	//
	// send by pipeline before processing the first sample
	//
	MFT_MESSAGE_NOTIFY_START_OF_STREAM = 0x10000003,

//#if (WINVER >= _WIN32_WINNT_WINTHRESHOLD)
	MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES = 0x10000004,
	MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES = 0x10000005,
	MFT_MESSAGE_NOTIFY_EVENT = 0x10000006,
//#endif // (WINVER >= _WIN32_WINNT_WINTHRESHOLD)

//#if (WINVER >= _WIN32_WINNT_WIN7)
	//
	// commands (applicable to async MFTs only) - must be acted on
	//
	MFT_MESSAGE_COMMAND_MARKER = 0x20000000
//#endif // (WINVER >= _WIN32_WINNT_WIN7)

} MFT_MESSAGE_TYPE;

typedef struct MFT_INPUT_STREAM_INFO {
	LONGLONG    hnsMaxLatency;      // maximum time latency in 100ns increments
	DWORD       dwFlags;            // MFT_INPUT_STREAM_INFO_FLAGS
	DWORD       cbSize;             // size of each sample's buffer
	DWORD       cbMaxLookahead;     // max total bytes held
	DWORD       cbAlignment;        // buffer alignment requirement
} MFT_INPUT_STREAM_INFO;

typedef struct MFT_OUTPUT_STREAM_INFO {
	DWORD       dwFlags;            // MFT_INPUT_STREAM_INFO_FLAGS
	DWORD       cbSize;             // size of each sample's buffer
	DWORD       cbAlignment;        // buffer alignment requirement
} MFT_OUTPUT_STREAM_INFO;

//
// Output buffer info structure: one of these must be passed in for each
// output stream with every ProcessOutput() call
// All [out] fields should be
// assumed undefined if ProcessOutput() failed
//
typedef struct MFT_OUTPUT_DATA_BUFFER {
	DWORD       dwStreamID; // [in] which stream is this for
	IMFSample* pSample;    // [in/out] can be NULL
	DWORD       dwStatus;   // [out] MFT_OUTPUT_DATA_BUFFER_FLAGS (INCOMPLETE, etc.)
	IMFCollection* pEvents; // [out] Can be NULL.  Zero or more events produced by the MFT
} MFT_OUTPUT_DATA_BUFFER;

[
	odl,
	uuid(bf94c121-5b05-4e6f-8000-ba598961414d)
]
interface IMFTransform : stdole.IUnknown
{

	//
	// Stream enumeration
	//
	HRESULT
		GetStreamLimits(
			[out] DWORD* pdwInputMinimum,
			[out] DWORD* pdwInputMaximum,
			[out] DWORD* pdwOutputMinimum,
			[out] DWORD* pdwOutputMaximum
		);

	HRESULT
		GetStreamCount(
			[out] DWORD* pcInputStreams,
			[out] DWORD* pcOutputStreams
		);

	HRESULT
		GetStreamIDs(
			[in] DWORD dwInputIDArraySize,
			[out] DWORD* pdwInputIDs,
			[in] DWORD dwOutputIDArraySize,
			[out] DWORD* pdwOutputIDs
		);

	HRESULT
		GetInputStreamInfo(
			[in] DWORD                     dwInputStreamID,
			[out] MFT_INPUT_STREAM_INFO* pStreamInfo
		);

	HRESULT
		GetOutputStreamInfo(
			[in] DWORD                     dwOutputStreamID,
			[out] MFT_OUTPUT_STREAM_INFO* pStreamInfo
		);

	HRESULT
		GetAttributes(
			[out] IMFAttributes** pAttributes
		);

	HRESULT
		GetInputStreamAttributes(
			[in] DWORD           dwInputStreamID,
			[out] IMFAttributes** pAttributes
		);

	HRESULT
		GetOutputStreamAttributes(
			[in] DWORD           dwOutputStreamID,
			[out] IMFAttributes** pAttributes
		);

	HRESULT
		DeleteInputStream(
			[in] DWORD dwStreamID
		);

	HRESULT
		AddInputStreams(
			[in] DWORD   cStreams,
			[in]  DWORD* adwStreamIDs
		);


	//
	// Mediatypes
	//
		//
		// GetxxxAvailableType - iterate through media types supported by a stream.
		//
	HRESULT
		GetInputAvailableType(
			[in] DWORD             dwInputStreamID,
			[in] DWORD             dwTypeIndex, // 0-based
			[out] IMFMediaType** ppType
		);
	HRESULT
		GetOutputAvailableType(
			[in] DWORD             dwOutputStreamID,
			[in] DWORD             dwTypeIndex, // 0-based
			[out] IMFMediaType** ppType
		);

	//
	// SetxxxType - tell the object the type of data it will work with.
	//
	HRESULT
		SetInputType(
			[in] DWORD               dwInputStreamID,
			[in]  IMFMediaType* pType,
			[in] DWORD               dwFlags
		);
	HRESULT
		SetOutputType(
			[in] DWORD               dwOutputStreamID,
			[in]  IMFMediaType* pType,
			[in] DWORD               dwFlags
		);

	//
	// GetxxxCurrentType - get the current type set for the given stream index.
	//
	HRESULT
		GetInputCurrentType(
			[in] DWORD                   dwInputStreamID,
			[out] IMFMediaType** ppType
		);
	HRESULT
		GetOutputCurrentType(
			[in] DWORD                   dwOutputStreamID,
			[out] IMFMediaType** ppType
		);

	//
	// Streaming / state methods
	//
		// GetInputStatus - the only flag defined right now is MFT_INPUT_STATUS_ACCEPT_DATA.
	HRESULT
		GetInputStatus(
			[in] DWORD           dwInputStreamID,
			[out] DWORD* pdwFlags // MFT_INPUT_STATUS_ACCEPT_DATA
		);

	// GetOutputStatus - the only flag defined right now is MFT_OUTPUT_STATUS_SAMPLE_READY.
	HRESULT
		GetOutputStatus(
			[out] DWORD* pdwFlags
		);

	//
	// SetOutputBounds - optional interface to tell transform the desired
	// range of output times desired. Implementation is optional.
	//
	HRESULT
		SetOutputBounds(
			[in] LONGLONG hnsLowerBound,
			[in] LONGLONG hnsUpperBound
		);

	HRESULT
		ProcessEvent(
			[in] DWORD                   dwInputStreamID,
			[in] IMFMediaEvent* pEvent
		);

	//
	// ProcessMessage - used to send a notification or command to a transform
	//
	HRESULT
		ProcessMessage(
			[in] MFT_MESSAGE_TYPE eMessage,
			[in] ULONG_PTR        ulParam
		);

	//
	// Pass one new buffer to an input stream
	//
	HRESULT
		ProcessInput(
			[in] DWORD       dwInputStreamID,
			[in] IMFSample* pSample,
			[in] DWORD       dwFlags
		);

	//
	// ProcessOutput() - generate output for current input buffers
	//
	// Output stream specific status information is returned in the
	// dwStatus member of each buffer wrapper structure.
	//
	HRESULT
		ProcessOutput(
			[in] DWORD                       dwFlags, // MFT_PROCESS_OUTPUT_FLAGS
			[in] DWORD                       cOutputBufferCount, // # returned by GetStreamCount()
			[in, out]	MFT_OUTPUT_DATA_BUFFER* pOutputSamples, // one per stream
		[out] DWORD* pdwStatus  // MFT_PROCESS_OUTPUT_XXX
		);

};

typedef struct STREAM_MEDIUM
{
	GUID gidMedium;
	UINT32 unMediumInstance;
} STREAM_MEDIUM;

typedef enum MF3DVideoOutputType
{
	MF3DVideoOutputType_BaseView = 0,
	MF3DVideoOutputType_Stereo = 1,
} MF3DVideoOutputType;

typedef enum DeviceStreamState {
	DeviceStreamState_Stop = 0,
	DeviceStreamState_Pause,
	DeviceStreamState_Run,
	DeviceStreamState_Disabled
}DeviceStreamState;


[
	odl,
	uuid(D818FBD8-FC46-42F2-87AC-1EA2D1F9BF32)
]
interface IMFDeviceTransform : stdole.IUnknown
{
	HRESULT InitializeTransform(
		[in] IMFAttributes* pAttributes
	);

	HRESULT GetInputAvailableType(
		[in] DWORD dwInputStreamID,
		[in] DWORD dwTypeIndex,
		[out] IMFMediaType** pMediaType
	);

	HRESULT GetInputCurrentType(
		[in] DWORD dwInputStreamID,
		[out] IMFMediaType** pMediaType
	);

	HRESULT GetInputStreamAttributes(
		[in] DWORD dwInputStreamID,
		[out] IMFAttributes** ppAttributes
	);

	HRESULT GetOutputAvailableType(
		[in] DWORD dwOutputStreamID,
		[in] DWORD dwTypeIndex,
		[out] IMFMediaType** pMediaType
	);

	HRESULT GetOutputCurrentType(
		[in] DWORD dwOutputStreamID,
		[out] IMFMediaType** pMediaType
	);

	HRESULT GetOutputStreamAttributes(
		[in] DWORD dwOutputStreamID,
		[out] IMFAttributes** ppAttributes
	);

	HRESULT GetStreamCount(
		[out] DWORD* pcInputStreams,
		[out] DWORD* pcOutputStreams
	);

	HRESULT GetStreamIDs(
		[in] DWORD dwInputIDArraySize,
		[out] DWORD* pdwInputStreamIds,
		[in] DWORD dwOutputIDArraySize,
		[out] DWORD* pdwOutputStreamIds
	);

	HRESULT ProcessEvent(
		[in] DWORD dwInputStreamID,
		[in] IMFMediaEvent* pEvent
	);

	HRESULT ProcessInput(
		[in] DWORD dwInputStreamID,
		[in] IMFSample* pSample,
		[in] DWORD dwFlags
	);

	HRESULT ProcessMessage(
		[in] MFT_MESSAGE_TYPE eMessage,
		[in] ULONG_PTR ulParam
	);

	HRESULT ProcessOutput(
		[in] DWORD dwFlags,
		[in] DWORD cOutputBufferCount,
		[in, out] MFT_OUTPUT_DATA_BUFFER* pOutputSample,
		[out] DWORD* pdwStatus
	);

	HRESULT SetInputStreamState(
		[in] DWORD dwStreamID,
		[in] IMFMediaType* pMediaType,
		[in] DeviceStreamState value,
		[in] DWORD dwFlags
	);

	HRESULT GetInputStreamState(
		[in] DWORD dwStreamID,
		[out] DeviceStreamState* value
	);

	HRESULT SetOutputStreamState(
		[in] DWORD dwStreamID,
		[in] IMFMediaType* pMediaType,
		[in] DeviceStreamState value,
		[in] DWORD dwFlags
	);

	HRESULT GetOutputStreamState(
		[in] DWORD dwStreamID,
		[out] DeviceStreamState* value
	);

	HRESULT GetInputStreamPreferredState(
		[in] DWORD dwStreamID,
		[out] DeviceStreamState* value,
		[out] IMFMediaType** ppMediaType
	);

	HRESULT FlushInputStream(
		[in] DWORD dwStreamIndex,
		[in] DWORD dwFlags
	);

	HRESULT FlushOutputStream(
		[in] DWORD dwStreamIndex,
		[in] DWORD dwFlags
	);


};

///////////////////////////////////////////////////////////////////////////////
//
// IMFDeviceTransformCallback Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(6D5CB646-29EC-41FB-8179-8C4C6D750811),
	helpstring("IMFDeviceTransformCallback")
]
interface IMFDeviceTransformCallback : stdole.IUnknown
{	// Provides information of buffers allocated and sent to driver
	//
	// PKSSTREAM_HEADER that is inside pInfo is meant only for READ-ONLY usage
	// i.e., user shouldn't try to allocate/deallocate, open/close 
	// anything within the header
	//
	HRESULT OnBufferSent(
		[in] IMFAttributes* pCallbackAttributes,
		[in] DWORD pinId
	);
};


//
// Attributes related to 3D video
//


typedef enum MFT_AUDIO_DECODER_DEGRADATION_REASON
{
	MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE = 0,
	MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT = 1
} MFT_AUDIO_DECODER_DEGRADATION_REASON;

typedef enum MFT_AUDIO_DECODER_DEGRADATION_TYPE
{
	MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE = 0,
	MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL = 1,
	MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL = 2,
	MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL = 3
} MFT_AUDIO_DECODER_DEGRADATION_TYPE;

typedef struct MFAudioDecoderDegradationInfo
{
	MFT_AUDIO_DECODER_DEGRADATION_REASON eDegradationReason;
	MFT_AUDIO_DECODER_DEGRADATION_TYPE eType;
} MFAudioDecoderDegradationInfo;

typedef enum MF_STREAM_STATE
{
	MF_STREAM_STATE_STOPPED = 0,
	MF_STREAM_STATE_PAUSED = 1, //(MF_STREAM_STATE_STOPPED + 1)
	MF_STREAM_STATE_RUNNING = 2 //(MF_STREAM_STATE_PAUSED + 1)
} MF_STREAM_STATE;

typedef struct MFT_STREAM_STATE_PARAM
{
	DWORD StreamId;
	MF_STREAM_STATE State;
} MFT_STREAM_STATE_PARAM;

/// <summary>
///     Flags for use with MFCreatePMPMediaSession
/// </summary>
typedef enum MFPMPSESSION_CREATION_FLAGS
{
	/// <summary>
	///     If set, the Protected Media Path will exist in an unprotected
	///     process.
	///     This is for applications that wish to play clear content in a
	///     separate (unprotected) process.
	///     If not set, the Protected Media Path will exist in a protected
	///     process, and both protected and clear content will play in
	///     this process.
	/// </summary>
	MFPMPSESSION_UNPROTECTED_PROCESS = 0x1,

//#if (WINVER >= _WIN32_WINNT_WINTHRESHOLD)
	/// <summary>
	///     If set, the Protected Media Path will exist in process.
	///     If hardware protection is not available, playing protected content
	///     will fail.
	/// </summary>
	MFPMPSESSION_IN_PROCESS = 0x2,
//#endif // (WINVER >= _WIN32_WINNT_WINTHRESHOLD) ")

}   MFPMPSESSION_CREATION_FLAGS;

typedef enum MF_CONNECT_METHOD
{
	MF_CONNECT_DIRECT = 0x00000000,
	MF_CONNECT_ALLOW_CONVERTER = 0x00000001,
	MF_CONNECT_ALLOW_DECODER = 0x00000003,

	//
	// If MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES is set, the topoloader
	// tries to fully resolve each output type, by inserting decoders/converters, etc. The
	// next type in the list of output types is tried only if every attempt to resolve the current
	// one failed.
	// Currently this flag is only used in conjunction with the MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES flag.
	// And as such it should be set only on a SourceStream topo node. If this flag is set on any other node, it is
	// a no-op.
	//
	MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES = 0x00000004,
	MF_CONNECT_AS_OPTIONAL = 0x00010000,
	MF_CONNECT_AS_OPTIONAL_BRANCH = 0x00020000,
} MF_CONNECT_METHOD;

[
	odl,
	uuid(3C9B2EB9-86D5-4514-A394-F56664F9F0D8),
]
interface IMFMediaSourceEx : IMFMediaSource
{
	HRESULT GetSourceAttributes(
		[out] IMFAttributes** ppAttributes
	);

	HRESULT GetStreamAttributes(
		[in]  DWORD dwStreamIdentifier,
		[out] IMFAttributes** ppAttributes
	);

	HRESULT SetD3DManager(
		[in]  stdole.IUnknown* pManager
	);
};


interface IMFPresentationClock;

[
	odl,
	uuid(6ef2a662-47c0-4666-b13d-cbb717f2fa2c)
]
interface IMFClockConsumer : stdole.IUnknown
{
	HRESULT SetPresentationClock(
		[in] IMFPresentationClock * pPresentationClock
	);

	HRESULT GetPresentationClock(
		[out] IMFPresentationClock** ppPresentationClock
	);
};

[
	odl,
	uuid(D182108F-4EC6-443f-AA42-A71106EC825F),
]
interface IMFMediaStream : IMFMediaEventGenerator
{
	HRESULT GetMediaSource(
		[out] IMFMediaSource** ppMediaSource
	);

	HRESULT GetStreamDescriptor(
		[out] IMFStreamDescriptor** ppStreamDescriptor
	);

	HRESULT RequestSample(
		[in] stdole.IUnknown* pToken
	);

};

typedef enum MF_TRANSFER_VIDEO_FRAME_FLAGS
{
	MF_TRANSFER_VIDEO_FRAME_DEFAULT = 0,
	MF_TRANSFER_VIDEO_FRAME_STRETCH = 1,
	MF_TRANSFER_VIDEO_FRAME_IGNORE_PAR = 2,
} MF_TRANSFER_VIDEO_FRAME_FLAGS;

interface IMFStreamSink;

[
	odl,
	uuid(6ef2a660-47c0-4666-b13d-cbb717f2fa2c)
]
interface IMFMediaSink : stdole.IUnknown
{
	/// <summary>
	///     The GetCharacteristics method allows the caller to
	///     retrieve the characteristics for this Media Sink.
	/// </summary>
	/// <param name="pdwCharacteristics">
	///     Pointer to a variable where the Media Sink characteristics
	///     flags will be returned.  Should not be NULL.
	/// </param>
	/// <remarks>
	///     The characteristics can be a combination of zero or
	///     more of the following flags:
	///     <para>
	///         MEDIASINK_FIXED_STREAMS:
	///             This flag indicates that AddStreamSink and
	///             RemoveStreamSink are not supported, since the
	///             Media Sink creates and maintains a fixed set
	///             of StreamSinks.
	///     </para>
	///     <para>
	///         MEDIASINK_CANNOT_MATCH_CLOCK:
	///             This flag indicates that this Media Sink cannot
	///             match to an outside Presentation Time Source.
	///             If this flag is set, then calling SetPresentationClock
	///             on this Media Sink with a Presentation Clock that is
	///             using a Time Source other than the one provided by
	///             this Media Sink will have suboptimal results.
	///             This flag should be used sparingly, since it restricts
	///             the scenarios in which this Media Sink can be used.
	///     </para>
	///     <para>
	///         MEDIASINK_RATELESS:
	///             This flag indicates that the Media Sink is "rateless".
	///             This means that the Media Sink simply operates as quickly
	///             as possible and does not make any attempt to operate in
	///             real time or to sync to a presentation clock.
	///             Most archiving sinks are rateless.
	///             See the MF Timing Model design doc for more details on how
	///             rateless sinks are handled.
	///     </para>
	///     <para>
	///         MEDIASINK_CLOCK_REQUIRED:
	///             This flag indicates that the Media Sink requires a
	///             Presentation Clock to be set via
	///             IMFMediaSink::SetPresentationClock in order for the
	///             sink to operate correctly.
	///             Video renderers that depend on a presentation clock
	///             for scheduling when to display their frames should
	///             set this flag.
	///     </para>
	/// </remarks>
	HRESULT GetCharacteristics(
		[out] DWORD* pdwCharacteristics
	);

	/// <summary>
	///     The AddStreamSink method provides a way to add a Stream Sink
	///     supporting the given Media Type.
	/// </summary>
	/// <param name="dwStreamSinkIdentifier">
	///     Identifier of the stream sink to support pMediaType.
	///     This must be an identifier that is not currently in use.
	/// </param>
	/// <param name="pMediaType">
	///     Pointer to the Media Type to support.
	///     This can point to a valid media type, or it can be NULL
	///     to signify that media type negotiation will happen later.
	/// </param>
	/// <param name="ppStreamSink">
	///     Pointer to a variable in which the pointer to the new
	///     Stream Sink is returned.  Should not be NULL.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_MEDIASINK_FIXED_STREAMS:
	///             This Media Sink has a fixed set of Stream Sinks,
	///             and therefore AddStreamSink and RemoveStreamSink are not
	///             supported.
	///     </para>
	///     <para>
	///         MF_E_STREAMSINK_EXISTS:
	///             A Stream Sink with identifier dwStreamSinkIdentifier
	///             already exists.
	///     </para>
	/// </returns>
	/// <remarks>
	///     Media Sinks that set MEDIASINK_FIXED_STREAMS in GetCharacteristics
	///     will fail this call.
	/// </remarks>
	HRESULT AddStreamSink(
		[in] DWORD dwStreamSinkIdentifier,
		[in] IMFMediaType* pMediaType,
		[out] IMFStreamSink** ppStreamSink
	);

	/// <summary>
	///     The RemoveStreamSink method signals to the Media Sink that
	///     the Stream Sink with the given identifier will no longer be
	///     used and should no longer be enumerated.
	/// </summary>
	/// <param name="dwStreamSinkIdentifier">
	///     Identifier of the Stream Sink to remove.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_MEDIASINK_FIXED_STREAMS:
	///             This Media Sink has a fixed set of Stream Sinks,
	///             and therefore AddStreamSink and RemoveStreamSink are not
	///             supported.
	///     </para>
	///     <para>
	///         MF_E_INVALIDSTREAMNUMBER:
	///             There is no Stream Sink with identifier dwStreamSinkIdentifier.
	///     </para>
	///     <para>
	///         MF_E_STREAM_REMOVED:
	///             This Stream Sink has already been removed
	///     </para>
	/// </returns>
	/// <remarks>
	///     Media Sinks that set MEDIASINK_FIXED_STREAMS in GetCharacteristics
	///     will fail this call.
	///     This Stream Sink will no longer be enumerated by
	///     GetStreamSinkByIndex or by GetStreamSinkById.
	///     This same identifier can be used to create a new Stream Sink
	///     via AddStreamSink.
	/// </remarks>
	HRESULT RemoveStreamSink(
		[in] DWORD dwStreamSinkIdentifier
	);

	/// <summary>
	///     The GetStreamSinkCount method allows the user to
	///     retrieve the number of Stream Sinks associated with
	///     this Media Sink.
	/// </summary>
	/// <param name="pcStreamSinkCount">
	///     Pointer to a variable in which the number of Stream Sinks
	///     associated with this Media Sink will be returned.
	///     Should not be NULL.
	/// </param>
	HRESULT GetStreamSinkCount(
		[out] DWORD* pcStreamSinkCount
	);

	/// <summary>
	///     The GetStreamSinkByIndex method allows the user to
	///     retrieve a pointer to a Stream Sink associated with
	///     this Media Sink given its index among the Media Sink's
	///     Stream Sinks.
	/// </summary>
	/// <param name="dwIndex">
	///     0-based index into the Media Sink's Stream Sinks.
	/// </param>
	/// <param name="ppStreamSink">
	///     Pointer to a variable that in which the pointer to
	///     the requested Stream Sink will be returned.  Should not be NULL.
	/// </param>
	/// <remarks>
	///     Note that enumeration is not a thread-safe operation,
	///     since Stream Sinks can be added or removed between
	///     calls to this method.
	/// </remarks>
	HRESULT GetStreamSinkByIndex(
		[in] DWORD dwIndex,
		[out] IMFStreamSink** ppStreamSink
	);

	/// <summary>
	///     The GetStreamSinkById method allows the user to retrieve
	///     a pointer to a Stream Sink associated with this Media Sink
	///     given its Stream Sink identifier.
	/// </summary>
	/// <param name="dwStreamSinkIdentifier">
	///     The Stream Sink identifier for the desired Stream Sink.
	/// </param>
	/// <param name="ppStreamSink">
	///     Pointer to a variable in which the pointer to the requested
	///     Stream Sink will be returned.  Should not be NULL.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_INVALIDSTREAMNUMBER:
	///             There is no Stream Sink with the given identifier.
	///     </para>
	/// </returns>
	HRESULT GetStreamSinkById(
		[in] DWORD dwStreamSinkIdentifier,
		[out] IMFStreamSink** ppStreamSink
	);

	/// <summary>
	///     The SetPresentationClock method allows the user to set a
	///     Presentation Clock on the Media Sink that will control
	///     how it sinks data
	/// </summary>
	/// <param name="pPresentationClock">
	///     A pointer to the Presentation Clock that the user chooses
	///     to control the sinking behavior.  Can be NULL.
	/// </param>
	/// <remarks>
	///     <para>
	///         A NULL value indicates that the Media Sink is being removed
	///         from the presentation.  The Media Sink should call
	///         IMFPresentationClock::RemoveClockStateSink to stop listening
	///         for notifications from its former Presentation Clock.
	///     </para>
	///     <para>
	///         pPresentationClock must have already had a valid
	///         Presentation Time Source set.
	///         Implementations must handle this call.
	///     </para>
	///     <para>
	///         If this Media Sink is a Presentation Time Source, the Presentation
	///         Clock may or may not be using this Media Sink as the Presentation
	///         Time Source.
	///         If SetPresentationClock has been called, the Media Sink should
	///         pay attention to the time on that Presentation Clock's Time Source
	///         and not fall behind, even if a Presentation Time Source other
	///         than this Media Sink is being used by the Presentation Clock.
	///         The exception is rateless sinks, which
	///         will ignore the clock.  If a Media Sink cannot do this,
	///         then the MEDIASINK_CANNOT_MATCH_CLOCK flag should be set from
	///         GetCharacteristics.  In this case, SetPresentationClock
	///         should still succeed, but the results may be suboptimal
	///         if this sink's failure to allocate samples quickly enough holds
	///         up the entire pipeline.
	///     </para>
	///     <para>
	///         The Media Sink is expected to call AddClockStateSink
	///         on this Presentation Clock to register itself
	///         for clock state change notifications.
	///         The Media Sink is expected to call RemoveClockStateSink
	///         to deregister itself when a new Presentation Clock is
	///         set via SetPresentationClock, or upon shutdown of the
	///         Media Sink.
	///     </para>
	/// </remarks>
	HRESULT SetPresentationClock(
		[in] IMFPresentationClock* pPresentationClock
	);

	/// <summary>
	///     The GetPresentationClock method allows the user to
	///     retrieve the last Presentation Clock that was set
	///     on the Media Sink.
	/// </summary>
	/// <param name="ppPresentationClock">
	///     A pointer to a variable in which a pointer to the last
	///     Presentation Clock set on this Media Sink is returned.
	///     Should not be NULL.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_NO_CLOCK:
	///             No clock was ever set.
	///     </para>
	/// </returns>
	HRESULT GetPresentationClock(
		[out] IMFPresentationClock** ppPresentationClock
	);

	/// <summary>
	///     The Shutdown method causes all the resources used by the
	///     Media Sink to be properly shutdown and released.
	///     The Media Sink should be shut down when the caller is done with
	///     it to prevent memory leaks
	/// </summary>
	/// <remarks>
	///     Upon successful completion of this call, all
	///     methods on the Media Sink will return MF_E_SHUTDOWN when called.
	///     The exception is the IMFMediaEventGenerator calls
	///     which are still allowed.
	/// </remarks>
	HRESULT Shutdown();
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/// <summary>
/// Marker types for use with IMFStreamSink::PlaceMarker.
/// </summary>
typedef enum MFSTREAMSINK_MARKER_TYPE
{
	/// <member name="MFSTREAMSINK_MARKER_DEFAULT">
	///     This indicates that this marker is not meant to convey
	///     any special information to the Stream Sink and is just
	///     for the caller's use.
	/// </member>
	MFSTREAMSINK_MARKER_DEFAULT,

	/// <member name="MFSTREAMSINK_MARKER_ENDOFSEGMENT">
	///     This is an informational marker sent to the Stream Sink
	///     when the end of a particular segment (topology) for this stream has been
	///     hit.
	///     Receiving this marker is an indication that there may be
	///     a gap in this stream until the next segment starts; however,
	///     samples for the next segment may follow immediately.
	/// </member>
	MFSTREAMSINK_MARKER_ENDOFSEGMENT,

	/// <member name="MFSTREAMSINK_MARKER_TICK">
	///     This is a hint to the Stream Sink that there is a gap
	///     in the sample times.  The marker value associated with
	///     this marker will be a VT_I8 100ns value indicating
	///     the next possible sample time for this Stream Sink.
	///     The Stream Sink can ignore this marker, but some Stream
	///     Sinks will want to inspect these markers for optimal behavior.
	/// </member>
	MFSTREAMSINK_MARKER_TICK,

	/// <member name="MFSTREAMSINK_MARKER_EVENT">
	///     The pvarMarkerValue argument to PlaceMarker will be a
	///     VT_UNKNOWN containing an IMFMediaEvent.  This event
	///     should be processed by the Stream Sink if the Stream Sink
	///     recognizes it; otherwise, it should just send the marker
	///     back.
	/// </member>
	MFSTREAMSINK_MARKER_EVENT,

}   MFSTREAMSINK_MARKER_TYPE;

interface IMFMediaTypeHandler;

[
	odl,
	uuid(0A97B3CF-8E7C-4a3d-8F8C-0C843DC247FB),
]
/// <summary>
/// The IMFStreamSink interface is the base interface for all
/// Media Foundation stream-based sinks (for both encoding
/// and rendering).
/// </summary>
interface IMFStreamSink : IMFMediaEventGenerator
{
	/// <summary>
	///     The GetMediaSink method allows the caller to retrieve
	///     a pointer to the Media Sink to which this stream belongs.
	/// </summary>
	/// <param name=ppMediaSink>
	///     Pointer to a variable where the pointer to the Media Sink
	///     for this stream will be returned.  Should not be NULL.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_STREAM_REMOVED:
	///             This Stream Sink has been removed and is no longer usable.
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         All Stream Sink objects should be associated with exactly
	///         one Media Sink.  Media Sinks can contain more than one Stream Sink.
	///     </para>
	///     <para>
	///         This call should return a pointer to a valid Media Sink
	///         odl, regardless of the state the Stream Sink was in when the
	///         call was made.
	///     </para>
	/// </remarks>
	HRESULT GetMediaSink(
		[out] IMFMediaSink** ppMediaSink
	);

	/// <summary>
	///     The GetIdentifier method allows the caller to retrieve the
	///     unique identifier for this stream.
	/// </summary>
	/// <param name=pdwIdentifier>
	///     Pointer to a variable where the stream identifier will be returned.
	///     Should not be NULL.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_STREAM_REMOVED:
	///             This Stream Sink has been removed and is no longer usable.
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         This call should return a Stream Sink identifier that is unique
	///         within this Media Sink.  It should do so regardless of the state
	///         of the Stream Sink.
	///     </para>
	///     <para>
	///         If the Stream Sink was created via IMFMediaSink::AddStreamSink,
	///         then this identifier will be the identifier with which the Stream
	///         Sink was created; otherwise, this identifier gets assigned by the
	///         Media Sink itself.  For certain implementations, this identifier
	///         has a meaning (for instance, in an ASF encoding sink, it would be
	///         the ASF stream number); for other implementations it is simply an
	///         identifier.
	///     </para>
	/// </remarks>
	HRESULT GetIdentifier(
		[out] DWORD* pdwIdentifier
	);

	/// <summary>
	///     The GetMediaTypeHandler method allows the caller to retrieve
	///     the Media Type Handler for this stream, which will in turn
	///     allow the user to see which media types are supported and to
	///     choose a media type.
	/// </summary>
	/// <param name=ppMediaTypeHandler>
	///     Pointer to a variable where the pointer to the stream's Media
	///     Type Handler will be returned.  Should not be NULL.
	/// </param>
	/// <remarks>
	///     This method should return a valid Media Type Handler, regardless
	///     of the state the Stream Sink is in (except, of course, if the
	///     Stream Sink has been removed from its Media Sink, in which case
	///     MF_E_STREAMSINK_REMOVED will be returned).  If no media types
	///     are currently supported, then the correct behavior is to return
	///     a Media Type Handler that simply fails the
	///     IMFMediaTypeHandler::GetCurrentMediaType and indicates from
	///     IMFMedaTypeHandler::IsMediaTypeSupported that no media types
	///     are supported.
	/// </remarks>
	HRESULT GetMediaTypeHandler(
		[out] IMFMediaTypeHandler** ppHandler
	);

	/// <summary>
	///     The ProcessSample method provides a way for the user to send
	///     samples into the Stream Sink to be either written or rendered.
	/// </summary>
	/// <param name=pSample>
	///     Pointer to an object implementing IMFSample that contains the
	///     sample to be written or rendered.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_STREAM_REMOVED:
	///             This Stream Sink has been removed and is no longer usable.
	///     </para>
	///     <para>
	///         MF_E_INVALIDREQUEST:
	///             This Stream Sink is either in the paused or stopped state
	///             and cannot handle the sample.
	///     </para>
	///     <para>
	///         MF_E_NO_TIMESTAMP:
	///             pSample is missing a timestamp, and this Stream Sink
	///             requires timestamps
	///     </para>
	/// </returns>
	/// <remarks>
	///     Please see Media Sink design spec for info on how ProcessSample works.
	/// </remarks>
	HRESULT ProcessSample(
		[in] IMFSample* pSample
	);

	/// <summary>
	///     The PlaceMarker method indicates to the Stream Sink that
	///     it should send an MEStreamSinkMarker event once it has
	///     finished processing all samples that were passed in before
	///     this call was made.
	/// </summary>
	/// <param name=eMarkerType>
	///     Indicates type of marker
	/// </param>
	/// <param name=pvarMarkerValue>
	///     This is an additional piece of data that may be useful,
	///     depending on the value of eMarkerType.
	///     For instance, if dwFlags is STREAMSINK_MARKER_TICK,
	///     then this is a VT_I8 containing the next possible sample time,
	///     in 100ns units.  May be NULL.
	/// </param>
	/// <param name=pvarContextValue>
	///     This is an optional piece of context data that will be
	////    returned to the caller as the value attached to the
	////    MEStreamSinkMarker event.
	////    This value is purely for the caller's use.
	////    The Stream Sink should make its own copy of this PROPVARIANT.
	////    May be NULL.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_STREAM_REMOVED:
	///             This Stream Sink has been removed and is no longer usable.
	///     </para>
	/// </returns>
	/// <remarks>
	///     Callers should call PlaceMarker with type STREAMSINK_MARKER_ENDOFSEGMENT
	///     when they are done passing data to this Stream Sink.
	///     All of the data waiting in the Stream Sink at the time of
	///     PlaceMarker will still get handled, even if the type is
	///     is STREAMSINK_MARKER_ENDOFSEGMENT..
	///     This call should succeed and queue the MEStreamSinkMarker
	///     event even while the Stream Sink is in a stopped or paused state
	///     Even if Flush is called on the Stream Sink after a
	///     PlaceMarker call but before the Stream Sink sends out the
	///     MEStreamSinkMarker event, then the MEStreamSinkMarker event
	///     should nevertheless get sent.
	///     If the marker is of the STREAMSINK_MARKER_ENDOFSEGMENT
	///     or STREAMSINK_MARKER_TICK types, then this call will likely affect
	///     the behavior of the Stream Sink in some way.
	///     If STREAMSINK_MARKER_DEFAULT is the type, then the Stream Sink's
	///     processing of samples should not be affected.
	/// </remarks>
	HRESULT PlaceMarker(
		[in] MFSTREAMSINK_MARKER_TYPE eMarkerType,
		[in] VARIANT* pvarMarkerValue,
		[in] VARIANT* pvarContextValue);

	/// <summary>
	///     The Flush method signals to the Stream Sink that it should
	///     drop all data that has come into ProcessSample but has not
	///     yet been processed.
	/// </summary>
	/// <returns>
	///     <para>
	///         MF_E_STREAM_REMOVED:
	///             This Stream Sink has been removed and is no longer usable.
	///     </para>
	/// </returns>
	/// <remarks>
	///     None of the data waiting in the Stream Sink at the time
	///     of Flush will get handled.
	///     The call will return once all of the waiting data has been
	///     successfully dropped.
	///     Flush does not change the running state of the Stream Sink
	///     (i.e. started, stopped, pause).
	///     Since queued data gets dropped at the Flush call,
	///     the result will be a glitch in the data.
	///     Flush does not drop any pending events on the Stream Sink's
	///     Media Event Generator.  Those events will still get delivered;
	///     however, they will contain the error code MF_E_STREAMSINK_FLUSHED
	///     in their status HRESULTs, which will indicate that they were
	///     generated after a Flush.
	/// </remarks>
	HRESULT Flush();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


[
	odl,
	uuid(86cbc910-e533-4751-8e3b-f19b5b806a03)
]
interface IMFVideoSampleAllocator : stdole.IUnknown
{
	HRESULT SetDirectXManager(
		[in] stdole.IUnknown* pManager);

	HRESULT UninitializeSampleAllocator(void);

	HRESULT InitializeSampleAllocator(
		[in] DWORD cRequestedFrames,
		[in] IMFMediaType* pMediaType);

	HRESULT AllocateSample(
		[out] IMFSample** ppSample);
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(A792CDBE-C374-4e89-8335-278E7B9956A4)
]
interface IMFVideoSampleAllocatorNotify : stdole.IUnknown
{
	HRESULT NotifyRelease();
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(3978AA1A-6D5B-4B7F-A340-90899189AE34)
]
interface IMFVideoSampleAllocatorNotifyEx : IMFVideoSampleAllocatorNotify
{
	HRESULT NotifyPrune([in] IMFSample* pSample);
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(992388B4-3372-4f67-8B6F-C84C071F4751)
]
interface IMFVideoSampleAllocatorCallback : stdole.IUnknown
{
	HRESULT SetCallback(
		[in] IMFVideoSampleAllocatorNotify* pNotify);

	HRESULT GetFreeSampleCount(
		[out] LONG* plSamples);
};

[
	odl,
	uuid(545b3a48-3283-4f62-866f-a62d8f598f9f),
	helpstring("IMFVideoSampleAllocatorEx Interface")
]
/// <summary>
///    The IMFVideoSampleAllocatorEx interface (used with DXGI buffer allocators)
/// </summary>
interface IMFVideoSampleAllocatorEx : IMFVideoSampleAllocator
{
	HRESULT InitializeSampleAllocatorEx(
		[in]  DWORD cInitialSamples,
		[in]  DWORD cMaximumSamples,
		[in]  IMFAttributes* pAttributes,
		[in]  IMFMediaType* pMediaType
	);
};

[
	odl,
	uuid(20bc074b-7a8d-4609-8c3b-64a0a3b5d7ce)
]
interface IMFDXGIDeviceManagerSource : stdole.IUnknown
{
	HRESULT GetManager(
		[out] IMFDXGIDeviceManager** ppManager);
}


typedef enum MF_VIDEO_PROCESSOR_ROTATION
{
	ROTATION_NONE = 0,
	ROTATION_NORMAL = 1
} MF_VIDEO_PROCESSOR_ROTATION;

typedef enum MF_VIDEO_PROCESSOR_MIRROR
{
	MIRROR_NONE = 0,
	MIRROR_HORIZONTAL = 1,
	MIRROR_VERTICAL = 2
} MF_VIDEO_PROCESSOR_MIRROR;

[
	odl,
	uuid(A3F675D5-6119-4f7f-A100-1D8B280F0EFB),
	helpstring("Configuration interface for Video Processors")
]
interface IMFVideoProcessorControl : stdole.IUnknown
{
	HRESULT SetBorderColor([in] MFARGB* pBorderColor);

	HRESULT SetSourceRectangle([in] RECT* pSrcRect);

	HRESULT SetDestinationRectangle([in] RECT* pDstRect);

	HRESULT SetMirror([in] MF_VIDEO_PROCESSOR_MIRROR eMirror);

	HRESULT SetRotation([in] MF_VIDEO_PROCESSOR_ROTATION eRotation);

	HRESULT SetConstrictionSize([in] SIZE* pConstrictionSize);
};

[
	odl,
	uuid(BDE633D3-E1DC-4a7f-A693-BBAE399C4A20)
]
interface IMFVideoProcessorControl2 : IMFVideoProcessorControl
{
	/// <summary>
	///     The SetRotationOverride method overrides the rotation operation 
	///     performed in the video processor.
	/// </summary>
	/// <param name=uiRotation>
	///     Rotation value in degrees.  Generally only values from
	///     the MFVideoRotationFormat enum are supported.
	/// </param>
	HRESULT SetRotationOverride([in] UINT uiRotation);

	/// <summary>
	///     The EnableHardwareEffects method enables VideoProcessorBlt
	///     implemented effects when using VideoProcessorBlt.
	/// </summary>
	/// <param name=fEnabled>
	///     Whether effects should be enabled.
	/// </param>
	HRESULT EnableHardwareEffects([in] BOOL fEnabled);

	/// <summary>
	///     The GetSupportedHardwareEffects method returns the list of
	///     supported effects in the currently configured video processor.
	/// </summary>
	/// <param name=puiSupport>
	///     Bitwise OR of effect capabilities from D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS
	/// </param>
	HRESULT GetSupportedHardwareEffects([out, retval] UINT* puiSupport);
};

typedef enum MF_TOPONODE_FLUSH_MODE
{
	/// <member name="MF_TOPONODE_FLUSH_ALWAYS">
	///     Transform is to be flushed for all types of stream changes
	///     (e.g. seeks, new segment, etc.)
	/// </member>
	MF_TOPONODE_FLUSH_ALWAYS,

	/// <member name="MF_TOPONODE_FLUSH_SEEK">
	///     Transform is to be flushed only when the stream is seeked
	/// </member>
	MF_TOPONODE_FLUSH_SEEK,

	/// <member name="MF_TOPONODE_FLUSH_NEVER">
	///     Transform is never to be flushed (except when we are completely done
	///     with it)
	/// </member>
	MF_TOPONODE_FLUSH_NEVER,

} MF_TOPONODE_FLUSH_MODE;

typedef enum MF_TOPONODE_DRAIN_MODE
{
	/// <member name="MF_TOPONODE_DRAIN_DEFAULT">
	///     Default draining behavior is to be applied:
	///         At EndOfStream: drain
	///         At a markout: do not drain
	/// </member>
	MF_TOPONODE_DRAIN_DEFAULT,

	/// <member name="MF_TOPONODE_DRAIN_ALWAYS">
	///     Transform is to be drained whenever a topology ends
	/// </member>
	MF_TOPONODE_DRAIN_ALWAYS,

	/// <member name="MF_TOPONODE_DRAIN_NEVER">
	///     Transform is never to be drained
	/// </member>
	MF_TOPONODE_DRAIN_NEVER,

} MF_TOPONODE_DRAIN_MODE;

[
	odl,
	uuid(fa993888-4383-415a-a930-dd472a8cf6f7)
]
interface IMFGetService : stdole.IUnknown
{
	/// <summary>
	///     Retrieves a service interface.
	/// </summary>
	/// <param name="guidService">
	///     The service identifier (SID) of the service.
	/// </param>
	/// <param name="riid">
	///     The interface identifier (IID) of the interface being requested.
	/// </param>
	/// <param name="ppvObject">
	///     Receives the interface pointer. The caller must release the interface.
	/// </param>
	///  <returns>
	///     If the method succeeds it returns S_OK. If the component does not
	///     support the service it returns MF_E_UNSUPPORTED_SERVICE.
	///  </returns>
	///  <remarks>
	///     Objects which implement IMFGetService should check to see that the
	///     REFIID is requested for the right service GUID.
	///  </remarks>
	HRESULT GetService(
		[in] REFGUID guidService,
		[in] REFIID riid,
		[out] LPVOID ppvObject
	);

}


interface IMFClockStateSink;
interface IMFPresentationTimeSource;

[
	odl,
	uuid(868CE85C-8EA9-4f55-AB82-B009A910A805)
]
/// <summary>
///     IMFPresentationClock is implemented by the Presentation Clock.
///     The caller can specify the Presentation Time Source from which
///     this clock is to read time.
///     There are also methods to control the state of the clock, as
///     well as methods for subscribing and unsubscribing to clock state
///     change notifications.
///     Timers can be set on the Presentation Clock by QIing for
///     IMFTimer.
///     The rate of the Presentation Clock can be set and queried by
///     QIing the Presentation Clock for IMFRateControl.
/// </summary>
interface IMFPresentationClock : IMFClock
{
	/// <summary>
	///     Sets the Presentation Time Source from which this Presentation
	///     Clock will read its time.
	/// </summary>
	/// <param name="pTimeSource">
	///     Pointer to a Presentation Time Source to be used by this
	///     Presentation Clock.
	/// </param>
	/// <remarks>
	///     <para>
	///         pTimeSource must QI for IMFClock.  All time queries on the
	///         Presentation Clock are forwarded to the Presentation Time
	///         Source.
	///     </para>
	///     <para>
	///         A Presentation Time Source must be set in order for
	///         the Presentation Clock to operate.
	///     </para>
	///     <para>
	///         Note that the Presentation Clock will subscribe pTimeSource
	///         as a Clock State Sink so that pTimeSource will receive
	///         state change notifications.  The Presentation Time Source
	///         will receive these notifications synchronously as the clock
	///         state change is happening; this is not necessarily true
	///         for other Clock State Sinks.
	///     </para>
	/// </remarks>
	HRESULT SetTimeSource(
		[in] IMFPresentationTimeSource* pTimeSource
	);

	/// <summary>
	///     Gets the Presentation Time Source currently in use by this
	///     Presentation Clock
	/// </summary>
	/// <param name="ppTimeSource>
	///     Pointer to a variable that will receive a pointer to the current
	///     Presentation Time Source
	/// </param>
	HRESULT GetTimeSource(
		[out] IMFPresentationTimeSource** ppTimeSource
	);

	/// <summary>
	///     GetTime is a helper that retrieves the latest clock time
	///     in 100ns units for Presentation Clocks with simple Presentation
	///     Time Sources.
	/// </summary>
	/// <param name="phnsClockTime">
	///     Pointer to a variable that will receive the latest clock time
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_CLOCK_NOT_SIMPLE:
	///             MFGetClockTime cannot read the time on the clock because
	///             the clock uses more advanced features.  See remarks
	///             for what kinds of clocks are handled by GetTime.
	///             If this error code is returned, then time should be obtained
	///             via IMFClock::GetCorrelatedTime() instead.
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         GetTime handles only "simple" clocks.  That is, clocks
	///         must have a frequency of 10MHz.  For more advanced clocks,
	///         IMFClock::GetCorrelatedTime() should be used.
	///     </para>
	///     <para>
	///         GetTime makes no attempt to smooth out jitter or
	///         otherwise account for any inaccuracies in the clock time.
	///         It simply estimates the current clock time based on the system
	///         time in the latest correlation (as given by
	///         IMFClock::GetCorrelatedTime) and the system time now.
	///         Callers wishing to get better information about the clock time
	///         should use IMFClock::GetCorrelatedTime along with the properties
	///         returned by IMFClock::GetProperties.
	///     </para>
	/// </remarks>
	HRESULT GetTime(
		[out] MFTIME* phnsClockTime
	);

	/// <summary>
	///     Subscribes an object to receive clock state change notifications
	/// </summary>
	/// <param name="pStateSink">
	///     Pointer to the Clock State Sink to be subscribed.
	/// </param>
	/// <remarks>
	///     <para>
	///         The Clock State Sink will be asynchronously notified of
	///         the current state of the Presentation Clock after it is
	///         added.
	///     </para>
	///     <para>
	///         See comments on IMFClockStateSink::OnClockStart for
	///         more info on how Clock State Sinks are notified of state
	///         changes.
	///     </para>
	/// </remarks>
	HRESULT AddClockStateSink(
		[in] IMFClockStateSink* pStateSink
	);

	/// <summary>
	///     Unsubscribes an object from receiving clock state change
	///     notifications.
	/// </summary>
	/// <param name="pStateSink">
	///     Pointer to the Clock State Sink to be unsubscribed.
	/// </param>
	HRESULT RemoveClockStateSink(
		[in] IMFClockStateSink* pStateSink
	);

	/// <summary>
	///     Starts the Presentation Clock so that it starts running from the
	///     specified clock offset.
	/// </summary>
	/// <param name="llClockStartOffset">
	///     Clock time from which the clock should start running.
	///     ullClockStartOffset is given in the units of the clock's frequency.
	///     Please see comments on the MF_CLOCK_PROPERTIES structure returned
	///     from IMFClock::GetProperties.
	///     A value of PRESENTATION_CURRENT_POSITION indicates that the
	///     clock should start running from wherever it is right now;
	///     this value is used to resume from the paused state.
	/// </param>
	/// <remarks>
	///     <para>
	///         The Presentation Clock will synchronously call OnClockStart on
	///         the Presentation Time Source and will proceed with the state
	///         change only if that call succeeds.  All other subscribed Clock
	///         State Sinks will be notified of the state change asynchronously.
	///     </para>
	/// </remarks>
	HRESULT Start(
		[in] LONGLONG llClockStartOffset
	);

	/// <summary>
	///     Stops the Presentation Clock.
	/// </summary>
	/// <remarks>
	///     <para>
	///         The Presentation Clock will synchronously call OnClockStop on
	///         the Presentation Time Source and will proceed with the state
	///         change only if that call succeeds.  All other subscribed Clock
	///         State Sinks will be notified of the state change asynchronously.
	///     </para>
	/// </remarks>
	HRESULT Stop(
	);

	/// <summary>
	///     Pauses the Presentation Clock.
	/// </summary>
	/// <remarks>
	///     <para>
	///         The Presentation Clock will synchronously call OnClockPause on
	///         the Presentation Time Source and will proceed with the state
	///         change only if that call succeeds.  All other subscribed Clock
	///         State Sinks will be notified of the state change asynchronously.
	///     </para>
	/// </remarks>
	HRESULT Pause(
	);

};

[
	odl,
	uuid(7FF12CCE-F76F-41c2-863B-1666C8E5E139),
]
interface IMFPresentationTimeSource : IMFClock
{
	/// <summary>
	///     GetUnderlyingClock gets the always-running clock that drives
	///     this Presentation Time Source
	/// </summary>
	/// <param name="ppClock">
	///     Pointer to a variable that will receive a pointer to the
	///     underlying clock for this Presentation Time Source
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_NO_CLOCK:
	///             There is no underlying clock
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         The underlying clock is useful to components in the
	///         pipeline that want to make decisions based on the speed
	///         at which the Presentation Clock will run, and they want
	///         to observe that speed even when the Presentation Clock is
	///         stopped or paused.  (For example, some Media Sources
	///         implement IMFPresentationClockClient for this purpose).
	///     </para>
	///     <para>
	///         The underlying clock is required to be always running,
	///         regardless of the state (started/stopped/paused) of the
	///         Presentation Time Source.  That is, the underlying clock
	///         must set the bit MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING
	///         in IMFClock::GetClockCharacteristics, even though this
	///         Presentation Time Source will not set that bit.
	///     </para>
	///     <para>
	///         Returning an underlying clock is optional.  If there is
	///         no such clock, implementations will return MF_E_NO_CLOCK.
	///     </para>
	/// </remarks>
	HRESULT GetUnderlyingClock(
		[out] IMFClock** ppClock
	);
};

/// <summary>
///     The IMFClockStateSink interface is implemented by any object
///     that wishes to subscribe to clock state notifications from a
///     Presentation Clock.
///     In particular, all Presentation Time Sources are Clock State Sinks.
/// </summary>
[
	odl,
	uuid(F6696E82-74F7-4f3d-A178-8A5E09C3659F)
]

interface IMFClockStateSink : stdole.IUnknown
{
	/// <summary>
	///     OnClockStart is called when the Presentation Clock has been started
	/// </summary>
	/// <param name="hnsSystemTime">
	///     The MF system time, given in 100ns units, at which the clock
	///     started running.
	/// </param>
	/// <param name="llClockStartOffset">
	///     Clock time, given in the clock's frequency units, from which
	///     the clock started running.
	/// </param>
	/// <remarks>
	///     <para>
	///         If the Clock State Sink is the Presentation Time Source
	///         currently being used by the Presentation Clock, then
	///         the Presentation Clock makes these state change notification
	///         calls synchronously from the IMFPresentationClock::Start,
	///         Stop, and Pause calls.  In this case, any failure code
	///         returned from this method will result in an error being
	///         returned to the caller of the Presentation Clock, and the state
	///         change will not take place.
	///     </para>
	///     <para>
	///         If the Clock State Sink is not the Presentation Time Source
	///         currently in use, then these state change notification calls
	///         are made asynchronously after the fact.  Error codes returned
	///         are ignored.
	///     </para>
	///     <para>
	///         hnsSystemTime should be in the very recent past.
	///     </para>
	/// </remarks>
	HRESULT OnClockStart(
		[in] MFTIME hnsSystemTime,
		[in] LONGLONG llClockStartOffset
	);

	/// <summary>
	///     OnClockStop is called when the Presentation Clock has been stopped
	/// </summary>
	/// <param name="hnsSystemTime">
	///     The MF system time, given in 100ns units, at which the clock
	///    stopped.
	/// </param>
	/// <remarks>
	///     <para>
	///         If the Clock State Sink is the Presentation Time Source
	///         currently being used by the Presentation Clock, then
	///         the Presentation Clock makes these state change notification
	///         calls synchronously from the IMFPresentationClock::Start,
	///         Stop, and Pause calls.  In this case, any failure code
	///         returned from this method will result in an error being
	///         returned to the caller of the Presentation Clock, and the state
	///         change will not take place.
	///     </para>
	///     <para>
	///         If the Clock State Sink is not the Presentation Time Source
	///         currently in use, then these state change notification calls
	///         are made asynchronously after the fact.  Error codes returned
	///         are ignored.
	///     </para>
	///     <para>
	///         hnsSystemTime should be in the very recent past.
	///     </para>
	/// </remarks>
	HRESULT OnClockStop(
		[in] MFTIME hnsSystemTime
	);

	/// <summary>
	///     OnClockPause is called when the Presentation Clock has been paused
	/// </summary>
	/// <param name="hnsSystemTime">
	///     The MF system time, given in 100ns units, at which the clock
	///    paused.
	/// </param>
	/// <remarks>
	///     <para>
	///         If the Clock State Sink is the Presentation Time Source
	///         currently being used by the Presentation Clock, then
	///         the Presentation Clock makes these state change notification
	///         calls synchronously from the IMFPresentationClock::Start,
	///         Stop, and Pause calls.  In this case, any failure code
	///         returned from this method will result in an error being
	///         returned to the caller of the Presentation Clock, and the state
	///         change will not take place.
	///     </para>
	///     <para>
	///         If the Clock State Sink is not the Presentation Time Source
	///         currently in use, then these state change notification calls
	///         are made asynchronously after the fact.  Error codes returned
	///         are ignored.
	///     </para>
	///     <para>
	///         hnsSystemTime should be in the very recent past.
	///     </para>
	/// </remarks>
	HRESULT OnClockPause(
		[in] MFTIME hnsSystemTime
	);

	/// <summary>
	///     OnClockRestart is called when the Presentation Clock has been
	///     restarted from the paused state.
	/// </summary>
	/// <param name="hnsSystemTime">
	///     The MF system time, given in 100ns units, at which the clock
	///     restarted.
	/// </param>
	/// <remarks>
	///     <para>
	///         If the Clock State Sink is the Presentation Time Source
	///         currently being used by the Presentation Clock, then
	///         the Presentation Clock makes these state change notification
	///         calls synchronously from the IMFPresentationClock::Start,
	///         Stop, and Pause calls.  In this case, any failure code
	///         returned from this method will result in an error being
	///         returned to the caller of the Presentation Clock, and the state
	///         change will not take place.
	///     </para>
	///     <para>
	///         If the Clock State Sink is not the Presentation Time Source
	///         currently in use, then these state change notification calls
	///         are made asynchronously after the fact.  Error codes returned
	///         are ignored.
	///     </para>
	///     <para>
	///         hnsSystemTime should be in the very recent past.
	///     </para>
	/// </remarks>
	HRESULT OnClockRestart(
		[in] MFTIME hnsSystemTime
	);


	/// <summary>
	///     OnClockSetRate is called when the rate has been changed on the
	///     PresentationClock.
	/// </summary>
	/// <param name="hnsSystemTime">
	///     The MF system time, given in 100ns units, at which the clock
	///     changed rates.
	/// </param>
	/// <param name="flRate>
	///     The new rate
	/// </param>
	/// <remarks>
	///     <para>
	///         If the Clock State Sink is the Presentation Time Source
	///         currently being used by the Presentation Clock, then
	///         the Presentation Clock makes these rate change notification
	///         calls synchronously from the IMFRateControl::SetRate call
	///         on the Presentation Clock.  In this case, any failure code
	///         returned from this method will result in an error being
	///         returned to the caller of the Presentation Clock, and the rate
	///         change will not take place.
	///     </para>
	///     <para>
	///         If the Clock State Sink is not the Presentation Time Source
	///         currently in use, then these rate change notification calls
	///         are made asynchronously after the fact.  Error codes returned
	///         are ignored.
	///     </para>
	/// </remarks>
	HRESULT OnClockSetRate(
		[in] MFTIME hnsSystemTime,
		[in] float flRate
	);

};


typedef enum MFTIMER_FLAGS
{
	/// <summary>
	///     Indicates that time passed to SetTimer function is relative to the
	///     current time
	/// </summary>
	MFTIMER_RELATIVE = 0x00000001,
} MFTIMER_FLAGS;
/// <summary>
///     IMFTimer is implemented by clocks that provide timer functionality
/// </summary>
[
	odl,
	uuid(e56e4cbd-8f70-49d8-a0f8-edb3d6ab9bf2)]

interface IMFTimer : stdole.IUnknown
{
	/// <summary>
	///     SetTimer sets a timer that will cause the callback
	///     function to be called at the specified clock time.
	/// </summary>
	/// <param name="dwFlags">
	///     Combination of MFTIMER_FLAGS flags.
	/// </param>
	/// <param name="llClockTime">
	///     Clock time at which the timer should fire.
	///     Given in the clock's frequency units.
	/// <param>
	/// <param name="pCallback">
	///     Callback that will be invoked when the timer fires.
	/// </param>
	/// <param name="punkState">
	///     Caller-defined state object that will be passed to
	///     pCallback->Invoke when the timer fires.  Optional.
	/// </param>
	/// <param name="ppunkKey">
	///     Pointer to a variable that will receive a key that can be
	///     used to cancel the timer.
	/// </param>
	HRESULT SetTimer(
		[in] DWORD dwFlags,
		[in] LONGLONG llClockTime,
		[in] IMFAsyncCallback * pCallback,
		[in] stdole.IUnknown * punkState,
		[out] stdole.IUnknown * *ppunkKey
	);

	/// <summary>
	///     Cancels a previously-set timer
	/// </summary>
	/// <param name="punkKey">
	///     The key associated with the timer.
	///     This key was returned from IMFTimer::SetTimer.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_CLOCK_INVALID_TIMER_KEY:
	///             punkKey does not correspond to any timer that can
	///             currently be canceled.
	///     </para>
	/// </returns>
	/// <remarks>
	///     If CancelTimer succeeds, the callback will not be invoked
	///     for that timer.
	/// </remarks>
	HRESULT CancelTimer(
		[in] stdole.IUnknown* punkKey
	);
};

typedef enum MFSHUTDOWN_STATUS
{
	MFSHUTDOWN_INITIATED,
	MFSHUTDOWN_COMPLETED,
} MFSHUTDOWN_STATUS;
/// <summary>
///     Many Media Foundation components need to be shut down upon exit to break
///     circular references and avoid memory leaks.  For any object that
///     implements an interface with a method called Shutdown(), this method
///     should be called at shutdown time.
///     However, some Media Foundation components instead need to be QIed
///     for IMFShutdown and shut down through this interface.
///     The easiest way to do this is to call MFShutdownObject on the object.
///     Most notably, applications should try to QI for IMFShutdown on
///     any objects implementing the following interfaces:
///         IMFPresentationClock
///         IMFActivate
///         IMFContentEnabler
///         IMFInputTrustAuthority
///         IMFTransform (for asynchronous MFTs)
[
	odl,
	uuid(97ec2ea4-0e42-4937-97ac-9d6d328824e1)
]

/// </summary>
interface IMFShutdown : stdole.IUnknown
{
	HRESULT Shutdown();

	HRESULT GetShutdownStatus(
		[out] MFSHUTDOWN_STATUS* pStatus);
};
	/// <summary>
	///     Given the input partial topology, the method will turn it into a
	///     fully loaded topology.
	/// </summary>
	/// <remarks>
	///     Topoloader will find all the intermediate transforms needed to
	///     provide a fully specified topology of sources, transforms,
	///     and sinks.
	///     Sets all the input and output media types on all the objects
	///     in the topology.
	///     If this method returns successfully, the output topology is
	///     ready for processing by the media processor.
	///     The third parameter pCurrentTopo can be NULL or a pointer to
	///     the preceding topology.
	/// </remarks>
	/// <param name="pInputTopo">
	///     The pointer to the partial topology to be resolved.
	/// </param>
	/// <param name="ppOutputTopo">
	///     The pointer to a IMFTopology pointer where the full topology
	///     is returned
	/// </param>
	/// <param name="pCurrentTopo">
	///     The pointer to the previous full topology for object caching.
	///     May be NULL.
	///     The topoloader will use this full topology as reference and
	///     pull the topology node objects from it into the new
	///     full topology it creates.
	///     Once Load completes successfully, pCurrentTopo should be discarded.
	/// </param>
	/// <returns>
	///     If the method succeeds, the return value is S_OK.
	///     If the method fails, the return value will be some failure code.
	/// </returns>
[
	odl,
	uuid(DE9A6157-F660-4643-B56A-DF9F7998C7CD)
]
interface IMFTopoLoader : stdole.IUnknown
{

	HRESULT Load(
		[in] IMFTopology* pInputTopo,
		[out] IMFTopology** ppOutputTopo,
		[in] IMFTopology* pCurrentTopo);
};

[
	odl,
	uuid(ACF92459-6A61-42bd-B57C-B43E51203CB0),
	helpstring("IMFContentProtectionManager Interface")
]
/// <summary>
///     IMFContentProtectionManager is the interface that an application is called
///     back on if a PMP component wants to perform some steps with the application's
///     help/consent, like license acquisition or individualization.
///     <para>
///         The application should implement this callback and set the callback pointer in
///         the configuration property store that it passes into the PMP Session as part
///         of the MFCreatePMPMediaSession method. If the application does not set a
///         callback pointer then certain operations like license acquisition that require
///         application help will fail.
///     </para>
///     <para>
///         The PMP marshals calls from within the Protected Environment to the application.
///     </para>
///     <para>
///         Typically, this interface will be invoked during the SetTopology operation, before
///         MESessionTopologySet is fired by the session. The application should be prepared to receive
///         multiple content enablers during this time. Content Enablers may also be fired outside
///         of the SetTopology operation, but those scenarios are not as common, and typically
///         involve just a single content enabler, so the application should not need special
///         UI to handle multiple enablers outside of the SetTopology operation.
///     </para>
/// </summary>
interface IMFContentProtectionManager : stdole.IUnknown
{
	/// <summary>
	///     BeginEnableContent requests the application to perform a specific step to
	///     acquire rights to the content. The application should not block in this method.
	///     It should do any time-consuming operations asynchronously on its own thread and
	///     when done notify the PMP via the pCallback parameter passed into this method.
	/// </summary>
	/// <param name="pEnablerActivate">
	///     [in]  An IMFActivate to a Content Enabler object. The methods of this object provide
	///     the various options available to the application to perform what is necessary to
	///     finish this step of acquiring rights to the content.
	/// </param>
	/// <param name="pTopo">
	///     [in]  A pointer to the topology that caused this content enabler
	///     to be fired. Note that in some cases, there is no relevant
	///     topology, and this parameter will be NULL.
	/// </param>
	/// <param name="pCallback">
	///     [in]  A callback pointer into the PMP. When the application is done with its
	///     asynchronous processing it should call pCallback->Invoke.
	/// </param>
	/// <param name="punkState">
	///     [in]  A context object that the application should pass back into pCallback->Invoke.
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	/// <remarks>
	///     If the application returns a success code from BeginEnableContent, then it must
	///     call pCallback->Invoke. If it returns an error code from BeginEnableContent, then
	///     it must not call pCallback->Invoke.
	///</remarks>
	HRESULT BeginEnableContent(
		[in] IMFActivate* pEnablerActivate,
		[in] IMFTopology* pTopo,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState
	);

	/// <summary>
	///     After the application notifies the PMP (via pCallback->Invoke) that it is done with
	///     all asynchronous processing following BeginEnableContent, PMP calls EndEnableContent
	///     on the application to fetch the result code of that processing.
	/// </summary>
	/// <param name="pResult">
	///     [in]  This is the same pointer that the application passed into pCallback->Invoke,
	///     where pCallback is what was passed into BeginEnableContent.
	/// </param>
	/// <returns>
	///     The application should return the success code or error code of the asynchronous
	///     processing that followed the BeginEnableContent call.
	/// </returns>
	/// <remarks>
	///     This method is called synchronously from the callback passed in to
	///     BeginEnableContent. Thus, this method will be called on the application's
	///     thread, and should not block.
	///</remarks>
	HRESULT EndEnableContent(
		[in] IMFAsyncResult* pResult
	);

};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

typedef enum MF_URL_TRUST_STATUS
{
	MF_LICENSE_URL_UNTRUSTED,
	MF_LICENSE_URL_TRUSTED,
	MF_LICENSE_URL_TAMPERED,
}   MF_URL_TRUST_STATUS;
/// <summary>
///     The IMFContentEnabler interface encapsulates all of the options available
///     to the application to perform one step along the way to acquire rights to
///     the content.
///     <para>
///         For instance, if the application wants to play WMDRM content, the steps
///         required may be to first individualize the machine and then acquire a license.
///     </para>
///     <para>
///     -   For individualization, the platform creates a Content Enabler object and
///         passes it to the application as part of a platform callback. The application
///         can then put up UI if required, get user consent if required, and finally
///         call the methods of the Content Enabler to perform individualization. The
///         AutomaticEnable method of the Content Enabler performs the individualization.
///     -   The same process is repeated for license acquisition. In this case as well
///         the platform creates (a different implementation of) the Content Enabler object.
///         The AutomaticEnable method of this Content Enabler fetches a license.
///     </para>
///     <para>
///         Abstracting these operations through the IMFContentEnabler interface allows an
///         application to write common code to deal with the various steps of acquiring
///         rights. This also makes it possible for a variety of current and future content
///         protection systems to automatically be plugged in under the application as long
///         as their requirements can be abstracted within this interface.
///     </para>
/// </summary>
[
	odl,
	uuid(D3C4EF59-49CE-4381-9071-D5BCD044C770),
	helpstring("IMFContentEnabler Interface")
]

interface IMFContentEnabler : stdole.IUnknown
{
	/// <summary>
	///     GetEnableType returns the type of operation that needs to be done to acquire
	///     rights to the content. For the types that the application is aware of, it can
	///     put up friendly strings in its UI.
	/// </summary>
	/// <param name="pType">
	///     [out]  GUID representing the type of operation requested.
	/// </param>
	/// <returns>
	///     If the method succeeds, it returns S_OK. Otherwise it returns a failure code.
	/// </returns>
	HRESULT GetEnableType(
		[out] GUID* pType);

	/// <summary>
	///     If the operation requested can be achieved by the application opening a certain
	///     URL in the browser then GetEnableURL returns that URL. For instance, for license
	///     acquisition an application might prefer to navigate to the URL itself.
	///     <para>
	///         The application is expected to do an HTTP POST request to this URL.
	///     </para>
	/// </summary>
	/// <param name="pwszURL">
	///     [out]  Pointer to a WCHAR array allocated by the caller. The Content Enabler
	///     object fills in the URL to navigate to if the length of the array, indicated by
	///     the pcchURL parameter, is sufficient.
	/// </param>
	/// <param name="pcchURL">
	///     [in, out]  Pointer to a DWORD. The caller should initialize it to the size of the
	///     array, in WCHARs, that pwszURL points to. The Content Enabler overwrites it with
	///     the length of the URL in WCHARs excluding the terminating NULL.
	/// </param>
	/// <param name="pTrustStatus">
	///     [out]  An enum that tells the application whether the URL is from a trusted source.
	///     See MF_URL_TRUST_STATUS for details.
	/// </param>
	/// <returns>
	///     If there is an URL to return and the method succeeds, it returns S_OK. Otherwise it
	///     returns a failure code.
	/// </returns>
	/// <remarks>
	///     The application needs to call this method twice - once with a NULL pwszURL in order
	///     to get the length of the WCHAR array to allocate, and the second time with the
	///     allocated array and its size.
	///     <para>
	///         The GetEnableURL call must be accompanied by a GetEnableData call. Typically the
	///         application will also call MonitorEnable subsequently.
	///     </para>
	///</remarks>
	HRESULT GetEnableURL(
		[out] LongPtr* ppwszURL,
		[out] DWORD* pcchURL,
		[in, out] MF_URL_TRUST_STATUS* pTrustStatus);

	/// <summary>
	///     GetEnableData returns the data that needs to accompany the HTTP POST request in case
	///     the application chooses to navigate to the URL returned by GetEnableURL.
	/// </summary>
	/// <param name="pbData">
	///     [out]  Pointer to a BYTE array allocated by GetEnableData that contains the HTTP POST data.
	/// </param>
	/// <param name="pcbData">
	///     [out]  Pointer to a DWORD. The Content Enabler overwrites this with the
	///     length of the POST data in BYTEs.
	/// </param>
	/// <returns>
	///     If there is POST data to return and the method succeeds, it returns S_OK. Otherwise
	///     it returns a failure code.
	/// </returns>
	/// <remarks>
	///</remarks>
	HRESULT GetEnableData(
		[out] LongPtr* ppbData,
		[out] DWORD* pcbData);

	/// <summary>
	///     The IsAutomaticSupported method indicates whether the Content Enabler can do all of the
	///     requested steps on its own. For WMDRM license acquisition for instance, the Content
	///     Enabler is able to navigate to the license acquisition URL on its own and download
	///     the license.
	/// </summary>
	/// <param name="pfAutomatic">
	///     [in]  Pointer to a BOOL. The Content Enabler sets the BOOL to TRUE if it can do the
	///     required operation on its own. It sets the BOOL to FALSE if it needs the application
	///     to do the required operation by calling GetEnableURL and navigating to it.
	/// </param>
	/// <returns>
	///     If the method succeeds it returns S_OK, otherwise it returns a failure code.
	/// </returns>
	/// <remarks>
	///</remarks>
	HRESULT IsAutomaticSupported(
		[out] BOOL* pfAutomatic);

	/// <summary>
	///     Through AutomaticEnable the application instructs the Content Enabler to perform the
	///     required operation on its own. MF ONLY: When the operation completes the Content Enabler
	///     queues up a MEEnablerCompleted event onto its IMFMediaEventGenerator interface.
	/// </summary>
	/// <returns>
	///     If the method succeeds it returns S_OK, otherwise it returns a failure code.
	/// </returns>
	/// <remarks>
	///</remarks>
	HRESULT AutomaticEnable();

	/// <summary>
	///     MF ONLY: In case the application chooses to call GetEnableURL and navigate itself, the
	///     application is expected to do so through a web browser or web browser control.
	///     From that point the rest of the operation proceeds without the application's
	///     involvement. If the application wants to be notified when the operation completes,
	///     then it should call MonitorEnable. In this case the Content Enabler queues up a
	///     MEEnablerCompleted event onto its IMFMediaEventGenerator interface, just like in
	///     the SilentEnable case.
	/// </summary>
	/// <returns>
	///     If the method succeeds it returns S_OK, otherwise it returns a failure code.
	/// </returns>
	/// <remarks>
	///</remarks>
	HRESULT MonitorEnable();

	/// <summary>
	///     The application can call Cancel to cancel a pending SilentEnable or MonitorEnable.
	///     MF ONLY: In response the Content Enabler queues up a MEEnablerCompleted event immediately
	///     with an error code of E_CANCEL.
	/// </summary>
	/// <returns>
	///     If the method succeeds it returns S_OK, otherwise it returns a failure code.
	/// </returns>
	/// <remarks>
	///</remarks>
	HRESULT Cancel();
};
/// <summary>
///     <para>
///     The IMFMetadata interface is the method by which MF-aware applications
///     access file metadata from media sources.
///     </para>
/// </summary>
[
	odl,
	uuid(F88CFB8C-EF16-4991-B450-CB8C69E51704)
]

interface IMFMetadata : stdole.IUnknown
{
	/// <summary>
	///     Sets the language context in which values are to be returned.
	/// </summary>
	/// <param name="pwszRFC1766">
	///     Language ID, specified per RFC 1766.
	/// </param>
	HRESULT SetLanguage(
		[in] LongPtr pwszRFC1766
	);

	/// <summary>
	///     Retrieves the current language context.
	/// </summary>
	/// <param name="pwszRFC1766">
	///     Language ID, specified per RFC 1766. Must be deallocated using CoTaskMemFree(...)
	/// </param>
	HRESULT GetLanguage(
		[out] LongPtr* ppwszRFC1766
	);

	/// <summary>
	///     Retrieves a list of all available languages in this metadata set.
	/// </summary>
	/// <param name="ppvLanguages">
	///     Returns a list of language IDs, per RFC1766, in a PROPVARIANT specified as type
	///     VT_VECTOR | VT_LongPtr.
	/// </PARAM>
	HRESULT GetAllLanguages(
		[out] VARIANT* ppvLanguages
	);

	/// <summary>
	///     Set given property to the given value.  For property type, consult schema
	///     documentation.
	/// </summary>
	/// <param name="pwszName">
	///     The name of the property.
	/// </param>
	/// <param name="ppvValue">
	///     Value to set.
	/// </param>
	/// <remarks>
	/// <para>
	///     If the value is recognized, the type of the PROPVARIANT will be enforced.
	/// </para>
	/// <para>
	///     If the value is NOT recognized, but exists in the current propery set,
	///     SetProperty will enforce agreement between the type of the existing value
	///     and the type of the new value.
	/// </para>
	/// <para>
	///     If the value is NOT recognized and does NOT exist in the current property
	///     set, SetProperty will successfully set the property regardless of type.
	/// </para>
	/// </remarks>
	HRESULT SetProperty(
		[in] LongPtr pwszName,
		[in] VARIANT* ppvValue
	);

	/// <summary>
	///     Retrieve value corresponding to the specified name.
	/// </summary>
	/// <param name="pwszName">
	///     The name of the property.
	/// </param>
	/// <param name="ppvValue">
	///     Value to retrieve.
	/// </param>
	/// <remarks>
	///     For predefined values, type will be as specified in schema documentation.
	///     For unknown values, type will be as specified when set, or in the case of
	///     unknown file metadata values, will default to string.
	/// </remarks>
	HRESULT GetProperty(
		[in] LongPtr pwszName,
		[out] VARIANT* ppvValue
	);

	/// <summary>
	///     Remove specified property from a set.
	/// </summary>
	/// <param name="pwszName">
	///     Name of the property to remove.
	/// </param>
	/// <remarks>
	///     Some properties may be considered read-only.  An attempt to delete a
	///     read-only property will result in an error.  An attempt to delete a
	///     property which is not part of the set will succeed with status code
	///     S_FALSE.
	/// </remarks>
	HRESULT DeleteProperty(
		[in] LongPtr pwszName
	);

	/// <summary>
	///     Retrieve the names of all properties in the given set.
	/// </summary>
	/// <param name="ppvNames">
	///     Array of VT_LongPtr property names.
	/// </param>
	/// <remarks>
	///     Note that the list will be returned as type VT_VECTOR | VT_LongPtr,
	///     i.e. a simple array, NOT in a SAFEARRAY type.
	/// </remarks>
	HRESULT GetAllPropertyNames(
		[out] VARIANT* ppvNames
	);
};
/// <summary>
///     IMFMetadataProvider is used to obtain a IMFMetadata interface
///     associated with a particular IMFPresentationDescriptor
/// </summary>
[
	odl,
	uuid(56181D2D-E221-4adb-B1C8-3CEE6A53F76F)
]

interface IMFMetadataProvider : stdole.IUnknown
{
	/// <summary>
	///     Returns a IMFMetadata interface
	/// </summary>
	/// <param name="pPresentationDescriptor">
	///     Pointer to the IMFPresentationDescriptor for which the
	///     IMFMetadata is desired.
	/// </param>
	/// <param name="dwStreamIdentifier">
	///     If set to 0, the function returns the IMFMetadata of the whole
	///     presentation. If dwStreamIdentifier is set to a non-zero value,
	///     the function returns a IMFMetadata belonging to the stream
	///    identified by dwStreamIdentifier.
	/// </param>
	/// <param name="dwFlags">
	///     Reserved for future use.  Must be set to zero.
	/// </param>
	/// <param name="ppMFMetadata">
	///     Pointer to a variable that will be set to a pointer to the IMFMetadata interface.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_PROPERTY_NOT_FOUND:
	///         An IMFMetadata interface is not available for the requested
	///         IMFPresentationDescriptor and/or stream identifier.
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         An IMFMetadata interface may not always be available for a
	///         certain IMFPresentationDescriptor and/or stream identifier.
	///     </para>
	/// </remarks>
	HRESULT GetMFMetadata(
		[in] IMFPresentationDescriptor * pPresentationDescriptor,
		[in] DWORD dwStreamIdentifier,
		[in] DWORD dwFlags,
		[out] IMFMetadata * *ppMFMetadata
	);
};

typedef enum MFRATE_DIRECTION
{
	//
	// Indicates forward playback
	//
	MFRATE_FORWARD,

	//
	// Indicates reverse playback
	//
	MFRATE_REVERSE

}   MFRATE_DIRECTION;

[
	odl,
	uuid(0a9ccdbc-d797-4563-9667-94ec5d79292d)
]
/// <summary>
///     IMFRateSupport is used to query a component for what
///     rates it supports.
///     This interface is obtained from the component via
///     IMFGetService::GetService using the MF_RATE_CONTROL_SERVICE
///     service GUID.
///     The Media Session provides IMFRateSupport.
///     Media Sources, Transforms, and Media Sinks may provide IMFRateSupport.
///     Those that do not are assumed to support any positive rate but
///     not zero or negative rates.
/// </summary>
interface IMFRateSupport : stdole.IUnknown
{
	/// <summary>
	///     Gets the slowest rate at which playback can happen
	/// </summary>
	/// <param name="eDirection">
	///     Indicates playback direction for this query.
	///     If MFRATE_FORWARD, then *pflRate will be set to the slowest
	///     positive rate supported.
	///     If MFRATE_REVERSE, then *pflRate will be set to the slowest
	///     negative rate (by absolute value) supported.
	/// </param>
	/// <param name="fThin">
	///     If TRUE, then *pflRate will be set to the slowest rate at
	///     which thinning will occur.
	/// </param>
	/// <param name="pflRate">
	///     Pointer to a variable to receive the slowest rate supported.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_REVERSE_UNSUPPORTED
	///         Returned by components that do not support reverse
	///         playback when fForwardPlayback is FALSE.
	///     </para>
	///     <para>
	///         MF_E_THINNING_UNSUPPORTED
	///         Returned by components that cannot thin streams or handle
	///         thinned streams when fThin is TRUE.
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         If 0 is returned in *pflRate, that does not guarantee that
	///         rate 0 is supported; the caller must do a separate
	///         IsRateSupported query to determine that.
	///         Otherwise, *pflRate can be assumed to be supported.
	///     </para>
	///     <para>
	///         "Thinning" is defined in a format-specific manner.
	///         For some formats (such as ASF), thinning will mean dropping
	///         all frames that are not I-frames.
	///         If the component produces stream data (like a Media Source
	///         or a demultiplexer), it should pay attention
	///         to the fThin argument and return MF_E_THINNING_UNSUPPORTED
	///         if it cannot thin the stream.
	///         If the component processes or receives a stream (like
	///         most transforms or Media Sinks), it may ignore this
	///         parameter if it does not care whether the stream is thinned.
	///         In the Media Session's implementation of rate support,
	///         if the transforms do not explicitly support reverse playback,
	///         the Media Session will attempt to do reverse playback in
	///         thinned mode (but will not do so unthinned).
	///         Therefore, most applications will set fThin to TRUE
	///         when using the Media Session for reverse playback.
	///     </para>
	/// </remarks>
	HRESULT GetSlowestRate(
		[in]  MFRATE_DIRECTION eDirection,
		[in]  BOOL fThin,
		[out] float* pflRate
	);

	/// <summary>
	///     Gets the fastest rate at which playback can happen
	/// </summary>
	/// <param name="eDirection">
	///     Indicates playback direction for this query.
	///     If MFRATE_FORWARD, then *pflRate will be set to the fastest
	///     positive rate supported.
	///     If MFRATE_REVERSE, then *pflRate will be set to the fastest
	///     negative rate (by absolute value) supported.
	/// </param>
	/// <param name="fThin">
	///     If TRUE, then *pflRate will be set to the fastest rate at
	///     which thinning will occur.
	/// </param>
	/// <param name="pflRate">
	///     Pointer to a variable to receive the fastest rate supported.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_REVERSE_UNSUPPORTED
	///         Returned by components that do not support reverse
	///         playback when fForwardPlayback is FALSE.
	///     </para>
	///     <para>
	///         MF_E_THINNING_UNSUPPORTED
	///         Returned by components that cannot thin streams or handle
	///         thinned streams when fThin is TRUE.
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         If 0 is returned in *pflRate, that does not guarantee that
	///         rate 0 is supported; the caller must do a separate
	///         IsRateSupported query to determine that.
	///         Otherwise, *pflRate can be assumed to be supported.
	///     </para>
	///     <para>
	///         "Thinning" is defined in a format-specific manner.
	///         For some formats (such as ASF), thinning will mean dropping
	///         all frames that are not I-frames.
	///         If the component produces stream data (like a Media Source
	///         or a demultiplexer), it should pay attention
	///         to the fThin argument and return MF_E_THINNING_UNSUPPORTED
	///         if it cannot thin the stream.
	///         If the component processes or receives a stream (like
	///         most transforms or Media Sinks), it may ignore this
	///         parameter if it does not care whether the stream is thinned.
	///         In the Media Session's implementation of rate support,
	///         if the transforms do not explicitly support reverse playback,
	///         the Media Session will attempt to do reverse playback in
	///         thinned mode (but will not do so unthinned).
	///         Therefore, most applications will set fThin to TRUE
	///         when using the Media Session for reverse playback.
	///     </para>
	/// </remarks>
	HRESULT GetFastestRate(
		[in]  MFRATE_DIRECTION eDirection,
		[in]  BOOL fThin,
		[out] float* pflRate
	);

	/// <summary>
	///     Queries whether a rate is supported by the component.
	/// </summary>
	/// <param name="fThin">
	///     If TRUE, then the query concerns support of a thinned stream
	///     at the flRate.
	///     If FALSE, then the query concerns an unthinned stream.
	/// </param>
	/// <param name="flRate">
	///     Rate for which support is being queried
	/// </param>
	/// <param name="pflNearestSupportedRate">
	///     Optional; may be NULL.
	///     If non-NULL and flRate is unsupported, the value returned
	///     should be the nearest rate that is supported (in the same direction
	///     of flRate) given the value specified for fThin.
	///     (In the success case, it will be set to flRate.)
	///     This return value is useful for components that support
	///     several discrete rates.
	///     If there are supported rates on either side of flRate,
	///     then whichever is closer to flRate is the one that is returned.
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_UNSUPPORTED_RATE:
	///         Rate is not supported
	///     </para>
	///     <para>
	///         MF_E_REVERSE_UNSUPPORTED
	///         Returned by components that do not support reverse
	///         playback when fForwardPlayback is FALSE.
	///     </para>
	///     <para>
	///         MF_E_THINNING_UNSUPPORTED
	///         Returned by components that cannot thin streams or handle
	///         thinned streams when fThin is TRUE.
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         The Media Foundation pipeline will pay attention to the
	///         value returned in pflNearestSupportedRate for Media Sources
	///         only; this value will be ignored coming from Transforms
	///         or Media Sinks.
	///     </para>
	///     <para>
	///         "Thinning" is defined in a format-specific manner.
	///         For some formats (such as ASF), thinning will mean dropping
	///         all frames that are not I-frames.
	///         If the component produces stream data (like a Media Source
	///         or a demultiplexer), it should pay attention
	///         to the fThin argument and return MF_E_THINNING_UNSUPPORTED
	///         if it cannot thin the stream.
	///         If the component processes or receives a stream (like
	///         most transforms or Media Sinks), it may ignore this
	///         parameter if it does not care whether the stream is thinned.
	///         In the Media Session's implementation of rate support,
	///         if the transforms do not explicitly support reverse playback,
	///         the Media Session will attempt to do reverse playback in
	///         thinned mode (but will not do so unthinned).
	///         Therefore, most applications will set fThin to TRUE
	///         when using the Media Session for reverse playback.
	///     </para>
	/// </remarks>
	HRESULT IsRateSupported(
		[in]  BOOL fThin,
		[in]  float flRate,
		[in, out] float* pflNearestSupportedRate
	);

};
/// <summary>
///     IMFRateControl is used to notify components of a rate change.
///     This interface is obtained from the component via
///     IMFGetService::GetService using the MF_RATE_CONTROL_SERVICE
///     service GUID.
///     The Media Session provides IMFRateControl.
///     Media Sources and Transforms may provide IMFRateControl.
///     If they do, they will be notified of rate changes.
///     Media Sinks should not provide IMFRateControl; instead, they
///     will be notified of rate changes via IMFClockStateSink::OnClockSetRate.
/// </summary>
[
	odl,
	uuid(88ddcd21-03c3-4275-91ed-55ee3929328f)
]

interface IMFRateControl : stdole.IUnknown
{
	/// <summary>
	///     Sets the rate on the component.
	/// </summary>
	/// <param name="fThin">
	///     A value of TRUE means that the stream will be thinned.
	///     For Media Sources and demultiplexers, this is an indication
	///     that the component should thin the stream.
	///     For downstream Transforms, this is an indication that
	///     the stream will be thinned.
	///     A value of FALSE means that the stream is not to be thinned.
	/// <param name="flRate">
	///     New rate
	/// </param>
	/// <returns>
	///     <para>
	///         MF_E_UNSUPPORTED_RATE_TRANSITION:
	///         The component cannot transition from the current rate
	///         to flRate while in the playing state.
	///     </para>
	///     <para>
	///         MF_E_UNSUPPORTED_RATE:
	///         flRate is not supported
	///     </para>
	///     <para>
	///         MF_E_REVERSE_UNSUPPORTED:
	///         Reverse rates are unsupported
	///     </para>
	///     <para>
	///         MF_E_THINNING_UNSUPPORTED
	///         Returned by components that cannot thin streams or handle
	///         thinned streams when fThin is TRUE.
	///     </para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         SetRate may fail with MF_E_UNSUPPORTED_RATE even though
	///         a previous call to IMFRateSupport::IsRateSupported
	///         succeeded for that rate.  This is because components
	///         can dynamically change which rates are supported.
	///     </para>
	///     <para>
	///         SetRate is an asynchronous call for the Media Session
	///         and Media Sources.
	///         How the rate change is completed depends on the component:
	///         <para>
	///             The Media Session will send MESessionRateChanged.
	///         </para>
	///         <para>
	///             Media Sources will send MESourceRateChanged.
	///         </para>
	///         <para>
	///             The Presentation Clock will notify all subscribed
	///             clock state sinks via IMFClockStateSinks::OnClockSetRate,
	///             and the Stream Sinks should send the
	///             MEStreamSinkRateChanged event.
	///         </para>
	///     </para>
	///     <para>
	///         If SetRate is called on an object that is in the running state,
	///         the rate change should proceed as soon as possible.
	///         If SetRate is called on an object that is in a non-running
	///         state, the new rate should be used next time the component
	///         enters the running state.
	///     </para>
	///     <para>
	///         "Thinning" is defined in a format-specific manner.
	///         For some formats (such as ASF), thinning will mean dropping
	///         all frames that are not I-frames.
	///         If the component produces stream data (like a Media Source
	///         or a demultiplexer), it should pay attention
	///         to the fThin argument and return MF_E_THINNING_UNSUPPORTED
	///         if it cannot thin the stream.
	///         If the component processes or receives a stream (like
	///         most transforms or Media Sinks), it may ignore this
	///         parameter if it does not care whether the stream is thinned.
	///         In the Media Session's implementation of rate support,
	///         if the transforms do not explicitly support reverse playback,
	///         the Media Session will attempt to do reverse playback in
	///         thinned mode (but will not do so unthinned).
	///         Therefore, most applications will set fThin to TRUE
	///         when using the Media Session for reverse playback.
	///     </para>
	/// </remarks>
	HRESULT SetRate(
		[in]    BOOL fThin,
		[in]    float flRate
	);

	/// <summary>
	///     Queries the component's current rate
	/// </summary>
	/// <param name="pfThin">
	///     Optional; may be NULL.
	///     Pointer to a variable whose value will indicate whether
	///     the stream is being thinned.
	///     Implementations that do not understand thinning should set
	///     this value to FALSE.
	/// </param>
	/// <param name="pflRate">
	///     Pointer to a variable to receive the current rate
	/// </param>
	HRESULT GetRate(
		[in, out]   BOOL* pfThin,
		[in, out]   float* pflRate
	);
};

[
	odl,
	uuid(ab9d8661-f7e8-4ef4-9861-89f334f94e74)
]
/// <summary>
///     IMFTimecodeTranslate interface is used to convert SMPTE timecodes to and from hundered nanoseconds units.
/// </summary>
interface IMFTimecodeTranslate : stdole.IUnknown
{
	/// <summary>
	///     Converts SMPTE Timecode to hunderd nanoseconds
	/// </summary>
	HRESULT BeginConvertTimecodeToHNS(
		[in] VARIANT* pPropVarTimecode,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState
	);

	HRESULT EndConvertTimecodeToHNS(
		[in] IMFAsyncResult* pResult,
		[out] MFTIME* phnsTime
	);

	HRESULT BeginConvertHNSToTimecode(
		[in] MFTIME hnsTime,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState
	);

	HRESULT EndConvertHNSToTimecode(
		[in] IMFAsyncResult* pResult,
		[out] VARIANT* pPropVarTimecode
	);
};
/// <summary>
///     A Media Source container plugin implements this interface
///     in order to demux raw multimedia data into media samples
///     pertaining to one or more media streams.
/// </summary>
/// <remarks>
///     A Media Source container plugin is required to implement
///     this interface.
/// </remarks>
[
	odl,
	uuid(26AFEA53-D9ED-42B5-AB80-E64F9EE34779)
]

interface IMFSeekInfo : stdole.IUnknown{
	/// <summary>
	///     For a given seek position, find the two nearest key frames
	/// </summary>
	/// <param name="pguidTimeFormat">
	///     Pointer to a GUID that specifies the time format.
	///     This can be GUID_NULL, in which case the time
	///     format is in 100-nanosecond units.
	/// </param>
	/// <param name="pvarStartPosition">
	///     Specifies the start position.  The units for this parameter
	///     are indicated by the time format given in pguidTimeFormat.
	/// </param>
	/// <param name="pvarPreviousKeyFrame">
	///     Receives previous key frame information. The units for this parameter
	///     are indicated by the time format given in pguidTimeFormat.
	/// </param>
	/// <param name="pvarNextKeyFrame">
	///     Receives next key frame information. The units for this parameter
	///     are indicated by the time format given in pguidTimeFormat.
	/// </param>
	HRESULT GetNearestKeyFrames(
		[in] GUID * pguidTimeFormat,
		[in] VARIANT * pvarStartPosition,
		[out] VARIANT * pvarPreviousKeyFrame,
		[out] VARIANT * pvarNextKeyFrame
	);
};
/// <summary>
///     This interface is used to set the application's session audio volume through Media Foundation.
///     It can be obtained via IMFGetService.
/// </summary>

[
	odl,
	uuid(089EDF13-CF71-4338-8D13-9E569DBDC319)
]

interface IMFSimpleAudioVolume : stdole.IUnknown
{
	HRESULT SetMasterVolume(
		[in] float fLevel
	);

	HRESULT GetMasterVolume(
		[out] float* pfLevel
	);

	HRESULT SetMute(
		[in] BOOL bMute
	);

	HRESULT GetMute(
		[out] BOOL* pbMute
	);
};
/// <summary>
///     This interface is used to set the stream audio volume through Media Foundation.
///     The IMFSimpleAudioVolume is the recommended way for Media Foundation applications
///     to control audio volume; however, this volume interface is provided for special cases
///     where an application needs to control the volume of an individual audio stream without
///     affecting the overall application volume.
///     It is implemented on the Streaming Audio Renderer sink (SAR) and is obtained via IMFGetService.
/// </summary>
[
	odl,
	uuid(76B1BBDB-4EC8-4f36-B106-70A9316DF593)
]

interface IMFAudioStreamVolume : stdole.IUnknown
{
	HRESULT GetChannelCount(
		[out] UINT32 * pdwCount
	);

	HRESULT SetChannelVolume(
		[in] UINT32 dwIndex,
		[in] float fLevel
	);

	HRESULT GetChannelVolume(
		[in] UINT32 dwIndex,
		[out] float* pfLevel
	);

	HRESULT SetAllVolumes(
		[in] UINT32 dwCount,
		[in] float* pfVolumes
	);

	HRESULT GetAllVolumes(
		[in] UINT32 dwCount,
		[out] float* pfVolumes
	);
};

[
	odl,
	uuid(a0638c2b-6465-4395-9ae7-a321a9fd2856)
]
/// <summary>
///     This interface is used to set the audio policy through Media Foundation.
///     It can be obtained via IMFGetService.
/// </summary>
interface IMFAudioPolicy : stdole.IUnknown
{
	HRESULT SetGroupingParam(
		[in] REFGUID rguidClass
	);
	HRESULT GetGroupingParam(
		[out] GUID* pguidClass
	);
	HRESULT SetDisplayName(
		[in] LongPtr pszName
	);
	HRESULT GetDisplayName(
		[out] LongPtr* pszName
	);
	HRESULT SetIconPath(
		[in] LongPtr pszPath
	);
	HRESULT GetIconPath(
		[out] LongPtr* pszPath
	);
};

[
	odl,
	uuid(8C7B80BF-EE42-4b59-B1DF-55668E1BDCA8)
]
interface IMFSampleGrabberSinkCallback : stdole.IUnknown
{
	HRESULT OnClockStart(
		[in] MFTIME hnsSystemTime,
		[in] LONGLONG llClockStartOffset
	);

	HRESULT OnClockStop(
		[in] MFTIME hnsSystemTime
	);

	HRESULT OnClockPause(
		[in] MFTIME hnsSystemTime
	);

	HRESULT OnClockRestart(
		[in] MFTIME hnsSystemTime
	);

	HRESULT OnClockSetRate(
		[in] MFTIME hnsSystemTime,
		[in] float flRate
	);


	//
	// Presentation Clock Setting
	//
	HRESULT OnSetPresentationClock(
		[in] IMFPresentationClock* pPresentationClock
	);

	//
	// Process Sample
	//
	HRESULT OnProcessSample(
		[in] REFGUID guidMajorMediaType,
		[in] DWORD dwSampleFlags,
		[in] LONGLONG llSampleTime,
		[in] LONGLONG llSampleDuration,
		[in] BYTE* pSampleBuffer,
		[in] DWORD dwSampleSize
	);

	//
	// Shutdown
	//
	HRESULT OnShutdown();
}

///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(ca86aa50-c46e-429e-ab27-16d6ac6844cb)
]
/// <summary>
///     The IMFSampleGrabberSinkCallback2 is used by the MF SampleGrabberSink to deliver samples to the implementer of this interface.
/// </summary>
/// <remarks>
///     Since this interface inherits from IMFSampleGrabberSinkCallback, the SampleGrabberSink (SGS) will attempt to QI for the IMFSampleGrabberSinkCallback2 interface.
///     If it finds the IMFSampleGrabberSinkCallback2 interface, then the SGS will ONLY deliver samples via the IMFSampleGrabberSinkCallback2::OnProcessSampleEx(...) method
///     and never use the IMFSampleGrabberSinkCallback::OnProcessSample(...) method.  However, if the callback object used to create the SGS only implements the
///     IMFSampleGrabberSinkCallback interface, then the SGS will naturally use the IMFSampleGrabberSinkCallback::OnProcessSample(...) to deliver the samples.
/// </remarks>
interface IMFSampleGrabberSinkCallback2 : stdole.IUnknown // IMFSampleGrabberSinkCallback
{
	HRESULT OnClockStart(
		[in] MFTIME hnsSystemTime,
		[in] LONGLONG llClockStartOffset
	);

	HRESULT OnClockStop(
		[in] MFTIME hnsSystemTime
	);

	HRESULT OnClockPause(
		[in] MFTIME hnsSystemTime
	);

	HRESULT OnClockRestart(
		[in] MFTIME hnsSystemTime
	);

	HRESULT OnClockSetRate(
		[in] MFTIME hnsSystemTime,
		[in] float flRate
	);


	//
	// Presentation Clock Setting
	//
	HRESULT OnSetPresentationClock(
		[in] IMFPresentationClock* pPresentationClock
	);

	//
	// Process Sample
	//
	HRESULT OnProcessSample(
		[in] REFGUID guidMajorMediaType,
		[in] DWORD dwSampleFlags,
		[in] LONGLONG llSampleTime,
		[in] LONGLONG llSampleDuration,
		[in] BYTE* pSampleBuffer,
		[in] DWORD dwSampleSize
	);

	//
	// Shutdown
	//
	HRESULT OnShutdown();
	/// <summary>
	///     The OnProcessSampleEx method is called by the SampleGrabberSink to deliver samples.
	/// </summary>
	/// <param name=guidMajorMediaType>
	///     The major GUID type of the sample being delivered
	/// </param>
	/// <param name=dwSampleFlags>
	///     The sample flags of the sample being delivered
	/// </param>
	/// <param name=llSampleTime>
	///     The timestamp in HNS units of the sample being delivered
	/// </param>
	/// <param name=llSampleDuration>
	///     The duration in HNS units of the sample being delivered
	/// </param>
	/// <param name=pSampleBuffer>
	///     A byte pointer to the sample data
	/// </param>
	/// <param name=dwSampleSize>
	///     The size in bytes of the data pointed to by the pSampleBuffer argument.
	/// </param>
	/// <param name=pAttributes>
	///     IMFAttributes pointer that allows the retrieval of the sample attributes
	/// </param>
	HRESULT OnProcessSampleEx(
		[in] REFGUID guidMajorMediaType,
		[in] DWORD dwSampleFlags,
		[in] LONGLONG llSampleTime,
		[in] LONGLONG llSampleDuration,
		[in] BYTE* pSampleBuffer,
		[in] DWORD dwSampleSize,
		[in] IMFAttributes* pAttributes
	);

};

[
	odl,
	uuid(35FE1BB8-A3A9-40fe-BBEC-EB569C9CCCA3),
]
/// <summary>
///     The IMFWorkQueueServices can be obtained from the session by querying
///     for the MF_WORKQUEUE_SERVICES service
/// </summary>
/// <remarks>
///     This interface allows applications to control
///     both platform and topology workqueues
/// </remarks>
interface IMFWorkQueueServices : stdole.IUnknown
{
	/// <summary>
	///     The BeginRegisterTopologyWorkQueuesWithMMCSS method parses
	///     the topology nodes and registers the assigned workqueues
	///     with the appropriate MMCSS classes
	/// </summary>
	/// <param name=pCallback>
	///     Standard callback used for async operations in MF
	/// </param>
	/// <param name=pState>
	///     Standard state used for async operations in MF
	/// </param>
	//[local]
	HRESULT BeginRegisterTopologyWorkQueuesWithMMCSS(
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* pState);

	//[call_as(BeginRegisterTopologyWorkQueuesWithMMCSS)]
	//HRESULT RemoteBeginRegisterTopologyWorkQueuesWithMMCSS(
	//	[in] IMFRemoteAsyncCallback* pCallback);

	/// <summary>
	///     The EndRegisterTopologyWorkQueuesWithMMCSS method is called
	///     by the application when all the WorkQueues of the current topology
	///     have been registered with MMCSS
	/// </summary>
	/// <param name=pResult>
	///     Standard result passed to end MF async operations
	/// </param>
	//[local]
	HRESULT EndRegisterTopologyWorkQueuesWithMMCSS(
		[in] IMFAsyncResult* pResult);

	//[call_as(EndRegisterTopologyWorkQueuesWithMMCSS)]
	//HRESULT RemoteEndRegisterTopologyWorkQueuesWithMMCSS(
	//	[in] stdole.IUnknown* pResult);


	/// <summary>
	///     The BeginUnregisterTopologyWorkQueuesWithMMCSS method unregisters
	///     the assigned workqueues from MMCSS
	/// </summary>
	/// <param name=pCallback>
	///     Standard callback used for async operations in MF
	/// </param>
	/// <param name=pState>
	///     Standard state used for async operations in MF
	/// </param>
	//[local]
	HRESULT BeginUnregisterTopologyWorkQueuesWithMMCSS(
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* pState);

	//[call_as(BeginUnregisterTopologyWorkQueuesWithMMCSS)]
	//HRESULT RemoteBeginUnregisterTopologyWorkQueuesWithMMCSS(
	//	[in] IMFRemoteAsyncCallback* pCallback);


	/// <summary>
	///     The EndUnregisterTopologyWorkQueuesWithMMCSS method is called
	///     by the application when all the WorkQueues of the current topology
	///     have been unregistered from MMCSS
	/// </summary>
	/// <param name=pResult>
	///     Standard result passed to end MF async operations
	/// </param>
	HRESULT EndUnregisterTopologyWorkQueuesWithMMCSS(
		[in] IMFAsyncResult* pResult);

	//[call_as(EndUnregisterTopologyWorkQueuesWithMMCSS)]
	//HRESULT RemoteEndUnregisterTopologyWorkQueuesWithMMCSS(
	//	[in] stdole.IUnknown* pResult);

	/// <summary>
	///     Retrieves the MMCSS class string associated with
	///     the given topology workqueue
	/// </summary>
	/// <param name=dwTopologyWorkQueueId>
	///     Topology workqueue id for which the info will be returned
	/// </param>
	/// <param name=pwszClass>
	///     Pointer to an array of WCHARs allocated by the caller
	/// </param>
	/// <param name=pcchClass>
	///     Size, in number of characters, of the pwszClass array
	/// </param>
	HRESULT GetTopologyWorkQueueMMCSSClass(
		[in] DWORD dwTopologyWorkQueueId,
		[out] LongPtr* pwszClass,
		[in, out] DWORD* pcchClass);

	/// <summary>
	///     Retrieves the MMCSS class string associated with
	///     the given topology workqueue
	/// </summary>
	/// <param name=dwTopologyWorkQueueId>
	///     Topology workqueue id for which the info will be returned
	/// </param>
	/// <param name=pdwTaskId>
	///     Pointer to a buffer allocated by the caller
	///     The workqueue's MMCSS task id will be filled in
	/// </param>
	HRESULT GetTopologyWorkQueueMMCSSTaskId(
		[in] DWORD dwTopologyWorkQueueId,
		[out] DWORD* pdwTaskId);

	/// <summary>
	///     The BeginRegisterPlatformWorkQueueWithMMCSS method registers
	///     the specified platform workqueue with MMCSS using the specified
	///     class and taskId
	/// </summary>
	/// <param name=dwPlatformWorkQueue>
	///     The id of one of the standard platform workqueues
	/// </param>
	/// <param name=wszClass>
	///     The MMCSS class which the workqueue should be registered with
	/// </param>
	/// <param name=dwTaskId>
	///     The task id which the workqueue should be registered to
	///     If dwTaskId is 0, new MMCSS bucket will be created
	/// </param>
	/// <param name=pCallback>
	///     Standard callback used for async operations in MF
	/// </param>
	/// <param name=pState>
	///     Standard state used for async operations in MF
	/// </param>
	HRESULT BeginRegisterPlatformWorkQueueWithMMCSS(
		[in] DWORD dwPlatformWorkQueue,
		[in] LongPtr wszClass,
		[in] DWORD dwTaskId,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* pState);


	/// <summary>
	///     The EndRegisterPlatformWorkQueueWithMMCSS method should be called
	///     by the application when the platform workqueue has been registered with MMCSS
	/// </summary>
	/// <param name=pResult>
	///     Standard result passed to end MF async operations
	/// </param>
	/// <param name=pdwTaskId>
	///     This buffer will be filled with the TaskId of the specified workqueue
	/// </param>
	HRESULT EndRegisterPlatformWorkQueueWithMMCSS(
		[in] IMFAsyncResult* pResult,
		[out] DWORD* pdwTaskId);


	/// <summary>
	///     The BeginUnregisterPlatformWorkQueueWithMMCSS method unregisters
	///     the specified platform workqueue from MMCSS
	/// </summary>
	/// <param name=dwPlatformWorkQueue>
	///     The id of one of the standard platform workqueues
	/// </param>
	/// <param name=pCallback>
	///     Standard callback used for async operations in MF
	/// </param>
	/// <param name=pState>
	///     Standard state used for async operations in MF
	/// </param>
	HRESULT BeginUnregisterPlatformWorkQueueWithMMCSS(
		[in] DWORD dwPlatformWorkQueue,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* pState);


	/// <summary>
	///     The EndUnregisterPlatformWorkQueueWithMMCSS method should be called
	///     by the application when the platform workqueue has been unregistered from MMCSS
	/// </summary>
	/// <param name=pResult>
	///     Standard result passed to end MF async operations
	/// </param>
	HRESULT EndUnregisterPlatformWorkQueueWithMMCSS(
		[in] IMFAsyncResult* pResult);
	/// <summary>
	///     Retrieves the MMCSS class string associated with
	///     the given platform workqueue
	/// </summary>
	/// <param name=dwPlatformWorkQueueId>
	///     Topology workqueue id for which the info will be returned
	/// </param>
	/// <param name=pwszClass>
	///     Pointer to an array of WCHARs allocated by the caller
	/// </param>
	/// <param name=pcchClass>
	///     Size, in number of characters, of the pwszClass array
	/// </param>
	HRESULT GetPlaftormWorkQueueMMCSSClass(
		[in] DWORD dwPlatformWorkQueueId,
		[out] LongPtr* pwszClass,
		[in, out] DWORD* pcchClass);

	/// <summary>
	///     Retrieves the MMCSS class string associated with
	///     the given platform workqueue
	/// </summary>
	/// <param name=dwPlatformWorkQueueId>
	///     Topology workqueue id for which the info will be returned
	/// </param>
	/// <param name=pdwTaskId>
	///     Pointer to a buffer allocated by the caller
	///     The workqueue's MMCSS task id will be filled in
	/// </param>
	HRESULT GetPlatformWorkQueueMMCSSTaskId(
		[in] DWORD dwPlatformWorkQueueId,
		[out] DWORD* pdwTaskId);
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/// <summary>
///     The IMFWorkQueueServices can be obtained from the session by querying
///     for the MF_WORKQUEUE_SERVICES service
/// </summary>
/// <remarks>
///     This interface allows applications to control
///     both platform and topology workqueues
/// </remarks>
[
	odl,
	uuid(96bf961b-40fe-42f1-ba9d-320238b49700)
]

interface IMFWorkQueueServicesEx : IMFWorkQueueServices
{
	/// <summary>
	///     Retrieves the MMCSS class string associated with
	///     the given topology workqueue
	/// </summary>
	/// <param name=dwTopologyWorkQueueId>
	///     Topology workqueue id for which the info will be returned
	/// </param>
	/// <param name=pdwTaskId>
	///     Pointer to a buffer allocated by the caller
	///     The workqueue's MMCSS task id will be filled in
	/// </param>
	HRESULT GetTopologyWorkQueueMMCSSPriority(
		[in] DWORD dwTopologyWorkQueueId,
		[out] LONG* plPriority);

	/// <summary>
	///     The BeginRegisterPlatformWorkQueueWithMMCSS method registers
	///     the specified platform workqueue with MMCSS using the specified
	///     class and taskId
	/// </summary>
	/// <param name=dwPlatformWorkQueue>
	///     The id of one of the standard platform workqueues
	/// </param>
	/// <param name=wszClass>
	///     The MMCSS class which the workqueue should be registered with
	/// </param>
	/// <param name=dwTaskId>
	///     The task id which the workqueue should be registered to
	///     If dwTaskId is 0, new MMCSS bucket will be created
	/// </param>
	/// <param name=pCallback>
	///     Standard callback used for async operations in MF
	/// </param>
	/// <param name=pState>
	///     Standard state used for async operations in MF
	/// </param>
	//[local]
	HRESULT BeginRegisterPlatformWorkQueueWithMMCSSEx(
		[in] DWORD dwPlatformWorkQueue,
		[in] LongPtr wszClass,
		[in] DWORD dwTaskId,
		[in] LONG lPriority,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* pState);

	//[call_as(BeginRegisterPlatformWorkQueueWithMMCSSEx)]
	//HRESULT RemoteBeginRegisterPlatformWorkQueueWithMMCSSEx(
	//	[in] DWORD dwPlatformWorkQueue,
	//	[in] LongPtr wszClass,
	//	[in] DWORD dwTaskId,
	//	[in] LONG lPriority,
	//	[in] IMFRemoteAsyncCallback* pCallback);

	/// <summary>
	///     Retrieves the MMCSS class string associated with
	///     the given platform workqueue
	/// </summary>
	/// <param name=dwPlatformWorkQueueId>
	///     Topology workqueue id for which the info will be returned
	/// </param>
	/// <param name=pdwTaskId>
	///     Pointer to a buffer allocated by the caller
	///     The workqueue's MMCSS task id will be filled in
	/// </param>
	HRESULT GetPlatformWorkQueueMMCSSPriority(
		[in] DWORD dwPlatformWorkQueueId,
		[out] LONG* plPriority);
};

typedef enum MF_QUALITY_DROP_MODE
{
	MF_DROP_MODE_NONE = 0x0,
	MF_DROP_MODE_1 = 0x1,
	MF_DROP_MODE_2 = 0x2,
	MF_DROP_MODE_3 = 0x3,
	MF_DROP_MODE_4 = 0x4,
	MF_DROP_MODE_5 = 0x5,
	MF_NUM_DROP_MODES = 0x6 // Helper value, indicates the # of drop modes supported.
} MF_QUALITY_DROP_MODE;


typedef enum MF_QUALITY_LEVEL
{
	MF_QUALITY_NORMAL = 0x0,
	MF_QUALITY_NORMAL_MINUS_1 = 0x1,
	MF_QUALITY_NORMAL_MINUS_2 = 0x2,
	MF_QUALITY_NORMAL_MINUS_3 = 0x3,
	MF_QUALITY_NORMAL_MINUS_4 = 0x4,
	MF_QUALITY_NORMAL_MINUS_5 = 0x5,
	MF_NUM_QUALITY_LEVELS = 0x6 // Helper value, indicates the # of quality levels supported.
} MF_QUALITY_LEVEL;

typedef enum MF_QUALITY_ADVISE_FLAGS
{
	MF_QUALITY_CANNOT_KEEP_UP = 0x1,
} MF_QUALITY_ADVISE_FLAGS;

///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(8D009D86-5B9F-4115-B1FC-9F80D52AB8AB)
]
interface IMFQualityManager : stdole.IUnknown
{

	/// <summary>
	///     The NotifyTopology method is called by the media processor to
	//      pass to the QM the topology that its about to use.
	/// </summary>
	/// <param name="pTopology">
	///     Pointer to the topology about to be used by Media Processor.
	///     Pass in NULL to inform the quality manager to release
	///     references to the topology.
	/// </param>
	HRESULT NotifyTopology([in] IMFTopology* pTopology);

	/// <summary>
	///     The NotifyPresentationClock method is called by the
	///     media processor to pass QM the presentation clock for the
	///     current presentation.
	/// </summary>
	/// <param name="pClock">
	///     Pointer to the clock that will be used for the current
	///     presentation. Pass in NULL to inform the quality manager
	///     to release references to the clock.
	/// </param>
	/// <remarks>
	///     The quality manager may subscribe to the clock to be informed
	///     of state changes, as well as the direction of playback
	///     (forward or reverse) and the rate.
	/// </remarks>
	HRESULT NotifyPresentationClock([in] IMFPresentationClock* pClock);

	/// <summary>
	///     The NotifyProcessInput method is called when the media proc is
	///     about to deliver a sample to a component
	/// </summary>
	/// <param name=pNode>
	///     Pointer to the node media processor is about to deliver data to.
	/// </param>
	/// <param name=lInputIndex>
	///     The index of the input on the node data is being fed to.
	/// </param>
	/// <param name=pSample>
	///     Pointer to the sample about to be fed into the topology node.
	/// </param>
	/// <remarks>
	///     This method is called for every sample passing through every
	///     component.  To avoid increasing the steady state latency too much,
	///     it needs to be as quick as possible.
	/// </remarks>
	HRESULT NotifyProcessInput(
		[in] IMFTopologyNode* pNode,
		[in] long lInputIndex,
		[in] IMFSample* pSample
	);

	/// <summary>
	///     The NotifyProcessOutput method is called when the media proc
	///     receives a sample from a component
	/// </summary>
	/// <param name=pNode>
	///     Pointer to the node the media processor has received data from.
	/// </param>
	/// <param name=lOutputIndex>
	///     The index of the output on the node data was produced from.
	/// </param>
	/// <param name=pSample>
	///     Pointer to the sample that was produced by the topology node.
	/// </param>
	/// <remarks>
	///     This method is called for every sample passing through every
	///     component.  To avoid increasing the steady state latency too much,
	///     it needs to be as quick as possible.
	/// </remarks>
	HRESULT NotifyProcessOutput(
		[in] IMFTopologyNode* pNode,
		[in] long lOutputIndex,
		[in] IMFSample* pSample
	);

	/// <summary>
	///     This callback is made to the Quality manager by the pipeline in
	///     response to the MEQualityNotify event.
	/// </summary>
	/// <param name=pObject>
	///     Pointer to the Object from which the notification is coming in.
	///     This is not the topo node. In case of MFTs this will be the MFT
	///     specifed on the toponode. In the case of sinks this will be the
	///     Media sink object itself.
	/// </param>
	/// <param name=pEvent>
	///     The event pointer.
	/// </param>
	/// <remarks>
	///     See data on the MEQualityNotify
	/// </remarks>
	HRESULT NotifyQualityEvent(
		[in] stdole.IUnknown* pObject,
		[in] IMFMediaEvent* pEvent);

	/// <summary>
	///     Called when the session is being shutdown
	/// </summary>
	/// <remarks>
	///     Releases references on pipeline components.
	/// </remarks>
	HRESULT Shutdown();
};
/// <summary>
///     Implemented by a component which can respond to quality adjustment requests from the Quality Manager.
/// </summary>
[
	odl,
	uuid(EC15E2E9-E36B-4f7c-8758-77D452EF4CE7)
]
interface IMFQualityAdvise : stdole.IUnknown
{
	/// <param name="eDropMode">
	///     The Quality Manager can request the component to go into a
	///     particular drop mode. The component can define what it wants to do
	///     for each drop level. See remarks section for some examples. MF
	///     defines 6 drop modes: MF_DROP_MODE_NONE, MF_DROP_MODE_1,
	///     MF_DROP_MODE_2, ... MF_DROP_MODE_5
	/// </param>
	/// <remarks>
	///     As an example, consider a video decoder which supports 3 drop modes.
	///     For example, if the content has 3 B-frames between each pair of
	///     P-frames, the decoder might decide the following 3 drop modes:
	///     -- Drop 1 B-frame for every 2 B-frames
	///     -- Drop every alternate B-frame
	///     -- Drop P-frames and go to key frame only mode
	///
	///     If the quality of playback is not improving over time the Quality Manager
	///     might make the following calls to this video decoder:
	///     -- SetDropMode( MF_DROP_MODE_NONE ). The decoder returns S_OK
	///         and knows that it should decode all samples.
	///     -- SetDropMode( MF_DROP_MODE_1 ). The decoder returns S_OK and
	///         starts dropping 1 B-frame for every 2 B-frames.
	///     -- SetDropMode( MF_DROP_MODE_2 ). The decoder returns S_OK and
	///         starts dropping every alternate B-frame
	///     -- SetDropMode( MF_DROP_MODE_3).
	///     -- SetDropMode( MF_DROP_MODE_4). The decoder returns
	///         MF_E_NO_MORE_DROP_MODES and start dropping P-frames. The
	///         special return code tells the Quality Manager that there the
	///         maximum drop mode is reached. The Quality Manager will not call
	///         SetDropMode( MF_DROP_MODE_4) on this component.
	/// </remarks>
	///  <returns>
	///     If the method succeeds it returns S_OK. If the component has
	///     reached its highest level of drop mode it should return
	///     MF_E_NO_MORE_DROP_MODES. This indicates to the Quality Manager
	///     that it cannot request any more drop modes from this component.
	///  </returns>
	HRESULT SetDropMode(
		[in] MF_QUALITY_DROP_MODE eDropMode);

	/// <param name="eQualityLevel">
	///     The Quality Manager can request the component to reduce its output
	///     to a particular quality level. The component can define what it wants
	///     to do for each quality level. See remarks section for some examples.
	///     MF defines 6 quality levels: MF_QUALITY_NORMAL,
	///     MF_QUALITY_NORMAL_MINUS_1, MF_QUALITY_NORMAL_MINUS_2,
	///     ... MF_QUALITY_NORMAL_MINUS_5.
	/// </param>
	/// <remarks>
	///     As an example, consider a video decoder which has 4 steps in
	///     post-processing of the decoded video. This decoder can drop these
	///     post-processing steps to produce frames faster even though they are
	///     at a lower quality.
	///     If the quality of playback is not improving over time the QM might
	///     make the following calls to this video decoder:
	///     -- SetQualityLevel(MF_QUALITY_NORMAL). The decoder returns S_OK
	///         and knows that it should use all the normal post processing steps.
	///     -- SetQualityLevel (MF_QUALITY_NORMAL_MINUS_1). The decoder
	///         returns S_OK and stops doing one of the post-processing steps.
	///     -- SetQualityLevel (MF_QUALITY_NORMAL_MINUS_2). The decoder
	///         returns S_OK and stops doing one of the post-processing steps.
	///     -- ...
	///     -- SetQualityLevel (MF_QUALITY_NORMAL_MINUS_4). The decoder
	///         returns S_OK and stops doing one of the post-processing steps.
	///     -- SetQualityLevel( MF_QUALITY_NORMAL_MINUS_5). The decoder returns
	///         MF_E_NO_MORE_QUALITY_LEVELS. The special return code tells the
	///         Quality Manager that the minimum level of quality has been
	///         reached. The Quality Manager will not call
	///         SetQualityLevel (MF_QUALITY_NORMAL_MINUS_5) on this component.
	/// </remarks>
	///  <returns>
	///     If the method succeeds it returns S_OK. If the component has
	///     reached its lowest level of quality  it should return
	///     MF_E_NO_MORE_QUALITY_LEVELS. This indicates to the
	///     Quality Manager that it cannot request any more quality levels
	///     below the currently requested level.
	///  </returns>
	HRESULT SetQualityLevel(
		[in] MF_QUALITY_LEVEL eQualityLevel);

	/// <param name="peDropMode">
	///     The current Drop mode is returned by the component.
	/// </param>
	//midl_pragma warning(disable: 2495)
		HRESULT GetDropMode(
			[out] MF_QUALITY_DROP_MODE* peDropMode);
	//midl_pragma warning(default: 2495)

		/// <param name="peQualityLevel">
		///     The current quality level is returned by the component.
		/// </param>
		//midl_pragma warning(disable: 2495)
		HRESULT GetQualityLevel(
			[out] MF_QUALITY_LEVEL* peQualityLevel);
	//midl_pragma warning(default: 2495)

		/// <param name="hnsAmountToDrop">
		///     The component should drop samples covering the time interval
		///     hnsDropTime.
		/// </param>
		/// <remarks>
		///     This is to get A/V back in sync once we are already out of sync.
		///     If video is already late by 30 ms, adjusting the quality on the
		///     video will not help. The quality will go down but that does not
		///     mean rendering will catch up. In such a scenario we will ask the
		///     EVR to DropTime( 30 ms ), indicating that it should drop 30 ms
		///     of data to quickly catch up. This functionality might not make
		///     sense for the decoder, the decoder can just return an error
		///     from this call.
		///
		///     If DropTime is called multiple times, the hnsAmountToDrop value is
		///     absolute. The renderer should not add/aggregate the
		///     hnsAmountToDrop value from subsequent calls.
		///
		///	    The caller can give a DropTime value of zero to ask the component
		///	    to come out of its DropTime mode.
		/// </remarks>
		///  <returns>
		///     S_OK on success. MF_E_DROPTIME_NOT_SUPPORTED if the
		///     component does not support drop time.
		///  </returns>
		HRESULT DropTime(
			[in] LONGLONG hnsAmountToDrop);
};

[
	odl,
	uuid(F3706F0D-8EA2-4886-8000-7155E9EC2EAE)
]
/// <summary>
///     Implemented by a component which can respond to quality notifications from the Quality Manager
///     and wants to manage its quality parameters itself
/// </summary>
interface IMFQualityAdvise2 : IMFQualityAdvise
{
	/// <summary>
	///     This callback is made to the component by the Quality manager in
	///     response to the MEQualityNotify event from the sink.
	/// </summary>
	/// <param name=pEvent>
	///     The event pointer.
	/// </param>
	/// <param name=pdwFlags>
	///     Flags specifying the state of the component.
	///     See the enumeration MF_QUALITY_ADVISE_FLAGS.
	/// </param>
	/// <remarks>
	///     See data on the MEQualityNotify
	/// </remarks>
	HRESULT NotifyQualityEvent(
		[in]  IMFMediaEvent* pEvent,
		[out] DWORD* pdwFlags);
};

///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(dfcd8e4d-30b5-4567-acaa-8eb5b7853dc9)
]
interface IMFQualityAdviseLimits : stdole.IUnknown
{
	/// <param name="peDropMode">
	///     The current Drop mode is returned by the component.
	/// </param>
	//midl_pragma warning(disable: 2495)
		HRESULT GetMaximumDropMode(
			[out] MF_QUALITY_DROP_MODE* peDropMode);
	//midl_pragma warning(default: 2495)

		/// <param name="peQualityLevel">
		///     The current quality level is returned by the component.
		/// </param>
		//midl_pragma warning(disable: 2495)
		HRESULT GetMinimumQualityLevel(
			[out] MF_QUALITY_LEVEL* peQualityLevel);
	//midl_pragma warning(default: 2495)
};

[
	odl,
	uuid(2347D60B-3FB5-480c-8803-8DF3ADCD3EF0)
]
/// <summary>
///     Use IMFRealTimeClientEx instead
/// </summary>
interface IMFRealTimeClient : stdole.IUnknown
{
	/// <summary>
	///     This method is called by MF when the RT operations start.
	///     Implementation uses this data for enlisting threads in MMCSS
	/// </summary>
	HRESULT RegisterThreads(
		[in] DWORD dwTaskIndex,
		[in] LongPtr wszClass);

	/// <summary>
	///     This method is called by MF when the RT operations end
	///     Implementation can deregister the threads now
	/// </summary>
	HRESULT UnregisterThreads(void);

	/// <summary>
	///     The application can ask the pipeline to run different branches of the topology
	///     on different work queues. When the pipeline is using private workqueues it will
	///     notify components on that branch about which work queue is being used through this
	///     function.
	/// </summary>
	HRESULT SetWorkQueue(
		[in] DWORD dwWorkQueueId);
};
/// <summary>
///     Implemented by components who spin off new threads and need to enlist
///     these threads in MMCSS in the same group with the rest of MF threads.
/// </summary>
[
	odl,
	uuid(03910848-AB16-4611-B100-17B88AE2F248)
]
interface IMFRealTimeClientEx : stdole.IUnknown
{
	/// <summary>
	///     This method is called by MF when the RT operations start.
	///     Implementation uses this data for enlisting threads in MMCSS
	/// </summary>
	HRESULT RegisterThreadsEx(
		[in, out] DWORD* pdwTaskIndex,
		[in] LongPtr wszClassName,
		[in] LONG lBasePriority);

	/// <summary>
	///     This method is called by MF when the RT operations end
	///     Implementation can deregister the threads now
	/// </summary>
	HRESULT UnregisterThreads(void);

	/// <summary>
	///     The application can ask the pipeline to run different branches of the topology
	///     on different work queues. When the pipeline is using private workqueues it will
	///     notify components on that branch about which work queue is being used through this
	///     function.
	/// </summary>
	HRESULT SetWorkQueueEx(
		[in] DWORD dwMultithreadedWorkQueueId,
		[in] LONG lWorkItemBasePriority);
};

///////////////////////////////////////////////////////////////////////////////
//
// Media Foundation sequence playback interfaces
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

typedef DWORD MFSequencerElementId;


typedef enum MFSequencerTopologyFlags
{
	SequencerTopologyFlags_Last = 0x00000001,
} MFSequencerTopologyFlags;
/// <summary>
///     IMFSequencerSource allows the caller to queue multiple topologies for
///     rendering.
/// </summary>
[
	odl,
	uuid(197CD219-19CB-4de1-A64C-ACF2EDCBE59E)
]

interface IMFSequencerSource : stdole.IUnknown
{
	/// <summary>
	///     AppendTopology adds a topology to the end of the queue of
	///     topologies.
	/// </summary>
	/// <param name="pTopology">
	///     Pointer to the topology to be queued. This pointer can be NULL.
	/// </param>
	/// <param name="dwFlags">
	///     Combination of MFSequencerTopologyFlags.
	/// </param>
	/// <param name="pdwId">
	///     Pointer to a variable to receive the sequencer element ID
	///     that the sequencer assigns to this topology
	/// </param>
	/// <remarks>
	///     Topologies are played by the sequencer in the order in which
	///     they are queued up.
	///     The application indicates that no more topologies will be queued
	///     either by setting the SequencerTopologyFlags_Last flag or
	///     by calling AppendTopology with a NULL pTopology.
	///     It is important to tell the sequencer that there are no more
	///     topologies coming. It uses this information to end playback
	///     in the pipeline.  If the application does not indicate when
	///     there are no more topologies to be queued, the sequencer will
	///     wait for a new topology to be queued up even if it has finished
	///     playing everything it currently has.
	/// </remarks>
	HRESULT AppendTopology(
		[in] IMFTopology* pTopology,
		[in] DWORD dwFlags,
		[out] MFSequencerElementId* pdwId);

	/// <summary>
	///     Deletes topology by ID.
	/// </summary>
	/// <param name="dwId">
	///     Sequencer element ID of the topology to delete
	/// </param>
	HRESULT DeleteTopology(
		[in] MFSequencerElementId dwId);

	/// <summary>
	///     GetPresentationContext maps a Presentation Descriptor to
	///     its associated sequencer element ID and topology.
	/// </summary>
	/// <param name="pPD>
	///     Pointer to the Presentation Descriptor to map
	/// </param>
	/// <param name="pId">
	///     Pointer to a variable that will receive the sequencer element
	///     ID associated with pPD.
	/// </param>
	/// <param name="ppTopology">
	///     Topology associated with this sequencer element
	///     The return value can be NULL if sequencer has already switched to the next presentation
	/// </param>
	///  <returns>
	///     <para> S_OK: On success</para>
	///     <para>
	///         MF_S_SEQUENCER_CONTEXT_CANCELED : For a topology which was cancelled.
	///         A cancelled topology is one which was prerolled but was then discarded because
	///         of a change in the order of playback. When a topology is cancelled the user will
	///         get events from the session when the topology is set, started, ended, etc. but the
	///         topology will not process any data.
	///     </para>
	///  </returns>
	///
	HRESULT GetPresentationContext(
		[in] IMFPresentationDescriptor* pPD,
		[out] MFSequencerElementId* pId,
		[out] IMFTopology** ppTopology);


	/// <summary>
	///     UpdateTopology updates a topology in the queue
	/// </summary>
	/// <param name="dwId">
	///     Sequencer element ID for this topology
	/// </param>
	/// <param name="pTopology">
	///     Updated topology for this sequencer element.
	///     Ignored unless SequencerTopologyMask_Topology is set in dwMask
	/// </param>
	HRESULT UpdateTopology(
		[in] MFSequencerElementId dwId,
		[in] IMFTopology* pTopology);

	/// <summary>
	///     UpdateTopologyFlags updates a topology in the queue
	/// </summary>
	/// <param name="dwId">
	///     Sequencer element ID for this topology
	/// </param>
	/// <param name="dwFlags">
	///     Bitflags defined by MFSequencerTopologyFlags.
	///     Ignored unless SequencerTopologyMask_Flags is set in dwMask
	/// </param>
	HRESULT UpdateTopologyFlags(
		[in] MFSequencerElementId dwId,
		[in] DWORD dwFlags);

};
/// <summary>
///     IMFMediaSourceTopologyProvider is implemented by sequencer sources.
/// </summary>
[
	odl,
	uuid(0E1D6009-C9F3-442d-8C51-A42D2D49452F)
]

interface IMFMediaSourceTopologyProvider : stdole.IUnknown
{
	/// <summary>
	///     Maps an IMFPresentationDescriptor to an IMFTopology for
	///     this Media Source
	/// </summary>
	/// <param name="pPresentationDescriptor">
	///     Presentation Descriptor for which to obtain the topology.
	///     This is generally obtained by obtaining the IMFMediaSource
	///     interface pointer for this source and calling
	///     IMFMediaSource::CreatePresentationDescriptor
	/// </param>
	/// <param name="ppTopology">
	///     Pointer to a variable that will receive the IMFTopology
	///     corresponding to pPresentationDescriptor.
	///     The application should use this topology when it calls
	///     IMFMediaSession::SetTopology.
	/// </param>
	HRESULT GetMediaSourceTopology(
		[in]  IMFPresentationDescriptor* pPresentationDescriptor,
		[out] IMFTopology** ppTopology
	);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/// <summary>
///     IMFMediaSourcePresentationProvider is provided by sequencer sources
///     and is obtained via IMFGetService::GetService
/// </summary>
[
	odl,
	uuid(0E1D600a-C9F3-442d-8C51-A42D2D49452F)
]

interface IMFMediaSourcePresentationProvider : stdole.IUnknown
{
	/// <summary>
	///     The Media Foundation pipeline calls this method to notify the
	///     Media Source that this presentation has hit its markout
	///     (or markin, for reverse playback).
	///     This is needed in the case of markout (markin for reverse)
	///     because the Media Source may not know exactly where it should
	///     end this segment to hit the specified markout.
	/// </summary>
	/// <param name="pPresentationDescriptor">
	///     Presentation Descriptor for the presentation whose end we
	///     have reached
	/// </param>

	HRESULT ForceEndOfPresentation(
		[in]  IMFPresentationDescriptor* pPresentationDescriptor
	);
}

// This structure is used in IMFTopologyNodeAttributeEditor::UpdateNodeAttributes.
// NodeId indicate which node's attributes to update.
//
typedef struct MFTOPONODE_ATTRIBUTE_UPDATE
{
	TOPOID NodeId;
	GUID guidAttributeKey;
	MF_ATTRIBUTE_TYPE attrType;
	CURRENCY uu;
	//[switch_is(attrType)] [switch_type(DWORD)] union
	//{
	//	[case(MF_ATTRIBUTE_UINT32)]

	//	UINT32 u32;

	//	[case(MF_ATTRIBUTE_UINT64)]

	//	UINT64 u64;

	//	[case(MF_ATTRIBUTE_DOUBLE)]

	//	double d;

	//	[default]
	//	;
	//};
} MFTOPONODE_ATTRIBUTE_UPDATE;

/// <summary>
///     IMFTopologyNodeAttributeEditor interface is exposed by pipeline to allow application to change
///     properties on the toponode objects during playback.
///     In the current implementation, the only supported property is MF_TOPONODE_MEDIASTOP.
///     Pipeline will ignore all other properties
/// </summary>
[
	odl,
	uuid(676aa6dd-238a-410d-bb99-65668d01605a)
]
interface IMFTopologyNodeAttributeEditor : stdole.IUnknown
{
	/// <summary>
	///     UpdateNodeAttributes makes one or more updates to
	///     the attributes on various nodes in the topology
	/// </summary>
	/// <param name="TopoId">
	///     Topology ID of the topology whose nodes' attributes
	///     will be updated
	/// </param>
	/// <param name="cUpdates">
	///     Number of elements in the array pUpdates
	/// </param>
	/// <param name="pUpdates">
	///     Array of size cUpdates of MFSEQUENCER_NODE_ATTRIBUTE_UPDATE structures.
	///     Each element indicates the node and the attribute to update.
	///     IMFAttributes::SetItem will be called using guidAttributeKey
	///     and the PROPVARIANT supplied
	/// </param>
	HRESULT UpdateNodeAttributes(
		[in] TOPOID TopoId,
		[in] DWORD cUpdates,
		[in] MFTOPONODE_ATTRIBUTE_UPDATE* pUpdates);
};
///////////////////////////////////////////////////////////////////////////////
//
// Media Foundation network playback interfaces
//
///////////////////////////////////////////////////////////////////////////////


typedef struct MF_LEAKY_BUCKET_PAIR
{
	DWORD dwBitrate;
	DWORD msBufferWindow;
}
MF_LEAKY_BUCKET_PAIR;

typedef struct MFBYTESTREAM_BUFFERING_PARAMS
{
	/// <member name="cbTotalFileSize">
	///     Total number of bytes in file, or -1 if unknown
	///     Type: QWORD.
	/// </member>
	QWORD cbTotalFileSize;
	/// <member name="cbPlayableDataSize">
	///     Number of bytes in Data Object, or -1 if unknown or N/A
	///     Type: QWORD.
	/// </member>
	QWORD cbPlayableDataSize;
	/// <member name="prgBuckets">
	///     Array of leaky buckets for various bitrates
	///     Type: MF_LEAKY_BUCKET_PAIR.
	/// </member>
	LongPtr prgBuckets;
	/// <member name="cBuckets">
	///     Number of leaky buckets in array
	///     Type: DWORD.
	/// </member>
	DWORD cBuckets;
	/// <member name="qwNetBufferingTime">
	///     Network buffering time to add to any leaky bucket parameters, in 100ns
	///     Type: QWORD.
	/// </member>
	QWORD qwNetBufferingTime;
	/// <member name="qwPlayDuration">
	///     Seek requires downloading the data starting from the Key frame
	///     This specifies the time duration,in 100ns, between the previous key frame
	///     poistion and the seek point.
	///     Type: QWORD.
	/// </member>
	QWORD qwExtraBufferingTimeDuringSeek;
	/// <member name="qwPlayDuration">
	///     Duration of playable portion of file in 100ns, or 0 if unknown
	///     Type: QWORD.
	/// </member>
	QWORD qwPlayDuration;
	/// <member name="dRate">
	///     The rate of the playback
	///     Type: FLOAT.
	/// </member>
	float dRate;
} MFBYTESTREAM_BUFFERING_PARAMS;

/// <summary>
///     The IMFByteStreamBuffering interface is for controlling the buffer on the byte stream
/// </summary>
[
	odl,
	uuid(6d66d782-1d4f-4db7-8c63-cb8c77f1ef5e)
]
interface IMFByteStreamBuffering : stdole.IUnknown
{
	/// <summary>
	///     The SetBufferingParams method is for setting the buffering parameters.
	/// </summary>
	/// <param name=pParams>
	///     The input MFBYTESTREAM_BUFFERING_PARAMS.
	/// </param>
	HRESULT SetBufferingParams(
		[in] MFBYTESTREAM_BUFFERING_PARAMS* pParams
	);

	/// <summary>
	///     The EnableBuffering method is for enabling/disabling the buffering on the byte stream
	/// </summary>
	/// <param name=fEnable>
	///     BOOL flag indicating enable or disable the buffering.
	/// </param>
	HRESULT EnableBuffering(
		[in] BOOL fEnable
	);

	/// <summary>
	///     If the byte stream is currently buffering, invoking this method will cause a MEBufferingStopped
	///     event to be sent immediately, without waiting for the necessary data to be buffered.
	///     Invoking this method while the byte stream is not buffering has no effect.
	/// </summary>
	HRESULT StopBuffering();
};

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
/// <summary>
///     This interface is exposed by byte streams that transfer data from
///     a remote resource to a local cache in the background. It allows the
///     application to have some control over the way the transfer happens.
/// </summary>
[
	odl,
	uuid(F5042EA4-7A96-4a75-AA7B-2BE1EF7F88D5)
]

interface IMFByteStreamCacheControl : stdole.IUnknown
{
	/// <summary>
	///     Instructs the byte stream to stop the background transfer to cache.
	///     The byte stream resumes the transfer the next time the application
	///     reads data.  The transfer is also resumed if buffering is enabled
	///     using IMFByteStreamBuffering::EnableBuffering.
	/// </summary>
	HRESULT StopBackgroundTransfer();
};

/// <summary>
///     The IMFByteStreamTimeSeek interface allows time based seek in
///     byte stream.
/// </summary>
[
	odl,
	uuid(64976BFA-FB61-4041-9069-8C9A5F659BEB)
]

interface IMFByteStreamTimeSeek : stdole.IUnknown
{
	/// <summary>
	///     Verifies if the Byte Stream supports time based seeking.
	/// </summary>
	/// <param name=pfTimeSeekIsSupported>
	///     Pointer to the result of the operation, which will be TRUE if
	///     the Byte Stream supports time based seeking, and FALSE otherwise.
	///     This parameter is optional and the caller can use the HRESULT instead.
	/// </param>
	/// <returns>
	///     <para> S_OK: Time based seeking is supported. </para>
	///     <para> S_FALSE: Time based seeking is not supported. </para>
	/// </returns>
	HRESULT IsTimeSeekSupported(
		[out] BOOL* pfTimeSeekIsSupported
	);

	/// <summary>
	///     Performs a time based seek in the Byte Stream.
	/// </summary>
	/// <param name=qwTimePosition>
	///     Position to seek (in hundreds of nanoseconds).
	/// </param>
	HRESULT TimeSeek(
		[in] QWORD qwTimePosition
	);

	/// <summary>
	///     Retrieves information provided by the remote server in response
	//       to a time based seek.
	//       This method normally cannot be invoked until after some data
	//       has been read from the byte stream, as invoking the TimeSeek
	//       method does not necessarily cause the request to be sent to the
	//       server immediately.
	/// </summary>
	/// <param name=pqwStartTime>
	///     Position that the server seeked to (in hundreds of nanoseconds).
	/// </param>
	/// <param name=pqwStopTime>
	///     Position that the server will stop at (in hundreds of nanoseconds), or 0 if unknown.
	/// </param>
	/// <param name=pqwDuration>
	///     Total duration of file being downloaded (in hundreds of nanoseconds), or -1 if unknown.
	/// </param>
	HRESULT GetTimeSeekResult(
		[out] QWORD* pqwStartTime,
		[out] QWORD* pqwStopTime,
		[out] QWORD* pqwDuration
	);
};

typedef struct
{
	// The start offset, in bytes, of a range of cached data
	QWORD qwStartOffset;
	// The end offset, in bytes, of a range of cached data
	QWORD qwEndOffset;
} MF_BYTE_STREAM_CACHE_RANGE;
/// <summary>
///     This interface is exposed by byte streams that transfer data from
///     a remote resource to a local cache in the background.  This interface
///     provides additional control over IMFByteStreamCacheControl2 over the
///     way the transfer happens.
/// </summary>
[
	odl,
	uuid(71CE469C-F34B-49EA-A56B-2D2A10E51149)
]

interface IMFByteStreamCacheControl2 : IMFByteStreamCacheControl
{
	/// <summary>
	///     Returns a series of MF_BYTE_STREAM_CACHE_RANGE structures that
	///     identify ranges of bytes in the cache.
	/// </summary>
	/// <param name="pcRanges">
	///     Receives the number of ranges in the output array ppRanges.
	/// </param>
	/// <param name="ppRanges">
	///     Recieves an array of MF_BYTE_STREAM_CACHE_RANGE structures with
	///     *pcRanges elements.  Each MF_BYTE_STREAM_CACHE_RANGE structure
	///     specifies a range of bytes stored in the byte stream's cache.
	///     The caller must free *ppRanges with CoTaskMemFree.
	/// </param>
	HRESULT GetByteRanges(
		[out] DWORD* pcRanges,
		[out] LongPtr* ppRanges
	);

	/// <summary>
	///     Limits the cache size to the specified number of bytes.
	/// </summary>
	/// <param name="qwBytes">
	///     The maximum number of bytes to store in the cache, or ULONGLONG_MAX (QWORD_MAX)
	///     for no limit.  The default value is no limit.
	/// </param>
	HRESULT SetCacheLimit(
		[in] QWORD qwBytes
	);

	/// <summary>
	///     Queries whether the background transfer is active.  The background
	///     transfer might be inactive if the cache has been filled (due to
	///     SetCacheLimit) or if background transfer has benn stopped (due to
	///     IMFByteStreamCacheControl::StopBackgroundTransfer).
	/// </summary>
	/// <param name="pfActive">
	///     Receives TRUE if the background transfer is currently active, FALSE
	///     if the background transfer is inactive
	/// </param>
	HRESULT IsBackgroundTransferActive(
		[out] BOOL* pfActive
	);
};

[
	odl,
	uuid(5b87ef6a-7ed8-434f-ba0e-184fac1628d1)
]
/// <summary>
///     The IMFNetCredential interface is used to set and retrieve the username
///     and password for authentication purposes.
/// </summary>
interface IMFNetCredential : stdole.IUnknown
{
	/// <summary>
	///  SetUser sets the user name of the credential.
	/// <param name="pbData">
	///  Pointer to a buffer containing a UNICODE string with the user name. The
	///  object will make an encrypted copy of this data. If the data is already
	///  encrypted, the application must set fDataIsEncrypted to TRUE. To encrypt
	///  the data the application must use the CryptProtectData function from the
	///  Platform SDK.
	/// </param>
	/// <param name="cbData">
	///  Size, in bytes, of the data pointed by pbData. If the data is an
	///  unencrypted string, this value must include the null terminator
	///  of the string.
	/// </param>
	/// <param name="fEncrypted">
	///  Boolean value that specifies if the data is already encrypted.
	/// </param>
	HRESULT SetUser(
		[in] BYTE* pbData,
		[in] DWORD cbData,
		[in] BOOL fDataIsEncrypted);


	/// <summary>
	///  SetPassword sets the password of the credential.
	/// <param name="pbData">
	///  Pointer to a buffer containing a UNICODE string with the password. The
	///  object will make an encrypted copy of this data. If the data is already
	///  encrypted, the application must set fDataIsEncrypted to TRUE. To encrypt
	///  the data the application must use the CryptProtectData function from the
	///  Platform SDK.
	/// </param>
	/// <param name="cbData">
	///  Size, in bytes, of the data pointed by pbData. If the data is an
	///  unencrypted string, this value must include the null terminator
	///  of the string.
	/// </param>
	/// <param name="fEncrypted">
	///  Boolean value that specifies if the data is already encrypted.
	/// </param>
	HRESULT SetPassword(
		[in] BYTE* pbData,
		[in] DWORD cbData,
		[in] BOOL fDataIsEncrypted);

	/// <summary>
	///  GetUser retrieves the user name of this credential.
	/// </summary>
	/// <param name="pbData">
	///  Pointer to the buffer that will receive the user name. If the application
	///  sets the fEncryptData parameter to TRUE, the function will return the data
	///  unencrypted as a UNICODE string format. If the application sets the
	///  sets the fEncryptData parameter to FALSE, the function will return the data
	///  encrypted. To unencrypt the data the application will have to use the
	///  CryptUnprotectData function from the Platform SDK.
	/// </param>
	/// <param name="pcbData">
	///  Pointer to a DWORD value that contains the size of the data buffer. Upon input,
	///  the value contains the maximum size of the buffer. Upon return, the value contains
	///  the number of bytes needed to hold the data, including the null terminator if the
	///  data is returned unencrypted.
	/// </param>
	/// <param name="fEncryptData">
	///  If this value is TRUE, the function will return the data encrypted, otherwise
	///  it'll return the data unencrypted.
	/// </param>
	HRESULT GetUser(
		[out] BYTE* pbData,
		[in, out] DWORD* pcbData,
		[in] BOOL fEncryptData);


	/// <summary>
	///  GetPassword retrieves the user name of this credential.
	/// </summary>
	/// <param name="pbData">
	///  Pointer to the buffer that will receive the password. If the application
	///  sets the fEncryptData parameter to TRUE, the function will return the data
	///  unencrypted as a UNICODE string format. If the application sets the
	///  sets the fEncryptData parameter to FALSE, the function will return the data
	///  encrypted. To unencrypt the data the application will have to use the
	///  CryptUnprotectData function from the Platform SDK.
	/// </param>
	/// <param name="pcbData">
	///  Pointer to a DWORD value that contains the size of the data buffer. Upon input,
	///  the value contains the maximum size of the buffer. Upon return, the value contains
	///  the number of bytes needed to hold the data, including the null terminator if the
	///  data is returned unencrypted.
	/// </param>
	/// <param name="fEncryptData">
	///  If this value is TRUE, the function will return the data encrypted, otherwise
	///  it'll return the data unencrypted.
	/// </param>
	HRESULT GetPassword(
		[out] BYTE* pbData,
		[in, out] DWORD* pcbData,
		[in] BOOL fEncryptData);

	/// <summary> LoggedOnUser returns TRUE if logged on credentials should be used. </summary>
	HRESULT LoggedOnUser([out] BOOL* pfLoggedOnUser);
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///     The MFNetCredentialManagerGetParam structure is for passing the authentication information to the credential manager .
	/// </summary>
	typedef struct MFNetCredentialManagerGetParam
	{
		/// <member name="hrOp">
		///     The response code of the authenticaion challenge.
		///     Examples are: NS_E_PROXY_ACCESSDENIED, E_ACCESSDENIED, etc.
		///     Type: HRESULT.
		/// </member>
		long hrOp;

		/// <member name="fAllowLoggedOnUser">
		///     Specify if currently logged on user's credential should be used as the default credential.
		///     Type: BOOL.
		/// </member>
		BOOL fAllowLoggedOnUser;

		/// <member name="fClearTextPackage">
		///     When set this flag indicates that the authentication package will send the credentials
		///     unencrypted over the network.
		/// </member>
		BOOL fClearTextPackage;

		/// <member name="pszUrl">
		///     The original URL for which authentication is required.
		///     Type: String.
		/// </member>
		LongPtr pszUrl;

		/// <member name="pszSite">
		///     The name of the site or proxy that required authentication.
		///     Type: String.
		/// </member>
		LongPtr pszSite;

		/// <member name="pszRealm">
		///     The Realm for the authentication.
		///     Type: String.
		/// </member>
		LongPtr pszRealm;

		/// <member name="pszPackage">
		///     The name of the authentication package. For example, "Digest" or "MBS_BASIC".
		///     Type: String.
		/// </member>
		LongPtr pszPackage;

		/// <member name="nRetries">
		///     The number of times that the credential manager should retry after authentication failed.
		///     Type: LONG.
		/// </member>
		LONG nRetries;

	} MFNetCredentialManagerGetParam;


/// <summary>
///     The IMFNetCredentialManager interface is used by MF to get user credentials.
///     The application can provide an object exposing this interface in the
///     MFNETSOURCE_CREDENTIAL_MANAGER property of the property store that is
///     passed to IMFSourceResolver or IMFSchemeHandler. If an object is not provided,
///     MF will not handle network authentication requests.
/// </summary>
[
	odl,
	uuid(5b87ef6b-7ed8-434f-ba0e-184fac1628d1)
]

interface IMFNetCredentialManager : stdole.IUnknown
{


	/// <summary> BeginGetCredentials is the start of the asynchronous call to get the credential. </summary>
	/// <param name="pParam">
	///   Pointer to the MFNetCredentialManagerGetParam parameter.
	/// </param>
	/// <param name="pCallback">
	///   The callback when the operation is completed.
	/// </param>
	/// <param name="pState">
	///   The state from the caller that should be returned in the callback.
	/// </param>
	HRESULT BeginGetCredentials(
		[in] MFNetCredentialManagerGetParam* pParam,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* pState);

	/// <summary> EndGetCredentials is the end of the asynchronous call to get the credential. </summary>
	/// <param name="pResult">
	///   The state of the operation from the callback.
	/// </param>
	/// <param name="ppCred">
	///   Pointer to the IMFNetCredential* interface for getting the credentials.
	/// </param>
	HRESULT EndGetCredentials(
		[in] IMFAsyncResult* pResult,
		[out] IMFNetCredential** ppCred
	);

	/// <summary> SetGood is called by MF to notify whether the credential succeeded authentication.</summary>
	/// <param name="pCred">
	///   The credential used in the authentication.
	/// </param>
	/// <param name="fGood">
	///   Notify whether the credential provided succeeded the authentication.
	/// </param>
	HRESULT SetGood(
		[in] IMFNetCredential* pCred,
		[in] BOOL fGood);
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	typedef enum MFNetCredentialRequirements
	{
		/// <member name="REQUIRE_PROMPT">
		///     Specify that the credential manager needs to prompt
		///     the user to provide the credentials.
		///     Type: DWORD.
		/// </member>
		REQUIRE_PROMPT = 0x00000001,

//#if (WINVER >= _WIN32_WINNT_WIN7)
		/// <member name="REQUIRE_SAVE_SELECTED">
		///     Specify that the credential manager needs to prompt
		///     the user with the option to save credentials selected.
		///     This happens when the credentials were saved already,
		///     therefore the user does not need to reselect the option.
		/// </member>
		REQUIRE_SAVE_SELECTED = 0x00000002,
//#endif // (WINVER >= _WIN32_WINNT_WIN7)

	} MFNetCredentialRequirements;

	/// <summary>
	///     The MFNetCredentialOptions is the enumerate of
	///     the options for the credential cache.
	/// </summary>
	typedef enum MFNetCredentialOptions
	{
		/// <member name="MFNET_CREDENTIAL_SAVE">
		///     Specify that the Credential Cache may save the
		///     credentials in a persistent storage to be used
		///     the next time it gets instantiated by the
		///     application.
		///     Type: DWORD.
		/// </member>
		MFNET_CREDENTIAL_SAVE = 0x00000001,

		/// <member name="MFNET_CREDENTIAL_DONT_CACHE">
		///     Specify that the Credential Cache must not cache
		///     the credentials in memory. If this flag
		///     is set, then MFNET_CREDENTIAL_SAVE must not be used.
		///     Type: DWORD.
		/// </member>
		MFNET_CREDENTIAL_DONT_CACHE = 0x00000002,

		/// <member name="MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT">
		///     Specify the user allowed the credentials to be sent over
		///     the network unencrypted.
		///     Type: DWORD.
		/// </member>
		MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT = 0x00000004,

	} MFNetCredentialOptions;


	/// <summary>
	///     Authentication flags.
	/// </summary>
	typedef enum MFNetAuthenticationFlags
	{
		/// <member name="MFNET_AUTHENTICATION_PROXY">
		///     Specify that the credentials will be used to authenticate with a proxy.
		///     Type: DWORD.
		/// </member>
		MFNET_AUTHENTICATION_PROXY = 0x00000001,

		/// <member name="MFNET_AUTHENTICATION_CLEAR_TEXT">
		///     Specify that the credentials will be sent over the network unencrypted.
		///     Type: DWORD.
		/// </member>
		MFNET_AUTHENTICATION_CLEAR_TEXT = 0x00000002,

		/// <member name="MFNET_AUTHENTICATION_LOGGED_ON_USER">
		///     Requires a credential for the logged on user.
		///     Type: DWORD.
		/// </member>
		MFNET_AUTHENTICATION_LOGGED_ON_USER = 0x00000004,

	} MFNetAuthenticationFlags;

/// <summary>
///     The IMFNetCredentialCache is for retrieving the credentials from the credential cache.
///     An application that implements a Credential Manager (see IMFNetCredentialManager)
///     can use MF's Credential Cache to cache credentials. To create a Credential Cache the
///     application calls MFCreateCredentialCache.
/// </summary>
[
	odl,
	uuid(5b87ef6c-7ed8-434f-ba0e-184fac1628d1)
]

interface IMFNetCredentialCache : stdole.IUnknown
{

	/// <summary>
	///     The GetCredential returns a credential object for a specific URL.
	/// </summary>
	/// <param name="pszUrl">
	///   The URL for which the credential is needed.
	/// </param>
	/// <param name="pszRealm">
	///   The Realm for the authentication.
	/// </param>
	/// <param name="dwAuthenticationFlags">
	///   Authenticaiton flags as defined in MFNetAuthenticationFlags.
	/// </param>
	/// <param name="ppCred">
	///   Pointer to get the credential.
	/// </param>
	/// <param name="pdwRequirementsFlags">
	///   Pointer to get the requirement flags, as defined in MFNetCredentialRequirements.
	/// </param>

	HRESULT GetCredential(
		[in] LongPtr pszUrl,
		[in] LongPtr pszRealm,
		[in] DWORD dwAuthenticationFlags,
		[out] IMFNetCredential** ppCred,
		[out] DWORD* pdwRequirementsFlags);

	/// <summary> SetGood is called by the Credential Manager to notify whether the credential provided succeeded the authentication.</summary>
	/// <param name="pCred">
	///   The credential used in the authentication.
	/// </param>
	/// <param name="fGood">
	///   Notify whether the credential provided succeeded the authentication.
	/// </param>

	HRESULT SetGood(
		[in] IMFNetCredential* pCred,
		[in] BOOL fGood);

	/// <summary>
	///     SetUserOptions is called by the Credential Manager to set user options for the credential.
	/// </summary>
	/// <param name="pCred">
	///   The credential being referred to.
	/// </param>
	/// <param name="dwOptionsFlags">
	///   User flags as defined in MFNetCredentialOptions.
	/// </param>

	HRESULT SetUserOptions(
		[in] IMFNetCredential* pCred,
		[in] DWORD dwOptionsFlags);
};

/// <summary>
///     The IMFSSLCertificateManager interface is used by MF to retrieve a
///     client SSL certificate in case HTTPS is used and the server requests
///     a client-side certificate.  The interface can also be used to allow the application
///     to validate the server's SSL certificate.
///     The application can provide an object exposing this interface in the
///     MFNETSOURCE_SSLCERTIFICATE_MANAGER property of the property store that is
///     passed to IMFSourceResolver or IMFSchemeHandler. If an object is not provided,
///     MF will be unable to use HTTPS if the server requests a client-side certificate.
/// </summary>
[
	odl,
	uuid(61f7d887-1230-4a8b-aeba-8ad434d1a64d)
]
interface IMFSSLCertificateManager : stdole.IUnknown
{
	/// <summary> GetClientCertificate is used to get the client's SSL certificate using a synchronous call </summary>
	/// <param name="pszURL">
	///   The URL used when sending a request to the server, and for which a client-side SSL certificate is now required.
	/// </param>
	/// <param name="ppbData">
	///  Pointer to a pointer which, on successful return, will point to the certificate.
	///   The certificate  is stored in a buffer which must be allocated using CoTaskMemAlloc,
	///   and the caller must free the memory pointed to by *ppbData using CoTaskMemFree.
	/// </param>
	/// <param name="pcbData">
	///  Pointer to a DWORD value that contains the size of the data buffer. Upon
	///  input, the value contains the maximum size of the buffer. Upon return, the
	///  value contains the number of bytes needed to hold the data.
	/// </param>
	HRESULT GetClientCertificate(
		[in] LongPtr pszURL,
		[out] BYTE** ppbData,
		[out] DWORD* pcbData);

	/// <summary> BeginGetClientCertificate is the start of the asynchronous call to get the client's SSL certificate. </summary>
	/// <param name="pszURL">
	///   The URL used when sending a request to the server, and for which a client-side SSL certificate is now required.
	/// </param>
	/// <param name="pCallback">
	///   The callback when the operation is completed.
	/// </param>
	/// <param name="pState">
	///   The state from the caller that should be returned in the callback.
	/// </param>
	HRESULT BeginGetClientCertificate(
		[in] LongPtr pszURL,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* pState);

	/// <summary> EndGetClientCertificate is the end of the asynchronous call to get the client's SSL certificate. </summary>
	/// <param name="pResult">
	///   The state of the operation from the callback.
	/// </param>
	/// <param name="ppbData">
	///  Pointer to a pointer which, on successful return, will point to the certificate.  The certificate is
	///  stored in a buffer which must be allocated using CoTaskMemAlloc, and the caller must free the memory
	///  pointed to by *ppbData using CoTaskMemFree.
	/// </param>
	/// <param name="pcbData">
	///  Pointer to a DWORD value that contains the size of the data buffer. Upon
	///  input, the value contains the maximum size of the buffer. Upon return, the
	///  value contains the number of bytes needed to hold the data.
	/// </param>
	HRESULT EndGetClientCertificate(
		[in] IMFAsyncResult* pResult,
		[out] BYTE** ppbData,
		[out] DWORD* pcbData);

	/// <summary> GetCertificatePolicy is called by MF to determine if the server's SSL certificate should be verified
	///  automatically or if IMFSSLCertificateManager should be used to verify the server's certificate.
	/// </summary>
	/// <param name="pszURL">
	///   The URL which will be sent to the server.
	/// </param>
	/// <param name=" pfOverrideAutomaticCheck">
	///   Set to TRUE if IMFSSLCertificateManager::OnServerCertificate should be used to verify the server's certificate.
	///   Set to FALSE to verify the server's certificate using the certificates in the Windows certificate store.
	/// </param>
	/// <param name=" pfClientCertificateAvailable">
	///   Set to TRUE if SSL certificate for the client is available upfront. In this case, the client certificate will
	///   be supplied with a synchronous call to GetClientCertificate. Set to FALSE to verify the server's certificate
	///   using the certificates in the Windows certificate store. In this case client`s SSL certificate will be obtained
	///   with an asynchronous call to BeginGetClientCertificate.
	/// </param>
	HRESULT GetCertificatePolicy(
		[in] LongPtr pszURL,
		[out] BOOL* pfOverrideAutomaticCheck,
		[out] BOOL* pfClientCertificateAvailable);

	/// <summary>
	///  OnServerCertificate is invoked by MF when the server's SSL certificate has been received, and is used for checking
	///  if the certificate is accepted.
	/// <param name="pszURL">
	///   The URL used when sending a request to the server, and for which a server-side SSL certificate has now been received.
	/// </param>
	/// <param name="pbData">
	///  Pointer to a buffer containing the server's SSL certificate.
	/// </param>
	/// <param name="cbData">
	///  Size, in bytes, of the data pointed by pbData.
	/// </param>
	/// <param name="pfGood">
	///  Boolean value which, if set to TRUE, indicates that the server's SSL certificate has been accepted and that the
	///  connection can proceed.  If set to FALSE, the certificate is rejected and the connection will be closed.
	/// </param>
	HRESULT OnServerCertificate(
		[in] LongPtr pszURL,
		[in] BYTE* pbData,
		[in] DWORD cbData,
		[out] BOOL* pfIsGood);
};
//+-----------------------------------------------------------------------------
//
//  Interface:  IMFNetResourceFilter
//
//  Synopsis:   Callbacks for filtering and sending requests.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(091878a3-bf11-4a5c-bc9f-33995b06ef2d),
	helpstring("IMFNetResourceFilter Interface"),
]
interface IMFNetResourceFilter : stdole.IUnknown
{
	HRESULT OnRedirect(
		[in] LongPtr pszUrl,
		[out] VARIANT_BOOL* pvbCancel
	);

	HRESULT OnSendingRequest(
		[in] LongPtr pszUrl
	);
};

/// <summary>
///     The application can provide an object exposing the IMFSourceOpenMonitor
///     interface to receive notifications on the progress of an asynchronous
///     open operation. The application provides the object in the
///     MFPKEY_SourceOpenMonitor property of the property store that
///     is passed to IMFSourceResolver or IMFSchemeHandler.
/// </summary>
[
	odl,
	uuid(059054B3-027C-494C-A27D-9113291CF87F)
]

interface IMFSourceOpenMonitor : stdole.IUnknown
{
	/// <summary>
	///     Called by the Network Media Source to indicate the progress of
	///     the asynchronous open operation.
	/// </summary>
	/// <param name=pEvent>
	///     The status of the open operation. It can be MEConnectStart or
	///     MEConnectEnd.
	/// </param>
	///
	HRESULT OnSourceEvent(
		[in] IMFMediaEvent* pEvent
	);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/// <summary>
///     The IMFNetProxyLocator interface is used to determine the proxy to
///     use for connecting to a server.
/// </summary>
[
	odl,
	uuid(e9cd0383-a268-4bb4-82de-658d53574d41)
]
interface IMFNetProxyLocator : stdole.IUnknown
{
	///  <summary>
	///     Initializes the ProxyLocator object. Once the ProxyLocator
	///     object has been initialized, the client has to call FindNextProxy to
	///     retrieve the information about the first proxy.
	///  </summary>
	///  <param name=pszHost>The hostname of the destination server.</param>
	///  <param name=pszUrl>The destination url.</param>
	///  <param name=fReserved>This parameter is reserved and should be set to FALSE.</param>
	///
	HRESULT FindFirstProxy(
		[in] LongPtr pszHost,
		[in] LongPtr pszUrl,
		[in] BOOL fReserved);

	///  <summary>
	///     Continues the proxy enumeration from a previous call to FindNextProxy or
	///     FindFirstProxy.
	///  </summary>
	///  <returns>
	///     <para> S_OK: a new proxy has been located.</para>
	///     <para> S_FALSE: no more proxies can be found.</para>
	///  </returns>
	///
	HRESULT FindNextProxy(void);

	///  <summary>
	///     RegisterProxyResult is called by the client to record the success
	///     or failure of using the current proxy.
	///  </summary>
	///  <param name=hrOp>The result of using the current proxy for connection.</param>
	HRESULT RegisterProxyResult(
		[in] long hrOp);

	///  <summary>Retrieve the current proxy information including hostname and port.</summary>
	///  <param name=pszStr>The proxy hostname and port.</param>
	///  <param name=pcchStr>The count of unicode characters in pszStr.</param>
	HRESULT GetCurrentProxy(
		[out] LongPtr* pszStr,
		[in, out] DWORD* pcchStr);

	///  <summary>Creates a new instance of the ProxyLocator.</summary>
	///  <param name=ppProxyLocator>The new ProxyLocator created.</param>
	HRESULT Clone(
		[out] IMFNetProxyLocator** ppProxyLocator);
};
///<summary>
///     IMFNetProxyLocatorFactory interface is used to create the
///     IMFNetProxyLocator interface which determines the proxy to use.
///     The application can provide an object exposing this interface
///     in the MFNETSOURCE_PROXYLOCATORFACTORY property of the property store
///     that is passed to IMFSourceResolver or IMFSchemeHandler.
///     If the object is not provided, MF will use the default ProxyLocatorFactory.
///</summary>
[
	odl,
	uuid(e9cd0384-a268-4bb4-82de-658d53574d41)
]
interface IMFNetProxyLocatorFactory : stdole.IUnknown
{
	/// <summary>
	///     CreateProxyLocator is called to create a ProxyLocator
	///     object for a given protocol.
	/// </summary>
	/// <param name="pszProtocol">
	///     The protocol name, such as "rtsp" and "http".
	/// </param>
	/// <param name="ppProxyLocator">
	///     The IMFNetProxyLocator interface of the ProxyLocator object.
	/// </param>
	HRESULT CreateProxyLocator(
		[in] LongPtr pszProtocol,
		[out] IMFNetProxyLocator** ppProxyLocator);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///<summary>
///     IMFSaveJob interface is a service interface that can be used to persist
///     content to a ByteStream object provided by the application. The application
///     uses the MFNET_SAVEJOB_SERVICE GUID to retrieve this service.
///     Currently only the HTTP ByteStream object provides it.
///</summary>
[
	odl,
	uuid(e9931663-80bf-4c6e-98af-5dcf58747d1f)
]
interface IMFSaveJob : stdole.IUnknown
{
	///  <summary>
	///     Starts an asynchronous operation that will persist the content
	///     of the object to a ByteStream given by the application.
	///  </summary>
	///  <param name=pStream>The ByteStream in which the service will persist the content.</param>
	///  <param name=pCallback>The callback when the operation is completed.</param>
	///  <param name=pState>The state from the caller that should be returned in the callback.</param>
	HRESULT BeginSave(
		[in] IMFByteStream* pStream,
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* pState);

	///<summary>
	///     Completes the operation started by BeginSave.
	///</summary>
	///<param name=pResult>
	///     The state of the operation from the callback.
	///</param>
	HRESULT EndSave(
		[in] IMFAsyncResult* pResult);

	///  <summary>Cancels the operation started by BeginSave.</summary>
	HRESULT CancelSave(void);

	///  <summary>Retrieves the percentage of content that has been persisted</summary>
	///  <param name=pdwPercentComplete>The percentage of completion.</param>
	HRESULT GetProgress(
		[out] DWORD* pdwPercentComplete);
};

typedef enum MFNETSOURCE_PROTOCOL_TYPE
{
	/// <member name="MFNETSOURCE_UNDEFINED">
	///     The protocol type has not yet been determined.
	/// </member>
	MFNETSOURCE_UNDEFINED = 0x0,

	/// <member name="MFNETSOURCE_HTTP">
	///     The protocol type is HTTP. This includes HTTPv9, WMSP and HTTP download.
	/// </member>
	MFNETSOURCE_HTTP = 0x1,

	/// <member name="MFNETSOURCE_RTSP">
	///     The protocol type is RTSP.
	/// </member>
	MFNETSOURCE_RTSP = 0x2,

	/// <member name="MFNETSOURCE_FILE">
	///     The content is read from a file. The file may be local or on a remote share.
	/// </member>
	MFNETSOURCE_FILE = 0x3,

	/// <member name="MFNETSOURCE_MULTICAST">
	///     The protocol type is multicast.
	/// </member>
	MFNETSOURCE_MULTICAST = 0x4,

} MFNETSOURCE_PROTOCOL_TYPE;
///<summary>
///     Used to query and set the configuration
///     of the Net Scheme plugin.
///</summary>

[
	odl,
	uuid(7BE19E73-C9BF-468a-AC5A-A5E8653BEC87)
]
interface IMFNetSchemeHandlerConfig : stdole.IUnknown
{
	/// <summary>
	///     Method that retrieves the number of protocols
	///     supported by this Net Scheme plugin.
	/// </summary>
	/// <param name=pcProtocols>
	///     Pointer used to return the number of protocols.
	/// </param>
	HRESULT GetNumberOfSupportedProtocols(
		[out] ULONG* pcProtocols);

	/// <summary>
	///     This method gets the protocol type for
	///     a given protocol index.
	/// </summary>
	/// <param name=nProtocolIndex>
	///     Protocol index. It is a value between 0 and
	///     the value returned by GetNumberOfSupportedProtocols,
	///     exclusively.
	/// </param>
	HRESULT GetSupportedProtocolType(
		[in] ULONG nProtocolIndex,
		[out] MFNETSOURCE_PROTOCOL_TYPE* pnProtocolType);

	/// <summary>
	///     Forces the Network scheme plugin to clean up the protocol
	///     rollover settings and use the default rollover behavior.
	///     NOTE: This method is not implemented in this version of MF,
	///     and it always returns S_OK.
	/// </summary>
	HRESULT ResetProtocolRolloverSettings(void);
};

typedef enum MFNETSOURCE_TRANSPORT_TYPE
{
	/// <member name="MFNETSOURCE_UDP">
	///     The data transport used is UDP.
	/// </member>
	MFNETSOURCE_UDP,

	/// <member name="MFNETSOURCE_TCP">
	///     The data transport used is TCP.
	/// </member>
	MFNETSOURCE_TCP,
} MFNETSOURCE_TRANSPORT_TYPE;

/// <summary>
///     The status of cache for a media file or entry.
///     See MFNETSOURCE_CACHE_STATE_ID.
/// </summary>
typedef enum MFNETSOURCE_CACHE_STATE
{
	/// <member name="MFNETSOURCE_CACHE_UNAVAILABLE">
	///     The cache for a file or entry does not exist.
	/// </member>
	MFNETSOURCE_CACHE_UNAVAILABLE,

	/// <member name=" MFNETSOURCE_CACHE_ACTIVE_WRITING">
	///     The cache for a file or entry is growing.
	/// </member>
	MFNETSOURCE_CACHE_ACTIVE_WRITING,

	/// <member name="MFNETSOURCE_CACHE_ACTIVE_COMPLETE">
	///     The cache for a file or entry is completed.
	/// </member>
	MFNETSOURCE_CACHE_ACTIVE_COMPLETE,
} MFNETSOURCE_CACHE_STATE;


/// <summary>
///     The property IDs of the statistics that are supported by
///     Network Media Sources and Byte Streams. To retrieve the
///     statistics the application uses IMFGetService::GetService with
///     the MFNETSOURCE_STATISTICS_SERVICE service GUID and a
///     IID_IPropertyStore RIID. Then the application can use the returned
///     IPropertyStore interface to read the object's statistics with
///     the following pids and the MFNETSOURCE_STATISTICS
///     fmtid.
/// </summary>
typedef enum MFNETSOURCE_STATISTICS_IDS
{
	/// <member name="MFNETSOURCE_RECVPACKETS_ID">
	///     The number of packets received.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_RECVPACKETS_ID = 0,

	/// <member name="MFNETSOURCE_LOSTPACKETS_ID">
	///     The number of packets lost.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_LOSTPACKETS_ID,

	/// <member name="MFNETSOURCE_RESENDSREQUESTED_ID">
	///     The number of packets resend requested.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_RESENDSREQUESTED_ID,

	/// <member name="MFNETSOURCE_RESENDSRECEIVED_ID">
	///     The number of packets resend received.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_RESENDSRECEIVED_ID,

	/// <member name="MFNETSOURCE_RECOVEREDBYECCPACKETS_ID">
	///     The total  of packets recovered by error correction (ECC).
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_RECOVEREDBYECCPACKETS_ID,

	/// <member name="MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID">
	///     The total number of packets recovered by retransmission (RTX).
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID,

	/// <member name="MFNETSOURCE_OUTPACKETS_ID">
	///     The total number of packets returned to user.
	///     This includes recovered packets.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_OUTPACKETS_ID,

	/// <member name="MFNETSOURCE_RECVRATE_ID">
	///     The 10 second average receive rate.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_RECVRATE_ID,

	/// <member name="MFNETSOURCE_AVGBANDWIDTHBPS_ID">
	///     The average bandwidth of the clip.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_AVGBANDWIDTHBPS_ID,

	/// <member name="MFNETSOURCE_BYTESRECEIVED_ID">
	///     The total number of bytes received.
	///     Type: QWORD.
	/// </member>
	MFNETSOURCE_BYTESRECEIVED_ID,

	/// <member name="MFNETSOURCE_PROTOCOL_ID">
	///     The type of control protocol used to receive the data.
	///     Valid values are defined in MFNETSOURCE_PROTOCOL_TYPE.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_PROTOCOL_ID,

	/// <member name="MFNETSOURCE_TRANSPORT_ID">
	///     The type of transport used to receive the data.
	///     Valid values are defined in MFNETSOURCE_TRANSPORT_TYPE.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_TRANSPORT_ID,

	/// <member name="MFNETSOURCE_CACHE_STATE_ID">
	///     The status of cache for a media file or entry.
	///     Valid values are defined in MFNETSOURCE_CACHE_STATE.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_CACHE_STATE_ID,

	/// <member name="MFNETSOURCE_LINKBANDWIDTH_ID">
	///     Current link bandwidth in bits per second.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_LINKBANDWIDTH_ID,

	/// <member name="MFNETSOURCE_CONTENTBITRATE_ID">
	///     Current content bitrate.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_CONTENTBITRATE_ID,

	/// <member name="MFNETSOURCE_SPEEDFACTOR_ID">
	///     The negotiated speed factor used in data transmission, multiplied by 1000.
	///     The sender sends data in the speed of speed factor * content bitrate.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_SPEEDFACTOR_ID,

	/// <member name="MFNETSOURCE_BUFFERSIZE_ID">
	///     The playout buffer size in milliseconds.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_BUFFERSIZE_ID,

	/// <member name="MFNETSOURCE_BUFFERPROGRESS_ID">
	///     The percentage of playout buffer filled up during buffering.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_BUFFERPROGRESS_ID,

	/// <member name="MFNETSOURCE_LASTBWSWITCHTS_ID">
	///     Tickcount of last bandwidth switch.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_LASTBWSWITCHTS_ID,

	/// <member name="MFNETSOURCE_SEEKRANGESTART_ID">
	///     Start of seekable range in nanoseconds.
	///     Type: QWORD.
	/// </member>
	MFNETSOURCE_SEEKRANGESTART_ID,

	/// <member name="MFNETSOURCE_SEEKRANGEEND_ID">
	///     End of seekable range in nanoseconds.
	///     Type: QWORD.
	/// </member>
	MFNETSOURCE_SEEKRANGEEND_ID,

	/// <member name="MFNETSOURCE_BUFFERINGCOUNT_ID">
	///     Number of times buffering happened (including the initial buffering).
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_BUFFERINGCOUNT_ID,

	/// <member name="MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID">
	///     Number of packets that had incorrect signature.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID,

	/// <member name="MFNETSOURCE_SIGNEDSESSION_ID">
	///     Whether this is a signed session.
	///     Type: BOOLEAN.
	/// </member>
	MFNETSOURCE_SIGNEDSESSION_ID,

	/// <member name="MFNETSOURCE_MAXBITRATE_ID">
	///     Current content maximum bitrate.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_MAXBITRATE_ID,

	/// <member name="MFNETSOURCE_RECEPTION_QUALITY_ID">
	///     Reception quality.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_RECEPTION_QUALITY_ID,

	/// <member name="MFNETSOURCE_RECOVEREDPACKETS_ID">
	///     The total number of packets recovered.
	///     Type: DWORD.
	/// </member>
	MFNETSOURCE_RECOVEREDPACKETS_ID,

	/// <member name="MFNETSOURCE_VBR_ID">
	///     Whether this is VBR content.
	///     Type: BOOLEAN.
	/// </member>
	MFNETSOURCE_VBR_ID,

	/// <member name="MFNETSOURCE_DOWNLOADPROGRESS_ID">
	///     The percentage of the content that has been downloaded so far.
	///     Type: BOOLEAN.
	/// </member>
	MFNETSOURCE_DOWNLOADPROGRESS_ID,

//#if (WINVER >= _WIN32_WINNT_WIN7)
	/// <member name="MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID">
	///     The name of protocol when MFNETSOURCE_PROTOCOL_ID is MFNETSOURCE_UNDEFINED.
	///     Data type: STRING
	/// </member>
	MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID,
//#endif // (WINVER >= _WIN32_WINNT_WIN7)

} MFNETSOURCE_STATISTICS_IDS;

typedef enum MFNET_PROXYSETTINGS
{
	/// <summary>
	///     This option sets the proxy locator to bypass all addresses.
	/// </summary>
	MFNET_PROXYSETTING_NONE = 0,

	/// <summary>
	///     This options sets the proxy locator to use manual settings.
	/// </summary>
	MFNET_PROXYSETTING_MANUAL = 1,

	/// <summary>
	///     This options sets the proxy locator to use proxy auto-discovery.
	/// </summary>
	MFNET_PROXYSETTING_AUTO = 2,

	/// <summary>
	///     This options sets the proxy locator to use the internet browser
	///     proxy settings.
	/// </summary>
	MFNET_PROXYSETTING_BROWSER = 3
} MFNET_PROXYSETTINGS;

[
	odl,
	uuid(6D4C7B74-52A0-4bb7-B0DB-55F29F47A668)
]
/// <summary>
///     A scheme handler is typically associated with one or more schemes
///     (e.g. file:// or http://) and is able to create an object (generally
///     an IMFByteStream) capable of reading from that URL.
/// </summary>
interface IMFSchemeHandler : stdole.IUnknown
{
	HRESULT BeginCreateObject(
		[in]  LongPtr pwszURL,
		[in]  DWORD dwFlags,
		[in]  IPropertyStore * pProps,
		[out] IUnknown * *ppIUnknownCancelCookie,
		[in]  IMFAsyncCallback * pCallback,
		[in]  stdole.IUnknown * punkState
	);

	HRESULT EndCreateObject(
		[in]  IMFAsyncResult* pResult,
		[out] MF_OBJECT_TYPE* pObjectType,
		[out] stdole.IUnknown** ppObject
	);

	HRESULT CancelObjectCreation(
		[in] stdole.IUnknown* pIUnknownCancelCookie
	);
};

///     A byte stream handler is typically associated with one or more formats
///     (e.g. WMV or MP3) and is able to create an object (generally an
///     IMFMediaSource) capable of reading that format.
/// </summary>

[
	odl,
	uuid(BB420AA4-765B-4a1f-91FE-D6A8A143924C)
]
interface IMFByteStreamHandler : stdole.IUnknown
{
	HRESULT BeginCreateObject(
		[in]  IMFByteStream * pByteStream,
		[in]  LongPtr pwszURL,
		[in]  DWORD dwFlags,
		[in]  IPropertyStore * pProps,
		[out] IUnknown * *ppIUnknownCancelCookie,
		[in]  IMFAsyncCallback * pCallback,
		[in]  stdole.IUnknown * punkState
	);

	HRESULT EndCreateObject(
		[in]  IMFAsyncResult* pResult,
		[out] MF_OBJECT_TYPE* pObjectType,
		[out] stdole.IUnknown** ppObject
	);

	HRESULT CancelObjectCreation(
		[in] stdole.IUnknown* pIUnknownCancelCookie
	);

	HRESULT GetMaxNumberOfBytesRequiredForResolution(
		[out] QWORD* pqwBytes
	);
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// Media Foundation Protected Media Path component interfaces
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(542612C4-A1B8-4632-B521-DE11EA64A0B0),
	helpstring("IMFTrustedInput Interface")
]
/// <summary>
///     A component that exposes Input Trust Authorities implements
///     IMFTrustedInput.
///     This interface provides a common way for the components to expose
///     ITAs on each of its streams.
///     In addition to the methods inherited from IUnknown, IMFTrustedInput also
///     exposes the following methods.
/// </summary>
interface IMFTrustedInput : stdole.IUnknown
{
	/// <summary>
	///     The GetInputTrustAuthority method returns an Input Trust Authority
	///     for the specified presentation and stream.
	/// </summary>
	/// <param name="dwStreamID">
	///     [in]  The stream ID for which the ITA is being requested.
	/// </param>
	/// <param name="riid">
	///     [in]  The interface ID that is requested from the ITA.
	/// </param>
	/// <param name="ppv">
	///     [out]  A pointer to the requested interface of an ITA.
	/// </param>
	/// <returns>
	///     If the method succeeds, it returns S_OK.
	///     Otherwise it returns a failure code.
	///     If the decrypter does not support the requested interface,
	///     the failure code is E_NOINTERFACE.
	/// </returns>
	/// <remarks>
	///     The only value of riid currently passed in by MF is
	///     IID_IMFInputTrustAuthority.
	///     We are using custom marshalling for cross-process remoting
	///</remarks>
	HRESULT GetInputTrustAuthority(
		[in] DWORD dwStreamID,
		[in] REFIID riid,
		[out] stdole.IUnknown** ppunkObject
	);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

typedef enum MFPOLICYMANAGER_ACTION
{
	PEACTION_NO = 0,
	PEACTION_PLAY = 1,
	PEACTION_COPY = 2,
	PEACTION_EXPORT = 3,
	PEACTION_EXTRACT = 4,
	PEACTION_RESERVED1 = 5,
	PEACTION_RESERVED2 = 6,
	PEACTION_RESERVED3 = 7,
	PEACTION_LAST = 7
} MFPOLICYMANAGER_ACTION;

typedef struct MFINPUTTRUSTAUTHORITY_ACTION
{
	// action performed by the OTA
	MFPOLICYMANAGER_ACTION Action;

	// pointer to ticket object provided by the OTA
	LongPtr pbTicket;

	// size of the ticket object
	DWORD cbTicket;
} MFINPUTTRUSTAUTHORITY_ACCESS_ACTION;


/// <summary>
///   Contains parameters for BindAccess / UpdateAccess operation
///   PolicyEngine has to do following operations in order to call BindAccess
///   - go through the list OTAs which are receiving data from the ITA
///   - call OTA::SetPolicy passing PolicyObject from the ITA
///   - get Ticket object (Ticket can be returned from OTA::SetPolicy call or as part of MESetPolicy event)
///       * OTA can return NULL if it does not support tickets
///   - put action / ticket to rgOutputActions array
///   - sign structure. append signature at the end of the structure
/// </summary>
typedef struct MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS
{
	// sizeof of structure
	DWORD dwSize;

	// version. should be 0
	DWORD dwVer;

	// offset and size of signature blob
	DWORD cbSignatureOffset;
	DWORD cbSignatureSize;

	// offset and size of extension blob
	DWORD cbExtensionOffset;
	DWORD cbExtensionSize;

	// number of elements in rgOutputActions array
	DWORD cActions;

	// array of MFINPUTTRUSTAUTHORITY_ACCESS_ACTION structure
	// one structure per OTA / per action;
	MFINPUTTRUSTAUTHORITY_ACCESS_ACTION rgOutputActions[1];

} MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS;

interface IMFOutputPolicy;

/// <summary>
///     Input Trust Authorities implement IMFInputTrustAuthority. This
///     interface provides a common way for the rest of the PMP components
///     to talk to various input protection systems. In addition to the methods
///     inherited from IUnknown, IMFInputTrustAuthority also exposes the
//      following methods.
/// </summary>

[
	odl,
	uuid(D19F8E98-B126-4446-890C-5DCB7AD71453),
	helpstring("IMFInputTrustAuthority Interface"),
]
interface IMFInputTrustAuthority : stdole.IUnknown
{
	/// <summary>
	///     The GetDecrypter method returns a decrypter transform.
	///     <para>
	///         Usually protected content is encrypted when it is stored
	///         or transmitted.
	///         After it enters the Media Path via a media source or transform,     ///         it typically needs to be decrypted first as the majority
	///         of components in the Media Path can process
	///         clear content only. The decrypter transform does this.
	///     </para>
	///     <para>
	///         The PMP inserts the decrypter as the first node in the
	///         topology right after the node corresponding to the ITA.
	///         For every protected stream of the ITA node object there
	///         is a separate instance of the ITA and decrypter.
	///         However since the ITA node object hands out
	///         all ITA instances (via ITA Creator) it can arrange for the
	///         ITAs to be light objects that point to a common underlying
	///         object. For instance, the ASF media source does this
	///         for the WMDRM ITAs it hands out for its streams.
	///     </para>
	/// </summary>
	/// <param name="riid">
	///     [in]  The interface ID that is requested from the decrypter
	///     transform.
	/// </param>
	/// <param name="ppv">
	///     [out]  A pointer to the requested interface of a decrypter
	///     transform.
	/// </param>
	/// <returns>
	///     If the method succeeds, it returns S_OK.
	///     Otherwise it returns a failure code.
	///     If the decrypter does not support the requested interface,
	///     the failure code is E_NOINTERFACE.
	/// </returns>
	/// <remarks>
	///     The only value of riid currently passed in by the MF Policy Engine
	///     is IID_IMFTransform.
	///     <para>
	///         It is recommended that on creation the decrypter transform
	///         should be in a "disabled" state i.e. the ProcessOutput method
	///         should fail. After the ITA verifies that it is running inside
	///         the PMP,
	///         it should enable the decrypter.
	///         It can do this through a private interface, since
	///         the decrypter is handed out by the ITA.
	///         Having the decrypter disabled by default
	///         prevents the decrypter from being used outside the PMP.
	///     </para>
	///     <para>
	///         The ITA node object and ITA together should ensure that the
	///         decrypter transform that they hand out can accept the media
	///         type(s) possible for the corresponding input stream.
	///     </para>
	///</remarks>
	//[local]
	HRESULT GetDecrypter(
		[in] REFIID riid,
		[out] LPVOID ppv);


	/// <summary>
	///     Through the RequestAccess method the Policy Engine tells the ITA
	///     about the actions that will be performed with that stream.
	///     <para>
	///         At this point the ITA should do whatever work it needs to
	///         verify a user's right to do those actions, check licenses etc.
	///     </para>
	///     <para>
	///         This method may be called multiple times, once for every
	///         output that this stream goes to.
	///         The actions in each call may be different.
	///     </para>
	///     <para>
	///         Sometimes even if the user currently does not have the
	///         requested right, the ITA may be able to get the user that
	///         right by performing some additional steps, but
	///         user consent would be required before performing those steps.
	///         An example is license acquisition or individualization.
	///         In such a case the ITA should pass back
	///         an IMFActivate to a ContentEnabler object through
	///         ppContentEnablerActivate. The ContentEnabler
	///         implementation should be provided by the ITA and its
	///         methods should completely encapsulate the additional steps to
	///         be done. The Policy Engine will pass this to
	///         the application, let the application Activate and call the
	///         ContentEnabler methods after getting the user's consent.
	///         Once that completes, the Policy Engine will call RequestAccess
	///         once again on the ITA.
	///     </para>
	/// </summary>
	/// <param name="Action">
	///     [in]  An enum that says how the data from this stream is going
	///           to be used.
	/// </param>
	/// <param name="ppContentEnablerActivate">
	///     [out]  An optional IMFActivate to a ContentEnabler object.
	/// </param>
	/// <returns>
	///     If this verification succeeds, the ITA should return S_OK
	///     and pass back NULL in the optional ppContentEnablerActivate
	///     parameter.
	///     <para>
	///         If the verification results in a definite no,
	///         the ITA should return MF_E_NO_RIGHTS
	///         and pass back NULL in the optional ppContentEnablerActivate
	///         parameter.
	///     </para>
	///     <para>
	///         If the verification needs additional steps to be performed
	///         with user consent, the ITA should return MF_E_NEEDS_ENABLING
	///         and pass back an IMFActivate to a ContentEnabler
	///         pointer in the ppContentEnablerActivate parameter.
	///     </para>
	/// </returns>
	/// <remarks>
	///     Through RequestAccess the Policy Engine tells the ITA to only
	///     prepare for an action.
	///     The ITA should not assume that the action will definitely happen.
	///     For instance there might be a failure in one of the later steps
	///     before even a single media sample is pulled out of the input.
	///     When the action is definitely about to happen the Policy
	///     Engine calls BindAccess.
	///</remarks>
	//[local]
	HRESULT RequestAccess(
		[in] MFPOLICYMANAGER_ACTION Action,
		[out] IMFActivate** ppContentEnablerActivate);

	/// <summary>
	///     The GetPolicy method returns the policy that dictates which output
	///     protection systems to allow for the given stream and the
	///     configuration data for each protection system.
	/// </summary>
	/// <param name="Action">
	///     [in]  An enum that says how the data from this stream is going
	///           to be used. The policy returned is typically a function of
	///           the action being performed on that
	///     stream.
	/// </param>
	/// <param name="ppPolicy">
	///     [out]  An IMFOutputPolicy object for that stream for that action.
	///            See IMFOutputPolicy for details.
	/// </param>
	/// <returns>
	///     The ITA should return S_OK on success and an appropriate error code
	///     on failure.
	/// </returns>
	/// <remarks>
	///</remarks>
	//[local]
	HRESULT GetPolicy(
		[in] MFPOLICYMANAGER_ACTION Action,
		[out] IMFOutputPolicy** ppPolicy);

	/// <summary>
	///     Through the BindAccess method the Policy Engine informs the
	///     ITA that the action requested is definitely happening.
	///     This allows the ITA to change any internal state.
	///     For instance a WMDRM ITA might update the playcount remaining
	///     for that piece of content.
	///     <para>
	///         The action passed in through BindAccess must be the same
	///         as the one passed in earlier through RequestAccess.
	///     </para>
	/// </summary>
	/// <param name="pParam">
	///     [in]  pointer to the structure which contains parameters for BIND operation.
	/// </param>
	/// <returns>
	///     If the ITA approves of the action it should return S_OK.
	///     Otherwise it should return a failure code.
	/// </returns>
	/// <remarks>
	/// </remarks>
	//[local]
	HRESULT BindAccess(
		[in] MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS* pParam);

	/// <summary>
	///     Through the UpdateAccess method the Policy Engine informs
	///     the ITA of any changes in the pipeline that affect the
	///     cActionCount value passed in the preceding BindAccess call for
	///     this action.
	///     This allows the ITA to change any internal state.
	///     For instance a WMDRM ITA might update the copycount remaining
	///     for that piece of content.
	/// </summary>
	/// <param name="pParam">
	///     [in]  pointer to the structure which contains parameters for BIND operation.
	/// </param>
	/// <returns>
	///     If the ITA approves of the action it should return S_OK.
	///     Otherwise it should return a failure code.
	/// </returns>
	/// <remarks>
	/// </remarks>
	//[local]
	HRESULT UpdateAccess(
		[in] MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS* pParam);

	/// <summary>
	///     The Reset method tells the ITA to return to the initial state.
	///     Any decrypter it handed out should be disabled at this point.
	/// </summary>
	/// <returns>
	///     If the ITA can reset successfully it should return an S_OK,
	///     otherwise it should return an error code.
	/// </returns>
	/// <remarks>
	///     The Policy Engine currently ignores the return code from this
	///     method.
	///</remarks>
	HRESULT Reset(void);
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

interface IMFOutputTrustAuthority;

[
	odl,
	uuid(D19F8E95-B126-4446-890C-5DCB7AD71453),
	helpstring("IMFTrustedOutput Interface")
]
/// <summary>
///     Media sinks and transforms that are designed to work with the PMP
///     and send protected content outside the MF pipeline must implement
///     IMFTrustedOutput. Through this interface the Policy Engine negotiates
///     which type of content protection the output should apply.
/// </summary>
interface IMFTrustedOutput : stdole.IUnknown
{
	/// <summary>
	///     GetOutputTrustAuthorityCount returns the number of Output Trust
	///     Authorities being exposed by this output. A trusted output
	///     can expose one or more OTAs, each of which reports a single action.
	/// </summary>
	/// <param name="pcOutputTrustAuthorities">
	///     [out]  The number of Output Trust Authorities exposed by this
	///     output.
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	HRESULT GetOutputTrustAuthorityCount(
		[out] DWORD* pcOutputTrustAuthorities);

	/// <summary>
	///     GetOutputTrustAuthorityByIndex returns the Trust Authority for
	///     the output at
	///     the specified index, which exposes an action being executed by this
	///     output, and implements the content protection systems supported for
	///     that action.
	/// </summary>
	/// <param name="dwIndex">
	///     [in]  The index for the requested Trust Authority pointer.
	/// </param>
	/// <param name="ppauthority">
	///     [out]  The output returns the Output Trust Authority pointer
	///     through this.
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	HRESULT GetOutputTrustAuthorityByIndex(
		[in] DWORD dwIndex,
		[out] IMFOutputTrustAuthority** ppauthority);

	/// <summary>
	///     IsFinal returns whether the trusted output is to be considered a
	///     policy sink, or whether policy needs to be enforced further
	///     downstream of this trusted output.
	/// </summary>
	/// <param name="pfIsFinal">
	///     [out]  The value returned indicates whether this is a final output
	///     which acts as a policy sink.
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	/// <remarks>
	///     A trusted output is generally considered final if it ensures that
	///     it either does not give out any of the media content it receives,
	///     or any part of the content that it gives out is protected by
	///     its own proprietary methods (e.g. encryption) or sufficiently
	///     devalued so as to not require protection.
	///</remarks>
	HRESULT IsFinal(
		[out] BOOL* pfIsFinal);
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(D19F8E94-B126-4446-890C-5DCB7AD71453),
	helpstring("IMFOutputTrustAuthority Interface")
]
/// <summary>
///     The Output Trust Authority encapsulates the functionality of one or
///     more specific content protection systems that a trusted output supports.
///     Every output must provide an IMFOutputTrustAuthority (OTA)
///     implementation for each virtual output it encapsulates.
///     It may do this through one OTA object if those outputs have the same
///     action or multiple OTAs if they are different actions.
/// </summary>
interface IMFOutputTrustAuthority : stdole.IUnknown
{
	/// <summary>
	///     GetAction returns what the output trust authority does with the
	///     content.
	/// </summary>
	/// <param name="pAction">
	///     [in]  A pointer to an MFPOLICYMANAGER_ACTION enum.
	///     The output fills in the enum value that comes closest to
	///     describing what the output does with the content.
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	HRESULT GetAction(
		[out] MFPOLICYMANAGER_ACTION* pAction);

	/// <summary>
	///     Through SetPolicy the Policy Engine passes the output the
	///     Policy Objects provided by the ITAs, which specify which
	///     content protections to apply to the content.
	///     Content from multiple Input TAs may be given to the same
	///     output, so SetPolicy takes an array of Policy Objects
	/// </summary>
	/// <param name="ppPolicy">
	///     [in]  An array of Policy Objects, each packaged as an
	///     IMFOutputPolicy.
	///     Each Policy Object negotiates policy with the OTA and specifies the
	///     content protection systems to apply to all content received by the
	///     output henceforth.
	/// </param>
	/// <returns>
	///     The return value is S_OK if the output supports the specified
	///     content protection systems.
	////    Otherwise the return value is an error code.
	/// </returns>
	HRESULT SetPolicy(
		[in] IMFOutputPolicy* ppPolicy,
		[in] DWORD nPolicy,
		[out] LongPtr* ppbTicket,
		[out] DWORD* pcbTicket);
};

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

interface IMFOutputSchema;

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/// <summary>
///     The IMFOutputPolicy interface allows OTAs to query for the
///     protection systems they are required to enforce on each of their
///     outputs for the current content
/// </summary>

[
	odl,
	uuid(7F00F10A-DAED-41AF-AB26-5FDFA4DFBA3C),
	helpstring("IMFOutputPolicy Interface")
]
interface IMFOutputPolicy : IMFAttributes
{
	/// <summary>
	///     GenerateRequiredSchemas takes in the specifics of the output type
	///     and the list of protection systems supported by the output.
	///     It returns either an error code or an IMFOutputSchemaCollection
	///     pointer indicating a subset of the output's supported protection
	///     schemas that need to be enforced, along with configuration
	///     data for each protection schema that needs to be enforced.
	/// </summary>
	/// <param name="dwAttributes">
	///     [in]  A bitfield that indicates the attributes of an output
	///           that this OTA represents and of the media going over this
	///           output.
	/// </param>
	/// <param name="guidOutputID">
	///     [in]  A GUID that indicates a specific media output connector or
	///     family of connectors that this OTA represents.
	///     For instance, for an analog video output, this tells the
	///     Policy Object whether this is a Component, Composite, S-Video or
	///     VGA output.
	///     For a digital audio output, this tells the Policy Object whether
	///     this is a S/PDIF or HDMI output.
	/// </param>
	/// <param name="rgGuidProtectionSchemasSupported">
	///     [in]  An array of GUIDs that indicates the output protection
	///           schemas this OTA supports.
	///           This is used by the Policy Object to determine whether
	///           this output supports enough protection
	///           to meet the security bar of the content this policy is for
	/// </param>
	/// <param name="cProtectionSchemasSupported">
	///     [in]  A DWORD that indicates the number of GUIDs passed in the
	///           rgGuidProtectionSchemasSupported parameter.
	/// </param>
	/// <param name="ppRequiredProtectionSchemas">
	///     [out]  A pointer to an IMFOutputSchemaCollection that will store
	///            the collection of IMFOutputSchema's to indicate the
	///            protection schemas this OTA is required to enforce on
	///            the specified output
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	HRESULT GenerateRequiredSchemas(
		[in] DWORD dwAttributes,
		[in] long guidOutputSubType1, [in] long guidOutputSubType2, [in] long guidOutputSubType3, [in] long guidOutputSubType4,
		[in] GUID* rgGuidProtectionSchemasSupported,
		[in] DWORD cProtectionSchemasSupported,
		[out] IMFCollection** ppRequiredProtectionSchemas);

	/// <summary>
	///     GetOriginatorID returns a GUID identifying the ITA originator
	///     of this Policy Object.
	///     The OriginatorID of an ITA should be the same for all of the
	///     Policy Objects and Output Schemas it gives out, as well as those
	///     given out by its topology component for dynamic policy changes.
	///     However, it should be unique from all the other ITAs that could
	///     give Policy Objects and Output Schemas to an OTA.
	/// </summary>
	/// <param name="pguidOriginatorID">
	///     [out]  A pointer to a GUID that will store the ID of the
	////           originator of this Policy Object.
	///            The Originator ID allows the OTA to distinguish
	///            Policy Objects coming from different ITAs, so it can
	///            know which one to update during dynamic policy changes
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	HRESULT GetOriginatorID(
		[out] GUID* pguidOriginatorID);

	/// <summary>
	///     GetMinimumGRLVersion returns a DWORD indicating the minimum version
	///     of the Global Revocation List that needs to be enforced by the
	///     Protected Environment to process the content that this
	///     policy applies to.
	/// </summary>
	/// <param name="pdwMinimumGRLVersion">
	///     [out]  A pointer to a DWORD that will store the minimum version
	///            of the GRL required for the content associated with this
	///            Policy Object.
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	/// <remarks>
	///     In MF v1, we do not support dynamic changes to a content's
	///     security level requirements within a single presentation.
	///     The content security level is checked before content streaming
	///     begins, and is assumed to remain constant for the duration of
	///     that presentation.
	///     If content exposes a new Policy Object via dynamic policy changes,
	///     any changes to the SL value will not be handled.
	///</remarks>
	HRESULT GetMinimumGRLVersion(
		[out] DWORD* pdwMinimumGRLVersion);
};

/// <summary>
///     The IMFOutputSchema interface encapsulates information for a single
///     output protection system and its corresponding configuration data.
///     IMFAttributes is used to store configuration data beyond the default DWORD
/// </summary>

[
	odl,
	uuid(7BE0FC5B-ABD9-44FB-A5C8-F50136E71599),
	helpstring("IMFOutputSchema Interface")
]
interface IMFOutputSchema : IMFAttributes
{
	/// <summary>
	///     GetSchemaType returns the GUID for the output protection system specified
	///     by this IMFOutputSchema.
	/// </summary>
	/// <param name="guidSchemaType">
	///     [out]  A GUID representing a specific output protection system.
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	HRESULT GetSchemaType(
		[out] GUID* pguidSchemaType);

	/// <summary>
	///     GetConfigurationData provides OTAs easy access to policy configuration data
	///     if that data does not need more than a DWORD of space (this is true for many
	///     of our OTAs right now.
	/// </summary>
	/// <param name="pdwVal">
	///     [out]  A pointer to a DWORD that will store the basic configuration data
	///     for the protection scheme specified by this IMFOutputSchema. The semantics
	///     of the DWORD vary across protection schemes.
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	HRESULT GetConfigurationData(
		[out] DWORD* pdwVal);

	/// <summary>
	///     GetOriginatorID returns a GUID identifying the ITA originator of this Output Schema.
	///     The OriginatorID of an ITA should be the same for all of the Policy Objects and Output Schemas
	///     it gives out, as well as those given out by its topology component for dynamic policy changes.
	///     However, it should be unique from all the other ITAs that could give Policy Objects and
	///     Output Schemas to an OTA.
	/// </summary>
	/// <param name="pguidOriginatorID">
	///     [out]  A pointer to a GUID that will store the ID of the originator of this Output
	///     Schema. The Originator ID allows the OTA to distinguish Output Schemas coming from
	///     different ITAs, so it can know which one to update during content protection messages
	/// </param>
	/// <returns>
	///     The return value is S_OK on success, and an error code otherwise.
	/// </returns>
	HRESULT GetOriginatorID(
		[out] GUID* pguidOriginatorID);

};


//  Protection levels for MFPROTECTION_CGMSA
typedef enum MF_OPM_CGMSA_PROTECTION_LEVEL
{
	MF_OPM_CGMSA_OFF = 0x00,
	MF_OPM_CGMSA_COPY_FREELY = 0x01,
	MF_OPM_CGMSA_COPY_NO_MORE = 0x02,
	MF_OPM_CGMSA_COPY_ONE_GENERATION = 0x03,
	MF_OPM_CGMSA_COPY_NEVER = 0x04,
	MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = 0x08,
} MF_OPM_CGMSA_PROTECTION_LEVEL;

//  Protection levels for MFPROTECTION_ACP
typedef enum MF_OPM_ACP_PROTECTION_LEVEL
{
	MF_OPM_ACP_OFF = 0,
	MF_OPM_ACP_LEVEL_ONE = 1,
	MF_OPM_ACP_LEVEL_TWO = 2,
	MF_OPM_ACP_LEVEL_THREE = 3,
	MF_OPM_ACP_FORCE_ULONG = 0x7fffffff
} MF_OPM_ACP_PROTECTION_LEVEL;

/// <summary>
///     IMFSecureChannel is the base level interfaced used for initializing
///     a one-way secure channel between a host and a client. The client
///     implements the IMFSecureChannel interface, which the host calls methods
///     on to setup the channel.
/// </summary>

[
	odl,
	uuid(d0ae555d-3b12-4d97-b060-0990bc5aeb67)
]
interface IMFSecureChannel : stdole.IUnknown
{
	/// <summary>
	///     GetCertificate should return the client's secure channel
	///     certificate.
	/// </summary>
	/// <param name="ppCoTaskMemCert">
	///     ppCoTaskMemCert receives a pointer to a chunk of memory containing
	///     the secure channel certificate. This memory should be allocated
	///     by the callee using CoTaskMemAlloc, and must be freed by the caller
	///     using CoTaskMemFree.
	/// </param>
	/// <param name="pcbCert">
	///     pcbCert receives the length of the buffer returned by the
	///     ppCoTaskMemCert parameter.
	/// </param>
	HRESULT GetCertificate([out] LongPtr* ppCert, [out] DWORD* pcbCert);

	/// <summary>
	///     SetupSession passes the encrypted session key to the callee. The
	///     callee should decrypt this key and use it as the session key for
	///     the secure channel connection.
	/// </summary>
	/// <param name="pbEncryptedSessionKey">
	///     Contains a pointer to a chunk of memory containing the encrypted
	///     session key.
	/// </param>
	/// <param name="cbSessionKey">
	///     Contains the length of the memory buffer pointed to by the
	///     pbEncryptedSessionKey parameter.
	/// </param>
	HRESULT SetupSession([in] BYTE* pbEncryptedSessionKey, [in] DWORD cbSessionKey);
};

typedef enum SAMPLE_PROTECTION_VERSION
{
	SAMPLE_PROTECTION_VERSION_NO = 0,
	SAMPLE_PROTECTION_VERSION_BASIC_LOKI = 1,
	SAMPLE_PROTECTION_VERSION_SCATTER = 2,
	SAMPLE_PROTECTION_VERSION_RC4 = 3,
	SAMPLE_PROTECTION_VERSION_AES128CTR = 4,
} SAMPLE_PROTECTION_VERSION;


[
	odl,
	uuid(8e36395f-c7b9-43c4-a54d-512b4af63c95)
]
interface IMFSampleProtection : stdole.IUnknown
{
	/// <summary>
	///     GetInputProtectionVersion returns the version of sample protection implemented by
	///     the component on the input.
	/// </summary>
	/// <param name="pdwVersion">
	///     pdwVersion receives a DWORD containing the version number.
	/// </param>
	HRESULT GetInputProtectionVersion([out] DWORD* pdwVersion);

	/// <summary>
	///     GetOutputProtectionVersion returns the version of sample protection implemented by
	///     the component on the input.
	/// </summary>
	/// <param name="pdwVersion">
	///     pdwVersion receives a DWORD containing the version number.
	/// </param>
	HRESULT GetOutputProtectionVersion([out] DWORD* pdwVersion);

	/// <summary>
	///     GetProtectionCertificate only needs to be implemented for a
	///     downstream component providing sample protection for certain
	///     version numbers of sample protection. It returns the sample
	///     protection certificate of that component.
	///     Components which do not need to implement the certificate
	///     functionality should simply return E_NOTIMPL.
	/// </summary>
	/// <param name="dwVersion">
	///     Contains the version number of the sample protection scheme for
	///     which to receive the sample protection certificate.
	/// </param>
	/// <param name="ppMemCert">
	///     Receives a pointer to a memory buffer containing the sample
	///     protection certificate. This memory should be allocated by the
	///     callee using CoTaskMemAlloc and freed by the caller using
	///     CoTaskMemFree.
	/// </param>
	/// <param name="pcbCert">
	///     Receives the length of the memory buffer returned in the
	///     ppCoTaskMemCert parameter.
	/// </param>
	HRESULT GetProtectionCertificate([in] DWORD dwVersion,
		[out] LongPtr* ppCert,
		[out] DWORD* pcbCert);

	/// <summary>
	///     InitOutputProtection is implemented by an upstream component
	///     providing sample protection functionality. It receives a version
	///     number for the sample protection scheme to use, and returns
	///     initialization information specific to that sample protection
	///     scheme.
	///     The component should return a failure code if the specified version
	///     of sample protection is not supported.
	///     A downstream component should return E_NOTIMPL for this method.
	/// </summary>
	/// <param name="dwVersion">
	///     Specifies the version number of sample protection to be used.
	/// </param>
	/// <param name="dwOutputId">
	///     Specifies the ID of the output (output ID for IMFTransform)
	/// </param>
	/// <param name="pbCert">
	///     Pointer to certificate blob provided by the downstream component
	/// </param>
	/// <param name="pbCert">
	///     Size to certificate blob provided by the downstream component
	/// </param>
	/// <param name="ppbSeed">
	///     Receives the initialization information for downstream component.
	///     This information should be deallocated by the caller using the
	///     CoTaskMemFree method.
	/// </param>
	/// <param name="pcbSeed">
	///     Receives the size of initialization information.
	/// </param>
	HRESULT InitOutputProtection([in] DWORD dwVersion,
		[in] DWORD dwOutputId,
		[in] BYTE* pbCert,
		[in] DWORD cbCert,
		[out] BYTE** ppbSeed,
		[out] DWORD* pcbSeed);

	/// <summary>
	///     InitInputProtection is implemented by a downstream component
	///     providing sample protection functionality. It takes a version
	///     number of sample protection, along with initialization information
	///     specific to that sample protection scheme.
	///     The method should return a failure code in the event that the
	///     component does not support the specified version of sample
	///     protection.
	///     An upstream component should return E_NOTIMPL for this method.
	/// </summary>
	/// <param name="dwVersion">
	///     Specifies the version number of sample protection to be used.
	/// </param>
	/// <param name="dwInputId">
	///     Specifies the ID of the input (input ID for IMFTransform or stream ID for IMFMediaSink)
	/// </param>
	/// <param name="pbSeed">
	///     Specifies the initialization information provided by the upstream node.
	///     The callee should copy this information if it is needed outside the
	///     scope of this call.
	/// </param>
	/// <param name="cbSeed">
	///     Specifies the size of initialization information contained in a
	///     pbSeed.
	/// </param>
	HRESULT InitInputProtection([in] DWORD dwVersion,
		[in] DWORD dwInputId,
		[in] BYTE* pbSeed,
		[in] DWORD cbSeed);
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// Media Foundation Media Source/Sink: interfaces for advanced implementations
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///
/// <summary>
///     IMFMediaSinkPreroll is optionally implemented by Media Sinks
///     that are able to preroll.  Prerolling helps avoid glitches
///     upon startup.
/// </summary>

[
	odl,
	uuid(5dfd4b2a-7674-4110-a4e6-8a68fd5f3688)
]
interface IMFMediaSinkPreroll : stdole.IUnknown
{
	/// <summary>
	///
	/// </summary>
	/// <param name="hnsUpcomingStartTime">
	///     An MFTIME indicating what the start time for IMFClock::Start call
	/// </param>
	/// <remarks>
	///     <para>
	///         For all IMFStreamSink::ProcessSample calls received
	///         between this call and the IMFClockStateSink::OnClockStart call,
	///         any necessary work should be done on the sample to prepare it
	///         to be processed, but the sample should not be rendered until
	///         OnClockStart is received.
	///     </para>
	/// </remarks>
	HRESULT NotifyPreroll(
		[in] MFTIME hnsUpcomingStartTime
	);
};

[
	odl,
	uuid(EAECB74A-9A50-42ce-9541-6A7F57AA4AD7)
]
/// <summary>
///     IMFFinalizableMediaSink is optionally supported by Media Sinks
///     that finish its time-consuming tasks before shutdown.
/// </summary>
interface IMFFinalizableMediaSink : IMFMediaSink
{
	///
	/// <summary>
	///     BeginFinalize tells the Media Sink to asynchronously
	///     take any steps it needs to finish its tasks.
	/// </summary>
	/// <param name="pCallback">
	///     Pointer to an Asynchronous Callback object.
	///     Should not be NULL.
	/// </param>
	/// <param name="punkState">
	///     Pointer to user-defined state that will be returned with the
	///     sample in the call to pCallback->Invoke.
	/// </param>
	/// <remarks>
	///     <para>
	///         Many archive Media Sinks have steps they need to do at
	///         the end of archiving to finish up the file, such as updating
	///         the header (for some formats) or flushing all pending writes
	///         to disk.  In some cases, this may include expensive operations
	///         (such as indexing the content).
	///         this is an asynchronous way to do this.
	///     </para>
	///     <para>
	///         Making this call is optional
	///     </para>
	/// </remarks>
	HRESULT BeginFinalize(
		[in] IMFAsyncCallback* pCallback,
		[in] stdole.IUnknown* punkState
	);

	/// <summary>
	///     EndFinalize should be called when the async callback
	///     given to BeginFinalize is invoked.
	/// </summary>
	/// <param name="pResult">
	///     Pointer to the Asynchronous Result which was passed into the
	///     IMFAsyncCallbackInvoke on the user's Asynchronous Callback object.
	///     Should not be NULL.
	/// </param>
	HRESULT EndFinalize(
		[in] IMFAsyncResult* pResult
	);
};

/// <summary>
///     IMFStreamingSinkConfig is optionally supported by Media Sinks.
///     The interface is used for passing configuration information to
///     Media Sinks that are used for streaming.
/// </summary>

[
	odl,
	uuid(9db7aa41-3cc5-40d4-8509-555804ad34cc)
]
interface IMFStreamingSinkConfig : stdole.IUnknown
{
	/// <summary>
	///     StartStreaming should be called before the Media Session
	///     is started.
	/// </summary>
	/// <param name="fSeekOffsetIsByteOffset">
	///     If TRUE, qwSeekOffset is the byte position specified by the
	///     streaming media client.  If FALSE, qwSeekOffset is the time
	///     position, in hundreds of nanoseconds, which was specified by
	///     the streaming media client.
	/// </param>
	/// <param name="qwSeekOffset">
	///     Either a byte offset or a time offset, depending on the value
	///     of fSeekOffsetIsByteOffset.  Time offsets are specified in
	///     hundreds of nanoseconds.
	/// </param>
	HRESULT StartStreaming(
		[in] BOOL fSeekOffsetIsByteOffset,
		[in] QWORD qwSeekOffset
	);
};

///////////////////////////////////////////////////////////////////////////////
//
// Media Foundation playback quality
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// Media Foundation interfaces for use with advanced content protection
// scenarios
//
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

/// <summary>
/// when pipeline runs source in the remote process, pipeline creates a special proxy objects in the application
/// process for source and sequencer. All proxy objects should implement the IMFRemoteProxy interface in order for
/// pipeline to access remote object and proxy host.
/// </summary>
[
	odl,
	uuid(994e23ad-1cc2-493c-b9fa-46f1cb040fa4)
]
interface IMFRemoteProxy : stdole.IUnknown
{
	HRESULT GetRemoteObject(
		[in] REFIID riid,
		[out] LPVOID ppv);

	HRESULT GetRemoteHost(
		[in] REFIID riid,
		[out] LPVOID ppv);
};

/// <summary>
///     Provide a way for activate to marshal interface across process.
///     If the activate can't be created in the remote process, the platform will know how to unmarshal the interface for the activate
/// </summary>

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(09EF5BE3-C8A7-469e-8B70-73BF25BB193F)
]
interface IMFObjectReferenceStream : stdole.IUnknown
{

	HRESULT SaveReference(
		[in] REFIID riid,
		[in] stdole.IUnknown* pUnk);

	HRESULT LoadReference(
		[in] REFIID riid,
		[out] LPVOID ppv);
};

[
	odl,
	uuid(F70CA1A9-FDC7-4782-B994-ADFFB1C98606),
]
interface IMFPMPHost : stdole.IUnknown
{
		/// <summary>
		///     Locks process from shutdown. If lock count is not 0, process will wait for 3 sec before terminating after shutdown
		/// </summary>
		HRESULT LockProcess(void);

	/// <summary>
	///     Unlocks process from shutdown
	/// </summary>
	HRESULT UnlockProcess(void);

	/// <summary>
	///     Creates object in pmp process by clsid
	/// </summary>
	/// <param name="pStream">
	///     Optional pointer to serialized object.
	///     If pointer is provided, pmp host will QI object for IPersistStream interface and call IPersistStream::Load
	/// </param>
	//[local]
	HRESULT CreateObjectByCLSID(
		[in] REFCLSID clsid,
		[in] IStream* pStream,
		[in] REFIID riid,
		[out] LPVOID ppv);

	//[call_as(CreateObjectByCLSID)]
	//HRESULT RemoteCreateObjectByCLSID(
	//	[in] REFCLSID clsid,
	//	[in, unique, size_is(cbData)] BYTE* pbData,
	//	[in] DWORD cbData,
	//	[in] REFIID riid,
	//	[out, iid_is(riid)] void** ppv);
};


/// <summary>
///     IMFPMPClient is the interface implemented by components (usualy sources)
///     which need access to IMFPMPHost
/// </summary>

[
	odl,
	uuid(6C4E655D-EAD8-4421-B6B9-54DCDBBDF820)
]
interface IMFPMPClient : stdole.IUnknown
{
	/// <summary>
	///     Initialize the component with IMFPMPHost.
	/// </summary>
	HRESULT SetPMPHost(
		[in] IMFPMPHost * pPMPHost
	);
};
/// <summary>
///     The IMFPMPServer interface is an internal interface used to communicate between PMPSession and  PMPHost objects
///     It provides methods to create and setup objects in PMP process.
/// </summary>

[
	odl,
	uuid(994e23af-1cc2-493c-b9fa-46f1cb040fa4)
]
interface IMFPMPServer : stdole.IUnknown
{
	/// <summary>
	///     Locks process from shutdown. If lock count is not 0, process will wait for 3 sec before terminating after shutdown
	/// </summary>
	HRESULT LockProcess(void);

	/// <summary>
	///     Unlocks process from shutdown
	/// </summary>
	HRESULT UnlockProcess(void);

	/// <summary>
	///     Creates object in the PMP process.
	/// </summary>
	HRESULT CreateObjectByCLSID(
		[in] REFCLSID clsid,
		[in] REFIID riid,
		[out] LPVOID ppObject);
};

/// <summary>
///     The IMFRemoteDesktopPlugin interface is expose by remote desktop plugin
///     Application should create remote desktop plugin and call it for every partial topology
/// </summary>

[
	odl,
	uuid(1cde6309-cae0-4940-907e-c1ec9c3d1d4a)
]
interface IMFRemoteDesktopPlugin : stdole.IUnknown
{
	/// <summary>
	///     Called by application to update topology
	/// </summary>
	HRESULT UpdateTopology(
		[in, out] IMFTopology* pTopology);
};

[
	odl,
	uuid(A7E025DD-5303-4a62-89D6-E747E1EFAC73)
]
interface IMFSAMIStyle : stdole.IUnknown
{
	/// <summary>
	///     Gets the total number of styles
	/// </summary>
	HRESULT GetStyleCount([out]           DWORD * pdwCount);

/// <summary>
///     Gets all of the styles as a string array in a PROPVARIANT.
///     The caller must properly clear the PROPVARIANT to avoid memory leaks.
/// </summary>
HRESULT GetStyles([out]               VARIANT* pPropVarStyleArray);

/// <summary>
///     Sets the current selected style to the provided style.
/// </summary>
HRESULT SetSelectedStyle([in]          LongPtr pwszStyle);

/// <summary>
///     Gets the currently selected style.
///     The returned string must be deallocated using CoTaskMemFree().
/// </summary>
HRESULT GetSelectedStyle([out] LongPtr* ppwszStyle);
};

////////////////////////////////////////////////////////////////////////////
//
// Transcode APIs
//
/////////////////////////////////////////////////////////////////////////////
/// <summary>
///     IMFTranscodeProfile is for setting transcode configurations
/// 	that user perfers for the transcoded output media file.
/// </summary>
[
	odl,
	uuid(4ADFDBA3-7AB0-4953-A62B-461E7FF3DA1E),
]
interface IMFTranscodeProfile : stdole.IUnknown
{
	/// <summary>
	///     SetAudioAttributes is used to specify the audio stream settings.
	///     These attributes are the ones defined by MF audio media type.
	/// </summary>
	/// <param name="pAttrs">
	///     A pointer to an IMFAttributes object having the audio stream settings.
	/// </param>
	HRESULT SetAudioAttributes([in] IMFAttributes* pAttrs);

	/// <summary>
	///     GetAudioAttributes is used to get the audio stream settings.
	/// </summary>
	/// <param name="ppAttrs">
	///     Specifies a pointer to a variable where IMFAttributes object stored.
	///     If no audio attributes have been set,
	///     GetAudioAttributes expected to succeed and return NULL.
	/// </param>
	HRESULT GetAudioAttributes([out] IMFAttributes** ppAttrs);

	/// <summary>
	///     SetVideoAttributes is used to specify the video stream settings.
	///     These attributes are the ones defined by MF video media type.
	/// </summary>
	/// <param name="pAttrs">
	///     A pointer to an IMFAttributes object having the video stream settings.
	///     If no video attributes have been set,
	///     GetVideoAttributes expected to succeed and return NULL.
	/// </param>
	HRESULT SetVideoAttributes([in] IMFAttributes* pAttrs);

	/// <summary>
	///     GetVideoAttributes is used to get the video stream settings.
	/// </summary>
	/// <param name="ppAttrs">
	///     Specifies a pointer to a variable where IMFAttributes object stored.
	/// </param>
	HRESULT GetVideoAttributes([out] IMFAttributes** ppAttrs);

	/// <summary>
	///     SetContainerAttributes is used to specify the container settings.
	///     These attributes are defined by transcode APIs.
	/// </summary>
	/// <param name="pAttrs">
	///     A pointer to an IMFAttributes object having the container settings.
	/// </param>
	HRESULT SetContainerAttributes([in] IMFAttributes* pAttrs);

	/// <summary>
	///     GetContainerAttributes is used to get the container settings.
	/// </summary>
	/// <param name="ppAttrs">
	///     Specifies a pointer to a variable where IMFAttributes object stored.
	///     If no container attributes have been set,
	///     GetContainerAttributes expected to succeed and return NULL.
	/// </param>
	HRESULT GetContainerAttributes([out] IMFAttributes** ppAttrs);
};


typedef enum MF_TRANSCODE_TOPOLOGYMODE_FLAGS
{
	// Only software MFTs inserted into a trancode topology, by default
	MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY = 0,
	// Allow hardware MFTs inserted into a trancode topology
	MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED = 1

	// Reserved for future use   
} MF_TRANSCODE_TOPOLOGYMODE_FLAGS;

typedef enum MF_TRANSCODE_ADJUST_PROFILE_FLAGS
{
	// Only adjust the frame rate/interlace mode if needed, by default
	MF_TRANSCODE_ADJUST_PROFILE_DEFAULT = 0,
	// Fill the missing media type attributes by the source media type. It does not overwrite the already set stream-level attributes. 
	MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES = 1

	//  Reserved for future use
} MF_TRANSCODE_ADJUST_PROFILE_FLAGS;

typedef enum MF_VIDEO_PROCESSOR_ALGORITHM_TYPE
{
	// default mode favors a balance of quality and speed
	MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT = 0,

	// the VP will always internally process in AYUV and use high quality filters
	MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444 = 1

} MF_VIDEO_PROCESSOR_ALGORITHM_TYPE;

typedef struct MF_TRANSCODE_SINK_INFO {
	DWORD dwVideoStreamID;
	IMFMediaType* pVideoMediaType;
	DWORD dwAudioStreamID;
	IMFMediaType* pAudioMediaType;
} MF_TRANSCODE_SINK_INFO;

[
	odl,
	uuid(8CFFCD2E-5A03-4a3a-AFF7-EDCD107C620E)
]
interface IMFTranscodeSinkInfoProvider : stdole.IUnknown
{
	HRESULT SetOutputFile([in] LongPtr pwszFileName);
	HRESULT SetOutputByteStream([in] IMFActivate* pByteStreamActivate);
	HRESULT SetProfile([in] IMFTranscodeProfile* pProfile);
	HRESULT GetSinkInfo([out] MF_TRANSCODE_SINK_INFO* pSinkInfo);
};
/// <summary>
///     IMFFieldOfUseMFTUnlock manages the unlocking process on behalf of the application
/// </summary>
/// <remarks>
///     Restricted MFTs need to be unlocked at creation time, otherwise both the type negociation
///     and data processing will fail with error codes MF_E_UNAUTHORIZED.
/// </remarks>

[
	odl,
	uuid(508E71D3-EC66-4fc3-8775-B4B9ED6BA847),
]
interface IMFFieldOfUseMFTUnlock : stdole.IUnknown
{
	/// <summary>
	///     Unlock manages the unlocking process on behalf of the application.
	/// </summary>
	/// <param name="pUnkMFT">
	///     Points to the IUnknown interface of the MFT to unlock.
	/// </param>
	/// <returns>
	///     The return value is S_OK if the MFT has been successfully unlocked, and an error code otherwise.
	/// </returns>
	HRESULT Unlock(
		[in] stdole.IUnknown* pUnkMFT
	);
}

typedef struct MFT_REGISTRATION_INFO
{
	CLSID clsid;
	GUID guidCategory;
	UINT32 uiFlags;
	LongPtr pszName;
	DWORD cInTypes;
	LongPtr pInTypes;
	DWORD cOutTypes;
	LongPtr pOutTypes;
} MFT_REGISTRATION_INFO;
/// <summary>
///     IMFLocalMFTRegistration is a service interface exposed by the session.  Using this
///     service, applications can register an MFT locally for its own use.  If the session
///     is running cross-process, the registration will be remoted into the remote process.
/// </summary>

[
	odl,
	uuid(149c4d73-b4be-4f8d-8b87-079e926b6add),
]
interface IMFLocalMFTRegistration : stdole.IUnknown
{
	/// <summary>
	///     Call RegisterMFTs to locally register a set of MFTs defined by an array
	///     of MFT_REGISTRATION_INFO structures.
	/// </summary>
	/// <param name="pMFTs">
	///     Points to an array of MFT_REGISTRATION_INFO structures.  The MFTs defined
	///     by these structures will be registered locally.
	/// </param>
	/// <param name="cMFTs">
	///     Defines how many MFT_REGISTRATION_INFO structures are pointed to by pMFTs.
	/// </param>
	///  <returns>
	///     S_OK on sucessful registration.  An error code may be returned if there is
	///     a problem remoting the registrations into the remote process.
	///  </returns>
	HRESULT RegisterMFTs([in] MFT_REGISTRATION_INFO * pMFTs,[in] DWORD cMFTs);
};

/// <summary>
///     IMFPMPHostApp supply the methods for creating object in the PMP process
/// </summary>

[
	odl,
	uuid(84d2054a-3aa1-4728-a3b0-440a418cf49c)
]
interface IMFPMPHostApp : stdole.IUnknown
{
	HRESULT LockProcess(void);
	HRESULT UnlockProcess(void);
	HRESULT ActivateClassById(
		[in] LongPtr id,
		[in] IStream* pStream,
		[in] REFIID riid,
		[out] LPVOID ppv);
};
/// <summary>
///     IMFPMPClient is the interface implemented by components (usualy sources)
///     which need access to IMFPMPHost
/// </summary>

[
	odl,
	uuid(c004f646-be2c-48f3-93a2-a0983eba1108)
]
interface IMFPMPClientApp : stdole.IUnknown
{
	/// <summary>
	///     Initialize the component with IMFPMPHost.
	/// </summary>
	HRESULT SetPMPHost(
		[in] IMFPMPHostApp * pPMPHost
	);
};

/// <summary>
///     MFMediaStreamSourceSampleRequest is implemented by the
///     Windows.Media.Core.MediaStreamSourceSampleRequest runtime class.
/// </summary>

[
	odl,
	uuid(380b9af9-a85b-4e78-a2af-ea5ce645c6b4)
]
interface IMFMediaStreamSourceSampleRequest : stdole.IUnknown
{
	HRESULT SetSample([in] IMFSample * value);
};


/// <summary>
//  The IMFTrackedSample interface is used to notify allocators when their 
//  samples are no longer in use by other clients.
/// </summary>
[
	odl,
	uuid(245BF8E9-0755-40f7-88A5-AE0F18D55E17),
	helpstring("IMFTrackedSample Interface")
]
interface IMFTrackedSample : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  This method sets the allocator on a sample. 
	//
	// Parameters:
	//
	//  pSampleAllocator - The sample allocator interface to be notified when all 
	//      clients have finished with a sample.
	//  punkState - Caller supplied state that will be furnished during the 
	//      Invoke call. This value will be addref'ed and it is therefore 
	//      recommended that the object passed be a pointer to the 
	//      object itself. This will guarantee that the 
	//      object does not disappear during the call.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  When the reference count
	//  on the sample reaches 1, indicating that only the owner (allocator)
	//  holds a reference, the owner will receive a callback. The allocator 
	//  interface will be subsequently NULL'ed out. This interface ensures that 
	//  the allocator does not get freed while it has samples outstanding.
	//
	HRESULT SetAllocator(
		[in] IMFAsyncCallback* pSampleAllocator,
		[in] stdole.IUnknown* pUnkState
	);
};

interface IMFSignedLibrary;

[
	odl,
	uuid(ef5dc845-f0d9-4ec9-b00c-cb5183d38434)
]
interface IMFProtectedEnvironmentAccess : stdole.IUnknown
{
	HRESULT Call([in] UINT32 inputLength, [in] BYTE* input,
		[in] UINT32 outputLength, [in, out] BYTE* output);
	HRESULT ReadGRL([out] UINT32* outputLength, [out] LongPtr* output);
};

[
	odl,
	uuid(4a724bca-ff6a-4c07-8e0d-7a358421cf06)
]
interface IMFSignedLibrary : stdole.IUnknown
{
	HRESULT GetProcedureAddress([in] LPSTR name, [out] LongPtr* address);
};

[
	odl,
	uuid(fff4af3a-1fc1-4ef9-a29b-d26c49e2f31a)
]
interface IMFSystemId : stdole.IUnknown
{
	HRESULT GetData([out] UINT32* size, [out] LongPtr* data);
	HRESULT Setup([in] UINT32 stage,
		[in] INT32 cbIn, [in] BYTE* pbIn,
		[out] UINT32* pcbOut, [out] LongPtr* ppbOut);

};

typedef struct MFCONTENTPROTECTIONDEVICE_INPUT_DATA
{
	/// <member name="HWProtectionFunctionID">
	/// Identifier of the function that needs to be executed. To be defined by protection system implementation.
	/// </member>
	DWORD HWProtectionFunctionID;

	/// <member name="PrivateDataByteCount">
	/// Contains the size of the private data reserved by the security processor implementation. Determined by calling IMFContentProtectionDevice::GetPrivateDataByteCount
	/// </member>
	DWORD PrivateDataByteCount;

	/// <member name="HWProtectionDataByteCount">
	/// Contains the size of the data for the protection system function to be executed.
	/// </member>
	DWORD HWProtectionDataByteCount;

	/// does not disturb 8-byte alignment
	DWORD Reserved;

	/// <member name="InputData">
	/// If PrivateDataByteCount is greater than 0, InputData[0]  InputData[PrivateDataSize - 1] is reserved for IHV use.
	/// InputData[PrivateDataByteCount]  InputData[HWProtectionDataByteCount + PrivateDataByteCount - 1] contains the input data for the protection system command. 
	/// The format and size of the DRM command is defined by the protection system specification.
	/// </member>
	BYTE InputData[4];
} MFCONTENTPROTECTIONDEVICE_INPUT_DATA;


typedef struct MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA
{
	/// <member name="PrivateDataByteCount">
	/// Contains the size of the private data reserved by the security processor implementation. Determined by calling IMFContentProtectionDevice::GetPrivateDataByteCount
	/// </member>
	DWORD PrivateDataByteCount;

	/// <member name="MaxHWProtectionDataByteCount">
	/// The maximum size of data that the IHV can return in the output buffer.
	/// </member>
	DWORD MaxHWProtectionDataByteCount;

	/// <member name="HWProtectionDataByteCount">
	/// Returns the size of the output data written by the IHV.
	/// </member>
	DWORD HWProtectionDataByteCount;

	/// <member name="Status">
	/// Returns the result of the protection system command.
	/// </member>
	HRESULT Status;

	/// <member name="TransportTimeInHundredsOfNanoseconds">
	/// Returns the number of 100 nanosecond units spent transporting the data. 
	/// </member>
	LONGLONG TransportTimeInHundredsOfNanoseconds;

	/// <member name="ExecutionTimeInHundredsOfNanoseconds">
	/// Returns the number of 100 nanosecond units spent executing the protection system command.
	/// </member>
	LONGLONG ExecutionTimeInHundredsOfNanoseconds;

	/// <member name="OutputData">
	/// If PrivateDataSize is greater than 0, OutputData[0]  OutputData[PrivateDataByteCount - 1] is reserved for IHV use.
	/// pbOutput[PrivateDataByteCount]  pbOutput[MaxHWProtectionDataByteCount + PrivateDataByteCount - 1] contains the region 
	/// into which the driver should return the output data from the protection system command.The format and size of the 
	/// command is defined by the protection system specification.
	/// </member>
	BYTE OutputData[4];
} MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA;

typedef struct MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {
    DWORD TaskIndex;
    WCHAR ClassName[260];
    LONG BasePriority;
} MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA;

[
	odl,
	uuid(E6257174-A060-4C9A-A088-3B1B471CAD28)
]
interface IMFContentProtectionDevice : stdole.IUnknown
{
	/// Calls into the protection system ID implementation in the security processor.
	/// <param name=FunctionId>Identifier of the function that needs to be executed. To be defined by protection system ID implementation</param>
	/// <param name=InputBufferByteCount>Number of bytes of buffer InputBuffer including private data </param>
	/// <param name=InputBuffer>Pointer to the input data </param>
	/// <param name=OutputBufferByteCount>Pointer to a value that specifies the length of the data buffer OutputBuffer including private data, in bytes. 
	///      When the function returns, this parameter contains the pointer to a value that specifies the length of the data written to the buffer, including the private bytes. </param>
	/// <param name=OutputBuffer>Pointer to the buffer where output data will be written </param>
	///
	HRESULT InvokeFunction(
		[in] DWORD FunctionId,
		[in] DWORD InputBufferByteCount,
		[in] BYTE* InputBuffer,
		[in, out] DWORD* OutputBufferByteCount,
		[in, out] BYTE* OutputBuffer);

	/// Gets the required number of bytes that need to be prepended to 
	/// input and output buffers when calling the security processor (see InvokeFunction above).
	/// This way the MFT decryptor is able to allocate the total amount of bytes and copies can 
	/// be avoided when moving the data to the security processor.
	/// <param name=PrivateInputByteCount> Required number of bytes that need to be prepended to 
	///      the content protection system input buffer</param>
	/// <param name=PrivateOutputByteCount> Required number of bytes that need to be prepended to 
	///      the content protection system output buffer</param>     
	HRESULT GetPrivateDataByteCount(
		[out] DWORD* PrivateInputByteCount,
		[out] DWORD* PrivateOutputByteCount);
};

[
	odl,
	uuid(7EC4B1BD-43FB-4763-85D2-64FCB5C5F4CB)
]
interface IMFContentDecryptorContext : stdole.IUnknown
{
	/// Allows the display driver to return IHV specific information used when initializing a new hardware key.
	/// <param name=InputPrivateDataByteCount>Number of bytes of buffer InputPrivateData </param>
	/// <param name=InputPrivateData>The contents of this parameter is defined by the implementation of 
	///     the protection system implementation running in the security processor. It may contain data about license or stream properties</param>
	/// <param name=OutputPrivateData>The return data is also defined by the protection system implementation 
	///     running in the security processor. It may contain data associated with the underlying hardware key</param>
	HRESULT InitializeHardwareKey(
		[in] UINT InputPrivateDataByteCount,
		[in] void* InputPrivateData,
		[out] UINT64* OutputPrivateData);
};

typedef enum MF_MEDIAKEYSESSION_TYPE
{
	MF_MEDIAKEYSESSION_TYPE_TEMPORARY,
	MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE,
	MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE
} MF_MEDIAKEYSESSION_TYPE;

typedef enum MF_MEDIAKEY_STATUS
{
	MF_MEDIAKEY_STATUS_USABLE,
	MF_MEDIAKEY_STATUS_EXPIRED,
	MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED,
	MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED,
	MF_MEDIAKEY_STATUS_STATUS_PENDING,
	MF_MEDIAKEY_STATUS_INTERNAL_ERROR
} MF_MEDIAKEY_STATUS;

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MFMediaKeyStatus
//
//  Synopsis:   Defines output parameter for IMFMediaKeySession2.get_KeyStatuses
//
//------------------------------------------------------------------------------
typedef struct MFMediaKeyStatus
{
	LongPtr pbKeyId;
	UINT  cbKeyId;
	MF_MEDIAKEY_STATUS eMediaKeyStatus;
} MFMediaKeyStatus;

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIAKEYSESSION_MESSAGETYPE
//
//  Synopsis:   Defines message type for IMFMediaKeySessionNotify2 KeyMessage event
//
//------------------------------------------------------------------------------
typedef enum MF_MEDIAKEYSESSION_MESSAGETYPE
{
	MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST = 0,
	MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL = 1,
	MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE = 2,
	MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST = 3
} MF_MEDIAKEYSESSION_MESSAGETYPE;

typedef enum D3DFORMAT
{

	D3DFMT_UNKNOWN = 0,

	D3DFMT_R8G8B8 = 20,
	D3DFMT_A8R8G8B8 = 21,
	D3DFMT_X8R8G8B8 = 22,
	D3DFMT_R5G6B5 = 23,
	D3DFMT_X1R5G5B5 = 24,
	D3DFMT_A1R5G5B5 = 25,
	D3DFMT_A4R4G4B4 = 26,
	D3DFMT_R3G3B2 = 27,
	D3DFMT_A8 = 28,
	D3DFMT_A8R3G3B2 = 29,
	D3DFMT_X4R4G4B4 = 30,
	D3DFMT_A2B10G10R10 = 31,
	D3DFMT_G16R16 = 34,

	D3DFMT_A8P8 = 40,
	D3DFMT_P8 = 41,

	D3DFMT_L8 = 50,
	D3DFMT_A8L8 = 51,
	D3DFMT_A4L4 = 52,

	D3DFMT_V8U8 = 60,
	D3DFMT_L6V5U5 = 61,
	D3DFMT_X8L8V8U8 = 62,
	D3DFMT_Q8W8V8U8 = 63,
	D3DFMT_V16U16 = 64,
	D3DFMT_W11V11U10 = 65,
	D3DFMT_A2W10V10U10 = 67,
	/*
		D3DFMT_UYVY                 = MAKEFOURCC('U', 'Y', 'V', 'Y'),
		D3DFMT_YUY2                 = MAKEFOURCC('Y', 'U', 'Y', '2'),
		D3DFMT_DXT1                 = MAKEFOURCC('D', 'X', 'T', '1'),
		D3DFMT_DXT2                 = MAKEFOURCC('D', 'X', 'T', '2'),
		D3DFMT_DXT3                 = MAKEFOURCC('D', 'X', 'T', '3'),
		D3DFMT_DXT4                 = MAKEFOURCC('D', 'X', 'T', '4'),
		D3DFMT_DXT5                 = MAKEFOURCC('D', 'X', 'T', '5'),
	*/
	D3DFMT_D16_LOCKABLE = 70,
	D3DFMT_D32 = 71,
	D3DFMT_D15S1 = 73,
	D3DFMT_D24S8 = 75,
	D3DFMT_D16 = 80,
	D3DFMT_D24X8 = 77,
	D3DFMT_D24X4S4 = 79,


	D3DFMT_VERTEXDATA = 100,
	D3DFMT_INDEX16 = 101,
	D3DFMT_INDEX32 = 102,

	D3DFMT_FORCE_DWORD = 0x7fffffff

} D3DFORMAT;

interface IMFVideoDisplayControl;
interface IMFVideoPresenter;
interface IMFVideoPositionMapper;
interface IMFDesiredSample;
interface IMFVideoMixerControl;
interface IMFVideoRenderer;
interface IMFVideoDeviceID;
interface IEVRFilterConfig;

[
	odl,
	uuid(1F6A9F17-E70B-4e24-8AE4-0B2C3BA7A4AE),
	helpstring("IMFVideoPositionMapper Interface")
]
interface IMFVideoPositionMapper : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  Provides the reverse transformation of coordinates for components that
	//  transform the video in such a way that co-ordinates in the input image
	//  map to different co-ordinate values in the output image.
	//
	// Parameters:
	//
	//  xOut - x coordinate of the output image normalized to the range [0,1]
	//  yOut - y coordinate of the output image normalized to the range [0,1]
	//  dwOutputStreamIndex - Output stream index relative to which co-ordinate
	//      mapping is required.
	//  dwInputStreamIndex - Input stream index relative to which co-ordinate 
	//      mapping is required.
	//  pxIn - Mapped x coordinate of the input image normalized to the range [0,1]
	//  pyIn - Mapped y coordinate of the input image normalized to the range [0,1]
	//         
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT MapOutputCoordinateToInputStream(
		[in] float xOut,
		[in] float yOut,
		[in] DWORD dwOutputStreamIndex,
		[in] DWORD dwInputStreamIndex,
		[out] float* pxIn,
		[out] float* pyIn
	);
};

//=============================================================================
// Description:
//
//  The IMFVideoDeviceID interface supports a single method, which returns the device
//  IID supported by that object. This IID must be compatible with other components.
//  This interface is mandatory for the Mixer and Presenter objects, since these 
//  components must use the same type of video device.
//
[
	odl,
	uuid(A38D9567-5A9C-4f3c-B293-8EB415B279BA),
	helpstring("IMFVideoDeviceID Interface")
]
interface IMFVideoDeviceID : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  The GetDeviceID method retrieves the video device ID of the video device 
	//  supported by this video component. Although not restricted to these, it 
	//  will generally be one of the following:
	//      - IID_IDirect3DDevice9
	//
	// Parameters:
	//
	//  pDeviceID - Pointer that receives the IID of the device supported by this component.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetDeviceID(
		[out] UUID* pDeviceID
	);
};

//=============================================================================
// Description:
//
//  Enumeration used to specify the aspect ratio mode desired to be used when
//  rendering video. Set by calling IMFVideoDisplayControl::SetRenderingPrefs.
//
typedef enum MFVideoAspectRatioMode {
	// No aspect ratio correction - fill window
	MFVideoARMode_None = 0x00000000,
	// Indicates that the picture aspect ratio should be preserved. That is, if the
	// video is 640 by 480 pixels (4:3), and the video destination region is a rectangle
	// 800 by 700, then the video should be letterboxed and displayed as 800 by 600
	// (retain 4:3).
	MFVideoARMode_PreservePicture = 0x00000001,
	// Indicates that the pixel aspect ratio should be preserved. This setting comes into
	// play when the video display is physically of a certain aspect ratio, but is set
	// to a resolution that is not the same aspect ratio, thus making the pixels non-square.
	// I.e. a monitor whose native resolution is 1600 by 1200 (4:3) is set to 1280 by 1024
	// (5:4). This flag is only valid when passed with MFVideoARMode_PreservePicture. 
	MFVideoARMode_PreservePixel = 0x00000002,
	// Indicates that a horizontal non-linear stretch should be applied when the aspect 
	// ratio of the destination rectangle does not match the aspect ratio of the source
	// rectangle. The non-linear stretch algorithm acts by preserving the aspect ratio in 
	// the middle of the picture (relative to the left and right) and stretching (or 
	// shrinking) progressively more towards the left and right. This mode is useful when
	// viewing 4:3 content full screen on a 16:9 aspect ratio display and would be used
	// instead of pillar-boxing. It can also be used to view 16:9 content on a 4:3 display
	// to replace the letterboxing. Note that this mode may cause performance degradation.
	MFVideoARMode_NonLinearStretch = 0x00000004,
	MFVideoARMode_Mask = 0x00000007
} MFVideoAspectRatioMode;

//=============================================================================
// Description:
//
//  The rendering preferences used by the video presenter object.
//
typedef enum MFVideoRenderPrefs {
	// Do not paint color keys (default off)
	MFVideoRenderPrefs_DoNotRenderBorder = 0x00000001,
	// Do not clip to monitor that has largest amount of video (default off)
	MFVideoRenderPrefs_DoNotClipToDevice = 0x00000002,
	MFVideoRenderPrefs_AllowOutputThrottling = 0x00000004,
	MFVideoRenderPrefs_ForceOutputThrottling = 0x00000008,
	MFVideoRenderPrefs_ForceBatching = 0x00000010,
	MFVideoRenderPrefs_AllowBatching = 0x00000020,
	MFVideoRenderPrefs_ForceScaling = 0x00000040,
	MFVideoRenderPrefs_AllowScaling = 0x00000080,
	MFVideoRenderPrefs_DoNotRepaintOnStop = 0x00000100,
	MFVideoRenderPrefs_Mask = 0x000001ff,
} MFVideoRenderPrefs;

//=============================================================================
// Description:
//
//  A Normalized relative rectangle where the coordinates exist in the rate [0,1].
//
// Remarks: 
//
//  When the rectangle refers to a video stream, the following restrictions apply
//  o  left <= right. 
//  o  top <= bottom.
//

typedef struct MFVideoNormalizedRect
{
	float left;
	float top;
	float right;
	float bottom;
} MFVideoNormalizedRect;


//=============================================================================
// Description:
//
//  The IMFVideoDisplayControl interface supports window-based rendering.  
//
//  If a video renderer supports this functionality it is accessible to the 
//  application via the IMFGetService interface from the renderer object
//  using service GUID MR_VIDEO_RENDER_SERVICE.
//
//  Custom Video Presenter objects may optionally support this interface.
//
[
	odl,
	uuid(a490b1e4-ab84-4d31-a1b2-181e03b1077a),
	helpstring("IMFVideoDisplayControl Interface")
]
interface IMFVideoDisplayControl : stdole.IUnknown
{
	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Retrieves the un-stretched video size and aspect ratio of the video.
	//
	// Parameters:
	//
	//  pszVideo - Receives the size of the native video rectangle. Optional, unless pszARVideo is NULL.
	//  pszARVideo - Receives the aspect ratio size of the native video rectangle. Optional, unless pszVideo is NULL.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - Both pointers passed were NULL.
	//
	// Remarks:
	//
	//  If the video renderer has not had one of its streams opened and
	//  media type set, this method will succeed but all parameters will be 
	//  set to zero.
	//
	HRESULT GetNativeVideoSize(
		[in, out] SIZE* pszVideo,
		[in, out] SIZE* pszARVideo
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves the minimum and maximum video sizes that the VIDEO RENDERER can 
	//  display without incurring significant performance or image quality degradation.
	//
	// Parameters:
	//
	//  pszMin - Receives the minimum ideal size. Optional, unless pszMax is NULL.
	//  pszMax - Receives the maximum ideal size. Optional, unless pszMax is NULL.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - Both pointers passed were NULL.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetIdealVideoSize(
		[in, out] SIZE* pszMin,
		[in, out] SIZE* pszMax
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Sets the source rectangle and destination region for the video.
	//
	// Parameters:
	//
	//  pnrcSource - Specifies the source zoom rectangle as a normalized rectangle. 
	//      This means that the coordinates exist as float values in the range {0, 1}.
	//      To zoom to 100 on the middle content, a rectangle of {.25, .25, .75, .75} 
	//      would be specified. A src rectangle with zero height or width is invalid; 
	//      it would be akin to a divide by zero, since nothing cannot be stretched. 
	//      Optional, unless prcDest is NULL.
	//  prgnDest - Specifies the destination rectangle. 
	//      Optional, unless pnrcSource is NULL.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT SetVideoPosition(
		[in] MFVideoNormalizedRect* pnrcSource,
		[in] RECT* prcDest
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Retrieves the current source rectangle and destination region used to display 
	//  the video.
	//
	// Parameters:
	//
	//  pnrcSource - Receives the current source rectangle. This is expressed as a
	//      normalized rectangle using float values in the range {0, 1}. If a rectangle
	//      of {.25, .25, .75, .75} is retrieved, then the middle content has been 
	//      zoomed to 200.
	//  prcDest - Receives the current destination rectangle.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  Need to add size_is(*pdwSizeofRgnData) attribute to prgnDest, 
	//  but since that represents array size, need to change prgnDest
	//  to be BYTE* first.
	//
	HRESULT GetVideoPosition(
		[out] MFVideoNormalizedRect* pnrcSource,
		[out] RECT *prcDest
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Specifies how the video renderer will preserve the aspect ratio of the source video.
	//
	// Parameters:
	//
	//  AspectRatioMode - The aspect ratio mode in which the video should presented. 
	//      This is an OR combination of MFVideoAspectRatioMode.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT SetAspectRatioMode(
		[in] DWORD dwAspectRatioMode
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves the current mode in which video is being displayed in a window.
	//
	// Parameters:
	//
	//  lpAspectRatioMode - Receives the aspect ratio mode. This is an OR 
	//      combination of MFVideoAspectRatioMode.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetAspectRatioMode(
		[out] DWORD* pdwAspectRatioMode
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Specifies the container window that video should be clipped to.
	//
	// Parameters:
	//
	//  hwndVideo - The window to which the video should be clipped.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT SetVideoWindow(
		[in] HWND hwndVideo
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Retrieves the container window that video is being clipped to.
	//
	// Parameters:
	//
	//  phwndVideo - Receives the HWND value to which the video is being clipped.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetVideoWindow(
		[out] HWND* phwndVideo
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Repaints the current video frame. Should be called when the application 
	//  receives a WM_PAINT message.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT RepaintVideo(void);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Retrieves a copy of the current image being displayed by the video renderer.
	//
	// Parameters:
	//
	//  pBih - Receives the description of the bitmap. biSize must be set
	//   to sizeof(BITMAPINFOHEADER).
	//  pDib - Receives the current image. Allocated by the callee.
	//  pcbDib - Receives the size of the the image in pDib.
	//  pTimeStamp - Receives the timestamp of the current frame.
	//  
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  The image is returned in the form of packed Windows DIB. The caller is
	//  responsible for free the returned memory by calling CoTaskMemFree.
	//
	//  GetCurrentImage can be called at any time, but excessive use of this 
	//  function will degrade video playback performed.
	//
	HRESULT GetCurrentImage(
		[in, out] BITMAPINFOHEADER* pBih,
		[out] LongPtr* pDib,
		[out] DWORD* pcbDib,
		[in, out] LONGLONG* pTimeStamp
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Sets the border color to be used by the video renderer.
	//
	// Parameters:
	//
	//  Clr - The color to be set.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//
	// Remarks:
	//
	// The border color is color used to fill any area of the
	// the destination rectangle that does not contain video.
	// It is typically used in two instances:
	//      1) When the video straddles two monitors and 
	//      2) When the EVR is trying to maintain the aspect
	//          ratio of the movies by letter boxing the video
	//          to fit within the specified destination rectangle.
	//          See also SetAspectRatioMode.
	//
	HRESULT SetBorderColor(
		[in] COLORREF Clr
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves the current border color used by the video renderer.
	//
	// Parameters:
	//
	//  pClr - Receives the current border color.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetBorderColor(
		[out] COLORREF* pClr
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Sets various application preferences related to video rendering.
	//
	// Parameters:
	//
	//  dwRenderFlags - A bitwise OR of MFVideoRenderPrefs values specifying the
	//      rendering preferences.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_INVALIDARG - An invalid set of preferences were supplied.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT SetRenderingPrefs(
		[in] DWORD dwRenderFlags  // a combination of MFVideoRenderPrefs
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves the current set of rendering preferences being used by 
	//  the video renderer.
	//
	// Parameters:
	//
	//  pdwRenderFlags - receives a DWORD representing a bitwise OR of 
	//      MFVideoRenderprefs values indicating the current rendering preferences.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetRenderingPrefs(
		[out] DWORD* pdwRenderFlags
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Sets or unsets the renderer from its fullscreen rendering mode. For the
	//  D3D9 renderer, this is D3D exclusive mode.
	//
	// Parameters:
	//
	//  fFullscreen - TRUE if the renderer should display to the entire screen. 
	//      FALSE otherwise.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT SetFullscreen(
		[in] BOOL fFullscreen
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Indicates whether or not the renderer is currently in full screen mode.
	//
	// Parameters:
	//
	//  pfFullscreen - TRUE if the renderer is displaying to the entire screen. 
	//      FALSE otherwise.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetFullscreen(
		[out] BOOL* pfFullscreen
	);
}

//=============================================================================
// Description:
//
//  The different message types that can be passed to the video presenter via
//  IMFVideoPresenter::ProcessMessage.
//
typedef enum MFVP_MESSAGE_TYPE {
	// Called by the video renderer when a flush request is received on the
	// reference video stream. In response, the presenter should clear its 
	// queue of samples waiting to be presented.
	// ulParam is unused and should be set to zero.
	MFVP_MESSAGE_FLUSH = 0x00000000,
	// Indicates to the presenter that the current output media type on the
	// mixer has changed. In response, the presenter may now wish to renegotiate 
	// the media type of the video mixer.
	// Return Values:
	//  S_OK - successful completion
	//  MF_E_INVALIDMEDIATYPE - The presenter and mixer could not agree on 
	//      a media type.
	// ulParam is unused and should be set to zero.
	MFVP_MESSAGE_INVALIDATEMEDIATYPE = 0x00000001,
	// Indicates that a sample has been delivered to the video mixer odl,
	// and there may now be a sample now available on the mixer's output. In
	// response, the presenter may want to draw frames out of the mixer's 
	// output.
	// ulParam is unused and should be set to zero.
	MFVP_MESSAGE_PROCESSINPUTNOTIFY = 0x00000002,
	// Called when streaming is about to begin. In 
	// response, the presenter should allocate any resources necessary to begin
	// streaming.
	// ulParam is unused and should be set to zero.
	MFVP_MESSAGE_BEGINSTREAMING = 0x00000003,
	// Called when streaming has completed. In 
	// response, the presenter should release any resources that were 
	// previously allocated for streaming.
	// ulParam is unused and should be set to zero.
	MFVP_MESSAGE_ENDSTREAMING = 0x00000004,
	// Indicates that the end of this segment has been reached.
	// When the last frame has been rendered, EC_COMPLETE should be sent
	// on the IMediaEvent interface retrieved from the renderer
	// during IMFTopologyServiceLookupClient::InitServicePointers method.
	// ulParam is unused and should be set to zero.
	MFVP_MESSAGE_ENDOFSTREAM = 0x00000005,
	// The presenter should step the number frames indicated by the lower DWORD
	// of ulParam.
	// The first n-1 frames should be skipped and only the nth frame should be 
	// shown. Note that this message should only be received while in the pause
	// state or while in the started state when the rate is 0. 
	// Otherwise, MF_E_INVALIDREQUEST should be returned.
	// When the nth frame has been shown EC_STEP_COMPLETE
	// should be sent on the IMediaEvent interface.
	// Additionally, if stepping is being done while the rate is set to 0
	// (a.k.a. "scrubbing"), the frame should be displayed immediately when
	// it is received, and EC_SCRUB_TIME should be sent right away after
	// sending EC_STEP_COMPLETE.
	MFVP_MESSAGE_STEP = 0x00000006,
	// The currently queued step operation should be cancelled. The presenter
	// should remain in the pause state following the cancellation.
	// ulParam is unused and should be set to zero.
	MFVP_MESSAGE_CANCELSTEP = 0x00000007,

} MFVP_MESSAGE_TYPE;

//=============================================================================
// Description:
//
//  The IMFVideoPresenter interface allows for direct control over the video 
//  frames, in that it receives video samples as soon as they are available 
//  from upstream. The video presenter must therefore take care of the timing
//  of the samples and synchronize with the render clock. 
//
//  Custom Video Presenter objects must support this interface.
//
[
	odl,
	uuid(29AFF080-182A-4a5d-AF3B-448F3A6346CB),
	helpstring("IMFVideoPresenter Interface")
]
interface IMFVideoPresenter : IMFClockStateSink
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  Indicates to the presenter that a certain action needs to be performed,
	//  or signals that something has occured. 
	//
	// Parameters:
	//
	//  eMessage - Indicates the action to be performed or the condition that
	//      has occured.
	//  ulParam - Allows for additional information to be passed to the caller.
	//      See the definition of eMessage for more information.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT ProcessMessage(
		[in] MFVP_MESSAGE_TYPE eMessage,
		[in] ULONG_PTR ulParam
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Retrieves the current media type that has been last negotiated by a
	//  successful call to InvalidateMediaType.
	//
	// Parameters:
	//
	//  ppMediaType - Receives the currently set media type.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetCurrentMediaType(
		[out] IMFVideoMediaType** ppMediaType
	);
}

//=============================================================================
// Description:
//
//  This interface may be optionally supported by buffers passed back to a 
//  D3D mixer. It allows the presenter more control over which frames the video
//  mixer gives back the presenter.
//
//  It is retrieved by calling QueryInterface on the IMFSample object.
//
[
	odl,
	uuid(56C294D0-753E-4260-8D61-A3D8820B1D54),
	helpstring("IMFDesiredSample Interface")
]
interface IMFDesiredSample : stdole.IUnknown
{

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Called by the Mixer to get the time and duration of sample that the 
	//  presenter wishes.
	//
	// Parameters:
	//
	//  phnsSampleTime - Receives the desired sample time which should be mixed. 
	//      For example, if the sample time is the same as the last sample time, 
	//      the same sample will be retrieved. To retrieve the next sample, use
	//      the actual sample time plus the actual sample duration.
	//  phnsSampleDuration - Receives the sample duration that should be mixed.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  E_POINTER - An invalid pointer was passed.
	//  MF_E_NOT_AVAILABLE - There is no timestamp set.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetDesiredSampleTimeAndDuration(
		[out] LONGLONG* phnsSampleTime,
		[out] LONGLONG* phnsSampleDuration
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Called by the Presenter to set the time and duration of sample which it 
	//  desires from the mixer.
	//
	// Parameters:
	//
	//  hnsSampleTime - The time of the sample that is wished from the mixer.
	//  hnsSampleDuration - The duration of the sample that is wished from the 
	//      mixer.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//
	// Remarks:
	//
	//  This value should be set prior to passing the buffer to the mixer for 
	//  a Mix operation. The mixer sets the actual start and duration times on 
	//  the IMFSample before handing it back.
	//
	void SetDesiredSampleTimeAndDuration(
		[in] LONGLONG hnsSampleTime,
		[in] LONGLONG hnsSampleDuration
	);

	//-------------------------------------------------------------------------    
	// Description:
	//
	//  Clears the timestamps previously set by a call to 
	//  SetDesiredSampleTimeAndDuration, thus resulting in any subsequent calls
	//  to GetDesiredSampleTimeAndDuration failing with error code
	//  MF_E_NOT_AVAILABLE.
	//
	void Clear(void);
};

//=============================================================================
// Description:
//
//  The IMFVideoMixerControl interface supports mixing of separate video streams.
//  If a video renderer supports this functionality it is accessed via the 
//  IMFGetService interface from the renderer odl, using service GUID
//  MR_VIDEO_MIXER_SERVICE.
//
[
	odl,
	uuid(A5C6C53F-C202-4aa5-9695-175BA8C508A5),
	helpstring("IMFVideoMixerControl Interface")
]
interface IMFVideoMixerControl : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  Sets this video stream's position in the Z-order.
	//
	// Parameters:
	//
	//  dwStreamID - The stream ID of the stream to set.
	//  dwZ - The z-order value. 0 indicates the bottom of the z-order and must 
	//      be the reference stream.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_INVALIDSTREAMNUMBER - an invalid stream ID was supplied.
	//  MF_E_INVALIDREQUEST - 0 was supplied as the Z-order for a stream other 
	//      then the reference stream, or a value other than 0 was supplied 
	//      for the reference stream.
	//  E_INVALIDARG - a z-order value greater than <the number of streams minus 
	//      one> was supplied.
	//
	// Remarks:
	//
	//  Z-order of the reference stream is always 0 and cannot be set otherwise.
	//
	HRESULT SetStreamZOrder(
		[in] DWORD dwStreamID,
		[in] DWORD dwZ
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves this video stream's position in the Z-order.
	//
	// Parameters:
	//
	//  dwStreamID - The stream ID of the stream to get.
	//  pdwZ - Receives the z-order value. 0 indicates the bottom of the z-order 
	//      will always be the value of the reference stream.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_INVALIDSTREAMNUMBER - an invalid stream ID was supplied.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetStreamZOrder(
		[in] DWORD dwStreamID,
		[out] DWORD* pdwZ
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Sets the position of this stream within the composition rectangle.
	//
	// Parameters:
	//
	//  dwStreamID - The stream ID of the stream to set.
	//  pnrcOutput - The bounding rectangle, in normalized coordinates.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_INVALIDSTREAMNUMBER - an invalid stream ID was supplied.
	//  E_INVALIDARG - the Normalized rectangle supplied had coordinates that
	//      were invalid. See MFVideoNormalizedRect for more information.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT SetStreamOutputRect(
		[in] DWORD dwStreamID,
		[in] MFVideoNormalizedRect* pnrcOutput
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves the position of this stream's video rectangle within the composition rectangle.
	//
	// Parameters:
	//
	//  dwStreamID - The stream ID of the stream to get.
	//  pnrcOutput - Receives the bounding rectangle, in normalized coordinates.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_INVALIDSTREAMNUMBER - an invalid stream ID was supplied.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetStreamOutputRect(
		[in] DWORD dwStreamID,
		[out] MFVideoNormalizedRect* pnrcOutput
	);
};

//=============================================================================
// Description:
//
//  The mixing preferences used by the video mixer object.
//
typedef enum MFVideoMixPrefs {
	MFVideoMixPrefs_ForceHalfInterlace = 0x00000001,
	MFVideoMixPrefs_AllowDropToHalfInterlace = 0x00000002,
	MFVideoMixPrefs_AllowDropToBob = 0x00000004,
	MFVideoMixPrefs_ForceBob = 0x00000008,
	MFVideoMixPrefs_EnableRotation = 0x00000010,
	MFVideoMixPrefs_Mask = 0x0000001f,
} MFVideoMixPrefs;

//=============================================================================
// Description:
//
//  The IMFVideoMixerControl2 interface supports mixing of separate video streams.
//  If a video renderer supports this functionality it is accessed via the 
//  IMFGetService interface from the renderer odl, using service GUID
//  MR_VIDEO_MIXER_SERVICE.
//
[
	odl,
	uuid(8459616d-966e-4930-b658-54fa7e5a16d3),
	helpstring("IMFVideoMixerControl2 Interface")
]
interface IMFVideoMixerControl2 : IMFVideoMixerControl
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  Sets various application preferences related to video mixing.
	//
	// Parameters:
	//
	//  dwMixFlags - A bitwise OR of MFVideoMixPrefs values specifying the
	//      rendering preferences.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video mixer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_INVALIDARG - An invalid set of preferences were supplied.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT SetMixingPrefs(
		[in] DWORD dwMixFlags  // a combination of MFVideoMixPrefs
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves the current set of mixing preferences being used by 
	//  the video mixer.
	//
	// Parameters:
	//
	//  pdwMixFlags - receives a DWORD representing a bitwise OR of 
	//      MFVideoMixingprefs values indicating the current mixing preferences.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video mixer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetMixingPrefs(
		[out] DWORD* pdwMixFlags
	);
};

//=============================================================================
// Description:
//
//  The IMFVideoRenderer interface supports a single method, which allows an 
//  application to replace the video presenter and mixer objects with ones of 
//  its own creation.
//
[
	odl,
	uuid(DFDFD197-A9CA-43d8-B341-6AF3503792CD),
	helpstring("IMFVideoRenderer Interface")
]
interface IMFVideoRenderer : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  Replaces the video presenter and mixer objects with ones specified by the 
	//  application.
	//
	// Parameters:
	//
	//  pVideoMixer - The new video mixer object. Can be NULL.
	//
	//  pVideoPresenter - The new video presenter object. Can be NULL.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_SHUTDOWN - The video renderer has been Shutdown and will no longer
	//      respond to methods calls. It must be released.
	//
	// Remarks:
	//
	//  If the video renderer is in the protected media path(PMP), then the mixer
	//  and presenter objects must be certified safe components and pass any trust
	//  authority verification that is being enforced. Otherwise, this method will fail.
	//
	//  It is legal to supply NULL as the parameter for both arguments.
	//
	HRESULT InitializeRenderer(
		[in] IMFTransform* pVideoMixer,
		[in] IMFVideoPresenter* pVideoPresenter
	);
}

//=============================================================================
// Description:
//
//  The IEVRFilterConfig interface exists for configuration of the DShow EVR 
//  filter. It allows for setting the stream count.
//
[
	odl,
	uuid(83E91E85-82C1-4ea7-801D-85DC50B75086),
	helpstring("IEVRFilterConfig Interface")
]
interface IEVRFilterConfig : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  Configures the video renderer filter with the desired number of streams.
	//
	// Parameters:
	//
	//  dwMaxStreams - The number of pins.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  VFW_E_WRONG_STATE - The Pin count has already been set or the EVR is 
	//      still connected.
	//  E_INVALIDARG - There must always be a minimum of one pin. Specifying 0 
	//      will result in this error code.
	//
	// Remarks:
	//
	//  Pins are created in the disabled state.
	//
	HRESULT SetNumberOfStreams(
		[in] DWORD dwMaxStreams
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves the current number of pins that exist on the video renderer.
	//  There is always at least one pin.
	//
	// Parameters:
	//
	//  pdwMaxStreams - Receives the number of pins on the filter.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  E_POINTER - pdwMaxStreams is NULL.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetNumberOfStreams(
		[out] DWORD* pdwMaxStreams
	);
}

//=============================================================================
// Description:
//
//  The configuration preferences used by the filter.
//
typedef enum EVRFilterConfig_Prefs {
	EVRFilterConfigPrefs_EnableQoS = 0x00000001,
	EVRFilterConfigPrefs_Mask = 0x00000001,
} EVRFilterConfigPrefs;

//=============================================================================
// Description:
//
//  The IEVRFilterConfigEx interface controls the filter behavior
//
[
	odl,
	uuid(aea36028-796d-454f-beee-b48071e24304),
	helpstring("IEVRFilterConfigEx Interface")
]
interface IEVRFilterConfigEx : IEVRFilterConfig
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  Sets various application filter preferences.
	//
	// Parameters:
	//
	//  dwConfigFlags - A bitwise OR of EVRFilterConfigPrefs values specifying the
	//      filter preferences.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  E_INVALIDARG - An invalid set of preferences were supplied.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT SetConfigPrefs(
		[in] DWORD dwConfigFlags  // a combination of EVRFilterConfigPrefs
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Retrieves the current set of Config preferences being used by 
	//  the EVR filter.
	//
	// Parameters:
	//
	//  pdwConfigFlags - receives a DWORD representing a bitwise OR of 
	//      EVRFilterConfigPrefs values indicating the current Config preferences.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  E_POINTER - An invalid pointer was passed.
	//
	// Remarks:
	//
	//  None.
	//
	HRESULT GetConfigPrefs(
		[out] DWORD* pdwConfigFlags
	);
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

typedef enum MF_SERVICE_LOOKUP_TYPE
{
	MF_SERVICE_LOOKUP_UPSTREAM,
	MF_SERVICE_LOOKUP_UPSTREAM_DIRECT,
	MF_SERVICE_LOOKUP_DOWNSTREAM,
	MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT,
	MF_SERVICE_LOOKUP_ALL, // lookup service on any components of the graph
	MF_SERVICE_LOOKUP_GLOBAL, // lookup global objects
} MF_SERVICE_LOOKUP_TYPE;

//=============================================================================
// Description:
//
//    Component can use IMFTopologyServiceLookup interface to lookup object in topology. 
//    Pipeline will call IMFTopologyServiceLookupClient::InitServicePointers some time after component is created 
//    Component should only use IMFTopologyServiceLookup in the context of IMFTopologyServiceLookupClient::InitServicePointers call
//    After call is complete IMFTopologyServiceLookup interface will return an error for any call
//
[
	odl,
	uuid(fa993889-4383-415a-a930-dd472a8cf6f7),
	helpstring("IMFTopologyServiceLookup Interface")
]
interface IMFTopologyServiceLookup : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//  Called by a client to retrieve external interfaces.
	//
	// Parameters:
	//
	//  Type - Identifies the scope of the search.
	// 
	//  dwIndex - Optional index to identify component input or output. Ignored for _ALL or _GLOBAL type .
	// 
	//  guidService - Identifies the service to lookup.
	// 
	//  riid - IID of the interface on the service.
	// 
	//  ppvObjects - Contains array of size == *pnObject to fill in  .
	// 
	//  pnObjects - At input time, contains the maximum number of elements in ppvObjects array.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//  MF_E_UNSUPPORTED_SERVICE - The service specified by guidService is not supported.
	//  MF_E_NOTACCEPTING - The method was called outside the context of an IMFTopologyServiceLookupClient::InitServicePointers method call.
	//  E_POINTER - pnObjects or ppvObjects was NULL.
	//  E_INVALIDARG - *pnObjects was zero.
	//
	// Remarks:
	//
	//  Method may only be called within the context of an 
	//  IMFTopologyServiceLookupClient::InitServicePointers method call.
	//
	HRESULT LookupService(
		[in] MF_SERVICE_LOOKUP_TYPE Type,
		[in] DWORD dwIndex,
		[in] REFGUID guidService,
		[in] REFIID riid,
		[out] LPVOID ppvObjects,
		[in, out] DWORD* pnObjects
	);
}


//=============================================================================
// Description:
//
//    Component can implement IMFTopologyServiceLookupClient if it wants to lookup services on other components in the pipeline
//
[
	odl,
	uuid(fa99388a-4383-415a-a930-dd472a8cf6f7)
]
interface IMFTopologyServiceLookupClient : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	//   Called by the EVR during initialization of the component. 
	//   Component can lookup services using pLookup object
	//
	// Parameters:
	//
	//  pLookup - The interface to be used to discover objects.
	//
	// Return values:
	//
	//  S_OK - Successful completion.
	//
	// Remarks:
	//
	//  The IMFTopologyServiceLookup pointer should not be addref'ed or cached 
	//  by the callee. It can not be used outside the context of this method 
	//  call and will fail if an attempt is made.
	//
	HRESULT InitServicePointers(
		[in] IMFTopologyServiceLookup* pLookup
	);

	//-------------------------------------------------------------------------
	// Description:
	//
	//  Called by the pipeline during deinitialization of the component. 
	//  Component should release all services acquired during InitServicePointers call
	//
	HRESULT ReleaseServicePointers(void);
}


//=============================================================================
// Description:
//
//    EVR plug-ins (mixer, presenter) are expected to implement IEVRTrustedVideoPlugin - QI-able interface
//    to enable working in the Protected Video Path. Video OTA uses them to communicate with
//	policy objects from ITA.
//
//	Abscence of this interface on the plug-in is interpreted as a negative answer to both predicates
//   for the purposes of EVR-OTA communication
//

[
	odl,
	uuid(83A4CE40-7710-494b-A893-A472049AF630),
	helpstring("IEVRTrustedVideoPlugin Interface")
]
interface IEVRTrustedVideoPlugin : stdole.IUnknown
{
	//-------------------------------------------------------------------------
	// Description:
	//
	// This predicate is a simple mechanism for a plug-in to report presence of transient/conditional "video vulnerabilities"
	// known to a plug-in on EVR's device change.  Returning FALSE here will result in indication to a Policy Object from ITA 
	// of an additional presence of "unknown software "connector" as an output. Policy Object may take this into consideration
	// when defining the protection settings.
	//
	// The method is called every time on every EVR plug-in after EVR's OTA is informed by EVR about new rendering "device"
	//
	// The example of such "transient" vulnerability is a windowed  (non-fullscreen DX)  mode for the EVR presenter in Vista
	// ("GDI hole") that is vulnerable to a screen scraping. Whenever the presenter finds itself in a windowed mode it should
	// return FALSE. Once "GDI hole" is fixed this may be reflected in this plug-in's implementation of this method.

	// The vulnerabilities are expected to be "transient" as a plug-in that is *always* cannot be trusted with premium video probably
	// shouldn't be certified to be loaded in PMP at all. It is responsibility of the plug-in to verify during this call all applicable transient
	// conditions for known video vulnerabilities.

	//
	//  Parameters:
	//
	//  pYes - To return TRUE if plug-in is in trusted video mode, FALSE otherwise
	//
	// Return values:
	//
	//  S_OK - Successful completion. Any failure is treated as if the method returned FALSE.
	//
	// Remarks:
	//
	HRESULT IsInTrustedVideoMode(
		[out] BOOL* pYes
	);



	//-------------------------------------------------------------------------
	// Description:
	//
	// Constriction (limiting the effective resolution of the image to a specified number of pixels)
	// is a protection mechanism offered by EVR via OTA to a content policy owner. It can be
	// implemented either by a mixer or a presenter plug-in (or both) with preference given to a
	// mixer. If no mixer is available or a mixer indicates that it cannot support constriction then
	// the presenter will be asked if it implements constriction.
	// This predicate currently is called immediately after every SetDevice  in EVR.
	//
	//  Parameters:
	//
	//  pYes - To return TRUE if plug-in can constrict, FALSE otherwise
	//
	// Return values:
	//
	//  S_OK - Successful completion. Any failure is treated as if the method returned FALSE.
	//
	// Remarks:
	//
	// Care should be taken that no public interface exposed by plug-ins can lessen bandwidth
	// restriction imposed by private IEVRTrustedVideo::SetConstriction. If constriction cannot be performed
	// in a trusted manner (regardless of the answer on IsInTrustedVideoMode) this capability should
	// not be reported.
	//
	//
	HRESULT CanConstrict(
		[out] BOOL* pYes
	);



	//-------------------------------------------------------------------------
	// Description:
	//
	// Once an EVR plug-in reports that it CanConstrict video it may be called at any time
	// to SetContsriction with the argument establishing  limit on the total number of "source" pixels
	// in the full output image in "kilopixels" (1000 pixels). (The actual number of pixels at destination can be
	// different  due to stretch scaling, etc) 
	// Two argument values are reserved: DWORD(0) and DWORD(0xFFFFFFFF). The former is meant
	// to "disable" video (0 "source" pixels, preferably "black video"
	// Refer to compliance rules for the definition of "disable". It may be possible to treat "ultra-constriction" 
	// (<1Kpix) as "disable".) The latter is used to indicate the end of any policy-imposed constriction
	// requirements that might be in effect before.
	//
	//  Parameters:
	//
	//  dwKPix - Amount of allowed source pixels in the image in KPixels, or one the two reserved value (see description)
	//
	// Return values:
	//
	//  S_OK - Successful completion. Any failure here is teated as Policy Enforcemet Failure and is reported to
	//			to MIG's policy engine as such.
	//
	// Remarks:
	//
	// Care should be taken that no public interface exposed by plug-ins can lessen bandwidth
	// restriction imposed by private IEVRTrustedVideo::SetConstriction. If constriction cannot be performed
	// in a trusted manner (regardless of the answer on IsInTrustedVideoMode) this capability should
	// not be reported.
	//
	//
	HRESULT SetConstriction(
		[in] DWORD dwKPix
	);


	//-------------------------------------------------------------------------
	// Description:
	//
	// Some plug-ins  (presenters) may implement some form of image exports 
	// like vidctrl GetCurrentImage(). This OTA callback sets permission to do that.
	//
	// By default the plug-in is assumed to start with  ImageExport functionality enabled
	// (if implemented)
	//
	// Parameters:
	//
	// BOOL bDisable  - TRUE/FALSE.  TRUE disables all subsequent image export requests, until set to FALSE.
	//
	// Return values:
	//
	// Should always S_OK. Failure will be reported as a policy enforcement error.
	//
	// Remarks:
	//
	// A plug-in is expected to return  MF_E_LICENSE_INCORRECT_RIGHTS
	// from an export methods when disabled.
	//
	HRESULT DisableImageExport(
		[in] BOOL bDisable
	);

};





interface IMFPMediaPlayer;
interface IMFPMediaItem;
interface IMFPMediaPlayerCallback;

interface IMFMediaEvent;

typedef enum MFP_CREATION_OPTIONS
{
	/// <summary>
	///    Used to indicate that no options are specified.
	/// </summary>
	MFP_OPTION_NONE = 0x00000000,

	/// <summary>
	///     Allows the Media Player to call methods in the IMFPMediaPlayerCallback
	///     interface in any thread. If not present, the Media Player will call
	///     in the same thread in which it is created - in this case the application
	///     must maintain a window message pump in the thread.
	/// </summary>
	MFP_OPTION_FREE_THREADED_CALLBACK = 0x00000001,

	/// <summary>
	///     Disables MMCSS (Multimedia Class Scheduler Service).
	/// </summary>
	MFP_OPTION_NO_MMCSS = 0x00000002,

	/// <summary>
	///     Disables any optimizing that may be done for the remote desktop case
	/// </summary>
	MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION = 0x00000004,

} MFP_CREATION_OPTIONS;


//////////////////////////////////////////////////////////////////////////////
/// <summary>
///     State of the Media Player object.
/// </summary>

typedef enum MFP_MEDIAPLAYER_STATE
{
	/// <summary>
	/// </summary>
	MFP_MEDIAPLAYER_STATE_EMPTY = 0x00000000,

	/// <summary>
	/// </summary>
	MFP_MEDIAPLAYER_STATE_STOPPED = 0x00000001,

	/// <summary>
	/// </summary>
	MFP_MEDIAPLAYER_STATE_PLAYING = 0x00000002,

	/// <summary>
	/// </summary>
	MFP_MEDIAPLAYER_STATE_PAUSED = 0x00000003,

	/// <summary>
	/// </summary>
	MFP_MEDIAPLAYER_STATE_SHUTDOWN = 0x00000004,

} MFP_MEDIAPLAYER_STATE;

typedef enum MFP_MEDIAITEM_CHARACTERISTICS
{
	/// <summary>
	/// </summary>
	MFP_MEDIAITEM_IS_LIVE = 0x00000001,

	/// <summary>
	/// </summary>
	MFP_MEDIAITEM_CAN_SEEK = 0x00000002,

	/// <summary>
	/// </summary>
	MFP_MEDIAITEM_CAN_PAUSE = 0x00000004,

	/// <summary>
	/// </summary>
	MFP_MEDIAITEM_HAS_SLOW_SEEK = 0x00000008,

} MFP_MEDIAITEM_CHARACTERISTICS;

typedef enum MFP_CREDENTIAL_FLAGS
{
	/// <summary>
	///     Passed in MFP_ACQUIRE_USER_CREDENTIAL_EVENT to indicate that
	///     the application must prompt the user for credentials.
	/// </summary>
	MFP_CREDENTIAL_PROMPT = 0x00000001,

	/// <summary>
	///     Passed in MFP_ACQUIRE_USER_CREDENTIAL_EVENT to indicate that
	///     the credential came from the persistent store. The application can
	///     modify this flag to indicate whether the credentials should be
	///     saved in the persistent store or not.
	/// </summary>
	MFP_CREDENTIAL_SAVE = 0x00000002,

	/// <summary>
	///     The application can set this flag before it returns from the
	///     MFP_ACQUIRE_USER_CREDENTIAL_EVENT callback to indicate that the
	///     credentials should not be cached in memory. If the application
	///     does not set this flag, credentials will be cached in memory
	///     for the lifetime of the Player object.
	/// </summary>
	MFP_CREDENTIAL_DO_NOT_CACHE = 0x00000004,

	/// <summary>
	///     Passed in MFP_ACQUIRE_USER_CREDENTIAL_EVENT to indicate that
	///     the credential will be used with a clear text authentication scheme.
	///     The application can modify this flag to indicate whether it allows
	///     the credential to be used with clear text authentication schemes.
	/// </summary>
	MFP_CREDENTIAL_CLEAR_TEXT = 0x00000008,

	/// <summary>
	///     Passed in the MFP_ACQUIRE_USER_CREDENTIAL_EVENT to indicate that
	///     the credential will be used with a network proxy.
	/// </summary>
	MFP_CREDENTIAL_PROXY = 0x00000010,

	/// <summary>
	///     Passed in MFP_ACQUIRE_USER_CREDENTIAL_EVENT to indicate that the
	///     authentication scheme supports authentication of the logged on
	///     user. The application can modify this flag to indicate whether
	///     it allows authentication of the logged on user or not.
	/// </summary>
	MFP_CREDENTIAL_LOGGED_ON_USER = 0x00000020,

} MFP_CREDENTIAL_FLAGS;


[
	odl,
	uuid(A714590A-58AF-430a-85BF-44F5EC838D85)
]
interface IMFPMediaPlayer : stdole.IUnknown
{
	/// <summary>
	/// </summary>
	HRESULT Play();

	/// <summary>
	/// </summary>
	HRESULT Pause();

	/// <summary>
	/// </summary>
	HRESULT Stop();

	/// <summary>
	/// </summary>
	HRESULT FrameStep();

	//
	// Position controls
	//

	/// <summary>
	/// </summary>
	HRESULT SetPosition([in] REFGUID guidPositionType,
		[in] VARIANT* pvPositionValue);

	/// <summary>
	/// </summary>
	HRESULT GetPosition([in] REFGUID guidPositionType,
		[out] VARIANT* pvPositionValue);

	/// <summary>
	/// </summary>
	HRESULT GetDuration([in] REFGUID guidPositionType,
		[out] VARIANT* pvDurationValue);
	//
	// Rate Control
	//

	/// <summary>
	/// </summary>
	HRESULT SetRate([in] float flRate);

	/// <summary>
	/// </summary>
	HRESULT GetRate([out] float* pflRate);

	/// <summary>
	/// </summary>
	HRESULT GetSupportedRates([in] BOOL fForwardDirection,
		[out] float* pflSlowestRate,
		[out] float* pflFastestRate);

	//
	// State
	//

	/// <summary>
	/// </summary>
	HRESULT GetState([out] MFP_MEDIAPLAYER_STATE* peState);

	//
	// Media Item Management
	//

	/// <summary>
	/// </summary>
	HRESULT CreateMediaItemFromURL(
		[in] LongPtr pwszURL,
		[in] BOOL fSync,
		[in] DWORD_PTR dwUserData,
		[out] IMFPMediaItem** ppMediaItem);

	/// <summary>
	/// </summary>
	HRESULT CreateMediaItemFromObject(
		[in] stdole.IUnknown* pIUnknownObj,
		[in] BOOL fSync,
		[in] DWORD_PTR dwUserData,
		[out] IMFPMediaItem** ppMediaItem);

	/// <summary>
	/// </summary>
	HRESULT SetMediaItem([in] IMFPMediaItem* pIMFPMediaItem);

	/// <summary>
	/// Clears the media item from the player and goes to the empty state
	/// </summary>
	HRESULT ClearMediaItem();

	/// <summary>
	/// Fails if no media item is present
	/// </summary>
	HRESULT GetMediaItem([out]IMFPMediaItem** ppIMFPMediaItem);


	//
	// Audio controls
	//

	/// <summary>
	/// </summary>
	HRESULT GetVolume([out] float* pflVolume);

	/// <summary>
	/// </summary>
	HRESULT SetVolume([in] float flVolume);

	/// <summary>
	/// </summary>
	HRESULT GetBalance([out] float* pflBalance);

	/// <summary>
	/// </summary>
	HRESULT SetBalance([in] float flBalance);

	/// <summary>
	/// </summary>
	HRESULT GetMute([out] BOOL* pfMute);

	/// <summary>
	/// </summary>
	HRESULT SetMute([in] BOOL fMute);

	//
	// Video controls
	//

	/// <summary>
	/// </summary>
	HRESULT GetNativeVideoSize([out] SIZE* pszVideo,
		[out] SIZE* pszARVideo);

	/// <summary>
	/// </summary>
	HRESULT GetIdealVideoSize([out] SIZE* pszMin,
		[out] SIZE* pszMax);

	/// <summary>
	/// </summary>
	HRESULT SetVideoSourceRect([in] MFVideoNormalizedRect* pnrcSource);

	/// <summary>
	/// </summary>
	HRESULT GetVideoSourceRect([out] MFVideoNormalizedRect* pnrcSource);

	/// <summary>
	/// </summary>
	HRESULT SetAspectRatioMode([in] DWORD dwAspectRatioMode);

	/// <summary>
	/// </summary>
	HRESULT GetAspectRatioMode([out] DWORD* pdwAspectRatioMode);

	/// <summary>
	/// </summary>
	HRESULT GetVideoWindow([out] HWND* phwndVideo);

	/// <summary>
	/// </summary>
	HRESULT UpdateVideo();

	/// <summary>
	/// </summary>
	HRESULT SetBorderColor([in] COLORREF Clr);

	/// <summary>
	/// </summary>
	HRESULT GetBorderColor([out] COLORREF* pClr);

	//
	// Effect Management
	//

	/// <summary>
	/// </summary>
	HRESULT InsertEffect([in] stdole.IUnknown* pEffect, [in] BOOL fOptional);

	/// <summary>
	/// </summary>
	HRESULT RemoveEffect([in] stdole.IUnknown* pEffect);

	/// <summary>
	/// </summary>
	HRESULT RemoveAllEffects();

	//
	// Shutdown
	//

	/// <summary>
	/// </summary>
	HRESULT Shutdown();
};

[
	odl,
	uuid(90EB3E6B-ECBF-45cc-B1DA-C6FE3EA70D57)
]
interface IMFPMediaItem : stdole.IUnknown
{
	//
	// Player, URL, Object and User Data Methods
	//

	/// <summary>
	/// </summary>
	HRESULT GetMediaPlayer([out] IMFPMediaPlayer** ppMediaPlayer);

	/// <summary>
	///      Must use CoTaskMemFree
	/// </summary>
	HRESULT GetURL([out] long* ppwszURL);

	/// <summary>
	/// </summary>
	HRESULT GetObject([out] IUnknown** ppIUnknown);

	/// <summary>
	/// </summary>
	HRESULT GetUserData([out] DWORD_PTR* pdwUserData);

	/// <summary>
	/// </summary>
	HRESULT SetUserData([in] DWORD_PTR dwUserData);

	//
	// Set/Get Start/Stop Times
	// Use VT_EMPTY to reset positions (with valid GUID)
	//

	/// <summary>
	/// </summary>
	HRESULT GetStartStopPosition([out] GUID* pguidStartPositionType,
		[out] VARIANT* pvStartValue,
		[out] GUID* pguidStopPositionType,
		[out] VARIANT* pvStopValue);


	/// <summary>
	/// </summary>
	HRESULT SetStartStopPosition([in] GUID* pguidStartPositionType,
		[in] VARIANT* pvStartValue,
		[in] GUID* pguidStopPositionType,
		[in] VARIANT* pvStopValue);

	//
	// Media Item Properties and Metadata
	//

	/// <summary>
	/// </summary>
	HRESULT HasVideo([out] BOOL* pfHasVideo,
		[out] BOOL* pfSelected);


	/// <summary>
	/// </summary>
	HRESULT HasAudio([out] BOOL* pfHasAudio,
		[out] BOOL* pfSelected);


	/// <summary>
	/// </summary>
	HRESULT IsProtected([out] BOOL* pfProtected);


	/// <summary>
	///      Does NOT return start/stop-time adjusted duration.
	/// </summary>
	HRESULT GetDuration([in] REFGUID guidPositionType,
		[out] VARIANT* pvDurationValue);


	/// <summary>
	/// </summary>
	HRESULT GetNumberOfStreams([out] DWORD* pdwStreamCount);


	/// <summary>
	/// </summary>
	HRESULT GetStreamSelection([in] DWORD dwStreamIndex,
		[out] BOOL* pfEnabled);

	/// <summary>
	///     SetStreamSelection will only take place in future "SetMediaItem" calls of the media item
	/// </summary>
	HRESULT SetStreamSelection([in] DWORD dwStreamIndex,
		[in] BOOL fEnabled);


	/// <summary>
	///     (e.g. MF_MT_FRAME_SIZE for video width and height. Will also return MF_SD_* attributes)
	/// </summary>
	HRESULT GetStreamAttribute([in] DWORD dwStreamIndex,
		[in] REFGUID guidMFAttribute,
		[out] VARIANT* pvValue);

	/// <summary>
	///     Will return MF_PD_* attributes
	/// </summary>
	HRESULT GetPresentationAttribute([in] REFGUID guidMFAttribute,
		[out] VARIANT* pvValue);

	/// <summary>
	///     Gets the media source characteristics.
	/// </summary>
	HRESULT GetCharacteristics([out] MFP_MEDIAITEM_CHARACTERISTICS* pCharacteristics);

	/// <summary>
	///     Attaches a media sink to a stream
	/// </summary>
	HRESULT SetStreamSink([in] DWORD dwStreamIndex,
		[in] stdole.IUnknown* pMediaSink);

	/// <summary>
	///      Retrieves the read-only IProperyStore that contains the content properties
	/// </summary>
	HRESULT GetMetadata([out] IPropertyStore** ppMetadataStore);
};


//////////////////////////////////////////////////////////////////////////////
typedef enum MFP_EVENT_TYPE
{
	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_PLAY = 0,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_PAUSE = 1,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_STOP = 2,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_POSITION_SET = 3,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_RATE_SET = 4,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_MEDIAITEM_CREATED = 5,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_MEDIAITEM_SET = 6,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_FRAME_STEP = 7,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_MEDIAITEM_CLEARED = 8,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_MF = 9,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_ERROR = 10,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_PLAYBACK_ENDED = 11,

	/// <summary>
	/// </summary>
	MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL = 12,
}
MFP_EVENT_TYPE;


/// <summary>
/// </summary>
typedef struct MFP_EVENT_HEADER
{
	MFP_EVENT_TYPE eEventType;
	HRESULT hrEvent;
	IMFPMediaPlayer* pMediaPlayer;
	MFP_MEDIAPLAYER_STATE eState;
	IPropertyStore* pPropertyStore;
} MFP_EVENT_HEADER;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_PLAY
/// </summary>
typedef struct MFP_PLAY_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
} MFP_PLAY_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_PAUSE
/// </summary>
typedef struct MFP_PAUSE_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
} MFP_PAUSE_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_STOP
/// </summary>
typedef struct MFP_STOP_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
} MFP_STOP_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_POSITION_SET
/// </summary>
typedef struct MFP_POSITION_SET_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
} MFP_POSITION_SET_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_RATE_SET
/// </summary>
typedef struct MFP_RATE_SET_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
	float flRate;
} MFP_RATE_SET_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_MEDIAITEM_CREATED
/// </summary>
typedef struct MFP_MEDIAITEM_CREATED_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
	DWORD_PTR dwUserData;
} MFP_MEDIAITEM_CREATED_EVENT;

/// <summary>
///     Parameters of event MFP_EVENT_TYPE_MEDIAITEM_SET
/// </summary>
typedef struct MFP_MEDIAITEM_SET_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
} MFP_MEDIAITEM_SET_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_FRAME_STEP
/// </summary>
typedef struct MFP_FRAME_STEP_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
} MFP_FRAME_STEP_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_MEDIAITEM_CLEARED
/// </summary>
typedef struct MFP_MEDIAITEM_CLEARED_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
} MFP_MEDIAITEM_CLEARED_EVENT;


/// <summary>
///     Parameters of event MFP_MF_EVENT
/// </summary>
typedef struct MFP_MF_EVENT
{
	MFP_EVENT_HEADER header;
	MediaEventType MFEventType;
	IMFMediaEvent* pMFMediaEvent;
	IMFPMediaItem* pMediaItem;
} MFP_MF_EVENT;


/// <summary>
///     Parameters of event MFP_ERROR_EVENT
/// </summary>
typedef struct MFP_ERROR_EVENT
{
	MFP_EVENT_HEADER header;
} MFP_ERROR_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_PLAYBACK_ENDED
/// </summary>
typedef struct MFP_PLAYBACK_ENDED_EVENT
{
	MFP_EVENT_HEADER header;
	IMFPMediaItem* pMediaItem;
} MFP_PLAYBACK_ENDED_EVENT;


/// <summary>
///     Parameters of event MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL
/// </summary>
typedef struct MFP_ACQUIRE_USER_CREDENTIAL_EVENT
{
	MFP_EVENT_HEADER header;
	DWORD_PTR dwUserData;
	BOOL fProceedWithAuthentication;
	HRESULT hrAuthenticationStatus;
	long pwszURL;
	long pwszSite;
	long pwszRealm;
	long pwszPackage;
	LONG nRetries;
	MFP_CREDENTIAL_FLAGS flags;
	IMFNetCredential* pCredential;
} MFP_ACQUIRE_USER_CREDENTIAL_EVENT;

[
	odl,
	uuid(766C8FFB-5FDB-4fea-A28D-B912996F51BD)
]
interface IMFPMediaPlayerCallback : stdole.IUnknown
{
	HRESULT OnMediaPlayerEvent([in] MFP_EVENT_HEADER* pEventHeader);
};

typedef enum MF_CAPTURE_ENGINE_DEVICE_TYPE
{
	/// <summary>
	/// Audio device which is a microphone
	/// </summary>
	MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO = 0x00000000,
	/// <summary>
	/// Video device which is a webcam
	/// </summary>
	MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO = 0x00000001
}MF_CAPTURE_ENGINE_DEVICE_TYPE;

//////////////////////////////////////////////////////////////////////////////
//
// MF_CAPTURE_ENGINE_SINK_TYPE Enumeration
//
/////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Defines the capture sink type
/// </summary>
typedef enum MF_CAPTURE_ENGINE_SINK_TYPE
{
	/// <summary>
	/// Record sink, used for outputting compressed data
	/// </summary>
	MF_CAPTURE_ENGINE_SINK_TYPE_RECORD = 0x00000000,
	/// <summary>
	/// Record sink, used for outputting uncompressed data or rendering video
	/// </summary>
	MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW = 0x00000001,
	/// <summary>
	/// Photo sink, used for retrieving a single photograph
	/// </summary>
	MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO = 0x00000002
}MF_CAPTURE_ENGINE_SINK_TYPE;


typedef enum MF_CAPTURE_ENGINE_PREFERRED_SOURCE
{
	MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW = 0xFFFFFFFA,    //The preferred stream for previewing video
	MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD = 0xFFFFFFF9,    //The preferred stream for recording video
	MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO = 0xFFFFFFF8,//The first independent photo stream if present, or else the same stream chosen by MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW 
	MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO = 0xFFFFFFF7,//The first available audio stream
//#if(NTDDI_VERSION > NTDDI_WIN10_FE)
	MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_METADATA = 0xFFFFFFF6,//The first available metadata stream
//#endif
	MF_CAPTURE_ENGINE_MEDIASOURCE = 0xFFFFFFFF,
} MF_CAPTURE_ENGINE_PREFERRED_SOURCE;


//////////////////////////////////////////////////////////////////////////////
//
// MF_CAPTURE_ENGINE_STREAM_CATEGORY Enumeration
//
/////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Defines the source stream category
/// </summary>
typedef enum MF_CAPTURE_ENGINE_STREAM_CATEGORY
{
	/// <summary>
	/// Video Preview stream
	/// </summary>
	MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW = 0x00000000,
	/// <summary>
	/// Video Capture Stream
	/// </summary>
	MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE = 0x00000001,
	/// <summary>
	/// Independent photo stream
	/// </summary>
	MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT = 0x00000002,
	/// <summary>
	/// Dependent photo stream
	/// </summary>
	MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT = 0x00000003,
	/// <summary>
	/// Audio stream
	/// </summary>
	MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO = 0x00000004,
	/// <summary>
   /// Unsupported stream
   /// </summary>
   MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED = 0x00000005,
//#if(NTDDI_VERSION > NTDDI_WIN10_FE)
   /// <summary>
   /// Video Metadata stream
   /// </summary>
   MF_CAPTURE_ENGINE_STREAM_CATEGORY_METADATA = 0x00000006
//#endif
} MF_CAPTURE_ENGINE_STREAM_CATEGORY;


//////////////////////////////////////////////////////////////////////////////
//
// MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE Enumeration
//
/////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Defines the media capture categories.
/// </summary>
typedef enum MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE
{
	/// <summary>
	/// Default capture category
	/// </summary>
	MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_OTHER = 0,
	/// <summary>
	/// Communications capture category
	/// </summary>
	MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_COMMUNICATIONS = 1,
	/// <summary>
	/// General media capture category
	/// </summary>
	MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_MEDIA = 2,
	/// <summary>
	/// Game Chat capture category
	/// </summary>
	MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_GAMECHAT = 3,
	/// <summary>
	/// Speech capture category
	/// </summary>
	MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_SPEECH = 4,
//#if NTDDI_VERSION >= NTDDI_WIN10_FE
	/// <summary>
	/// Capture Audio located in the 'far field' for the purpose of speech recognition
	/// </summary>
	MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_FARFIELDSPEECH = 5,
	/// <summary>
	/// Consistent speech processing for the captured Audio. Used for Machine Learning
	/// </summary>
	MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_UNIFORMSPEECH = 6,
	/// <summary>
	/// Capture Audio with the intent of enabling dictation or typing by voice
	/// </summary>
	MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_VOICETYPING = 7
} MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE;


//////////////////////////////////////////////////////////////////////////////
//
// MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE Enumeration
//
/////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Defines the capture audio processing mode.
/// </summary>
typedef enum MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE
{
	/// <summary>
	/// Normal audio signal processing.
	/// </summary>
	MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT = 0,
	/// <summary>
	/// Minimal audio signal processing.
	/// </summary>
	MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW = 1
} MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// IMFCaptureEngineOnEventCallback Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface is used as the callback mechanism for the
/// Capture Engine. The application
/// passes in an instance of an object that implements this
/// callback interface as a param to IMFCaptureEngine::Intialize
/// </summary>
[
	odl,
	uuid(aeda51c0-9025-4983-9012-de597b88b089)
]
interface IMFCaptureEngineOnEventCallback : stdole.IUnknown
{
	/// <summary>
	/// Callback function that completes an asynchronous call on the capture engine
	/// </summary>
	/// <param name="IMFMediaEvent">
	/// Pointer to IMFMediaEvent interface
	/// </param>
	HRESULT OnEvent([in] IMFMediaEvent* pEvent);
};



///////////////////////////////////////////////////////////////////////////////
//
// IMFCaptureEngineOnSampleCallback Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface is used as the callback mechanism for returning
/// samples from the Capture Engine. The application
/// passes in an instance of an object that implements this
/// callback interface as an attribute by configuring one
/// of the Capture Engine's sinks. This callback is used to
/// return samples from a single stream
/// </summary>
[
	odl,
	uuid(52150b82-ab39-4467-980f-e48bf0822ecd)
]
interface IMFCaptureEngineOnSampleCallback : stdole.IUnknown //To send compressed/uncompressed samples back to app
{
	/// <summary>
	/// Callback function that completes an asynchronous request for the
	/// next available sample.
	/// </summary>
	/// <param name="pSample">
	/// Contains the next sample for the stream. It is possible for
	/// this parameter to be NULL, so the application should
	/// explicitly check for NULL before dereferencing the sample.
	/// </param>
	HRESULT OnSample([in] IMFSample* pSample);
};


///////////////////////////////////////////////////////////////////////////////
//
// IMFCaptureSink Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface is used to configure a sink
/// within the Capture Engine. The app obtains a
/// pointer to this interface using IMFCaptureEngine::GetSink
/// </summary>

[
	odl,
	uuid(72d6135b-35e9-412c-b926-fd5265f2a885),
	helpstring("IMFCaptureSink Interface")
]
interface IMFCaptureSink : stdole.IUnknown
{
	/// <summary>
	/// Method to get the current output media type on the sink
	/// </summary>
	/// <param name="ppMediaType">
	/// Receives a pointer to the current output media type of the sink
	/// </param>
	HRESULT GetOutputMediaType([in] DWORD dwSinkStreamIndex, [out] IMFMediaType** ppMediaType);

	/// <summary>
	/// Allows access to an interface from IMFCaptureSink
	/// </summary>
	/// <param name="dwSinkStreamIndex">
	/// The zero based stream index of sink
	/// </param>
	/// <param name="rguid">
	/// Specifies the service guid. Can be GUID_NULL.
	/// </param>
	/// <param name="riid">
	/// Specifies the interface identifier
	/// </param>     
	/// <param name="ppUnknown">
	/// Receives a pointer to the interface requested
	/// </param>
	HRESULT GetService([in] DWORD dwSinkStreamIndex, [in] REFGUID rguidService, [in] REFIID riid, [out] IUnknown** ppUnknown);

	/// <summary>
	/// Allows application to choose which source read stream is used as input into this sink
	/// </summary>   
	/// <param name="dwSourceStreamIndex">
	/// The zero based source stream index
	/// </param>
	/// <param name="pMediaType">
	/// Desired output media type 
	/// </param>
	/// <param name="pAttributes">
	/// A pointer to the IMFAttributes interface of an attribute store
	/// </param>
	/// <param name="pdwSinkStreamIndex">
	/// Sink stream index
	/// </param>    
	HRESULT AddStream([in] DWORD dwSourceStreamIndex, [in] IMFMediaType* pMediaType, [in]  IMFAttributes* pAttributes, [out] DWORD* pdwSinkStreamIndex);


	/// <summary>
	/// Prepares the sink. At this time the topology of the sink is built, after which GetService can be used to configure individual components
	/// </summary>   
	/// <remarks>
	/// This method is optional and only required if the user wants to configure the encoder, XVP etc before actually calling StartPreview/StartRecord/TakePhoto
	/// </remarks>
	HRESULT Prepare();

	/// <summary>
	/// Allows application to remove all streams
	/// </summary>   
	HRESULT RemoveAllStreams();

};


///////////////////////////////////////////////////////////////////////////////
//
// IMFCaptureRecordSink Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface is used to set the output of the record sink
/// The output can be set to a file, a bytestream or a callback
/// </summary>
[
	odl,
	uuid(3323b55a-f92a-4fe2-8edc-e9bfc0634d77),
	helpstring("IMFCaptureRecordSink Interface")
]
interface IMFCaptureRecordSink : IMFCaptureSink
{
	/// <summary>
	/// Allows an app to the set output of the record sink to an IMFBytestream
	/// </summary>
	/// <param name = "pByteStream">
	/// Pointer to an IMFByestream
	/// </param>
	/// <param name = "guidContainerType">
	/// Container type GUID
	/// </param>
	HRESULT SetOutputByteStream([in] IMFByteStream* pByteStream, [in] REFGUID guidContainerType);

	/// <summary>
	/// Allows an app to the set output file name to store a muxed stream
	/// </summary>
	/// <param name = "fileName">
	/// File name for storing output
	/// </param>
	HRESULT SetOutputFileName([in] LongPtr fileName);

	/// <summary>
	/// Allows an app to retrieve samples via a callback
	/// </summary>   
	/// <param name="dwSinkStreamIndex">
	/// The zero based stream index for sink
	/// </param>
	/// <param name="pCallback">
	/// Pointer to IMFCaptureEngineOnSamplecallback interface
	/// </param>
	HRESULT SetSampleCallback([in] DWORD dwStreamSinkIndex, [in]IMFCaptureEngineOnSampleCallback* pCallback);

	/// <summary>
	/// Allows an app to set a custom sink for the record path
	/// </summary>   
	/// </param>
	/// <param name="pMediaSink">
	/// Pointer to IUnknown(IMFMediaSink) interface
	/// </param>
	HRESULT SetCustomSink([in] IMFMediaSink* pMediaSink);

	/// <summary>
	/// Allows the application to get the current rotation value on the video stream.
	/// </summary>
	/// <param name="dwStreamIndex">
	/// Index of the stream to query.  Must be a video stream.
	/// </param>
	/// <param name="pdwRotationValue">
	/// The degree by which the video is rotated.  Valid values are 0, 90, 180, or 270.
	/// </param>
	HRESULT GetRotation([in] DWORD dwStreamIndex, [out] DWORD* pdwRotationValue);

	/// <summary>
	/// Allows the application to rotate the preview video stream 0, 90, 180 or 270 degrees.
	/// 0 degrees restores the video to non-rotated state.
	/// </summary>
	/// <param name="dwStreamIndex">
	/// Index of the stream to rotate.  Must be a video stream.
	/// </param>
	/// <param name="dwRotationValue">
	/// The degree by which the video is rotated.  Valid values are 0, 90, 180, or 270.
	/// </param>
	HRESULT SetRotation([in] DWORD dwStreamIndex, [in] DWORD dwRotationValue);
};


///////////////////////////////////////////////////////////////////////////////
//
// IMFCapturePreviewSink Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface is used to set the output of the preview sink
/// The output can be set a handle for rendering or a callback
/// </summary>
[
	odl,
	uuid(77346cfd-5b49-4d73-ace0-5b52a859f2e0),
	helpstring("IMFCapturePreviewSink Interface")
]
interface IMFCapturePreviewSink : IMFCaptureSink
{
	/// <summary>
	/// Allows an app to render samples
	/// </summary>
	/// <param name="handle">
	/// HWND
	/// </param>
	HRESULT SetRenderHandle([in] HANDLE handle);

	/// <summary>
	/// Allows an app to render samples
	/// </summary>
	/// <param name="pSurface">
	/// IUnknown(IDCompositionVisual)
	/// </param>
	HRESULT SetRenderSurface([in] IUnknown* pSurface);

	/// <summary>
	/// Updates the video frame.
	/// </summary>
	/// <param name= "pSrc">
	/// MFVideoNormalizedRect
	/// </param>
	/// <param name= "pDst">
	/// RECT
	/// </param>
	/// <param name= "pBorderClr">
	/// COLORREF
	/// </param>
	HRESULT UpdateVideo([in] MFVideoNormalizedRect* pSrc,
		[in] RECT* pDst,
		[in] COLORREF* pBorderClr);

	/// <summary>
	/// Allows an app to retrieve samples via a callback
	/// </summary>  
	/// <param name="dwSinkStreamIndex">
	/// The zero based stream index for sink
	/// </param>
	/// <param name="pCallback">
	/// Pointer to IMFCaptureEngineOnSamplecallback interface
	/// </param>
	HRESULT SetSampleCallback([in] DWORD dwStreamSinkIndex, [in] IMFCaptureEngineOnSampleCallback* pCallback);

	/// <summary>
	/// Method to query for the current preview output's mirroring state
	/// </summary>
	/// <param name="pfMirrorState">
	/// Receives the boolean flag indicating the current mirror state (true=on, false=off).
	/// </param>
	HRESULT GetMirrorState([out]BOOL* pfMirrorState);

	/// <summary>
	/// Method to set the current preview output's mirroring state
	/// </summary>
	/// <param name="fMirrorState">
	/// Boolean flag indicating the current mirror state (true=on, false=off).
	/// </param>
	HRESULT SetMirrorState([in]BOOL fMirrorState);

	/// <summary>
	/// Allows the application to get the current rotation value on the video stream.
	/// </summary>
	/// <param name="dwStreamIndex">
	/// Index of the stream to query.  Must be a video stream.
	/// </param>
	/// <param name="pdwRotationValue">
	/// The degree by which the video is rotated.  Valid values are 0, 90, 180, or 270.
	/// </param>
	HRESULT GetRotation([in] DWORD dwStreamIndex, [out] DWORD* pdwRotationValue);

	/// <summary>
	/// Allows the application to rotate the preview video stream 0, 90, 180 or 270 degrees.
	/// 0 degrees restores the video to non-rotated state.
	/// </summary>
	/// <param name="dwStreamIndex">
	/// Index of the stream to rotate.  Must be a video stream.
	/// </param>
	/// <param name="dwRotationValue">
	/// The degree by which the video is rotated.  Valid values are 0, 90, 180, or 270.
	/// </param>
	HRESULT SetRotation([in] DWORD dwStreamIndex, [in] DWORD dwRotationValue);

	/// <summary>
	/// Allows an app to set a custom sink for the preview path
	/// </summary>   
	/// </param>
	/// <param name="pMediaSink">
	/// Pointer to IUnknown(IMFMediaSink) interface
	/// </param>
	HRESULT SetCustomSink([in] IMFMediaSink* pMediaSink);
};

///////////////////////////////////////////////////////////////////////////////
//
// IMFCapturePhotoSink Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface is used to set the output of the photo sink
/// The output can be set to a file or a callback
/// </summary>
[
	odl,
	uuid(d2d43cc8-48bb-4aa7-95db-10c06977e777),
	helpstring("IMFCapturePhotoSink Interface")
]
interface IMFCapturePhotoSink : IMFCaptureSink
{
	/// <summary>
	/// Allows an app to the set output file name to store an image
	/// </summary>
	/// <param name = "fileName">
	/// File name for storing output
	/// </param>
	HRESULT SetOutputFileName([in] LongPtr fileName);

	/// <summary>
	/// Allows an app to retrieve a sample via a callback
	/// </summary>
	/// <param name="pCallback">
	/// Pointer to IMFCaptureEngineOnSamplecallback interface
	/// </param>
	HRESULT SetSampleCallback([in] IMFCaptureEngineOnSampleCallback* pCallback);

	/// <summary>
	/// Allows an app to the set output of the photo sink to an IMFBytestream
	/// </summary>
	/// <param name = "pByteStream">
	/// Pointer to an IMFByestream
	/// </param>
	HRESULT SetOutputByteStream([in] IMFByteStream* pByteStream);

};


///////////////////////////////////////////////////////////////////////////////
//
// IMFCaptureSource Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface is used to configure the capture source which is a wrapper over the source reader
/// </summary>
[
	odl,
	uuid(439a42a8-0d2c-4505-be83-f79b2a05d5c4),
	helpstring("IMFCaptureSource Interface")
]
interface IMFCaptureSource : stdole.IUnknown
{
	/// <summary>
	/// Allows an app to get the current capture device's IMFMediaSource object pointer 
	/// </summary>
	/// <param name = "mfCaptureEngineDeviceType">
	/// Device type from MF_CAPTURE_ENGINE_DEVICE_TYPE enumeration
	/// </param>
	/// <param name = "ppMediaSource">
	/// Receives a pointer to IMFMediaSource that represents a device
	/// </param>
	HRESULT GetCaptureDeviceSource([in] MF_CAPTURE_ENGINE_DEVICE_TYPE mfCaptureEngineDeviceType, [out] IMFMediaSource** ppMediaSource);

	/// <summary>
	/// Allows an app to get the current capture device's IMFActivate object pointer
	/// </summary>
	/// <param name = "mfCaptureEngineDeviceType">
	/// Device type from MF_CAPTURE_ENGINE_DEVICE_TYPE enumeration
	/// </param>
	/// <param name = "ppActivate">
	/// Receives a pointer to IMFActivate that represents a device
	/// </param>
	HRESULT GetCaptureDeviceActivate([in] MF_CAPTURE_ENGINE_DEVICE_TYPE mfCaptureEngineDeviceType, [out] IMFActivate** ppActivate);

	/// <summary>
	/// Allows access to an interface from IMFCaptureSource
	/// </summary>
	/// <param name="rguid">
	/// Specifies the service guid. Can be GUID_NULL.
	/// </param>    
	/// <param name="riid">
	/// Specifies the interface identifier
	/// </param>    
	/// <param name="ppUnknown">
	/// Receives a pointer to the interface requested
	/// </param>
	HRESULT GetService([in] REFIID rguidService, [in] REFIID riid, [out] IUnknown** ppUnknown);

	/// <summary>
	/// Allows an app to add an effect to the device stream
	/// </summary>  
	/// <param name="dwSourceStreamIndex">
	/// Zero based stream index of source
	/// </param>
	/// <param name="pUnknown">
	/// Pointer to IUnknown, can be an IMFTransform or IMFActivate
	/// </param>
	HRESULT AddEffect([in] DWORD dwSourceStreamIndex, [in] IUnknown* pUnknown);

	/// <summary>
	/// Allows an app to remove an effect to the device stream
	/// </summary>
	/// <param name="dwSourceStreamIndex">
	/// Zero based stream index of source
	/// </param>
	/// <param name="pUnknown">
	/// Pointer to IUnknown, can be an IMFTransform or IMFActivate
	/// </param>
	HRESULT RemoveEffect([in] DWORD dwSourceStreamIndex, [in]IUnknown* pUnknown);

	/// <summary>
	/// Allows an app to remove all effects from to the device stream
	/// </summary>  
	/// <param name="dwSourceStreamIndex">
	/// Zero based stream index of source
	/// </param>
	HRESULT RemoveAllEffects([in] DWORD dwSourceStreamIndex);

	/// <summary>
	/// Gets an available media type for a stream from the device
	/// </summary>
	/// <param name="dwSourceStreamIndex">
	/// Zero based stream index of source
	/// </param>
	/// <param name="dwMediaTypeIndex">
	/// Index of the media type to retrieve. Media types are indexed from zero.
	/// </param>
	/// <param name="ppMediaType">
	/// Receives a pointer to IMFMediaType. App should release this.
	/// </param>
	HRESULT GetAvailableDeviceMediaType([in] DWORD dwSourceStreamIndex, [in] DWORD dwMediaTypeIndex, [out] IMFMediaType** ppMediaType);

	/// <summary>
	/// Sets a media type for an stream from the device
	/// </summary>  
	/// <param name="dwSourceStreamIndex">
	/// Zero based stream index of source
	/// </param>
	/// <param name="pMediaType">
	/// Pointer to IMFMediaType.
	/// </param>
	HRESULT SetCurrentDeviceMediaType([in] DWORD dwSourceStreamIndex, [in] IMFMediaType* pMediaType);

	/// <summary>
	/// Gets the currently set media type for a stream from the device
	/// </summary>
	/// <param name="dwSourceStreamIndex">
	/// Zero based stream index of source
	/// </param>
	/// <param name="dwMediaTypeIndex">
	/// Index of the media type to retrieve. Media types are indexed from zero.
	/// </param>
	/// <param name="ppMediaType">
	/// Receives a pointer to IMFMediaType. App should release this.
	/// </param>
	HRESULT GetCurrentDeviceMediaType([in] DWORD dwSourceStreamIndex, [out] IMFMediaType** ppMediaType);

	/// <summary>
	/// Gets the number of streams that is available on the source (includes audio and video streams)
	/// </summary>  
	/// <param name="pdwStreamCount">
	/// Receives the number of streams available
	/// </param>
	HRESULT GetDeviceStreamCount([out] DWORD* pdwStreamCount);

	/// <summary>
   /// Gets the stream category for a given source stream index
   /// </summary>  
   /// <param name="dwSourceStreamIndex">
   /// Source stream index
   /// </param>
   /// <param name="pStreamCategory">
   /// Receives a value from the MF_CAPTURE_ENGINE_STREAM_CATEGORY enumeration
   /// </param>
	HRESULT GetDeviceStreamCategory([in] DWORD dwSourceStreamIndex, [out] MF_CAPTURE_ENGINE_STREAM_CATEGORY* pStreamCategory);

	/// <summary>
	/// Method to query for the current preview output's mirroring state
	/// </summary>
	/// <param name="pfMirrorState">
	/// Receives the boolean flag indicating the current mirror state (true=on, false=off).
	/// </param>
	HRESULT GetMirrorState([in] DWORD dwStreamIndex, [out]BOOL* pfMirrorState);

	/// <summary>
	/// Method to set the current preview output's mirroring state
	/// </summary>
	/// <param name="fMirrorState">
	/// Boolean flag indicating the current mirror state (true=on, false=off).
	/// </param>
	HRESULT SetMirrorState([in] DWORD dwStreamIndex, [in]BOOL fMirrorState);

	/// <summary>
	/// Translates a friendly stream name to an actual device stream index
	/// </summary>
	/// <param name="uifriendlyName">
	/// can be one of  MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM, MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM , MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM
	/// MF_CAPTURE_ENGINE_PREFERRED_SOURCE_VIDEO_STREAM_FOR_RECORD, MF_CAPTURE_ENGINE_PREFERRED_SOURCE_VIDEO_STREAM_FOR_PREVIEW, MF_CAPTURE_ENGINE_FIRST_SOURCE_INDEPENDENT_PHOTO_STREAM
	/// </param>
	/// <param name="pdwActualStreamIndex>
	/// Receives the value of the stream index that corresponds to the friendly name
	/// </param>    
	HRESULT GetStreamIndexFromFriendlyName([in]UINT32 uifriendlyName, [out]DWORD* pdwActualStreamIndex);
};




///////////////////////////////////////////////////////////////////////////////
//
// IMFCaptureEngine Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface is used to control the Capture Engine
/// </summary>
[
	odl,
	uuid(a6bba433-176b-48b2-b375-53aa03473207),
	helpstring("IMFCaptureEngine Interface")
]
interface IMFCaptureEngine : stdole.IUnknown
{
	/// <summary>
	/// Initializes the the capture engine. App should listen for MF_CAPTURE_ENGINE_INITIALIZED via IMFCaptureEngineOnEventCallback
	/// </summary>
	/// <param name ="pEventCallback">
	/// A pointer to IMFCaptureEngineOnEventCallback interface
	/// </param>
	/// <param name ="pAttributes">
	/// A pointer to IMFAttributes interface
	/// </param>
	/// </param>
	/// <param name ="pAudioSource">
	/// A pointer to IMFMediaSource or IMFActivate interface that represents an audio device
	/// </param>
	/// </param>
	/// <param name ="pVideoSource">
	/// A pointer to IMFAttributes or IMFActivate interface that represetns a video device
	/// </param>
	HRESULT Initialize([in] IMFCaptureEngineOnEventCallback* pEventCallback, [in] IMFAttributes* pAttributes, [in] IUnknown* pAudioSource, [in] IUnknown* pVideoSource);

	/// <summary>
	/// Asynchronous method to start preview. App should listen for MF_CAPTURE_ENGINE_PREVIEW_STARTED via IMFCaptureEngineOnEventCallback
	/// </summary>
	HRESULT StartPreview();

	/// <summary>
	/// Asynchronous method to stop preview. App should listen for MF_CAPTURE_ENGINE_PREVIEW_STOPPED via IMFCaptureEngineOnEventCallback
	/// </summary>
	HRESULT StopPreview();

	/// <summary>
	/// Asynchronous method to start recording. App should listen for MF_CAPTURE_ENGINE_RECORD_STARTED via IMFCaptureEngineOnEventCallback
	/// </summary>
	HRESULT StartRecord();

	/// <summary>
	/// Asynchronous method to stop recording. App should listen for MF_CAPTURE_ENGINE_RECORD_STOPPED via IMFCaptureEngineOnEventCallback
	/// </summary>
	/// </param>
	/// <param name="bFinalize">
	/// Specifies if the output file should be finalized. If this is false then the output file wont be able to play back
	/// </param>
	/// <param name="bFlushUnprocessedSamples">
	/// Specifies if the unprocessed samples waiting to be encoded should be flushed
	/// </param>

	HRESULT StopRecord([in] BOOL bFinalize, [in] BOOL bFlushUnprocessedSamples);

	/// <summary>
	/// Asynchronous method to take a photo. App should listen for MF_CAPTURE_ENGINE_PHOTO_TAKEN via IMFCaptureEngineOnEventCallback
	/// </summary>
	HRESULT TakePhoto();

	/// <summary>
	/// Method to obtain access to an IMFCaptureSink
	/// </summary>
	/// <param name="mfCaptureEngineSinkType">
	/// Specifies the capture sink type from the MF_CAPTURE_ENGINE_SINK_TYPE enumeration
	/// </param>
	/// <param name="ppSink">
	/// Receives a pointer to IMFCaptureSink interface
	/// </param>
	HRESULT GetSink([in]MF_CAPTURE_ENGINE_SINK_TYPE mfCaptureEngineSinkType, [out]IMFCaptureSink** ppSink);

	/// <summary>
	/// Method to obtain access to IMFCaptureSource
	/// </summary>
	/// <param name="ppSource">
	/// Receives a pointer to IMFCaptureSource interface
	/// </param>
	HRESULT GetSource([out] IMFCaptureSource** ppSource);

};



//////////////////////////////////////////////////////////////////////////////
//
// Class Factory for MF Capture Engine
//
/////////////////////////////////////////////////////////////////////////////


[
	odl,
	uuid(8f02d140-56fc-4302-a705-3a97c78be779)
]
interface IMFCaptureEngineClassFactory : stdole.IUnknown
{
	HRESULT CreateInstance(
		[in] REFCLSID clsid,
		[in] REFIID riid,
		[out] LPVOID ppvObject);

};

///////////////////////////////////////////////////////////////////////////////
// IMFCaptureEngineOnSampleCallback2Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
///     This interface is used to communicate format change events inband with sample callback
/// </summary>
[
	odl,
	uuid(e37ceed7-340f-4514-9f4d-9c2ae026100b)
]
interface IMFCaptureEngineOnSampleCallback2 : stdole.IUnknown
{
	//IMFCaptureEngineOnSampleCallback methods
	HRESULT OnSample([in] IMFSample* pSample);
	//IMFCaptureEngineOnSampleCallback2 methods
	HRESULT OnSynchronizedEvent([in] IMFMediaEvent* pEvent);
};

///////////////////////////////////////////////////////////////////////////////
// IMFCaptureSink2 Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
///     This interface is used to set the output of the record sink or preview sink after record or preview has started
/// </summary>
[
	odl,
	uuid(f9e4219e-6197-4b5e-b888-bee310ab2c59),
	helpstring("IMFCaptureSink2 Interface")
]
interface IMFCaptureSink2 : IMFCaptureSink
{
	HRESULT SetOutputMediaType([in] DWORD dwStreamIndex, [in] IMFMediaType* pMediaType, [in] IMFAttributes* pEncodingAttributes);
};




//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_ENGINE_ERROR 
//
//  Synopsis:   Defines the error status of <video>/<audio> elements
//
//------------------------------------------------------------------------------
typedef enum MF_MEDIA_ENGINE_ERR
{
	MF_MEDIA_ENGINE_ERR_NOERROR = 0,
	MF_MEDIA_ENGINE_ERR_ABORTED = 1,
	MF_MEDIA_ENGINE_ERR_NETWORK = 2,
	MF_MEDIA_ENGINE_ERR_DECODE = 3,
	MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED = 4,
	MF_MEDIA_ENGINE_ERR_ENCRYPTED = 5
} MF_MEDIA_ENGINE_ERR;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaError
//
//  Synopsis:   Media engine error information
//
//  See http://dev.w3.org/html5/spec/video.html#mediaerror for details
//------------------------------------------------------------------------------
[
	odl,
	uuid(fc0e10d2-ab2a-4501-a951-06bb1075184c)
]
interface IMFMediaError : stdole.IUnknown
{
	USHORT GetErrorCode();
	HRESULT GetExtendedErrorCode();
	HRESULT SetErrorCode([in] MF_MEDIA_ENGINE_ERR error);
	HRESULT SetExtendedErrorCode([in] HRESULT error);
};

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaTimeRange
//
//  Synopsis:   IMFMediaTimeRange represents a list of ranges (periods) of time
//
//  See http://dev.w3.org/html5/spec/video.html#timeranges for details            
//------------------------------------------------------------------------------
[
	odl,
	uuid(db71a2fc-078a-414e-9df9-8c2531b0aa6c)
]
interface IMFMediaTimeRange : stdole.IUnknown
{
	DWORD GetLength();

	HRESULT GetStart(
		[in] DWORD index,
		[out] double* pStart
	);

	HRESULT GetEnd(
		[in] DWORD index,
		[out] double* pEnd
	);

	// Extensions
	BOOL ContainsTime(
		[in] double time
	);

	HRESULT AddRange(
		[in] double startTime,
		[in] double endTime
	);

	HRESULT Clear();
};

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_ENGINE_EVENT
//
//  Synopsis:   A list of events generated by the media engine
//
//  See http://dev.w3.org/html5/spec/video.html#mediaevents for details
//------------------------------------------------------------------------------
typedef enum MF_MEDIA_ENGINE_EVENT
{
	//
	// Standard events
	//
	MF_MEDIA_ENGINE_EVENT_LOADSTART = 1,
	MF_MEDIA_ENGINE_EVENT_PROGRESS = 2,
	MF_MEDIA_ENGINE_EVENT_SUSPEND = 3,
	MF_MEDIA_ENGINE_EVENT_ABORT = 4,
	MF_MEDIA_ENGINE_EVENT_ERROR = 5,
	MF_MEDIA_ENGINE_EVENT_EMPTIED = 6,
	MF_MEDIA_ENGINE_EVENT_STALLED = 7,
	MF_MEDIA_ENGINE_EVENT_PLAY = 8,
	MF_MEDIA_ENGINE_EVENT_PAUSE = 9,
	MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA = 10,
	MF_MEDIA_ENGINE_EVENT_LOADEDDATA = 11,
	MF_MEDIA_ENGINE_EVENT_WAITING = 12,
	MF_MEDIA_ENGINE_EVENT_PLAYING = 13,
	MF_MEDIA_ENGINE_EVENT_CANPLAY = 14,
	MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH = 15,
	MF_MEDIA_ENGINE_EVENT_SEEKING = 16,
	MF_MEDIA_ENGINE_EVENT_SEEKED = 17,
	MF_MEDIA_ENGINE_EVENT_TIMEUPDATE = 18,
	MF_MEDIA_ENGINE_EVENT_ENDED = 19,
	MF_MEDIA_ENGINE_EVENT_RATECHANGE = 20,
	MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE = 21,
	MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE = 22,

	//
	// Extensions
	//
	MF_MEDIA_ENGINE_EVENT_FORMATCHANGE = 1000,
	MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS = 1001,
	MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER = 1002,
	MF_MEDIA_ENGINE_EVENT_BALANCECHANGE = 1003,
	MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE = 1004,
	MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED = 1005,
	MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED = 1006,
	MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED = 1007,
	MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE = 1008,
	MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY = 1009,
	MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE = 1010,
	MF_MEDIA_ENGINE_EVENT_OPMINFO = 1011,
	MF_MEDIA_ENGINE_EVENT_RESOURCELOST = 1012,
	MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED = 1013,
	MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR = 1014,
	MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED = 1015,
	MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE = 1016,

} MF_MEDIA_ENGINE_EVENT;


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineNotify
//
//  Synopsis:   IMFMediaEngineNotify fires events
//
//  This interface is implemented by the component using IMFMediaEngine
//------------------------------------------------------------------------------
[
	odl,
	uuid(fee7c112-e776-42b5-9bbf-0048524e2bd5)
]
interface IMFMediaEngineNotify : stdole.IUnknown
{
	HRESULT EventNotify(
		[in] DWORD event,
		[in] LongPtr param1,
		[in] DWORD param2
	);
};

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineSrcElements
//
//  Synopsis:   IMFMediaEngineSrcElements represents a list of <source> elements
//
//  See http://dev.w3.org/html5/spec/video.html#the-source-element for details
//------------------------------------------------------------------------------
[
	odl,
	uuid(7a5e5354-b114-4c72-b991-3131d75032ea)
]
interface IMFMediaEngineSrcElements : stdole.IUnknown
{
	DWORD GetLength();

	HRESULT GetURL(
		[in] DWORD index,
		[out] BSTR* pURL
	);

	HRESULT GetType(
		[in] DWORD index,
		[out] BSTR* pType
	);

	HRESULT GetMedia(
		[in] DWORD index,
		[out] BSTR* pMedia
	);

	HRESULT AddElement(
		[in] BSTR pURL,
		[in] BSTR pType,
		[in] BSTR pMedia
	);

	HRESULT RemoveAllElements();
};

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_ENGINE_NETWORK
//
//  Synopsis:   Defines different network states of the <audio>/<video> elements
//
//  See http://dev.w3.org/html5/spec/video.html#dom-media-networkstate for details
//------------------------------------------------------------------------------
typedef enum MF_MEDIA_ENGINE_NETWORK
{
	MF_MEDIA_ENGINE_NETWORK_EMPTY = 0,
	MF_MEDIA_ENGINE_NETWORK_IDLE = 1,
	MF_MEDIA_ENGINE_NETWORK_LOADING = 2,
	MF_MEDIA_ENGINE_NETWORK_NO_SOURCE = 3
} MF_MEDIA_ENGINE_NETWORK;



//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_ENGINE_READY
//
//  Synopsis:   Defines different ready states of the <audio>/<video> elements
//
//  See http://dev.w3.org/html5/spec/video.html#the-ready-states for details
//------------------------------------------------------------------------------
typedef enum MF_MEDIA_ENGINE_READY
{
	MF_MEDIA_ENGINE_READY_HAVE_NOTHING = 0,
	MF_MEDIA_ENGINE_READY_HAVE_METADATA = 1,
	MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA = 2,
	MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA = 3,
	MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA = 4
} MF_MEDIA_ENGINE_READY;


//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_ENGINE_CANPLAY
//
//  Synopsis:   Defines the likelihood that the <audio>/<video> elements will be able
///             to play a source
//
//  See http://dev.w3.org/html5/spec/video.html#dom-navigator-canplaytype for details
//------------------------------------------------------------------------------
typedef enum MF_MEDIA_ENGINE_CANPLAY
{
	MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED = 0,
	MF_MEDIA_ENGINE_CANPLAY_MAYBE = 1,
	MF_MEDIA_ENGINE_CANPLAY_PROBABLY = 2,
} MF_MEDIA_ENGINE_CANPLAY;


//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_ENGINE_PRELOAD
//
//  Synopsis:   Defines different types of preloads
//
//  See http://dev.w3.org/html5/spec/video.html#attr-media-preload for details
//------------------------------------------------------------------------------
typedef enum MF_MEDIA_ENGINE_PRELOAD
{
	MF_MEDIA_ENGINE_PRELOAD_MISSING = 0,
	MF_MEDIA_ENGINE_PRELOAD_EMPTY = 1,
	MF_MEDIA_ENGINE_PRELOAD_NONE = 2,
	MF_MEDIA_ENGINE_PRELOAD_METADATA = 3,
	MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC = 4
} MF_MEDIA_ENGINE_PRELOAD;


//cpp_quote("#ifndef _MFVideoNormalizedRect_")
//cpp_quote("#define _MFVideoNormalizedRect_")
//typedef struct MFVideoNormalizedRect
//{
//	float left;
//	float top;
//	float right;
//	float bottom;
//} MFVideoNormalizedRect;
//cpp_quote("#endif")

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngine
//
//  Synopsis:   IMFMediaEngine provides audio and video playback for the
//              HTML5 <audio> and <video> elements.
//
//  See http://dev.w3.org/html5/spec/video.html#video for details
//------------------------------------------------------------------------------
[
	odl,
	uuid(98a1b0bb-03eb-4935-ae7c-93c1fa0e1c93)
]
interface IMFMediaEngine : stdole.IUnknown
{
	// Error state
	HRESULT GetError(
		[out] IMFMediaError** ppError
	);

	HRESULT SetErrorCode(
		[in] MF_MEDIA_ENGINE_ERR error
	);

	// Network state
	HRESULT SetSourceElements(
		[in] IMFMediaEngineSrcElements* pSrcElements
	);

	HRESULT SetSource(
		[in] BSTR pUrl
	);

	HRESULT GetCurrentSource(
		[out] BSTR* ppUrl
	);

	USHORT GetNetworkState();

	MF_MEDIA_ENGINE_PRELOAD GetPreload();

	HRESULT SetPreload(
		[in] MF_MEDIA_ENGINE_PRELOAD Preload
	);

	HRESULT GetBuffered(
		[out] IMFMediaTimeRange** ppBuffered
	);

	HRESULT Load();

	HRESULT CanPlayType(
		[in] BSTR type,
		[out] MF_MEDIA_ENGINE_CANPLAY* pAnswer
	);

	// Ready state
	USHORT GetReadyState();

	BOOL IsSeeking();


	// Playback state
	double GetCurrentTime();

	HRESULT SetCurrentTime(
		[in] double seekTime
	);

	double GetStartTime();

	double GetDuration();

	BOOL IsPaused();

	double GetDefaultPlaybackRate();

	HRESULT SetDefaultPlaybackRate(
		[in] double Rate
	);

	double GetPlaybackRate();

	HRESULT SetPlaybackRate(
		[in] double Rate
	);

	HRESULT GetPlayed(
		[out] IMFMediaTimeRange** ppPlayed
	);

	HRESULT GetSeekable(
		[out] IMFMediaTimeRange** ppSeekable
	);

	BOOL IsEnded();

	BOOL GetAutoPlay();

	HRESULT SetAutoPlay(
		[in] BOOL AutoPlay
	);

	BOOL GetLoop();

	HRESULT SetLoop(
		[in] BOOL Loop
	);

	HRESULT Play();

	HRESULT Pause();

	// Controls
	BOOL GetMuted();

	HRESULT SetMuted(
		[in] BOOL Muted
	);

	double GetVolume();

	HRESULT SetVolume(
		[in] double Volume
	);

	// Extensions
	BOOL HasVideo();

	BOOL HasAudio();

	HRESULT GetNativeVideoSize(
		[out] DWORD* cx,
		[out] DWORD* cy
	);

	HRESULT GetVideoAspectRatio(
		[out] DWORD* cx,
		[out] DWORD* cy
	);

	HRESULT Shutdown();

	HRESULT TransferVideoFrame(
		[in] IUnknown* pDstSurf,
		[in] MFVideoNormalizedRect* pSrc,
		[in] RECT* pDst,
		[in] MFARGB* pBorderClr
	);

	HRESULT OnVideoStreamTick(
		[out] LONGLONG* pPts
	);
};


typedef enum MF_MEDIA_ENGINE_S3D_PACKING_MODE
{
	MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE = 0,
	MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE = 1,
	MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM = 2

} MF_MEDIA_ENGINE_S3D_PACKING_MODE;


typedef enum MF_MEDIA_ENGINE_STATISTIC
{
	MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED = 0,
	MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED = 1,
	MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED = 2,
	MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS = 3,
	MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND = 4,
	MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER = 5,
	MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED = 6,
	MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY = 7,

} MF_MEDIA_ENGINE_STATISTIC;

typedef enum MF_MEDIA_ENGINE_SEEK_MODE
{
	MF_MEDIA_ENGINE_SEEK_MODE_NORMAL = 0,
	MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE = 1,
} MF_MEDIA_ENGINE_SEEK_MODE;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineEx
//
//  Synopsis:   IMFMediaEngineEx extends the media engine beyond the basic 
//              specification of the HTML5 <audio> and <video> elements.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(83015ead-b1e6-40d0-a98a-37145ffe1ad1),
]
interface IMFMediaEngineEx : IMFMediaEngine
{
	HRESULT SetSourceFromByteStream(
		[in] IMFByteStream* pByteStream,
		[in] BSTR pURL
	);

	HRESULT GetStatistics(
		[in] MF_MEDIA_ENGINE_STATISTIC StatisticID,
		[out] VARIANT* pStatistic
	);

	HRESULT UpdateVideoStream(
		[in] MFVideoNormalizedRect* pSrc,
		[in] RECT* pDst,
		[in] MFARGB* pBorderClr
	);

	double GetBalance();

	HRESULT SetBalance(
		[in] double balance
	);

	BOOL IsPlaybackRateSupported(
		[in] double rate
	);

	HRESULT FrameStep(
		[in] BOOL Forward
	);

	HRESULT GetResourceCharacteristics(
		[out] DWORD* pCharacteristics
	);

	HRESULT GetPresentationAttribute(
		[in] REFGUID guidMFAttribute,
		[out] VARIANT* pvValue
	);

	HRESULT GetNumberOfStreams(
		[out] DWORD* pdwStreamCount
	);

	HRESULT GetStreamAttribute(
		[in] DWORD dwStreamIndex,
		[in] REFGUID guidMFAttribute,
		[out] VARIANT* pvValue
	);

	HRESULT GetStreamSelection(
		[in] DWORD dwStreamIndex,
		[out] BOOL* pEnabled
	);

	HRESULT SetStreamSelection(
		[in] DWORD dwStreamIndex,
		[in] BOOL Enabled
	);

	HRESULT ApplyStreamSelections();

	HRESULT IsProtected(
		[out] BOOL* pProtected
	);

	HRESULT InsertVideoEffect(
		[in] IUnknown* pEffect,
		[in] BOOL fOptional
	);

	HRESULT InsertAudioEffect(
		[in] IUnknown* pEffect,
		[in] BOOL fOptional
	);

	HRESULT RemoveAllEffects();

	HRESULT SetTimelineMarkerTimer(
		[in] double timeToFire
	);

	HRESULT GetTimelineMarkerTimer(
		[out] double* pTimeToFire
	);

	HRESULT CancelTimelineMarkerTimer();

	// Stereoscopic 3D support
	BOOL IsStereo3D();

	HRESULT GetStereo3DFramePackingMode(
		[out] MF_MEDIA_ENGINE_S3D_PACKING_MODE* packMode
	);
	HRESULT SetStereo3DFramePackingMode(
		[in] MF_MEDIA_ENGINE_S3D_PACKING_MODE packMode
	);

	HRESULT GetStereo3DRenderMode(
		[out] MF3DVideoOutputType* outputType
	);

	HRESULT SetStereo3DRenderMode(
		[in] MF3DVideoOutputType outputType
	);

	// DComp support
	HRESULT EnableWindowlessSwapchainMode(
		[in] BOOL fEnable
	);

	HRESULT GetVideoSwapchainHandle(
		[out] HANDLE* phSwapchain
	);

	// video mirroring
	HRESULT EnableHorizontalMirrorMode(
		[in] BOOL fEnable
	);

	// audio settings for next resource load
	HRESULT GetAudioStreamCategory(
		[out] UINT32* pCategory
	);

	HRESULT SetAudioStreamCategory(
		[in] UINT32 category
	);

	HRESULT GetAudioEndpointRole(
		[out] UINT32* pRole
	);

	HRESULT SetAudioEndpointRole(
		[in] UINT32 role
	);

	HRESULT GetRealTimeMode(
		[out] BOOL* pfEnabled
	);

	HRESULT SetRealTimeMode(
		[in] BOOL fEnable
	);

	// advanced seeking support
	HRESULT SetCurrentTimeEx(
		[in] double seekTime,
		[in] MF_MEDIA_ENGINE_SEEK_MODE seekMode
	);

	// timer control
	HRESULT EnableTimeUpdateTimer(
		[in] BOOL fEnableTimer
	);
};

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineAudioEndpointId
//
//  Synopsis:   IMFMediaEngineAudioEndpointId extends the media engine for audio endpoint Ids
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(7a3bac98-0e76-49fb-8c20-8a86fd98eaf2)
]
interface IMFMediaEngineAudioEndpointId : stdole.IUnknown
{
	HRESULT SetAudioEndpointId(
		[in] LongPtr pszEndpointId
	);

	HRESULT GetAudioEndpointId(
		[out] LongPtr* ppszEndpointId
	);
};

typedef enum MF_MEDIA_ENGINE_EXTENSION_TYPE
{
	MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE = 0,
	MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM = 1
} MF_MEDIA_ENGINE_EXTENSION_TYPE;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMediaEngineExtension
//
//  Synopsis:   Allows Media Engine clients to extend the range of formats 
//              supported by the Media Engine by providing the Media Engine
//              with a mechanism to load custom MF Media Sources.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(2f69d622-20b5-41e9-afdf-89ced1dda04e)
]
interface IMFMediaEngineExtension : stdole.IUnknown
{
	HRESULT CanPlayType(
		[in] BOOL AudioOnly, // are we being called by an audio or video tag
		[in] BSTR MimeType,  // mime type of interest
		[out] MF_MEDIA_ENGINE_CANPLAY* pAnswer // answer returned here
	);

	HRESULT BeginCreateObject(
		[in] BSTR bstrURL,                   // URL of object to be created
		[in] IMFByteStream* pByteStream, // optional bytestream to use
		[in] MF_OBJECT_TYPE type,            // type of object to be created
		[out] IUnknown** ppIUnknownCancelCookie,// cancel cookie to be used if we abort the operation early
		[in] IMFAsyncCallback* pCallback,    // callback to be invoked when operation completes
		[in] IUnknown* punkState         // optional async state
	);

	HRESULT CancelObjectCreation(
		[in] IUnknown* pIUnknownCancelCookie // cancel cookie from BeginCreateObject
	);

	HRESULT EndCreateObject(
		[in] IMFAsyncResult* pResult,        // Object creation result
		[out] IUnknown** ppObject     // pointer to created object
	);
};

typedef enum MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS
{
	MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED = 0x01,
	MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION = 0x02,
	MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION = 0x04,
} MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineProtectedContent
//
//  Synopsis:   Support for playback of DRM'ed content by the  
//              supported by the Media Engine by providing the Media Engine
//              with a mechanism to load custom MF Media Sources.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(9f8021e8-9c8c-487e-bb5c-79aa4779938c)
]
interface IMFMediaEngineProtectedContent : stdole.IUnknown
{
	//  Call this to share surfaces in a device with the PMP process
	HRESULT ShareResources([in] IUnknown* pUnkDeviceContext);

	//  Get required frame protections
	//  these may be required by some or all frames in the content
	HRESULT GetRequiredProtections([out] DWORD* pFrameProtectionFlags);

	//  Set the window to apply link protections to
	HRESULT SetOPMWindow([in] HWND hwnd);

	//  Transfer a frame from protected content
	HRESULT TransferVideoFrame(
		[in] IUnknown* pDstSurf,
		[in] MFVideoNormalizedRect* pSrc,
		[in] RECT* pDst,
		[in] MFARGB* pBorderClr,
		[out] DWORD* pFrameProtectionFlags
	);

	//  Set the content protection manager
	HRESULT SetContentProtectionManager([in] IMFContentProtectionManager* pCPM);

	//  Set certificate - needed for accessing raw protected frames
	HRESULT SetApplicationCertificate(
		[in] BYTE* pbBlob,
		[in] DWORD cbBlob
	);
}

//+-----------------------------------------------------------------------------
//
//  Interface:  IAudioSourceProvider
//
//  Synopsis:   IAudioSourceProvider allows the caller (when Web Audio is connected)
//              to obtain uncompressed audio data (i.e. audio "frame server")
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(EBBAF249-AFC2-4582-91C6-B60DF2E84954)
]
interface IAudioSourceProvider : stdole.IUnknown
{
	HRESULT ProvideInput(
		[in] DWORD dwSampleCount,
		[in, out] DWORD* pdwChannelCount,
		[out] float* pInterleavedAudioData
	);
};

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineWebSupport
//
//  Synopsis:   IMFMediaEngineWebSupport extends the Media Engine to support the
//              latest W3C specifications.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(ba2743a1-07e0-48ef-84b6-9a2ed023ca6c)
]
interface IMFMediaEngineWebSupport : stdole.IUnknown
{
	BOOL ShouldDelayTheLoadEvent();

	HRESULT ConnectWebAudio(
		[in] DWORD dwSampleRate,
		[out] IAudioSourceProvider** ppSourceProvider
	);

	HRESULT DisconnectWebAudio();
};


////////////////////////////////////////////////////////////////////////////////
//
// Media Source Extension see: 
//
//  http://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html
//
////////////////////////////////////////////////////////////////////////////////


// Media Source Extension creation attributes


//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MSE_VP9_SUPPORT_TYPE 
//
//  Synopsis:   Controls VP9 support in MSE
//
//------------------------------------------------------------------------------
typedef enum MF_MSE_VP9_SUPPORT_TYPE
{
	MF_MSE_VP9_SUPPORT_DEFAULT = 0,
	MF_MSE_VP9_SUPPORT_ON = 1,
	MF_MSE_VP9_SUPPORT_OFF = 2,
} MF_MSE_VP9_SUPPORT_TYPE;

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MSE_OPUS_SUPPORT_TYPE 
//
//  Synopsis:   Controls Opus support in MSE
//
//------------------------------------------------------------------------------
typedef enum MF_MSE_OPUS_SUPPORT_TYPE
{
	MF_MSE_OPUS_SUPPORT_ON = 0,
	MF_MSE_OPUS_SUPPORT_OFF = 1,
} MF_MSE_OPUS_SUPPORT_TYPE;


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaSourceExtensionNotify
//
//  Synopsis:   callback interfaces used to notify MSE clients about important
//              events within the MSE.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(a7901327-05dd-4469-a7b7-0e01979e361d)
]
interface IMFMediaSourceExtensionNotify : stdole.IUnknown
{
	void OnSourceOpen();
	void OnSourceEnded();
	void OnSourceClose();
};


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFBufferListNotify
//
//  Synopsis:   callback interfaces used to notify MSE buffer list clients
//              about important events associated with the buffer list.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(24cd47f7-81d8-4785-adb2-af697a963cd2)
]
interface IMFBufferListNotify : stdole.IUnknown
{
	void OnAddSourceBuffer();
	void OnRemoveSourceBuffer();
};


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFSourceBufferNotify
//
//  Synopsis:   callback interfaces used to notify MSE buffer list clients
//              about important events associated with the buffer list.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(87e47623-2ceb-45d6-9b88-d8520c4dcbbc)
]
interface IMFSourceBufferNotify : stdole.IUnknown
{
	void OnUpdateStart();

	void OnAbort();
	void OnError([in] HRESULT hr);
	void OnUpdate();

	void OnUpdateEnd();
};

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFSourceBuffer
//
//  Synopsis:   interface to a Source Buffer
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(e2cd3a4b-af25-4d3d-9110-da0e6f8ee877)
]
interface IMFSourceBuffer : stdole.IUnknown
{
	BOOL GetUpdating();

	HRESULT GetBuffered(
		[out] IMFMediaTimeRange** ppBuffered
	);

	double GetTimeStampOffset();
	HRESULT SetTimeStampOffset(
		[in] double offset
	);

	double GetAppendWindowStart();
	HRESULT SetAppendWindowStart(
		[in] double time
	);

	double GetAppendWindowEnd();
	HRESULT SetAppendWindowEnd(
		[in] double time
	);

	HRESULT Append(
		[in] BYTE* pData,
		[in] DWORD len
	);

	HRESULT AppendByteStream(
		[in] IMFByteStream* pStream,
		[in] DWORDLONG* pMaxLen
	);

	HRESULT Abort();

	HRESULT Remove(
		[in] double start,
		[in] double end
	);
};

typedef enum MF_MSE_APPEND_MODE
{
	MF_MSE_APPEND_MODE_SEGMENTS = 0,
	MF_MSE_APPEND_MODE_SEQUENCE = 1,
} MF_MSE_APPEND_MODE;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFSourceBufferAppendMode
//
//  Synopsis:   controls the Source Buffer's AppendMode attribute
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(19666fb4-babe-4c55-bc03-0a074da37e2a)
]
interface IMFSourceBufferAppendMode : stdole.IUnknown
{
	MF_MSE_APPEND_MODE GetAppendMode();
	HRESULT SetAppendMode(
		[in] MF_MSE_APPEND_MODE mode
	);
}
//+-----------------------------------------------------------------------------
//
//  Interface:  IMFSourceBufferList
//
//  Synopsis:   SourceBufferList interface.
//              Events generated:
//                  onAddSourceBuffer
//                  onRemoveSourceBuffer
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(249981f8-8325-41f3-b80c-3b9e3aad0cbe)
]
interface IMFSourceBufferList : stdole.IUnknown
{
	DWORD GetLength();

	IMFSourceBuffer* GetSourceBuffer(
		[in] DWORD index
	);
};


//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MSE_READY
//
//  Synopsis:   Defines different ready states of the Media Source Extension
//
//  See 
//------------------------------------------------------------------------------
typedef enum MF_MSE_READY
{
	MF_MSE_READY_CLOSED = 1,
	MF_MSE_READY_OPEN = 2,
	MF_MSE_READY_ENDED = 3,
} MF_MSE_READY;

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MSE_ERROR
//
//  Synopsis:   Defines different error states of the Media Source Extension
//
//  See 
//------------------------------------------------------------------------------
typedef enum MF_MSE_ERROR
{
	MF_MSE_ERROR_NOERROR = 0,
	MF_MSE_ERROR_NETWORK = 1,
	MF_MSE_ERROR_DECODE = 2,
	MF_MSE_ERROR_UNKNOWN_ERROR = 3
} MF_MSE_ERROR;


//+-----------------------------------------------------------------------------
//
//  Class:      IMFMediaSourceExtension
//
//  Synopsis:   Media Source extension interface
//              events generated:
//                  onSourceOpen
//                  onSourceEnded
//                  onSourceClose
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(e467b94e-a713-4562-a802-816a42e9008a)
]
interface IMFMediaSourceExtension : stdole.IUnknown
{
	IMFSourceBufferList* GetSourceBuffers();
	IMFSourceBufferList* GetActiveSourceBuffers();

	// enum State { "closed", "open", "ended" };
	MF_MSE_READY GetReadyState();

	double GetDuration();
	HRESULT SetDuration(
		[in] double duration
	);

	HRESULT AddSourceBuffer(
		[in] BSTR type,
		[in] IMFSourceBufferNotify* pNotify,
		[out] IMFSourceBuffer** ppSourceBuffer
	);

	HRESULT RemoveSourceBuffer(
		[in] IMFSourceBuffer* pSourceBuffer
	);

	// enum EOSError { "network", "decode" };
	HRESULT SetEndOfStream(
		[in] MF_MSE_ERROR error
	);

	BOOL IsTypeSupported(
		[in] BSTR type
	);

	IMFSourceBuffer* GetSourceBuffer(
		[in] DWORD dwStreamIndex
	);
};

//+-----------------------------------------------------------------------------
//
//  Class:      IMFMediaSourceExtensionLiveSeekableRange
//
//  Synopsis:   Media Source extension interface for setting and clearing
//              the live seekable range.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(5D1ABFD6-450A-4D92-9EFC-D6B6CBC1F4DA)
]
interface IMFMediaSourceExtensionLiveSeekableRange : stdole.IUnknown
{
	HRESULT SetLiveSeekableRange(
		[in] double start,
		[in] double end
	);

	HRESULT ClearLiveSeekableRange();
};

//////////////////////////////////////////////////////////////////////////////
//
//  Encrypted Media Extensions (EME)
//
//  See http://dvcs.w3.org/hg/html-media/raw-file/tip/encrypted-media/encrypted-media.html
//
//////////////////////////////////////////////////////////////////////////////

interface IMFMediaEngineEME;
interface IMFMediaKeys;
interface IMFMediaKeySession;
interface IMFMediaKeySessionNotify;
interface IMFCdmSuspendNotify;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineEME
//
//  Synopsis:   Extensions to the media engine for EME extensions
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(50dc93e4-ba4f-4275-ae66-83e836e57469)
]
interface IMFMediaEngineEME : stdole.IUnknown
{
	HRESULT get_Keys(
		[out] IMFMediaKeys** keys
	);
	HRESULT SetMediaKeys(
		[in] IMFMediaKeys* keys
	);
}

[
	odl,
	uuid(654a6bb3-e1a3-424a-9908-53a43a0dfda0)
]
interface IMFMediaEngineSrcElementsEx : IMFMediaEngineSrcElements
{
	HRESULT AddElementEx(
		[in] BSTR pURL,
		[in] BSTR pType,
		[in] BSTR pMedia,
		[in] BSTR keySystem
	);
	HRESULT GetKeySystem(
		[in] DWORD index,
		[out] BSTR* pType
	);
}


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaKeysNotify
//
//  Synopsis:   Implement NeedKey
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(46a30204-a696-4b18-8804-246b8f031bb1)
]
interface IMFMediaEngineNeedKeyNotify : stdole.IUnknown
{
	void NeedKey(
		[in] BYTE* initData,
		[in] DWORD cb
	);
}

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaKeys
//
//  Synopsis:   Media Keys interface for EME
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(5cb31c05-61ff-418f-afda-caaf41421a38)
]
interface IMFMediaKeys : stdole.IUnknown
{
	HRESULT CreateSession(
		[in] BSTR mimeType,
		[in] BYTE* initData,
		[in] DWORD cb,
		[in] BYTE* customData,
		[in] DWORD cbCustomData,
		[in] IMFMediaKeySessionNotify* notify,
		[out] IMFMediaKeySession** ppSession
	);

	HRESULT get_KeySystem(
		[out] BSTR* keySystem
	);

	HRESULT Shutdown();

	HRESULT GetSuspendNotify([out] IMFCdmSuspendNotify** notify);
}


//  Errors - see MediaKeyError interface
typedef enum MF_MEDIA_ENGINE_KEYERR {
	MF_MEDIAENGINE_KEYERR_UNKNOWN = 1,
	MF_MEDIAENGINE_KEYERR_CLIENT = 2,
	MF_MEDIAENGINE_KEYERR_SERVICE = 3,
	MF_MEDIAENGINE_KEYERR_OUTPUT = 4,
	MF_MEDIAENGINE_KEYERR_HARDWARECHANGE = 5,
	MF_MEDIAENGINE_KEYERR_DOMAIN = 6
} MF_MEDIA_ENGINE_KEYERR;


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaKeySession
//
//  Synopsis:   Media Key Session interface for EME
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(24fa67d5-d1d0-4dc5-995c-c0efdc191fb5)
]
interface IMFMediaKeySession : stdole.IUnknown
{
	//  Caller must turn this into a MediaKeyError object
	HRESULT GetError([in, out] USHORT* code, [in, out] DWORD* systemCode);

	HRESULT get_KeySystem(
		[in, out] BSTR* keySystem
	);

	HRESULT get_SessionId(
		[in, out] BSTR* sessionId
	);

	HRESULT Update([in] BYTE* key, [in] DWORD cb);

	HRESULT Close();
}

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaKeySessionNotify
//
//  Synopsis:   Events for MediaKeySession
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(6a0083f9-8947-4c1d-9ce0-cdee22b23135)
]
interface IMFMediaKeySessionNotify : stdole.IUnknown
{
	void KeyMessage(
		[in] BSTR destinationURL,
		[in] BYTE* message,
		[in] DWORD cb
	);

	void KeyAdded();

	//  Caller should turn data into MediaKeyError object
	void KeyError(
		[in] USHORT code,
		[in] DWORD systemCode
	);

}

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFCdmSuspendNotify
//
//  Synopsis:   Events for MediaKeySession
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(7a5645d2-43bd-47fd-87b7-dcd24cc7d692)
]
interface IMFCdmSuspendNotify : stdole.IUnknown
{
	HRESULT Begin();
	HRESULT End();
}

//  End of Encrypted Media Extensions

//+-----------------------------------------------------------------------------
//
//  Interface:  MF_HDCP_STATUS
//
//  Synopsis:   HDCP Status values
//
//------------------------------------------------------------------------------
typedef enum MF_HDCP_STATUS
{
	MF_HDCP_STATUS_ON = 0,
	MF_HDCP_STATUS_OFF = 1,
	MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT = 2
} MF_HDCP_STATUS;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFHDCPStatus
//
//  Synopsis:   HDCP Status set/get interface
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(DE400F54-5BF1-40CF-8964-0BEA136B1E3D)
]
interface IMFHDCPStatus : stdole.IUnknown
{
	HRESULT Query(
		[in, out] MF_HDCP_STATUS* pStatus,
		[in, out] BOOL* pfStatus
	);

	HRESULT Set(
		[in] MF_HDCP_STATUS status
	);
};

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_ENGINE_OPM_STATUS
//
//  Synopsis:   Defines the status of OPM:
//              0. MF_MEDIA_ENGINE_OPM_NOT_REQUESTED: default status, used to 
//                     return the correct status when the content is unprotected
//              1. MF_MEDIA_ENGINE_OPM_ESTABLISHED: OPM succussfully established
//              2. MF_MEDIA_ENGINE_OPM_FAILED_VM: running in a VM
//              3. MF_MEDIA_ENGINE_OPM_FAILED_BDA: there is no graphics driver,
//                     system is using BDA
//              4. MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER: the graphics 
//                     driver is not PE signed, falling back to WARP
//              5. MF_MEDIA_ENGINE_OPM_FAILED: OPM failed for other reasons
//
//------------------------------------------------------------------------------
typedef enum MF_MEDIA_ENGINE_OPM_STATUS
{
	MF_MEDIA_ENGINE_OPM_NOT_REQUESTED = 0,
	MF_MEDIA_ENGINE_OPM_ESTABLISHED = 1,
	MF_MEDIA_ENGINE_OPM_FAILED_VM = 2,
	MF_MEDIA_ENGINE_OPM_FAILED_BDA = 3,
	MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER = 4,
	MF_MEDIA_ENGINE_OPM_FAILED = 5

} MF_MEDIA_ENGINE_OPM_STATUS;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineOPMInfo
//
//  Synopsis:   Interface to get OPM information and constriction status
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(765763e6-6c01-4b01-bb0f-b829f60ed28c)
]
interface IMFMediaEngineOPMInfo : stdole.IUnknown
{
	HRESULT GetOPMInfo(
		[out] MF_MEDIA_ENGINE_OPM_STATUS* pStatus,
		[out] BOOL* pConstricted
	);
}

typedef enum MF_MEDIA_ENGINE_CREATEFLAGS
{
	MF_MEDIA_ENGINE_AUDIOONLY = 0x0001,
	MF_MEDIA_ENGINE_WAITFORSTABLE_STATE = 0x0002,
	MF_MEDIA_ENGINE_FORCEMUTE = 0x0004,
	MF_MEDIA_ENGINE_REAL_TIME_MODE = 0x0008,   // sets the default real time mode, can be changed later by calling IMFMediaEngineEx::SetRealTimeMode
	MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS = 0x0010,
	MF_MEDIA_ENGINE_CREATEFLAGS_MASK = 0x001F,
} MF_MEDIA_ENGINE_CREATEFLAGS;

typedef enum MF_MEDIA_ENGINE_PROTECTION_FLAGS
{
	MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT = 1,
	MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT = 2,   //  Testing
	MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP = 4        //  Testing

} MF_MEDIA_ENGINE_PROTECTION_FLAGS;


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineClassFactory
//
//  Synopsis:   Allows client applications to create a new instance of the 
//              Media Engine.  CoInitialize and MFStartup must be called 
//              prior to using this interface.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(4D645ACE-26AA-4688-9BE1-DF3516990B93)
]
interface IMFMediaEngineClassFactory : stdole.IUnknown
{
	long CreateInstance(
		[in] DWORD dwFlags,
		[in] IMFAttributes* pAttr,
		[out] IMFMediaEngine** ppPlayer
	);

	long CreateTimeRange(
		[out] IMFMediaTimeRange** ppTimeRange
	);

	long CreateError(
		[out] IMFMediaError** ppError
	);
}

[
	odl,
	uuid(c56156c6-ea5b-48a5-9df8-fbe035d0929e)
]
interface IMFMediaEngineClassFactoryEx : IMFMediaEngineClassFactory
{
	long CreateMediaSourceExtension(
		[in] DWORD dwFlags,
		[in] IMFAttributes* pAttr,
		[out] IMFMediaSourceExtension** ppMSE
	);

	long CreateMediaKeys(
		[in] BSTR keySystem,
		[in] BSTR cdmStorePath,
		[out] IMFMediaKeys** ppKeys
	);

	long IsTypeSupported(
		[in] BSTR type,
		[in] BSTR keySystem,
		[out] BOOL* isSupported
	);
}

[
	odl,
	uuid(09083cef-867f-4bf6-8776-dee3a7b42fca)
]
interface IMFMediaEngineClassFactory2 : stdole.IUnknown
{
	long CreateMediaKeys2(
		[in] BSTR keySystem,
		[in] BSTR defaultCdmStorePath,
		[in] BSTR inprivateCdmStorePath,
		[out] IMFMediaKeys** ppKeys
	);
}

[
	odl,
	uuid(332EC562-3758-468D-A784-E38F23552128)
]
interface IMFExtendedDRMTypeSupport : stdole.IUnknown
{
	long IsTypeSupportedEx(
		[in] BSTR type,
		[in] BSTR keySystem,
		[out] MF_MEDIA_ENGINE_CANPLAY* pAnswer
	);
}

[
	odl,
	uuid(a724b056-1b2e-4642-a6f3-db9420c52908)
]
interface IMFMediaEngineSupportsSourceTransfer : stdole.IUnknown
{
	HRESULT ShouldTransferSource([out] BOOL* pfShouldTransfer);

	HRESULT DetachMediaSource(
		[out] IMFByteStream** ppByteStream,
		[out] IMFMediaSource** ppMediaSource,
		[out] IMFMediaSourceExtension** ppMSE
	);

	HRESULT AttachMediaSource(
		[in] IMFByteStream* pByteStream,
		[in] IMFMediaSource* pMediaSource,
		[in] IMFMediaSourceExtension* pMSE
	);
}


// <summary>
// This interface is implemented by objects that implement IMFMediaEngine.
// It transfers the state of one IMFMediaEngine object to another.
// It is used by the Edge browser for transferring the state from an IMFMediaEngine
// used for local playback to a Sharing Engine (IMFMediaSharingEngine), and vice versa.
// </summary>
[
	odl,
	uuid(24230452-fe54-40cc-94f3-fcc394c340d6)
]
interface IMFMediaEngineTransferSource : stdole.IUnknown
{
	HRESULT TransferSourceToMediaEngine([in] IMFMediaEngine* destination);
}


//////////////////////////////////////////////////////////////////////////////
//
//  Timed Text
//
//////////////////////////////////////////////////////////////////////////////

//
// MFMediaEngine services
//

typedef enum MF_TIMED_TEXT_TRACK_KIND
{
	MF_TIMED_TEXT_TRACK_KIND_UNKNOWN = 0,
	MF_TIMED_TEXT_TRACK_KIND_SUBTITLES = 1,
	MF_TIMED_TEXT_TRACK_KIND_CAPTIONS = 2,
	MF_TIMED_TEXT_TRACK_KIND_METADATA = 3,
} MF_TIMED_TEXT_TRACK_KIND;

typedef enum MF_TIMED_TEXT_UNIT_TYPE
{
	MF_TIMED_TEXT_UNIT_TYPE_PIXELS = 0,
	MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE = 1
} MF_TIMED_TEXT_UNIT_TYPE;

typedef enum MF_TIMED_TEXT_FONT_STYLE
{
	MF_TIMED_TEXT_FONT_STYLE_NORMAL = 0,
	MF_TIMED_TEXT_FONT_STYLE_OBLIQUE = 1,
	MF_TIMED_TEXT_FONT_STYLE_ITALIC = 2
} MF_TIMED_TEXT_FONT_STYLE;

typedef enum MF_TIMED_TEXT_ALIGNMENT
{
	MF_TIMED_TEXT_ALIGNMENT_START = 0,
	MF_TIMED_TEXT_ALIGNMENT_END = 1,
	MF_TIMED_TEXT_ALIGNMENT_CENTER = 2,
} MF_TIMED_TEXT_ALIGNMENT;

typedef enum MF_TIMED_TEXT_DISPLAY_ALIGNMENT
{
	MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE = 0,
	MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER = 1,
	MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER = 2,
} MF_TIMED_TEXT_DISPLAY_ALIGNMENT;

typedef enum MF_TIMED_TEXT_DECORATION
{
	MF_TIMED_TEXT_DECORATION_NONE = 0,
	MF_TIMED_TEXT_DECORATION_UNDERLINE = 1,
	MF_TIMED_TEXT_DECORATION_LINE_THROUGH = 2,
	MF_TIMED_TEXT_DECORATION_OVERLINE = 4
} MF_TIMED_TEXT_DECORATION;

typedef enum MF_TIMED_TEXT_WRITING_MODE
{
	MF_TIMED_TEXT_WRITING_MODE_LRTB = 0,
	MF_TIMED_TEXT_WRITING_MODE_RLTB = 1,
	MF_TIMED_TEXT_WRITING_MODE_TBRL = 2,
	MF_TIMED_TEXT_WRITING_MODE_TBLR = 3,
	MF_TIMED_TEXT_WRITING_MODE_LR = 4,
	MF_TIMED_TEXT_WRITING_MODE_RL = 5,
	MF_TIMED_TEXT_WRITING_MODE_TB = 6
} MF_TIMED_TEXT_WRITING_MODE;

typedef enum MF_TIMED_TEXT_SCROLL_MODE
{
	MF_TIMED_TEXT_SCROLL_MODE_POP_ON = 0,
	MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP = 1
} MF_TIMED_TEXT_SCROLL_MODE;

typedef enum MF_TIMED_TEXT_ERROR_CODE
{
	// No error
	MF_TIMED_TEXT_ERROR_CODE_NOERROR = 0,
	// Fatal, non-continuable error, the state of the component will
	// be reset after that.
	MF_TIMED_TEXT_ERROR_CODE_FATAL = 1,
	// Data format error - continuable
	MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT = 2,
	// Network error - continuable
	MF_TIMED_TEXT_ERROR_CODE_NETWORK = 3,
	// Internal error, involved data sources will be disabled
	// but the error is continuable
	MF_TIMED_TEXT_ERROR_CODE_INTERNAL = 4
} MF_TIMED_TEXT_ERROR_CODE;

typedef enum MF_TIMED_TEXT_CUE_EVENT
{
	// Cue has become active
	MF_TIMED_TEXT_CUE_EVENT_ACTIVE,
	// Cue has become inactive
	MF_TIMED_TEXT_CUE_EVENT_INACTIVE,
	// All cues has been deactivated
	MF_TIMED_TEXT_CUE_EVENT_CLEAR
} MF_TIMED_TEXT_CUE_EVENT;

typedef enum MF_TIMED_TEXT_TRACK_READY_STATE
{
	// Loading track cues has not been started yet.
	MF_TIMED_TEXT_TRACK_READY_STATE_NONE,
	// Track cues are being loaded.
	MF_TIMED_TEXT_TRACK_READY_STATE_LOADING,
	// Track cues are loaded and ready.
	MF_TIMED_TEXT_TRACK_READY_STATE_LOADED,
	// Track error occurred.
	MF_TIMED_TEXT_TRACK_READY_STATE_ERROR,
} MF_TIMED_TEXT_TRACK_READY_STATE;

typedef enum MF_TIMED_TEXT_RUBY_POSITION
{
	MF_TIMED_TEXT_RUBY_POSITION_BEFORE = 0,
	MF_TIMED_TEXT_RUBY_POSITION_AFTER = 1,
	MF_TIMED_TEXT_RUBY_POSITION_OUTSIDE = 2,
} MF_TIMED_TEXT_RUBY_POSITION;

typedef enum MF_TIMED_TEXT_RUBY_ALIGN
{
	MF_TIMED_TEXT_RUBY_ALIGN_CENTER = 0,
	MF_TIMED_TEXT_RUBY_ALIGN_START = 1,
	MF_TIMED_TEXT_RUBY_ALIGN_END = 2,
	MF_TIMED_TEXT_RUBY_ALIGN_SPACEAROUND = 3,
	MF_TIMED_TEXT_RUBY_ALIGN_SPACEBETWEEN = 4,
	MF_TIMED_TEXT_RUBY_ALIGN_WITHBASE = 5
} MF_TIMED_TEXT_RUBY_ALIGN;

typedef enum MF_TIMED_TEXT_RUBY_RESERVE
{
	MF_TIMED_TEXT_RUBY_RESERVE_NONE = 0,
	MF_TIMED_TEXT_RUBY_RESERVE_BEFORE = 1,
	MF_TIMED_TEXT_RUBY_RESERVE_AFTER = 2,
	MF_TIMED_TEXT_RUBY_RESERVE_BOTH = 3,
	MF_TIMED_TEXT_RUBY_RESERVE_OUTSIDE = 4
} MF_TIMED_TEXT_RUBY_RESERVE;

typedef enum MF_TIMED_TEXT_BOUTEN_TYPE
{
	MF_TIMED_TEXT_BOUTEN_TYPE_NONE = 0,
	MF_TIMED_TEXT_BOUTEN_TYPE_AUTO = 1,
	MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDCIRCLE = 2,
	MF_TIMED_TEXT_BOUTEN_TYPE_OPENCIRCLE = 3,
	MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDDOT = 4,
	MF_TIMED_TEXT_BOUTEN_TYPE_OPENDOT = 5,
	MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDSESAME = 6,
	MF_TIMED_TEXT_BOUTEN_TYPE_OPENSESAME = 7
} 	MF_TIMED_TEXT_BOUTEN_TYPE;

typedef enum MF_TIMED_TEXT_BOUTEN_POSITION
{
	MF_TIMED_TEXT_BOUTEN_POSITION_BEFORE = 0,
	MF_TIMED_TEXT_BOUTEN_POSITION_AFTER = 1,
	MF_TIMED_TEXT_BOUTEN_POSITION_OUTSIDE = 2
} 	MF_TIMED_TEXT_BOUTEN_POSITION;


interface IMFTimedText;
interface IMFTimedTextNotify;
interface IMFTimedTextTrack;
interface IMFTimedTextTrackList;
interface IMFTimedTextCue;
interface IMFTimedTextCueList;
interface IMFTimedTextBinary;
interface IMFTimedTextRegion;
interface IMFTimedTextStyle;
interface IMFTimedTextFormattedText;

[
	odl,
	uuid(1f2a94c9-a3df-430d-9d0f-acd85ddc29af)
]
interface IMFTimedText : stdole.IUnknown
{
	HRESULT RegisterNotifications(
		[in] IMFTimedTextNotify* notify
	);

	HRESULT SelectTrack(
		[in] DWORD trackId,
		[in] BOOL selected
	);

	HRESULT AddDataSource(
		[in] IMFByteStream* byteStream,
		[in] LongPtr label,
		[in] LongPtr language,
		[in] MF_TIMED_TEXT_TRACK_KIND kind,
		[in] BOOL isDefault,
		[in, out] DWORD* trackId
	);

	HRESULT AddDataSourceFromUrl(
		[in] LongPtr url,
		[in] LongPtr label,
		[in] LongPtr language,
		[in] MF_TIMED_TEXT_TRACK_KIND kind,
		[in] BOOL isDefault,
		[in, out] DWORD* trackId
	);

	HRESULT AddTrack(
		[in] LongPtr label,
		[in] LongPtr language,
		[in] MF_TIMED_TEXT_TRACK_KIND kind,
		[out] IMFTimedTextTrack** track
	);

	HRESULT RemoveTrack(
		[in] IMFTimedTextTrack* track
	);

	HRESULT GetCueTimeOffset(
		[out] double* offset
	);

	HRESULT SetCueTimeOffset(
		[in] double offset
	);

	HRESULT GetTracks(
		[out] IMFTimedTextTrackList** tracks
	);

	HRESULT GetActiveTracks(
		[out] IMFTimedTextTrackList** activeTracks
	);

	HRESULT GetTextTracks(
		[out] IMFTimedTextTrackList** textTracks
	);

	HRESULT GetMetadataTracks(
		[out] IMFTimedTextTrackList** metadataTracks
	);

	HRESULT SetInBandEnabled([in] BOOL enabled);

	BOOL IsInBandEnabled();
}

[
	odl,
	uuid(df6b87b6-ce12-45db-aba7-432fe054e57d)
]
interface IMFTimedTextNotify : stdole.IUnknown
{
	void TrackAdded(
		[in] DWORD trackId
	);

	void TrackRemoved(
		[in] DWORD trackId
	);

	void TrackSelected(
		[in] DWORD trackId,
		[in] BOOL selected
	);

	void TrackReadyStateChanged(
		[in] DWORD trackId
	);

	void Error(
		[in] MF_TIMED_TEXT_ERROR_CODE errorCode,
		[in] HRESULT extendedErrorCode,
		[in] DWORD sourceTrackId
	);

	void Cue(
		[in] MF_TIMED_TEXT_CUE_EVENT cueEvent,
		[in] double currentTime,
		[in] IMFTimedTextCue* cue
	);

	void Reset();
}

[
	odl,
	uuid(8822c32d-654e-4233-bf21-d7f2e67d30d4)
]
interface IMFTimedTextTrack : stdole.IUnknown
{
	DWORD GetId();

	HRESULT GetLabel(
		[out] LongPtr* label
	);

	HRESULT SetLabel(
		[in] LongPtr label
	);

	HRESULT GetLanguage(
		[out] LongPtr* language
	);

	MF_TIMED_TEXT_TRACK_KIND GetTrackKind();

	BOOL IsInBand();

	HRESULT GetInBandMetadataTrackDispatchType(
		[out] LongPtr* dispatchType
	);

	BOOL IsActive();

	MF_TIMED_TEXT_ERROR_CODE GetErrorCode();

	HRESULT GetExtendedErrorCode();

	HRESULT GetDataFormat([out] GUID* format);

	MF_TIMED_TEXT_TRACK_READY_STATE GetReadyState();

	HRESULT GetCueList([out] IMFTimedTextCueList** cues);
}

[
	odl,
	uuid(23ff334c-442c-445f-bccc-edc438aa11e2)
]
interface IMFTimedTextTrackList : stdole.IUnknown
{
	DWORD GetLength();

	HRESULT GetTrack(
		[in] DWORD index,
		[out] IMFTimedTextTrack** track
	);

	HRESULT GetTrackById(
		[in] DWORD trackId,
		[out] IMFTimedTextTrack** track
	);
}

[
	odl,
	uuid(1e560447-9a2b-43e1-a94c-b0aaabfbfbc9)
]
interface IMFTimedTextCue : stdole.IUnknown
{
	DWORD GetId();

	HRESULT GetOriginalId(
		[out] LongPtr* originalId
	);

	MF_TIMED_TEXT_TRACK_KIND GetCueKind();

	double GetStartTime();

	double GetDuration();

	DWORD GetTrackId();

	HRESULT GetData(
		[out] IMFTimedTextBinary** data
	);

	HRESULT GetRegion(
		[out] IMFTimedTextRegion** region
	);

	HRESULT GetStyle(
		[out] IMFTimedTextStyle** style
	);

	DWORD GetLineCount();

	HRESULT GetLine(
		[in] DWORD index,
		[out] IMFTimedTextFormattedText** line
	);
}

[
	odl,
	uuid(e13af3c1-4d47-4354-b1f5-e83ae0ecae60)
]
interface IMFTimedTextFormattedText : stdole.IUnknown
{
	HRESULT GetText(
		[out] LongPtr* text
	);

	DWORD GetSubformattingCount();

	HRESULT GetSubformatting(
		[in] DWORD index,
		[out] DWORD* firstChar,
		[out] DWORD* charLength,
		[out] IMFTimedTextStyle** style
	);
}

[
	odl,
	uuid(09b2455d-b834-4f01-a347-9052e21c450e)
]
interface IMFTimedTextStyle : stdole.IUnknown
{
	HRESULT GetName(
		[out] LongPtr* name
	);

	BOOL IsExternal();

	HRESULT GetFontFamily(
		[out] LongPtr* fontFamily
	);

	HRESULT GetFontSize(
		[out] double* fontSize,
		[out] MF_TIMED_TEXT_UNIT_TYPE* unitType
	);

	HRESULT GetColor(
		[out] MFARGB* color
	);

	HRESULT GetBackgroundColor(
		[out] MFARGB* bgColor
	);

	HRESULT GetShowBackgroundAlways(
		[out] BOOL* showBackgroundAlways
	);

	HRESULT GetFontStyle(
		[out] MF_TIMED_TEXT_FONT_STYLE* fontStyle
	);

	HRESULT GetBold(
		[out] BOOL* bold
	);

	HRESULT GetRightToLeft(
		[out] BOOL* rightToLeft
	);

	HRESULT GetTextAlignment(
		[out] MF_TIMED_TEXT_ALIGNMENT* textAlign
	);

	HRESULT GetTextDecoration(
		[out] DWORD* textDecoration
	);

	HRESULT GetTextOutline(
		[out] MFARGB* color,
		[out] double* thickness,
		[out] double* blurRadius,
		[out] MF_TIMED_TEXT_UNIT_TYPE* unitType
	);
}

[
	odl,
	uuid(c8d22afc-bc47-4bdf-9b04-787e49ce3f58)
]
interface IMFTimedTextRegion : stdole.IUnknown
{
	HRESULT GetName(
		[out] LongPtr* name
	);

	HRESULT GetPosition(
		[out] double* pX,
		[out] double* pY,
		[out] MF_TIMED_TEXT_UNIT_TYPE* unitType
	);

	HRESULT GetExtent(
		[out] double* pWidth,
		[out] double* pHeight,
		[out] MF_TIMED_TEXT_UNIT_TYPE* unitType
	);

	HRESULT GetBackgroundColor(
		[out] MFARGB* bgColor
	);

	HRESULT GetWritingMode(
		[out] MF_TIMED_TEXT_WRITING_MODE* writingMode
	);

	HRESULT GetDisplayAlignment(
		[out] MF_TIMED_TEXT_DISPLAY_ALIGNMENT* displayAlign
	);

	HRESULT GetLineHeight(
		[out] double* pLineHeight,
		[out] MF_TIMED_TEXT_UNIT_TYPE* unitType
	);

	HRESULT GetClipOverflow(
		[out] BOOL* clipOverflow
	);

	HRESULT GetPadding(
		[out] double* before,
		[out] double* start,
		[out] double* after,
		[out] double* end,
		[out] MF_TIMED_TEXT_UNIT_TYPE* unitType
	);

	HRESULT GetWrap(
		[out] BOOL* wrap
	);

	HRESULT GetZIndex(
		[out] INT32* zIndex
	);

	HRESULT GetScrollMode(
		[out] MF_TIMED_TEXT_SCROLL_MODE* scrollMode
	);
}

[
	odl,
	uuid(4ae3a412-0545-43c4-bf6f-6b97a5c6c432)
]
interface IMFTimedTextBinary : stdole.IUnknown
{
	HRESULT GetData(
		[out] LongPtr *data,
		[out] DWORD* length
	);
}

[
	odl,
	uuid(ad128745-211b-40a0-9981-fe65f166d0fd)
]
interface IMFTimedTextCueList : stdole.IUnknown
{
	DWORD GetLength();

	HRESULT GetCueByIndex(
		[in] DWORD index,
		[out] IMFTimedTextCue** cue
	);

	HRESULT GetCueById(
		[in] DWORD id,
		[out] IMFTimedTextCue** cue
	);

	HRESULT GetCueByOriginalId(
		[in] LongPtr originalId,
		[out] IMFTimedTextCue** cue
	);

	HRESULT AddTextCue(
		[in] double start,
		[in] double duration,
		[in] LongPtr text,
		[out] IMFTimedTextCue** cue
	);

	HRESULT AddDataCue(
		[in] double start,
		[in] double duration,
		[in] BYTE* data,
		[in] DWORD dataSize,
		[out] IMFTimedTextCue** cue
	);

	HRESULT RemoveCue(
		[in] IMFTimedTextCue* cue
	);
}

[
	odl,
	uuid(76c6a6f5-4955-4de5-b27b-14b734cc14b4)
]
interface IMFTimedTextRuby : stdole.IUnknown
{
	HRESULT GetRubyText(
		[out] LongPtr* rubyText
	);
	HRESULT GetRubyPosition(
		[out] MF_TIMED_TEXT_RUBY_POSITION* value
	);
	HRESULT GetRubyAlign(
		[out] MF_TIMED_TEXT_RUBY_ALIGN* value
	);
	HRESULT GetRubyReserve(
		[out] MF_TIMED_TEXT_RUBY_RESERVE* value
	);
}

[
	odl,
	uuid(3c5f3e8a-90c0-464e-8136-898d2975f847)
]
interface IMFTimedTextBouten : stdole.IUnknown
{
	HRESULT GetBoutenType(
		[out] MF_TIMED_TEXT_BOUTEN_TYPE* value
	);
	HRESULT GetBoutenColor(
		[out] MFARGB* value
	);
	HRESULT GetBoutenPosition(
		[out] MF_TIMED_TEXT_BOUTEN_POSITION* value
	);
}

[
	odl,
	uuid(db639199-c809-4c89-bfca-d0bbb9729d6e)
]
interface IMFTimedTextStyle2 : stdole.IUnknown
{
	HRESULT GetRuby(
		[out] IMFTimedTextRuby** ruby
	);
	HRESULT GetBouten(
		[out] IMFTimedTextBouten** bouten
	);
	// Tate-chu-yoko
	HRESULT IsTextCombined(
		[out] BOOL* value
	);
	// Slanted Text, when is 0, that means the texts are not slanted texts
	HRESULT GetFontAngleInDegrees(
		[out] double* value
	);
}

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_ENGINE_STREAMTYPE_FAILED
//
//  Synopsis:   Defines stream type that failed to render
//
//------------------------------------------------------------------------------
typedef enum MF_MEDIA_ENGINE_STREAMTYPE_FAILED
{
	MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN = 0,
	MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO = 1,
	MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO = 2,
} MF_MEDIA_ENGINE_STREAMTYPE_FAILED;


//////////////////////////////////////////////////////////////////////////////
//
//  Encrypted Media Extensions (EME 2) March 31,2015
//
//  See http://www.w3.org/TR/2015/WD-encrypted-media-20150331/
//
//////////////////////////////////////////////////////////////////////////////
interface IMFMediaEngineEMENotify;
interface IMFMediaEngineClassFactory3;
interface IMFMediaKeySystemAccess;
interface IMFMediaKeySessionNotify2;
interface IMFMediaKeys2;
interface IMFMediaKeySession2;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineEMENotify
//
//  Synopsis:   Implement EME2 Events for MediaEngine
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(9e184d15-cdb7-4f86-b49e-566689f4a601)
]
interface IMFMediaEngineEMENotify : stdole.IUnknown
{
	void Encrypted(
		[in] BYTE* pbInitData,
		[in] DWORD cb,
		[in] BSTR bstrInitDataType
	);

	void WaitingForKey();
}

//+-----------------------------------------------------------------------------
//
//  Enumeration:  MF_MEDIA_KEYS_REQUIREMENT
//
//  Synopsis:   Defines requirement for DistinctiveId and PersistedState
//
//------------------------------------------------------------------------------
typedef enum MF_MEDIAKEYS_REQUIREMENT
{
	MF_MEDIAKEYS_REQUIREMENT_REQUIRED = 1,
	MF_MEDIAKEYS_REQUIREMENT_OPTIONAL = 2,
	MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED = 3
} MF_MEDIAKEYS_REQUIREMENT;

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaKeySessionNotify2
//
//  Synopsis:   Implement EME2 Events for MediaKeySession
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(c3a9e92a-da88-46b0-a110-6cf953026cb9)
]
interface IMFMediaKeySessionNotify2 : IMFMediaKeySessionNotify
{
	void KeyMessage2(
		[in] MF_MEDIAKEYSESSION_MESSAGETYPE eMessageType,
		[in] BSTR destinationURL,
		[in] BYTE* pbMessage,
		[in] DWORD cbMessage
	);

	void KeyStatusChange();
}

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaKeySystemAccess
//
//  Synopsis:   Implement return value of requestMediaKeySystemAccess for EME
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(aec63fda-7a97-4944-b35c-6c6df8085cc3)
]
interface IMFMediaKeySystemAccess : stdole.IUnknown
{
	HRESULT CreateMediaKeys(
		[in] IPropertyStore* pCdmCustomConfig,
		[out] IMFMediaKeys2** ppKeys
	);

	HRESULT get_SupportedConfiguration(
		[out] IPropertyStore** ppSupportedConfiguration
	);

	HRESULT get_KeySystem(
		[out] BSTR* pKeySystem
	);
}


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineClassFactory3
//
//  Synopsis:   Implement requestMediaKeySystemAccess for EME
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(3787614f-65f7-4003-b673-ead8293a0e60)
]
interface IMFMediaEngineClassFactory3 : stdole.IUnknown
{
	HRESULT CreateMediaKeySystemAccess(
		[in] BSTR keySystem,
		[in] IPropertyStore* ppSupportedConfigurationsArray,
		[in] UINT uSize,
		[out] IMFMediaKeySystemAccess** ppKeyAccess
	);
}


//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaKeys2
//
//  Synopsis:   Implement IMFMediaKeys2 for EME
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(45892507-ad66-4de2-83a2-acbb13cd8d43)
]
interface IMFMediaKeys2 : IMFMediaKeys
{
	HRESULT CreateSession2(
		[in] MF_MEDIAKEYSESSION_TYPE eSessionType,
		[in] IMFMediaKeySessionNotify2* pMFMediaKeySessionNotify2,
		[out] IMFMediaKeySession2** ppSession
	);

	HRESULT SetServerCertificate(
		[in] BYTE* pbServerCertificate,
		[in] DWORD cb
	);

	HRESULT GetDOMException(
		[in] HRESULT systemCode,
		[out] HRESULT* code
	);
}

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaKeySession2
//
//  Synopsis:   Implement IMFMediaKeySession2 for EME
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(e9707e05-6d55-4636-b185-3de21210bd75)
]
interface IMFMediaKeySession2 : IMFMediaKeySession
{
	HRESULT get_KeyStatuses(
		[out] LongPtr* pKeyStatusesArray,
		[out] UINT* puSize
	);

	HRESULT Load(
		[in] BSTR bstrSessionId,
		[out] BOOL* pfLoaded
	);

	HRESULT GenerateRequest(
		[in] BSTR initDataType,
		[in] BYTE* pbInitData,
		[in] DWORD cb
	);

	HRESULT get_Expiration(
		[out] double* dblExpiration
	);

	HRESULT Remove();

	HRESULT Shutdown();
}

//////////////////////////////////////////////////////////////////////////////
//
//  Store CDMs May 10, 2019
//
//  Allows direct usage of CDM objects that can be defined in store apps.
//
//////////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------------
//
//  Interface:  IMFMediaEngineClassFactory4
//
//  Synopsis:   Implement direct access of CDM object that could be defined in store apps.
//
//------------------------------------------------------------------------------
[
	odl,
	uuid(fbe256c1-43cf-4a9b-8cb8-ce8632a34186)
]
interface IMFMediaEngineClassFactory4 : stdole.IUnknown
{
	HRESULT CreateContentDecryptionModuleFactory(
		[in] LongPtr keySystem,
		[in] REFIID riid,
		[out] LPVOID ppvObject
	);
}


// IMFContentDecryptionModuleSession is designed based on EME MediaKeySession:
// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession
[
	odl,
	uuid(4e233efd-1dd2-49e8-b577-d63eee4c0d33)
]
interface IMFContentDecryptionModuleSession : stdole.IUnknown
{
	// A unique string identifier generated by the CDM that can be used by the application
	// to identify session objects.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-sessionid
	HRESULT GetSessionId(
		[out] LongPtr* sessionId
	);

	// The expiration time for all key(s) in the session, or NaN if no such time exists or
	// if the license explicitly never expires, as determined by the CDM.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-expiration
	// expiration is based on https://tc39.es/ecma262/#sec-time-values-and-time-range
	HRESULT GetExpiration(
		[out] double* expiration
	);

	// A reference to an array of key IDs known to the session to the current status
	// of the associated key. Each entry MUST have a unique key ID.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-keystatuses
	HRESULT GetKeyStatuses(
		[out] LongPtr* keyStatuses,
		[out] UINT* numKeyStatuses
	);

	// Loads the data stored for the specified session into this object.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-load
	HRESULT Load(
		[in] LongPtr sessionId,
		[out] BOOL* loaded
	);

	// Generates a license request based on the initData. A message of type "license-request" or
	// "individualization-request" will always be queued if the algorithm succeeds
	// and the promise is resolved.
	// Structure for init data is based on initDataType
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-generaterequest
	// https://www.w3.org/TR/eme-initdata-registry/
	HRESULT GenerateRequest(
		[in] LongPtr initDataType,
		[in] BYTE* initData,
		[in] DWORD initDataSize
	);

	// Provides messages, including licenses, to the CDM.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-update
	HRESULT Update(
		[in] BYTE* response,
		[in] DWORD responseSize
	);

	// Indicates that the application no longer needs the session and the CDM should release any resources
	// associated with the session and close it. Persisted data should not be released or cleared.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-close
	HRESULT Close();

	// Removes all license(s) and key(s) associated with the session. For persistent session types,
	// other session data will be cleared as defined for each session type once a
	// release message acknowledgment is processed by Update().
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-remove
	HRESULT Remove();
}

// IMFContentDecryptionModuleSessionCallbacks is designed based on EME keystatuseschange event:
// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-evt-keystatuseschange
[
	odl,
	uuid(3f96ee40-ad81-4096-8470-59a4b770f89a)
]
interface IMFContentDecryptionModuleSessionCallbacks : stdole.IUnknown
{
	// The CDM has generated a message for the session.
	HRESULT KeyMessage(
		[in] MF_MEDIAKEYSESSION_MESSAGETYPE messageType,
		[in] BYTE* message,
		[in] DWORD messageSize,
		[in] LongPtr destinationURL
	);

	// There has been a change in the keys in the session or their status.
	HRESULT KeyStatusChanged();
}

[
	odl,
	uuid(87be986c-10be-4943-bf48-4b54ce1983a2)
]
interface IMFContentDecryptionModule : stdole.IUnknown
{
	// This method allows the caller to specify the IMFContentEnabler interface that shall be used
	// by the Content Decryption Module.
	// The IMFContentEnabler is normally obtained from IMFInputTrustAuthority::RequestAccess.
	HRESULT SetContentEnabler(
		[in] IMFContentEnabler* contentEnabler,
		[in] IMFAsyncResult* result
	);

	// Provides an object for IMFContentDecryptionModuleSession suspend events.
	HRESULT GetSuspendNotify([out] IMFCdmSuspendNotify** notify);

	// This method allows the caller to specify the IMFPMPHostApp interface, which represents
	// a protected process. The IMFPMPHostApp interface is used by the CDM to create the
	// IMFTrustedInput object.
	HRESULT SetPMPHostApp([in] IMFPMPHostApp* pmpHostApp);

	// Creates an object based on the EME spec MediaKeySession object:
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeys-createsession
	HRESULT CreateSession(
		[in] MF_MEDIAKEYSESSION_TYPE sessionType,
		[in] IMFContentDecryptionModuleSessionCallbacks* callbacks,
		[out] IMFContentDecryptionModuleSession** session
	);

	// Provides a server certificate to be used to encrypt messages to the license server.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeys-setservercertificate
	HRESULT SetServerCertificate(
		[in] BYTE* certificate,
		[in] DWORD certificateSize
	);

	// Creates an IMFTrustedInput object that implements the decryption of content.
	// ContentInitData will only be used if initData from
	// IMFContentDecryptionModuleSession::GenerateRequest is not provided or incomplete.
	// Initialization Data should be structured in PSSH Box Format. For more details, see
	// https://www.w3.org/TR/eme-initdata-cenc/#common-system
	HRESULT CreateTrustedInput(
		[in] BYTE* contentInitData,
		[in] DWORD contentInitDataSize,
		[out] IMFTrustedInput** trustedInput
	);

	// Identifies the SystemIDs that this object supports.
	// SystemIDs are identifiers used in the "cenc" Initialization Data Format. For more details, see
	// https://w3c.github.io/encrypted-media/format-registry/initdata/cenc.html
	// systemIds should be allocated and freed using CoTaskMem.
	HRESULT GetProtectionSystemIds(
		[out] LongPtr* systemIds,
		[out] DWORD* count
	);
}

// IMFContentDecryptionModuleAccess is designed based on MediaKeySystemAccess:
// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#mediakeysystemaccess-interface
[
	odl,
	uuid(a853d1f4-e2a0-4303-9edc-f1a68ee43136)
]
interface IMFContentDecryptionModuleAccess : stdole.IUnknown
{
	// Creates an object based on the EME spec MediaKeys object:
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#mediakeys-interface
	// Supported contentDecryptionModuleProperties are detailed below.
	HRESULT CreateContentDecryptionModule(
		[in] IPropertyStore* contentDecryptionModuleProperties,
		[out] IMFContentDecryptionModule** contentDecryptionModule
	);

	// Returns the supported combination of configuration options.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysystemaccess-getconfiguration
	HRESULT GetConfiguration(
		[out] IPropertyStore** configuration
	);

	// Identifies the Key System being used.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysystemaccess-keysystem
	// String should be allocated and freed using CoTaskMem.
	HRESULT GetKeySystem(
		[out] LongPtr* keySystem
	);
}

[
	odl,
	uuid(7d5abf16-4cbb-4e08-b977-9ba59049943e)
]
interface IMFContentDecryptionModuleFactory : stdole.IUnknown
{
	// Identifies what Key Systems are be supported.
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#key-system
	BOOL IsTypeSupported(
		[in] LongPtr keySystem,
		[in] LongPtr contentType
	);

	// Creates an object based on the EME spec MediaKeySystemAccess object:
	// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#mediakeysystemaccess-interface
	// See IMFMediaKeySystemAccess::CreateMediaKeys for configuration information.
	HRESULT CreateContentDecryptionModuleAccess(
		[in] LongPtr keySystem,
		[in] IPropertyStore* configurations,
		[in] DWORD numConfigurations,
		[out] IMFContentDecryptionModuleAccess** contentDecryptionModuleAccess
	);
}






//////////////////////////////////////////////////////////////////////////////
//
//  MPEG-2 Media Sink
//
/// <summary>
///     Initialize Media Foundation MPEG-2 sink
/// </summary>
//////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(0c012799-1b61-4c10-bda9-04445be5f561)
]
interface IMFDLNASinkInit : stdole.IUnknown
{
	/// <summary>
	///    Initialize the MPEG2 DLNA sink
	/// </summary>
	///
	/// <param name="pByteStream">
	///    Byte stream to write to.  Must be writable
	/// </param>
	///
	/// <param name="fPal">
	///    if TRUE video size and frame rate will be one of the accepted values for PAL
	///    if FALSE video size and frame frame will be one of the accepted values for NTSC
	HRESULT Initialize([in] IMFByteStream* pByteStream, [in] BOOL fPal);
}

typedef struct MFMPEG2DLNASINKSTATS         
{                                            
   DWORDLONG  cBytesWritten;                 
   BOOL       fPAL;                          
   DWORD      fccVideo;                      
   DWORD      dwVideoWidth;                  
   DWORD      dwVideoHeight;                 
   DWORDLONG  cVideoFramesReceived;          
   DWORDLONG  cVideoFramesEncoded;           
   DWORDLONG  cVideoFramesSkipped;           
   DWORDLONG  cBlackVideoFramesEncoded;      
   DWORDLONG  cVideoFramesDuplicated;        
   DWORD      cAudioSamplesPerSec;           
   DWORD      cAudioChannels;                
   DWORDLONG  cAudioBytesReceived;           
   DWORDLONG  cAudioFramesEncoded;           
} MFMPEG2DLNASINKSTATS;                      

interface ID3D12CommandQueue;

[
	odl,
	uuid(09D0F835-92FF-4E53-8EFA-40FAA551F233)
]
/// <summary>
///     Synchronization object commands allow a producer or a consumer of D3D12 resource to signal down-stream
///     components when the resource is ready for use or can be released.
/// </summary>
interface IMFD3D12SynchronizationObjectCommands : stdole.IUnknown
{
	/// <summary>
	///     Queues a fence on the specified producer command queue that will signal to a downstream consumer 
	///     when the associated D3D12 resource is ready to be used. This method also signals that the resource is 
	///     no longer in use and has been released by the producer.
	/// </summary>
	/// <param name="pProducerCommandQueue">
	///     Pointer to the producer command queue into which the fence should be inserted.
	/// </param>
	HRESULT EnqueueResourceReady([in] ID3D12CommandQueue* pProducerCommandQueue);

	/// <summary>
	///     Queues a wait command on the specified consumer command queue, starting a wait for the
	///     Resource Ready signal from the producer command queue.  This function allows the consumer 
	///     to immediately start scheduling commands its GPU engine.  The wait will ensure 
	///     that the commands scheduled after the wait are not executed until the corresponding 
	///     Ready Signal is fired by the producer GPU engine.
	/// </summary>
	/// <param name="pCommandQueue">
	///     Pointer to the consumer command queue onto which the wait command should be queued.
	/// </param>
	HRESULT EnqueueResourceReadyWait([in] ID3D12CommandQueue* pConsumerCommandQueue);

	/// <summary>
	///     Stores an event handle that will be set when the D3D12 resource is 
	///     ready.  This event can be used by a CPU thread to wait until the resource
	///     producer GPU tasks have finished executing, and the producer fires the Resource Ready 
	///     signal. If the event handle has restricted access rights, the handle must have at least
	///     the EVENT_MODIFY_STATE right.
	/// </summary>
	/// <param name="hEvent">
	///     Handle to the event that will be set when the resource is ready.
	/// </param>
	HRESULT SignalEventOnResourceReady([in] HANDLE hEvent);

	/// <summary>
	///     Queues a fence into the specified command queue that will signal to the synchronization
	///     object when GPU is finished processing the consumer commands.  This method signals when
	///     the resource is no longer in use and has been released by the consumer.
	/// </summary>
	/// <param name="pCommandQueue">
	///     Pointer to the consumer command queue onto which the fence should be queued.
	/// </param>
	HRESULT EnqueueResourceRelease([in] ID3D12CommandQueue* pConsumerCommandQueue);
}


[
	odl,
	uuid(802302B0-82DE-45E1-B421-F19EE5BDAF23),
]
/// <summary>
///     The synchronization object interface allows a D3D12 resource allocator to
///     manage the lifetime of a D3D12 resource.
/// </summary>
interface IMFD3D12SynchronizationObject : stdole.IUnknown
{
	/// <summary>
	///     Stores an event handle that will be set when the resource is free and can be recycled,
	///     reused, or destroyed.  The handle is signaled when there are no longer any pending
	///     Resource Release or Resource Ready signals for the current resource.  If the event handle
	///     has restricted access rights, the handle must have at least the EVENT_MODIFY_STATE right.
	/// </summary>
	/// <param name="hEvent">
	///     Handle to the event that will be set when the resource is freed.
	/// </param>
	HRESULT SignalEventOnFinalResourceRelease([in] HANDLE hEvent);

	/// <summary>
	///     Resets the synchronization object state, allowing the allocator to reuse the resource and
	///     this corresponding synchronization object.
	/// </summary>
	HRESULT Reset();
}




//
// This enumeration indicates the D3D version of the resource used in the stream associated with a media type.
//
typedef enum MF_MT_D3D_RESOURCE_VERSION_ENUM
{
	MF_D3D11_RESOURCE,
	MF_D3D12_RESOURCE
}MF_MT_D3D_RESOURCE_VERSION_ENUM;


//////////////////////////////////////////////////////////////////////////////
//
// IAdvancedMediaCaptureInitializationSettings Interface
//
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(3DE21209-8BA6-4f2a-A577-2819B56FF14D)
]
/// <summary>
/// This interface is used to set advanced MediaCapture Initialization settings on
/// MediaCapture object
/// </summary>
interface IAdvancedMediaCaptureInitializationSettings : stdole.IUnknown
{
	/// <summary>
	/// Sets DX manager to be used for the video capture session
	/// </summary>
	/// <param name="IMFDXGIDeviceManager">
	/// DX device manager interface pointer
	/// </param>
	HRESULT SetDirectxDeviceManager([in] IMFDXGIDeviceManager* value);
};

///////////////////////////////////////////////////////////////////////////////
//
// IAdvancedMediaCaptureSettings Interface
//
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(24E0485F-A33E-4aa1-B564-6019B1D14F65)
]
/// <summary>
/// This interface is used to set/get advanced MediaCapture object settings 
/// </summary>
interface IAdvancedMediaCaptureSettings : stdole.IUnknown
{
	/// <summary>
	/// Gets DirectX manager that is being used in MediaCapture object 
	/// </summary>
	/// <param name="IMFDXGIDeviceManager">
	/// Pointer to receive DX manager interface pointer 
	/// </param>
	HRESULT GetDirectxDeviceManager([out] IMFDXGIDeviceManager** value);

};

///////////////////////////////////////////////////////////////////////////////
//
// IAdvancedMediaCapture Interface
//
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(D0751585-D216-4344-B5BF-463B68F977BB)
]
interface IAdvancedMediaCapture : stdole.IUnknown
{
	HRESULT GetAdvancedMediaCaptureSettings([out] IAdvancedMediaCaptureSettings** value);
};


typedef struct DEVICE_INFO
{
	BSTR pFriendlyDeviceName;
	BSTR pUniqueDeviceName;
	BSTR pManufacturerName;
	BSTR pModelName;
	BSTR pIconURL;
}   DEVICE_INFO;

/// <summary>
///     Events fired by the <video>/<audio>/<img> elements
///     Extends MF_MEDIA_ENGINE_EVENT
/// </summary>
typedef enum MF_SHARING_ENGINE_EVENT
{
	MF_SHARING_ENGINE_EVENT_DISCONNECT = 2000,
	MF_SHARING_ENGINE_EVENT_LOCALRENDERINGSTARTED = 2001,
	MF_SHARING_ENGINE_EVENT_LOCALRENDERINGENDED = 2002,
	MF_SHARING_ENGINE_EVENT_STOPPED = 2003,
	MF_SHARING_ENGINE_EVENT_ERROR = 2501,
} MF_SHARING_ENGINE_EVENT;

/// <summary>
///     Events fired by the <video>/<audio> elements
///     Extends MF_MEDIA_ENGINE_EVENT
/// </summary>
typedef enum MF_MEDIA_SHARING_ENGINE_EVENT
{
	MF_MEDIA_SHARING_ENGINE_EVENT_DISCONNECT = 2000,
} MF_MEDIA_SHARING_ENGINE_EVENT;

///////////////////////////////////////////////////////////////////////////////
//
// IMFSharingEngineClassFactory Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(2BA61F92-8305-413B-9733-FAF15F259384)
]
interface IMFSharingEngineClassFactory : stdole.IUnknown
{
	HRESULT CreateInstance(
		[in] DWORD dwFlags,             // see MF_MEDIA_ENGINE_CREATEFLAGS
		[in] IMFAttributes* pAttr,
		[out] IUnknown** ppEngine   // implements either IMFMediaEngineEx, IMFMediaSharingEngine, 
															// or IMFImageSharingEngine based on flags passed to IPlayToConnectionClassFactory
	);
}

///////////////////////////////////////////////////////////////////////////////
//
// IMFMediaSharingEngine Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(8D3CE1BF-2367-40E0-9EEE-40D377CC1B46),
	helpstring("IMFMediaSharingEngine Interface")
]
interface IMFMediaSharingEngine : IMFMediaEngine
{
	HRESULT GetDevice([out] DEVICE_INFO* pDevice);
}

///////////////////////////////////////////////////////////////////////////////
//
// IMFMediaSharingEngineClassFactory Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(524D2BC4-B2B1-4FE5-8FAC-FA4E4512B4E0),
	helpstring("IMFMediaSharingEngineClassFactory Interface")
]
interface IMFMediaSharingEngineClassFactory : stdole.IUnknown
{
	HRESULT CreateInstance(
		[in] DWORD dwFlags,
		[in] IMFAttributes* pAttr,
		[out] IMFMediaSharingEngine** ppEngine
	);
}

///////////////////////////////////////////////////////////////////////////////
//
// IMFImageSharingEngine Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(CFA0AE8E-7E1C-44D2-AE68-FC4C148A6354),
	helpstring("IMFImageSharingEngine Interface")
]
interface IMFImageSharingEngine : stdole.IUnknown
{
	HRESULT SetSource([in] IUnknown* pStream);

	HRESULT GetDevice([out] DEVICE_INFO* pDevice);

	HRESULT Shutdown();
}

///////////////////////////////////////////////////////////////////////////////
//
// IMFImageSharingEngineClassFactory Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(1FC55727-A7FB-4FC8-83AE-8AF024990AF1),
	helpstring("IMFImageSharingEngineClassFactory Interface")
]
interface IMFImageSharingEngineClassFactory : stdole.IUnknown
{
	HRESULT CreateInstanceFromUDN(
		[in] BSTR pUniqueDeviceName,
		[out] IMFImageSharingEngine** ppEngine
	);
}

///////////////////////////////////////////////////////////////////////////////
//
// PLAYTO_SOURCE_CREATEFLAGS
//
///////////////////////////////////////////////////////////////////////////////

typedef enum PLAYTO_SOURCE_CREATEFLAGS
{
	PLAYTO_SOURCE_NONE = 0x0,
	PLAYTO_SOURCE_IMAGE = 0x1,
	PLAYTO_SOURCE_AUDIO = 0x2,
	PLAYTO_SOURCE_VIDEO = 0x4,
//#if (WINVER >= _WIN32_WINNT_WINBLUE)
	PLAYTO_SOURCE_PROTECTED = 0x8,
//#endif // (WINVER >= _WIN32_WINNT_WINBLUE)
} PLAYTO_SOURCE_CREATEFLAGS;

///////////////////////////////////////////////////////////////////////////////
//
// IPlayToControl Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(607574EB-F4B6-45C1-B08C-CB715122901D)
]
interface IPlayToControl : stdole.IUnknown
{
	HRESULT Connect(
		[in] IMFSharingEngineClassFactory* pFactory
	);

	HRESULT Disconnect();
}

///////////////////////////////////////////////////////////////////////////////
//
// IPlayToControlWithCapabilities Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(AA9DD80F-C50A-4220-91C1-332287F82A34)
]
interface IPlayToControlWithCapabilities : IPlayToControl
{
	HRESULT GetCapabilities(
		[out] PLAYTO_SOURCE_CREATEFLAGS* pCapabilities
	);
}

///////////////////////////////////////////////////////////////////////////////
//
// IPlayToSourceClassFactory Interface
//
///////////////////////////////////////////////////////////////////////////////

[
	odl,
	uuid(842B32A3-9B9B-4D1C-B3F3-49193248A554)
]
interface IPlayToSourceClassFactory : stdole.IUnknown
{
	HRESULT CreateInstance(
		[in] PLAYTO_SOURCE_CREATEFLAGS dwFlags,                             // see PLAYTO_SOURCE_CREATEFLAGS
		[in] IPlayToControl* pControl,                  // element which controls the media
		[out] IUnknown** ppSource               // implements Windows.Media.PlayTo.PlayToSource
	);
}


/// <summary>
///     The IMFSpatialAudioObjectBuffer interface represents a section of audio data with
///     associated positional and rendering information metadata.  Spatial audio
///     objects are stored in IMFSpatialAudioSample instances, and allow passing of 
///     spatial audio information between Media Foundation components.
///
///	    To get the audio data contained in the spatial audio object, use the IMFMediaBuffer
///	    Lock() and Unlock() methods.
/// </summary>
[
	odl,
	uuid(d396ec8c-605e-4249-978d-72ad1c312872)
]
interface IMFSpatialAudioObjectBuffer : IMFMediaBuffer
{
	/// <summary>
	///     The SetID() method sets the ID of the spatial audio object.
	/// </summary>
	/// <param name="u32ID">
	///     A 32-bit unsigned unique ID of the audio object.
	/// </param>
	/// <remarks>
	///     The object ID must be unique for each spatial audio sample.  Subsequent samples can 
	///     contain spatial audio objects with the same IDs to represent moving objects or constant
	///     static objects (speaker channels).
	/// </remarks>
	HRESULT SetID(
		[in] UINT32 u32ID);

	/// <summary>
	///     The GetID() method returns 32-bit unique, unsigned ID of the spatial audio object.
	///     If SetID() method was not called, this method returns the invalid object ID -1 
	///     (0xffffffff).  The invalid ID indicates that the object buffer is unused and
	///     contains invalid data.
	/// </summary>
	/// <param name="pu32ID">
	///     Pointer to a 32-bit variable where the object ID will be stored.
	/// </param>
	HRESULT GetID(
		[out] UINT32* pu32ID);

	/// <summary>
	///     The SetType() method sets the type of audio object.
	/// </summary>
	/// <param name="type">
	///     A value from the AudioObjectType enumeration, specifying the type of the audio object.
	/// </param>
	/// <remarks>
	///     A spatial audio object can represent a dynamic moving object with changing coordinates 
	///     (AudioObjectType_Dynamic), or it can be a pre-defined speaker channel such as 
	///     AudioObjectType_FrontLeft.
	/// </remarks>
	HRESULT SetType(
		[in] AudioObjectType type);

	/// <summary>
	///     The GetType() method returns the audio object type of the spatial audio object.  If
	///     SetType() method was not called, this method returns a default value of 
	///     AudioObjectType_None.
	/// </summary>
	/// <param name="pType">
	///     Pointer to an AudioObjectType variable where the audio object type will be stored.
	/// </param>
	HRESULT GetType(
		[out] AudioObjectType* pType);

	/// <summary>
	///     The GetMetadataItems() method retrieves a pointer to a buffer that may 
	///     contain metadata.  The metadata is written to the ISpatialAudioMetadtaItems
	///     collection in a format identified by the MF_MT_SPATIAL_AUDIO_OBJECT_METADATA_ID 
	///     media type attribute specified during media type negotiation phase of MF 
	///     topology construction.
	/// </summary>
	/// <param name="ppMetadataItems">
	///     Pointer to a ISpatialAudioMetadataItems object which will contain a collection
	///     of metadata metadata items.
	/// </param>
	HRESULT GetMetadataItems(
		[out] ISpatialAudioMetadataItems** ppMetadataItems);
};


/// <summary>
///     The IMFSpatialAudioSample interface represents a multimedia sample 
///     with spatial audio information.  Each spatial audio sample contains one
///     or more IMFSpatialAudioObjectBuffer objects.
/// </summary>

[
	odl,
	uuid(abf28a9B-3393-4290-ba79-5ffc46d986b2)
]
interface IMFSpatialAudioSample : IMFSample
{
	/// <summary>
	///     The GetObjectCount method returns the number of spatial audio objects in the 
	///     sample.
	/// </summary>
	/// <param name="pdwObjectCount">
	///     Pointer to a 32 bit variable where the total number of audio objects in the 
	///     sample will be stored.
	/// </param>
	HRESULT GetObjectCount([out] DWORD* pdwObjectCount);

	/// <summary>
	///     The AddSpatialAudioObject method adds a new spatial audio object to the spatial
	///     sample.
	/// </summary>
	/// <param name="pAudioObjBuffer">
	///     Pointer to the new IMFSpatialAudioObject.
	/// </param>
	HRESULT AddSpatialAudioObject(
		[in] IMFSpatialAudioObjectBuffer* pAudioObjBuffer);

	/// <summary>
	///     The GetSpatialAudioObjectByIndex() method returns an audio object specified
	///     with the passed-in index.
	/// </summary>
	/// <param name="dwIndex">
	///     A 32 bit variable with the 0-based index of the audio object requested.
	/// </param>
	/// <param name="ppSpatialAudioObjectBuffer">
	///     The out param where a pointer to the IMFSpatialAudioObjectBuffer with the 
	///     specified index will be stored.
	/// </param>
	HRESULT GetSpatialAudioObjectByIndex(
		[in] DWORD dwIndex,
		[out] IMFSpatialAudioObjectBuffer** ppAudioObjBuffer);
};


typedef enum DEVPROPTYPE
{
    DEVPROP_TYPE_EMPTY                      = 0x00000000, // nothing, no property data
    DEVPROP_TYPE_NULL                       = 0x00000001, // null property data
    DEVPROP_TYPE_SBYTE                      = 0x00000002, // 8-bit signed int (SBYTE)
    DEVPROP_TYPE_BYTE                       = 0x00000003, // 8-bit unsigned int (BYTE)
    DEVPROP_TYPE_INT16                      = 0x00000004, // 16-bit signed int (SHORT)
    DEVPROP_TYPE_UINT16                     = 0x00000005, // 16-bit unsigned int (USHORT)
    DEVPROP_TYPE_INT32                      = 0x00000006, // 32-bit signed int (LONG)
    DEVPROP_TYPE_UINT32                     = 0x00000007, // 32-bit unsigned int (ULONG)
    DEVPROP_TYPE_INT64                      = 0x00000008, // 64-bit signed int (LONG64)
    DEVPROP_TYPE_UINT64                     = 0x00000009, // 64-bit unsigned int (ULONG64)
    DEVPROP_TYPE_FLOAT                      = 0x0000000A, // 32-bit floating-point (FLOAT)
    DEVPROP_TYPE_DOUBLE                     = 0x0000000B, // 64-bit floating-point (DOUBLE)
    DEVPROP_TYPE_DECIMAL                    = 0x0000000C, // 128-bit data (DECIMAL)
    DEVPROP_TYPE_GUID                       = 0x0000000D, // 128-bit unique identifier (GUID)
    DEVPROP_TYPE_CURRENCY                   = 0x0000000E, // 64 bit signed int currency value (CURRENCY)
    DEVPROP_TYPE_DATE                       = 0x0000000F, // date (DATE)
    DEVPROP_TYPE_FILETIME                   = 0x00000010, // file time (FILETIME)
    DEVPROP_TYPE_BOOLEAN                    = 0x00000011, // 8-bit boolean (DEVPROP_BOOLEAN)
    DEVPROP_TYPE_STRING                     = 0x00000012, // null-terminated string
    DEVPROP_TYPE_STRING_LIST = 0x00002012, //(DEVPROP_TYPE_STRING|DEVPROP_TYPEMOD_LIST), // multi-sz string list
    DEVPROP_TYPE_SECURITY_DESCRIPTOR        = 0x00000013, // self-relative binary SECURITY_DESCRIPTOR
    DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING = 0x00000014, // security descriptor string (SDDL format)
    DEVPROP_TYPE_DEVPROPKEY                 = 0x00000015, // device property key (DEVPROPKEY)
    DEVPROP_TYPE_DEVPROPTYPE                = 0x00000016, // device property type (DEVPROPTYPE)
    DEVPROP_TYPE_BINARY     = 0x00001016, // (DEVPROP_TYPE_BYTE|DEVPROP_TYPEMOD_ARRAY), // custom binary data
    DEVPROP_TYPE_ERROR                      = 0x00000017, // 32-bit Win32 system error code
    DEVPROP_TYPE_NTSTATUS                   = 0x00000018, // 32-bit NTSTATUS code
    DEVPROP_TYPE_STRING_INDIRECT            = 0x00000019, // string resource (@[path\]<dllname>,-<strId>)
    DEVPROP_TYPEMOD_ARRAY                   = 0x00001000, // array of fixed-sized data elements
    DEVPROP_TYPEMOD_LIST                    = 0x00002000  // list of variable-sized data elements
} DEVPROPTYPE;



typedef enum MFVirtualCameraType
{
	MFVirtualCameraType_SoftwareCameraSource,
} MFVirtualCameraType;

typedef enum PMFVirtualCameraLifetime
{
	MFVirtualCameraLifetime_Session,
	MFVirtualCameraLifetime_System,
} MFVirtualCameraLifetime;

typedef enum PMFVirtualCameraAccess
{
	MFVirtualCameraAccess_CurrentUser,
	MFVirtualCameraAccess_AllUsers,
} MFVirtualCameraAccess;

[
	odl,
	uuid(6338B23A-3042-49D2-A3EA-EC0FED815407)
]
interface IMFCameraSyncObject : stdole.IUnknown
{
	HRESULT WaitOnSignal(
		[in] DWORD timeOutInMs
	);

	void Shutdown(
	);
};


[
	odl,
	uuid(1C08A864-EF6C-4C75-AF59-5F2D68DA9563),
	helpstring("IMFVirtualCamera Interface")
]
interface IMFVirtualCamera : IMFAttributes
{
	HRESULT AddDeviceSourceInfo(
		[in] LongPtr DeviceSourceInfo
	);

	HRESULT AddProperty(
		[in] DEVPROPKEY* pKey,
		[in] DEVPROPTYPE Type,
		[in] BYTE* pbData,
		[in] ULONG cbData
	);

	HRESULT AddRegistryEntry(
		[in] LongPtr EntryName,
		[in] LongPtr SubkeyPath,
		[in] DWORD dwRegType,
		[in] BYTE* pbData,
		[in] ULONG cbData
	);

	/// <summary>
	///     Start the virtual camera discoverability via the PnP enumeration.
	/// </summary>
	/// <param name="pCallback">
	///     Caller implemented IMFAsyncCallback that receives the state
	///     change for the virtual camera.
	/// </param>
	HRESULT Start(
		[in] IMFAsyncCallback* pCallback
	);

	/// <summary>
	///     Stop the virtual camera discoverability via the PnP enumeration.
	/// </summary>
	/// <remarks>
	///     Stop does not remove the PnP device from the system.  It simply
	///     marks it as disabled (i.e., can still enumerate if the enumeration
	///     is specified for both enabled and disabled devices).  It also keeps
	///     the virtual camera configuration information.  Remove method will
	///     delete the PnP device node and delete all configuration information
	///     as well.
	/// </remarks>
	HRESULT Stop(
	);

	/// <summary>
	///     Remove the PnP device from the machine.
	/// </summary>
	/// <remarks>
	///     Remove will delete the virtual camera device node and all stored
	///     configuration information.
	/// </remarks>
	HRESULT Remove(
	);

	HRESULT GetMediaSource(
		[out] IMFMediaSource** ppMediaSource
	);

	/// <summary>
	///     Issue a GET/SET command to the virtual camera.  This wraps
	///     the IKsControl::KsProperty method.
	/// </summary>
	/// <param name="propertySet">
	///     Corresponds to KSPROPERTY.Set defined in ks.h.
	/// </param>
	/// <param name="propertyId">
	///     Corresponds to KSPROPERTY.Id defined in ks.h.
	/// </param>
	/// <param name="propertyFlags">
	///     Corresponds to KSPROPERTY.Flags defined in ks.h
	///     Only KSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET,
	///     KSPROPERTY_TYPE_BASICSUPPORT and KSPROPERTY_TYPE_DEFAULTVALUES
	///     are supported.
	/// </param>
	/// <param name="propertyPayload">
	///     Additional payload that will be added to the
	///     end of the KSPROPERTY structure when sent to
	///     the virtual camera's IKsControl::KsProperty.
	/// </param>
	/// <param name="propertyPayloadLength">
	///     Size in bytes of propertyPayload.
	/// </param>
	/// <param name="data">
	///     The data payload issued to the virtual camera's
	///     IKsControl::KsProperty.
	/// </param>
	/// <param name="dataLength">
	///     Size in bytes of  data.
	/// </param>
	/// <param name="dataWritten">
	///     When KSPROPERTY_TYPE_GET, KSPROPERTY_TYPE_BASICSUPPORT or
	///     KSPROPERTY_TYPE_DEFAULTVALUES is specified, the size in bytes
	///     written into the data buffer (or if the data buffer is insufficient,
	///     the amount needed).
	///     For KSPROPERTY_TYPE_SET, this parameter is not used.
	/// </param>
	HRESULT SendCameraProperty(
		[in] REFGUID propertySet,
		[in] ULONG propertyId,
		[in] ULONG propertyFlags,
		[in] void* propertyPayload,
		[in] ULONG propertyPayloadLength,
		[in] void* data,
		[in] ULONG dataLength,
		[out] ULONG* dataWritten
	);

	/// <summary>
	///     Create a sync object wrapping the KSEVENT event handle.
	/// </summary>
	/// <param name="kseventSet">
	///     Corresponds to KSEVENT.Set defined in ks.h.
	/// </param>
	/// <param name="kseventId">
	///     Corresponds to KSEVENT.Id defined in ks.h.
	/// </param>
	/// <param name="kseventFlags">
	///     Corresponds to KSEVENT.Flags defined in ks.h
	///     Only KSEVENT_TYPE_ENABLE & KSEVENT_TYPE_ONESHOT are supported.
	/// </param>
	/// <param name="eventHandle">
	///     NT event handle to signal when the KSEVENT is triggered by
	///     the camera driver.
	/// </param>
	HRESULT CreateSyncEvent(
		[in] REFGUID kseventSet,
		[in] ULONG kseventId,
		[in] ULONG kseventFlags,
		[in] LongPtr eventHandle,
		[out] IMFCameraSyncObject** cameraSyncObject
	);

	/// <summary>
	///     Create an sync object wrapping the KSEVENT semaphore handle.
	/// </summary>
	/// <param name="kseventSet">
	///     Corresponds to KSEVENT.Set defined in ks.h.
	/// </param>
	/// <param name="kseventId">
	///     Corresponds to KSEVENT.Id defined in ks.h.
	/// </param>
	/// <param name="kseventFlags">
	///     Corresponds to KSEVENT.Flags defined in ks.h
	///     Only KSEVENT_TYPE_ENABLE & KSEVENT_TYPE_ONESHOT are supported.
	/// </param>
	/// <param name="semaphoreHandle">
	///     NT semaphore handle to signal when the KSEVENT is triggered by
	///     the camera driver.
	/// </param>
	/// <param name="semaphoreAdjustment">
	///     Corresponds to the KSEVENTDATA.SemaphoreHandle.Adjustment
	///     defined in ks.h.
	/// </param>
	HRESULT CreateSyncSemaphore(
		[in] REFGUID kseventSet,
		[in] ULONG kseventId,
		[in] ULONG kseventFlags,
		[in] LongPtr semaphoreHandle,
		[in] LONG semaphoreAdjustment,
		[out] IMFCameraSyncObject** cameraSyncObject
	);

	HRESULT Shutdown(
	);
};



/// <summary>
///    The IMFMuxStreamAttributesManager interface
/// </summary>

[
	odl,
	uuid(CE8BD576-E440-43B3-BE34-1E53F565F7E8),
	helpstring("IMFMuxStreamAttributesManager Interface")
]
interface IMFMuxStreamAttributesManager : stdole.IUnknown
{
	HRESULT GetStreamCount(
		[out] DWORD* pdwMuxStreamCount
	);

	HRESULT GetAttributes(
		[in] DWORD dwMuxStreamIndex,
		[out] IMFAttributes** ppStreamAttributes
	);
}
/// <summary>
///    The IMFMuxStreamMediaTypeManager interface
/// </summary>

[
	odl,
	uuid(505A2C72-42F7-4690-AEAB-8F513D0FFDB8),
	helpstring("IMFMuxStreamMediaTypeManager Interface")
]
interface IMFMuxStreamMediaTypeManager : stdole.IUnknown
{
	HRESULT GetStreamCount(
		[out] DWORD* pdwMuxStreamCount
	);

	HRESULT GetMediaType(
		[in] DWORD dwMuxStreamIndex,
		[out] IMFMediaType** ppMediaType
	);

	HRESULT GetStreamConfigurationCount(
		[out] DWORD* pdwCount
	);

	HRESULT AddStreamConfiguration(
		[in] ULONGLONG ullStreamMask
	);

	HRESULT RemoveStreamConfiguration(
		[in] ULONGLONG ullStreamMask
	);

	HRESULT GetStreamConfiguration(
		[in] DWORD ulIndex,
		[out] ULONGLONG* pullStreamMask
	);
}

/// <summary>
///    The IMFMuxStreamSampleManager interface
/// </summary>
[
	odl,
	uuid(74ABBC19-B1CC-4E41-BB8B-9D9B86A8F6CA),
	helpstring("IMFMuxStreamSampleManager Interface")
]
interface IMFMuxStreamSampleManager : stdole.IUnknown
{
	HRESULT GetStreamCount(
		[out] DWORD* pdwMuxStreamCount
	);

	HRESULT GetSample(
		[in] DWORD dwMuxStreamIndex,
		[out] IMFSample** ppSample
	);

	ULONGLONG GetStreamConfiguration();
}

///////////////////////////////////////////////////////////////////////////////
//
// IMFSecureBuffer Interface
//
///////////////////////////////////////////////////////////////////////////////
/// <summary>
/// This interface encapsulates a secure buffer allocated by the frame server
/// trustlet.
/// </summary>
[
	odl,
	uuid(C1209904-E584-4752-A2D6-7F21693F8B21)
]
interface IMFSecureBuffer : stdole.IUnknown
{
	/// <summary>
	/// Get the identifier for a secure buffer.  This GUID can be used by
	/// a device's trustlet to open a secure section containing the buffer.
	/// </summary>  
	HRESULT GetIdentifier(
		[out] GUID* pGuidIdentifier);
};


// <summary>
// This enum maps to the W3C cross origin settings (CORS) attribute used by the HTML5 media element: 
//  * Omitted Attribute -- No CORS state.
//  * Anonymous -- Requests for the element will have their mode set to "cors" and their credentials mode set to "same-origin".
//  * Use Credentials -- Requests for the element will have their mode set to "cors" and their credentials mode set to "include".
// </summary>
typedef enum MF_CROSS_ORIGIN_POLICY
{
	MF_CROSS_ORIGIN_POLICY_NONE = 0,
	MF_CROSS_ORIGIN_POLICY_ANONYMOUS = 1,
	MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS = 2,
} MF_CROSS_ORIGIN_POLICY;

// <summary>
// This interface is implemented by clients that want to enforce a cross origin policy for HTML5 media downloads.
// The Media Foundation network code uses these client callbacks to implement and enforce cross origin downloads.
//  * GetCrossOriginPolicy() returns the client's current cross origin policy to apply to the download session.
//  * GetSourceOrigin() returns the W3C origin of the HTML5 media element.  Use CoTaskMemFree to free the string.
//  * IsSameOrigin() returns true when the specified URL has the same origin as the HTML5 media element.
// </summary>
[
	odl,
	uuid(bc2b7d44-a72d-49d5-8376-1480dee58b22),
	helpstring("IMFNetCrossOriginSupport Interface")
]
interface IMFNetCrossOriginSupport : stdole.IUnknown
{
	HRESULT GetCrossOriginPolicy(
		[out] MF_CROSS_ORIGIN_POLICY* pPolicy
	);

	HRESULT GetSourceOrigin(
		[out] LongPtr* wszSourceOrigin
	);

	HRESULT IsSameOrigin(
		[in] LongPtr wszURL,
		[out] BOOL* pfIsSameOrigin
	);
};


// <summary>
// This interface is implemented by clients to provide HTTP based download functionality to Media Foundation.
// </summary>
[
	odl,
	uuid(F779FDDF-26E7-4270-8A8B-B983D1859DE0)
]
interface IMFHttpDownloadRequest : stdole.IUnknown
{
	HRESULT AddHeader(
		[in] LongPtr szHeader
	);

	HRESULT BeginSendRequest(
		[in] BYTE* pbPayload,
		[in] ULONG cbPayload,
		[in] IMFAsyncCallback* pCallback,
		[in] IUnknown* punkState
	);

	HRESULT EndSendRequest(
		[in] IMFAsyncResult* pResult
	);

	HRESULT BeginReceiveResponse(
		[in] IMFAsyncCallback* pCallback,
		[in] IUnknown* punkState
	);

	HRESULT EndReceiveResponse(
		[in] IMFAsyncResult* pResult
	);

	HRESULT BeginReadPayload(
		[out] BYTE* pb,
		[in] ULONG cb,
		[in] IMFAsyncCallback* pCallback,
		[in] IUnknown* punkState
	);

	HRESULT EndReadPayload(
		[in] IMFAsyncResult* pResult,
		[out] QWORD* pqwOffset,
		[out] ULONG* pcbRead
	);

	HRESULT QueryHeader(
		[in] LongPtr szHeaderName,
		[in] DWORD dwIndex,
		[out] LongPtr* ppszHeaderValue
	);

	HRESULT GetURL(
		[out] LongPtr* ppszURL
	);

	HRESULT HasNullSourceOrigin(
		[out] BOOL* pfNullSourceOrigin
	);

	HRESULT GetTimeSeekResult(
		[out] QWORD* pqwStartTime,
		[out] QWORD* pqwStopTime,
		[out] QWORD* pqwDuration
	);

	HRESULT GetHttpStatus(
		[out] DWORD* pdwHttpStatus
	);

	HRESULT GetAtEndOfPayload(
		[out] BOOL* pfAtEndOfPayload
	);

	HRESULT GetTotalLength(
		[out] QWORD* pqwTotalLength
	);

	HRESULT GetRangeEndOffset(
		[out] QWORD* pqwRangeEnd
	);

	HRESULT Close();
};

// <summary>
// This interface is implemented by clients to provide an IMFHttpDownloadRequest implementation to Media Foundation.
// </summary>
[
	odl,
	uuid(71FA9A2C-53CE-4662-A132-1A7E8CBF62DB)
]
interface IMFHttpDownloadSession : stdole.IUnknown
{
	HRESULT SetServer(
		[in] LPCWSTR szServerName,
		[in] DWORD nPort
	);

	HRESULT CreateRequest(
		[in] LPCWSTR szObjectName,
		[in] BOOL fBypassProxyCache,
		[in] BOOL fSecure,
		[in] LPCWSTR szVerb,
		[in] LPCWSTR szReferrer,
		[out, retval] IMFHttpDownloadRequest** ppRequest
	);

	HRESULT Close();
};

// <summary>
// This interface is implemented by clients that want to provide their own IMFHttpDownloadSession implementation.
// Media Foundation uses this interface to create an IMFHttpDownloadSession for downloading media.
// </summary>
[
	odl,
	uuid(1B4CF4B9-3A16-4115-839D-03CC5C99DF01)
]
interface IMFHttpDownloadSessionProvider : stdole.IUnknown
{
	HRESULT CreateHttpDownloadSession(
		[in] LongPtr wszScheme,
		[out] IMFHttpDownloadSession** ppDownloadSession
	);
};

typedef enum MF_MEDIASOURCE_STATUS_INFO
{
	MF_MEDIASOURCE_STATUS_INFO_FULLYSUPPORTED = 0,
	MF_MEDIASOURCE_STATUS_INFO_UNKNOWN = 1
} MF_MEDIASOURCE_STATUS_INFO;


// Struct describing the view direction for spherical video
typedef struct MF_VIDEO_SPHERICAL_VIEWDIRECTION
{
	int iHeading;           // Range: -180 to 180
	int iPitch;             // Range: -180 to 180
	int iRoll;              // Range: -180 to 180
} MF_VIDEO_SPHERICAL_VIEWDIRECTION;

[
	odl,
	uuid(FBB03414-D13B-4786-8319-5AC51FC0A136)
]
interface IMFMediaSource2 : IMFMediaSourceEx
{

	HRESULT SetMediaType(
		[in] DWORD dwStreamID,
		[in] IMFMediaType* pMediaType
	);
};

[
	odl,
	uuid(C5BC37D6-75C7-46A1-A132-81B5F723C20F)
]
interface IMFMediaStream2 : IMFMediaStream
{
	HRESULT SetStreamState(
		[in] MF_STREAM_STATE value
	);
	HRESULT GetStreamState(
		[out] MF_STREAM_STATE* value
	);
};


typedef enum MFSensorDeviceType
{
	MFSensorDeviceType_Unknown = 0,
	MFSensorDeviceType_Device,
	MFSensorDeviceType_MediaSource,
	MFSensorDeviceType_FrameProvider,
	MFSensorDeviceType_SensorTransform
} MFSensorDeviceType;

typedef enum MFSensorStreamType
{
	MFSensorStreamType_Unknown = 0,
	MFSensorStreamType_Input,
	MFSensorStreamType_Output
} MFSensorStreamType;

typedef enum MFSensorDeviceMode
{
	MFSensorDeviceMode_Controller = 0,
	MFSensorDeviceMode_Shared
} MFSensorDeviceMode;

[
	odl,
	uuid(FB9F48F2-2A18-4E28-9730-786F30F04DC4),
	helpstring("IMFSensorDevice Interface")
]
interface IMFSensorDevice : stdole.IUnknown
{
	HRESULT GetDeviceId(
		[out] ULONGLONG* pDeviceId
	);

	HRESULT GetDeviceType(
		[out] MFSensorDeviceType* pType
	);

	HRESULT GetFlags(
		[out] ULONGLONG* pFlags
	);

	HRESULT GetSymbolicLink(
		[out] LongPtr* SymbolicLink,
		[in] LONG cchSymbolicLink,
		[out] LONG* pcchWritten
	);

	HRESULT GetDeviceAttributes(
		[out] IMFAttributes** ppAttributes
	);

	HRESULT GetStreamAttributesCount(
		[in] MFSensorStreamType eType,
		[out] DWORD* pdwCount
	);

	HRESULT GetStreamAttributes(
		[in] MFSensorStreamType eType,
		[in] DWORD dwIndex,
		[out] IMFAttributes** ppAttributes
	);

	HRESULT SetSensorDeviceMode(
		[in] MFSensorDeviceMode eMode
	);

	HRESULT GetSensorDeviceMode(
		[out] MFSensorDeviceMode* peMode
	);
};

[
	odl,
	uuid(4110243A-9757-461F-89F1-F22345BCAB4E),
	helpstring("IMFSensorGroup Interface")
]
interface IMFSensorGroup : stdole.IUnknown
{
	HRESULT GetSymbolicLink(
		[out] LongPtr *SymbolicLink,
		[in] LONG cchSymbolicLink,
		[out] LONG* pcchWritten
	);

	HRESULT GetFlags(
		[out] ULONGLONG* pFlags
	);

	HRESULT GetSensorGroupAttributes(
		[out] IMFAttributes** ppAttributes
	);

	HRESULT GetSensorDeviceCount(
		[out] DWORD* pdwCount
	);

	HRESULT GetSensorDevice(
		[in] DWORD dwIndex,
		[out] IMFSensorDevice** ppDevice
	);

	HRESULT SetDefaultSensorDeviceIndex(
		[in] DWORD dwIndex
	);

	HRESULT GetDefaultSensorDeviceIndex(
		[out] DWORD* pdwIndex
	);

	HRESULT CreateMediaSource(
		[out] IMFMediaSource** ppSource
	);
};

[
	odl,
	uuid(E9A42171-C56E-498A-8B39-EDA5A070B7FC),
	helpstring("IMFSensorStream Interface")
]
interface IMFSensorStream : IMFAttributes
{
	HRESULT GetMediaTypeCount(
		[out] DWORD* pdwCount
	);

	HRESULT GetMediaType(
		[in] DWORD dwIndex,
		[out] IMFMediaType** ppMediaType
	);

	HRESULT CloneSensorStream(
		[out] IMFSensorStream** ppStream
	);
};

[
	odl,
	uuid(EED9C2EE-66B4-4F18-A697-AC7D3960215C),
	helpstring("IMFSensorTransformFactory Interface")

]
interface IMFSensorTransformFactory : stdole.IUnknown
{
	HRESULT GetFactoryAttributes(
		[out] IMFAttributes** ppAttributes
	);

	HRESULT InitializeFactory(
		[in] DWORD dwMaxTransformCount,
		[in] IMFCollection* pSensorDevices,
		[in] IMFAttributes* pAttributes
	);

	HRESULT GetTransformCount(
		[out] DWORD* pdwCount
	);

	HRESULT GetTransformInformation(
		[in] DWORD TransformIndex,
		[out] UUID* pguidTransformId,
		[out] IMFAttributes** ppAttributes,
		[out] IMFCollection** ppStreamInformation
	);

	HRESULT CreateTransform(
		[in] REFIID guidSensorTransformID,
		[in] IMFAttributes* pAttributes,
		[out, retval] IMFDeviceTransform** ppDeviceMFT
	);
};


typedef struct SENSORPROFILEID
{
	UUID    Type;
	UINT32  Index;
	UINT32  Unused;
} SENSORPROFILEID;

[
	odl,
	uuid(22F765D1-8DAB-4107-846D-56BAF72215E7),
	helpstring("IMFSensorProfile Interface")
]
interface IMFSensorProfile : stdole.IUnknown
{
	HRESULT GetProfileId(
		[out] SENSORPROFILEID* pId
	);

	HRESULT AddProfileFilter(
		[in] UINT32 StreamId,
		[in] LongPtr wzFilterSetString
	);

	HRESULT IsMediaTypeSupported(
		[in] UINT32 StreamId,
		[in] IMFMediaType* pMediaType,
		[out] BOOL* pfSupported
	);

	HRESULT AddBlockedControl(
		[in] LongPtr wzBlockedControl
	);
};

[
	odl,
	uuid(C95EA55B-0187-48BE-9353-8D2507662351),
	helpstring("IMFSensorProfileCollection Interface")
]
interface IMFSensorProfileCollection : stdole.IUnknown
{
	DWORD GetProfileCount(
	);

	HRESULT GetProfile(
		[in] DWORD Index,
		[out] IMFSensorProfile** ppProfile
	);

	HRESULT AddProfile(
		[in] IMFSensorProfile* pProfile
	);

	HRESULT FindProfile(
		[in] SENSORPROFILEID* ProfileId,
		[out] IMFSensorProfile** ppProfile
	);

	void RemoveProfileByIndex(
		[in] DWORD Index
	);

	void RemoveProfile(
		[in] SENSORPROFILEID* ProfileId
	);
};


[
	odl,
	uuid(39DC7F4A-B141-4719-813C-A7F46162A2B8),
	helpstring("IMFSensorProcessActivity Interface")
]
interface IMFSensorProcessActivity : stdole.IUnknown
{
	HRESULT GetProcessId(
		[out] ULONG* pPID
	);

	HRESULT GetStreamingState(
		[out] BOOL* pfStreaming
	);

	HRESULT GetStreamingMode(
		[out] MFSensorDeviceMode* pMode
	);

	HRESULT GetReportTime(
		[out] FILETIME* pft
	);
};

[
	odl,
	uuid(3E8C4BE1-A8C2-4528-90DE-2851BDE5FEAD),
	helpstring("IMFSensorActivityReport  Interface")
]
interface IMFSensorActivityReport : stdole.IUnknown
{
	HRESULT GetFriendlyName(
		[out] LongPtr *FriendlyName,
		[in] ULONG cchFriendlyName,
		[out] ULONG* pcchWritten
	);

	HRESULT GetSymbolicLink(
		[out] LongPtr* SymbolicLink,
		[in] ULONG cchSymbolicLink,
		[out] ULONG* pcchWritten
	);

	HRESULT GetProcessCount(
		[out] ULONG* pcCount
	);

	HRESULT GetProcessActivity(
		[in] ULONG Index,
		[out] IMFSensorProcessActivity** ppProcessActivity
	);
};

[
	odl,
	uuid(683F7A5E-4A19-43CD-B1A9-DBF4AB3F7777),
	helpstring("IMFSensorActivitiesReport Interface")
]
interface IMFSensorActivitiesReport : stdole.IUnknown
{
	HRESULT GetCount(
		[out] ULONG* pcCount
	);

	HRESULT GetActivityReport(
		[in] ULONG Index,
		[out] IMFSensorActivityReport** sensorActivityReport
	);

	HRESULT GetActivityReportByDeviceName(
		[in] LongPtr SymbolicName,
		[out] IMFSensorActivityReport** sensorActivityReport
	);
};

[
	odl,
	uuid(DE5072EE-DBE3-46DC-8A87-B6F631194751),
	helpstring("IMFSensorActivitiesReportCallback Interface")
]
interface IMFSensorActivitiesReportCallback : stdole.IUnknown
{
	HRESULT OnActivitiesReport(
		[in] IMFSensorActivitiesReport* sensorActivitiesReport
	);
};

[
	odl,
	uuid(D0CEF145-B3F4-4340-A2E5-7A5080CA05CB),
	helpstring("IMFSensorActivityMonitor Interface")
]
interface IMFSensorActivityMonitor : stdole.IUnknown
{
	HRESULT Start(
	);

	HRESULT Stop(
	);
};

// Focal lengths and principal points to be used together with 
// distortion model coefficients to create complete parameter set
// for distortion model.
typedef struct MFCameraIntrinsic_CameraModel
{
	FLOAT FocalLength_x;
	FLOAT FocalLength_y;
	FLOAT PrincipalPoint_x;
	FLOAT PrincipalPoint_y;
} MFCameraIntrinsic_CameraModel;

// Coefficients for radial lens distortion model with 6 radial
// and 2 tangential parameters
typedef struct MFCameraIntrinsic_DistortionModel6KT
{
	FLOAT Radial_k1;
	FLOAT Radial_k2;
	FLOAT Radial_k3;
	FLOAT Radial_k4;
	FLOAT Radial_k5;
	FLOAT Radial_k6;
	FLOAT Tangential_p1;
	FLOAT Tangential_p2;
} MFCameraIntrinsic_DistortionModel6KT;

// Coefficients for ArcTan or F-Theta lens distortion model.
// This is equidistant fish-eye lens model
typedef struct MFCameraIntrinsic_DistortionModelArcTan
{
	FLOAT Radial_k0;
	FLOAT DistortionCenter_x; // center of distortion in Z=1 plane, x
	FLOAT DistortionCenter_y; // center of distortion in Z=1 plane, y
	FLOAT Tangential_x;
	FLOAT Tangential_y;
} MFCameraIntrinsic_DistortionModelArcTan;

typedef enum MFCameraIntrinsic_DistortionModelType {
	MFCameraIntrinsic_DistortionModelType_6KT = 0,
	MFCameraIntrinsic_DistortionModelType_ArcTan
} MFCameraIntrinsic_DistortionModelType;

typedef struct MFExtendedCameraIntrinsic_IntrinsicModel
{
	// Pixel size of the frame
	UINT32 Width;
	UINT32 Height;

	// Identifier for camera's that provide two or more frames as one combined frame
	// E.g., 360-cameras typically contains two physical camera sensors but provides single stream of samples where one sample contains
	// two frames, one from each sensor. This field is used to identify those individual frames starting from top-left with id 0.
	//
	// Example of 2x1 combined frames and their identification: [0][1]
	UINT32 SplitFrameId;

	// Pinhole camera model parameters
	MFCameraIntrinsic_CameraModel CameraModel;
} MFExtendedCameraIntrinsic_IntrinsicModel;

[
	odl,
	uuid(5C595E64-4630-4231-855A-12842F733245)
]
interface IMFExtendedCameraIntrinsicModel : stdole.IUnknown
{
	HRESULT GetModel(
		[out] MFExtendedCameraIntrinsic_IntrinsicModel* pIntrinsicModel
	);

	HRESULT SetModel(
		[in] MFExtendedCameraIntrinsic_IntrinsicModel* pIntrinsicModel
	);

	HRESULT GetDistortionModelType(
		[out] MFCameraIntrinsic_DistortionModelType* pDistortionModelType
	);
};

[
	odl,
	uuid(74C2653B-5F55-4EB1-9F0F-18B8F68B7D3D)
]
interface IMFExtendedCameraIntrinsicsDistortionModel6KT : stdole.IUnknown
{
	HRESULT GetDistortionModel(
		[out] MFCameraIntrinsic_DistortionModel6KT* pDistortionModel
	);

	HRESULT SetDistortionModel(
		[in] MFCameraIntrinsic_DistortionModel6KT* pDistortionModel
	);
};

[
	odl,
	uuid(812D5F95-B572-45DC-BAFC-AE24199DDDA8)
]
interface IMFExtendedCameraIntrinsicsDistortionModelArcTan : stdole.IUnknown
{
	HRESULT GetDistortionModel(
		[out] MFCameraIntrinsic_DistortionModelArcTan* pDistortionModel
	);

	HRESULT SetDistortionModel(
		[in] MFCameraIntrinsic_DistortionModelArcTan* pDistortionModel
	);
};

[
	odl,
	uuid(687F6DAC-6987-4750-A16A-734D1E7A10FE)
]
interface IMFExtendedCameraIntrinsics : stdole.IUnknown
{
	// Initialize from buffer will clear any existing models in underlying data store
	HRESULT InitializeFromBuffer(
		[in] BYTE* pbBuffer,
		[in] DWORD dwBufferSize
	);

	HRESULT GetBufferSize(
		[out] DWORD* pdwBufferSize
	);

	HRESULT SerializeToBuffer(
		[out] BYTE* pbBuffer,
		[in, out] DWORD* pdwBufferSize
	);

	HRESULT GetIntrinsicModelCount(
		[out] DWORD* pdwCount
	);

	HRESULT GetIntrinsicModelByIndex(
		[in] DWORD dwIndex,
		[out] IMFExtendedCameraIntrinsicModel** ppIntrinsicModel
	);

	HRESULT AddIntrinsicModel(
		[in] IMFExtendedCameraIntrinsicModel* pIntrinsicModel
	);

};

///////////////////////////////////////////////////////////////////////////////
//
// IMFExtendedCameraControl Interface
//
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(38E33520-FCA1-4845-A27A-68B7C6AB3789),
	helpstring("IMFExtendedCameraControl Interface")
]
/// <summary>
/// This interface is used to configure the camera's extended properties.
/// </summary>
interface IMFExtendedCameraControl : stdole.IUnknown
{
	/// <summary>
	/// Queries for property capabilities.
	/// </summary>
	/// <return>
	/// ULONGLONG mapping to property capabilities (KSCAMERA_EXTENDEDPROP_*) defined in ksmedia.h
	/// </return>
	ULONGLONG GetCapabilities();

	/// <summary>
	/// Sets the property flags.
	/// </summary>  
	/// <param name="ulFlags">
	/// ULONGLONG mapping to property flags (KSCAMERA_EXTENDEDPROP_*) defined in ksmedia.h
	/// </param>
	HRESULT SetFlags([in] ULONGLONG ulFlags);

	/// <summary>
	/// Queries for property flags.
	/// </summary>
	/// <return>
	/// ULONGLONG mapping to property flags (KSCAMERA_EXTENDEDPROP_*) defined in ksmedia.h
	/// </return>
	ULONGLONG GetFlags();

	/// <summary>
	/// Locks the internal payload buffer for query/changes.
	/// </summary>  
	/// <param name="ppPayload">
	/// BYTE pointer to the buffer containing the raw payload.
	/// Caller should not free the buffer but instead call UnlockPayload
	/// </param>
	/// <param name="pulPayload">
	/// Size of the payload.
	/// </param>
	HRESULT LockPayload([out] LongPtr* ppPayload, [out] ULONG* pulPayload);

	/// <summary>
	/// Unlocks the raw payload contained in this control.
	/// </summary>  
	HRESULT UnlockPayload();

	/// <summary>
	/// Commits the configured control settings to the camera driver.
	/// </summary>
	HRESULT CommitSettings();
};


///////////////////////////////////////////////////////////////////////////////
//
// IMFExtendedCameraController Interface
//
///////////////////////////////////////////////////////////////////////////////
[
	odl,
	uuid(B91EBFEE-CA03-4AF4-8A82-A31752F4A0FC),
	helpstring("IMFExtendedCameraController Interface")
]
/// <summary>
/// This interface is used to configure the camera's extended properties.
/// </summary>
interface IMFExtendedCameraController : stdole.IUnknown
{
	/// <summary>
	/// Allows an app to get the current camera's extended property controls
	/// </summary>
	/// <param name = "dwStreamIndex">
	/// Indicates stream index to use for this property.
	/// MF_CAPTURE_ENGINE_MEDIASOURCE indicates a filter level property.
	/// </param>
	/// <param name = "ulPropertyId">
	/// ID index for identifying the property within KSPROPERTYSETID_ExtendedCameraControl.
	/// </param>
	/// <param name = "ppControl">
	/// IMFExtendedCameraControl pointer, representing the control.
	/// </param>
	HRESULT GetExtendedCameraControl(
		[in] DWORD dwStreamIndex,
		[in] ULONG ulPropertyId,
		[out] IMFExtendedCameraControl** ppControl);
};


[
	odl,
	uuid(F25362EA-2C0E-447F-81E2-755914CDC0C3),
	helpstring("IMFRelativePanelReport Interface")
]
/// <summary>
/// This interface is used to retrieve the relative panel current value.
/// </summary>
interface IMFRelativePanelReport : stdole.IUnknown
{
	/// <summary>
	/// Allows an app to get the current relative panel value
	/// </summary>
	/// <param name = "panel"> 
	/// Indicates the panel associated with the camera's relative facing to the displayRegion, using a 
	/// value from the ACPI_PLD_PANEL enumeration. Only the enumeration values of AcpiPldPanelFront, 
	/// AcpiPldPanelBack, and AcpiPldPanelUnknown are expected. 
	/// </param>
	HRESULT GetRelativePanel(
		[out] ULONG* panel
	);
};

/// <summary>
/// This interface is used to control a IMFAsyncCallback, with an IMFAsyncResult to retrieve a report of its value.
/// </summary>
[
	odl,
	uuid(421AF7F6-573E-4AD0-8FDA-2E57CEDB18C6),
	helpstring("IMFRelativePanelWatcher Interface")
]
interface IMFRelativePanelWatcher : IMFShutdown
{
	HRESULT BeginGetReport([in] IMFAsyncCallback* pCallback, [in] IUnknown* pState);

	HRESULT EndGetReport([in] IMFAsyncResult* pResult, [out] IMFRelativePanelReport** ppRelativePanelReport);

	/// <summary>
	/// Allows an app to retrieve the report of the current relative panel value
	/// </summary>
	/// <param name = "ppRelativePanelReport">
	/// IMFRelativePanelReport pointer, representing the panel value.
	/// </param>
	HRESULT GetReport(
		[out] IMFRelativePanelReport** ppRelativePanelReport
	);
};


/// <summary>
/// The IMFVideoCaptureSampleAllocator interface is a specialized
/// sample allocator for video capture devices.
/// </summary>
[
	odl,
	uuid(725B77C7-CA9F-4FE5-9D72-9946BF9B3C70),
	helpstring("IMFVideoCaptureSampleAllocator Interface")
]
interface IMFVideoCaptureSampleAllocator : IMFVideoSampleAllocator
{
	/// <param name="cbSampleSize">
	/// Sample size in bytes.
	/// The actual sample size used by the allocator is the maximum of
	/// the size required by pMediaType and cbSampleSize.
	/// </param>
	/// <param name="cbCaptureMetadataSize">
	/// Capture metadata size in bytes. Applies only to callers that want to
	/// to include additional metadata with the captured frames. The metadata size
	/// should include the size of a KSCAMERA_METADATA_ITEMHEADER in addition to
	/// the size of the metadata payload itself.
	/// </param>
	/// <param name="cbAlignment">
	/// Buffer alignment size in bytes.
	/// The default and minimum alignment size is 4KB. Custom alignment sizes
	/// less than 4KB will be treated as 4KB.
	/// </param>
	/// <param name="cMinimumSamples">
	/// Minimum number of pre-allocated samples.
	/// This method will fail if the allocator cannot pre-allocate the specified
	/// minimum number of samples.
	/// </param>
	/// <param name="pAttributes">
	/// Optional parameter. An IMFAttributes store with additional configuration
	/// attributes for the sample allocator. The attributes that are accepted
	/// are the same as for IMFVideoSampleAllocatorEx::InitializeSampleAllocatorEx.
	/// (See online documentation for that API for more details.)
	/// </param>
	/// <param name="pMediaType">
	/// The IMFMediaType for which samples will be allocator. The sample
	/// allocator uses this parameter to calculate the minimum required size
	/// for the media samples.
	/// </param>
	HRESULT InitializeCaptureSampleAllocator(
		[in] DWORD cbSampleSize,
		[in] DWORD cbCaptureMetadataSize,
		[in] DWORD cbAlignment,
		[in] DWORD cMinimumSamples,
		[in] IMFAttributes* pAttributes,
		[in] IMFMediaType* pMediaType
	);
};

/// <summary>
///     The enumeration type defines video capture sample allocator mode
/// </summary>
typedef enum MFSampleAllocatorUsage
{
	MFSampleAllocatorUsage_UsesProvidedAllocator = 0,
	MFSampleAllocatorUsage_UsesCustomAllocator,
	MFSampleAllocatorUsage_DoesNotAllocate
} MFSampleAllocatorUsage;

/// <summary>
/// An enumeration that specifies how an object that implements
/// IMFSampleAllocatorControl uses a sample allocator.
/// </summary>
[
	odl,
	uuid(DA62B958-3A38-4A97-BD27-149C640C0771),
	helpstring("IMFSampleAllocatorControl Interface")
]
interface IMFSampleAllocatorControl : stdole.IUnknown
{
	/// <summary>
	/// Sets the default sample allocator to use for the specified output stream.
	/// When this allocator is in use, the sample allocator usage value is
	/// MFSampleAllocatorUsage_UsesProvidedAllocator.
	/// </summary>
	/// <param name="dwOutputStreamID">
	/// The ID of the output stream that the pAllocator parameter applies to.
	/// </param>
	/// <param name="pAllocator">
	/// Provides a sample allocator to use for the specified output stream. The
	/// allocator must support one of the MF allocator interfaces, such as,
	/// IMFVideoCaptureSampleAllocator or IMFVideoSampleAllocatorEx.
	/// </param>
	HRESULT SetDefaultAllocator(
		[in] DWORD dwOutputStreamID,
		[in] IUnknown* pAllocator
	);

	/// <summary>
	/// Retrieves the sample allocator usage for the specified output stream.
	/// </summary>
	/// <param name="dwOutputStreamID">
	/// The ID of the output stream whose sample allocator usage is requested.
	/// </param>
	/// <param name="pdwInputStreamID">
	/// If the allocator usage is MFSampleAllocatorUsage_DoesNotAllocate,
	/// then this output parameter is set to the ID of the input stream that
	/// the output samples are coming from.
	/// For all other allocator usage values, this parameter shall be ignored.
	/// </param>
	/// <param name="peUsage">
	/// The sample allocator usage of the specified output stream.
	/// </param>
	HRESULT GetAllocatorUsage(
		[in] DWORD dwOutputStreamID,
		[out] DWORD* pdwInputStreamID,
		[out] MFSampleAllocatorUsage* peUsage
	);
};

/// <summary>
/// This enum defines the possible occlusion states for a camera
/// </summary>
typedef enum MFCameraOcclusionState
{
	MFCameraOcclusionState_Open = 0x0,
	MFCameraOcclusionState_OccludedByLid = 0x1,
	MFCameraOcclusionState_OccludedByCameraHardware = 0x2,
} MFCameraOcclusionState;

/// <summary>
/// This interface is an input parameter for OnOcclusionStateReport callback function
/// adn is used to get the most recent camera occlusion state for the camera under monitoring.
/// </summary>
[
	odl,
	uuid(1640B2CF-74DA-4462-A43B-B76D3BDC1434),
	helpstring("IMFCameraOcclusionStateReport Interface")
]
interface IMFCameraOcclusionStateReport : stdole.IUnknown
{
	/// <summary>
	/// This function will get the most recent occlusion state for the camera that's being monitored.
	/// </summary>
	/// <param name = "occlusionState">
	/// Numeric value that represents one or more MFCameraOcclusionState values.
	/// </param>
	HRESULT GetOcclusionState(
		[out] DWORD* occlusionState
	);
};

/// <summary>
/// This callback interface is required to be implemented by the client that creates
/// an IMFCameraOcclusionStateMonitor object.
/// </summary>
[
	odl,
	uuid(6E5841C7-3889-4019-9035-783FB19B5948),
	helpstring("IMFCameraOcclusionStateReportCallback Interface")
]
interface IMFCameraOcclusionStateReportCallback : stdole.IUnknown
{
	/// <summary>
	/// This function will be called when the monitor detects that the occlusion state has changed.
	/// </summary>
	/// <param name = "occlusionStateReport">
	/// Pointer to the IMFCameraOcclusionStateReport interface that is used to get the most recent state.
	/// </param>
	HRESULT OnOcclusionStateReport(
		[in] IMFCameraOcclusionStateReport* occlusionStateReport
	);
};

/// <summary>
/// This interface represents the main camera occlusion state monitor object.
/// </summary>
[
	odl,
	uuid(CC692F46-C697-47E2-A72D-7B064617749B),
	helpstring("IMFCameraOcclusionStateMonitor Interface")
]
interface IMFCameraOcclusionStateMonitor : stdole.IUnknown
{
	/// <summary>
	/// This function will start the monitor and will immediately cause 
	/// OnOcclusionStateReport callback funtion to be called with the current state information.
	/// </summary>
	HRESULT Start(
	);

	/// <summary>
	/// This function will stop the monitor.
	/// </summary>
	HRESULT Stop(
	);

	/// <summary>
	/// This function will return supported camera occlusion states, the return value
	/// is combination MFCameraOcclusionState flags. MFCameraOcclusionState_Open is always supported.
	/// </summary>
	DWORD GetSupportedStates(
	);
}

/// <summary>
/// This interface represents the callback mechanism for the camera control monitor object. 
/// A client passes an implmented instance of this interface when creating a monitor
/// </summary>
[
	odl,
	uuid(E8F2540D-558A-4449-8B64-4863467A9FE8),
	helpstring("IMFCameraControlNotify Interface")
]
interface IMFCameraControlNotify : stdole.IUnknown
{
	/// <summary>
	/// This method represents the notification callback for changes to controls. 
	/// </summary>
	/// <param name = "controlSet">
	/// If provided controlSet GUID is MF_CAMERACONTROL_PROPSET_CUSTOM, then the callback was invoked by a 
	/// subscription for a change to a control outside the supported Property Sets
	/// </param>
	/// <param name = "id">
	/// This is the id of the control in its set.
	/// </param>
	void OnChange(
		[in] REFIID controlSet,
		[in] UINT32 id);

	/// <summary>
	/// This method notifies client if an unrecoverable error occurs within the monitor.
	/// After call returns to monitor, it will cleanup and remove reference to IMFCameraControlNotify
	/// There is not a need to call IMFCameraControlMonitor::Shutdown after receiving an OnError
	/// </summary>
	/// <param name = "hrStatus">
	/// The internal error code. 
	/// If E_OUTOFMEMORY, then there were not enough resources available for the monitor to function properly
	/// If MF_INVALID_STATE_ERR, then there has been some corruption of memory states.
	/// </param>
	void OnError(
		[in] HRESULT hrStatus);
}

/// <summary>
/// This interface represents the main camera control monitor object.
/// </summary>
[
	odl,
	uuid(4D46F2C9-28BA-4970-8C7B-1F0C9D80AF69),
	helpstring("IMFCameraControlMonitor Interface")
]
interface IMFCameraControlMonitor : stdole.IUnknown
{
	/// <summary>
	/// This function will start the monitor. The monitor will call OnChange on Subscriptions linked to changed controls
	/// If called when Monitor is already started or has shutdown, method will return error MF_E_INVALIDREQUEST
	/// </summary>
	HRESULT Start(
	);

	/// <summary>
	/// This function will stop the monitor. A client can stop the monitor to pause notifications.
	/// In Stopped state, client can Add/Remove Control Subscriptions.
	/// If called when Monitor is already stopped or has shutdown, method will return error MF_E_INVALIDREQUEST
	/// </summary>
	HRESULT Stop(
	);

	/// <summary>
	/// This function will add to the list of controls for which the client wants to be notified
	/// If the provided controlSet is MF_CAMERACONTROL_PROPSET_CUSTOM, then the monitor's callback will be called for the change of "Any Control"
	/// If called when Monitor is in Start or Shutdown state, method will return error MF_E_INVALIDREQUEST
	/// If controlSet is not MF_CAMERACONTROL_PROPSET_CUSTOM, PROPSETID_VIDCAP_VIDEOPROCAMP, PROPSETID_VIDCAP_CAMERACONTROL or
	/// KSPROPERTYSETID_ExtendedCameraControl then method will return with error E_INVALIDARG
	/// </summary>
	HRESULT AddControlSubscription(
		[in] long controlSet1, [in] long controlSet2, [in] long controlSet3, [in] long controlSet4,
		[in] UINT32 id
	);

	/// <summary>
	/// This function will remove the subscription for this control from the monitor
	/// If the provided controlSet is MF_CAMERACONTROL_PROPSET_CUSTOM, then the subscription for "Any Control" change will be removed
	/// If called when Monitor is in Start or Shutdown state, method will return with error MF_E_INVALIDREQUEST
	/// If provided control description does not match a current subscription, method will return with error MF_E_NOT_FOUND
	/// </summary>
	HRESULT RemoveControlSubscription(
		[in] long controlSet1, [in] long controlSet2, [in] long controlSet3, [in] long controlSet4,
		[in] UINT32 id
	);

	/// This function will cleanup and shutdown the monitor.
	/// It is acceptable to call Shutdown even if monitor is not in stop state 
	/// After Shutdown, a client cannot call on the Monitor to Add/Remove Control Subscriptions or Start/Stop notifications    
	/// </summary>
	void Shutdown();
}



typedef enum MF_CAMERA_CONTROL_CONFIGURATION_TYPE
{
	MF_CAMERA_CONTROL_CONFIGURATION_TYPE_PRESTART = 0,
	MF_CAMERA_CONTROL_CONFIGURATION_TYPE_POSTSTART,
} MF_CAMERA_CONTROL_CONFIGURATION_TYPE;

typedef struct MF_CAMERA_CONTROL_RANGE_INFO
{
	LONG    minValue;
	LONG    maxValue;
	LONG    stepValue;
	LONG    defaultValue;
} MF_CAMERA_CONTROL_RANGE_INFO;

[
	odl,
	uuid(75510662-B034-48F4-88A7-8DE61DAA4AF9),
	helpstring("IMFCameraControlDefaults Interface")
]
interface IMFCameraControlDefaults : stdole.IUnknown
{
	/// <summary>
	/// Gets the configuration type (pre-start or post-start).  Some 
	/// camera level controls can only be set after the camera has
	/// started (such as focus/brightness/whitebalance) since the 
	/// controls require frame data for the parameters to converge. 
	/// While still other types of controls can only be configured 
	/// when the camera is not in a running state (such as HDR 
	/// support) since it requires a re-programming of the camera 
	/// mode.
	/// 
	/// Whether a well known control is pre or post start is 
	/// specified in the DDI specification of the control. 
	/// (NOTE:  If the DDI specification does not explicitly 
	/// indicate the control is a pre-start control, caller must 
	/// assume the control is post-start).  
	/// </summary>
	MF_CAMERA_CONTROL_CONFIGURATION_TYPE GetType(
	);

	/// <summary>
	/// The legacy PROPSETID_VIDCAP_VIDEOPROCAMP and 
	/// PROPSETID_VIDCAP_CAMERACONTROL control sets provide a 
	/// min/max/step/default value which bounds the acceptable range 
	/// of values that can be configured. 
	///  
	/// For other controls, the caller is responsible for knowing 
	/// whether the underlying control supports the basic range 
	/// information.  Calling into this method for a control that 
	/// does not support basic range will return MF_E_NOT_FOUND. 
	/// </summary>
	HRESULT GetRangeInfo(
		[out] MF_CAMERA_CONTROL_RANGE_INFO* rangeInfo
	);

	/// <summary>
	/// Because the camera control schema and optional data payload 
	/// schema can be arbitrary (the only constraint is that all 
	/// control schema must have KSPROPERTY as the first structure 
	/// in the binary format), this method provides the caller a way 
	/// to modify the contents of the control and data payload 
	/// directly. 
	///  
	/// UnlockControlData must be called before the collection this 
	/// control is contained in is sent to 
	/// IMFCameraConfigurationManager::SaveDefaults() method. 
	/// </summary>
	HRESULT LockControlData(
		[out] LPVOID control,
		[out] ULONG* controlSize,
		[out] LPVOID data,
		[out] ULONG* dataSize
	);

	/// <summary>
	/// Once UnlockControlData is called, the caller must not attempt to 
	/// modify the buffer pointer returned from LockControlData.  Doing 
	/// so will result in undefined behavior. 
	/// </summary>
	HRESULT UnlockControlData(
	);
};

[
	odl,
	uuid(92D43D0F-54A8-4BAE-96DA-356D259A5C26),
	helpstring("IMFCameraControlDefaultsCollection Interface")
]
interface IMFCameraControlDefaultsCollection : IMFAttributes
{
	/// <summary>
	/// Return the number of controls currently in the collection.
	/// </summary>
	ULONG   GetControlCount(
	);

	/// <summary>
	/// Return the control based on the 0 based index provided.  The
	/// index provided must be -1 of the control count. 
	/// </summary>
	HRESULT GetControl(
		[in] ULONG index,
		[out] IMFCameraControlDefaults** configuration
	);

	/// <summary>
	/// Add a new extended camera control to the collection.  The 
	/// controlId provided must be an id in the 
	/// KSPROPERTYSETID_ExtendedCameraControl property set. 
	///  
	/// The streamId is only used when the underlying camera control 
	/// is a pin level control, otherwise this value is ignored. 
	///  
	/// Depending on the control, the data payload size/schema may 
	/// vary.  The dataSize must be valid for the control payload 
	/// schema so the control can reserve the buffer required. 
	/// </summary>
	HRESULT GetOrAddExtendedControl(
		[in] MF_CAMERA_CONTROL_CONFIGURATION_TYPE configType,
		[in] ULONG constrolId,
		[in] DWORD streamId,
		[in] ULONG dataSize,
		[out] IMFCameraControlDefaults** defaults
	);

	/// <summary>
	/// For custom controls, controlSet/controlId are based on the 
	/// custom control DDI published by the camera driver vendor. 
	/// Similarly, the controlSize and dataSize are based on the DDI 
	/// published by the vendor. 
	///  
	/// NOTE:  controlSize must be >= sizeof(KSPROPERTY) even for 
	/// custom controls. 
	/// </summary>
	HRESULT GetOrAddControl(
		[in] MF_CAMERA_CONTROL_CONFIGURATION_TYPE configType,
		[in] REFGUID controlSet,
		[in] ULONG constrolId,
		[in] ULONG controlSize,
		[in] ULONG dataSize,
		[out] IMFCameraControlDefaults** defaults
	);

	/// <summary>
	/// Removes a control based on the set/id.
	/// </summary>
	HRESULT RemoveControl(
		[in] REFGUID controlSet,
		[in] ULONG constrolId
	);

	/// <summary>
	/// Removes all controls in the collection. 
	/// </summary>
	HRESULT RemoveAllControls();
};


[
	odl,
	uuid(A624F617-4704-4206-8A6D-EBDA4A093985),
	helpstring("IMFCameraConfigurationManager Interface")
]
interface IMFCameraConfigurationManager : stdole.IUnknown
{
	/// Loads the camera control defaults as specified by the 
	/// MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK in 
	/// the cameraAttributes parameter. 
	/// If there are no default controls specified, the resulting 
	/// collection will be empty (GetControlCount returns 0) 
	///  
	/// NOTE: If the
	/// MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK is 
	/// not set, this method will return MF_E_ATTRIBUTENOTFOUND. 
	HRESULT LoadDefaults(
		[in] IMFAttributes* cameraAttributes,
		[out] IMFCameraControlDefaultsCollection** configurations
	);

	/// Save the collection of camera control defaults.  The 
	/// information will be stored on the camera defined by the 
	/// MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK when 
	/// the collection was loaded.  Saving an empty collection will 
	/// result in all the existing control defaults being cleared. 
	HRESULT SaveDefaults(
		[in] IMFCameraControlDefaultsCollection* configurations
	);

	/// Shutdown the configuration manager.  Subsequent calls to 
	/// LoadDefaults/SaveDefaults after the 
	/// IMFCameraConfigurationManager is shutdown will result in 
	/// MF_E_SHUTDOWN error. 
	void Shutdown(
	);
};


typedef
enum MFASF_SPLITTERFLAGS
{
	MFASF_SPLITTER_REVERSE = 0x1,
	MFASF_SPLITTER_WMDRM = 0x2
} 	MFASF_SPLITTERFLAGS;

typedef
enum ASF_STATUSFLAGS
{
	ASF_STATUSFLAGS_INCOMPLETE = 0x1,
	ASF_STATUSFLAGS_NONFATAL_ERROR = 0x2
} 	ASF_STATUSFLAGS;


typedef
enum MFASF_MULTIPLEXERFLAGS
{
	MFASF_MULTIPLEXER_AUTOADJUST_BITRATE = 0x1
} 	MFASF_MULTIPLEXERFLAGS;

typedef struct ASF_MUX_STATISTICS
{
	DWORD cFramesWritten;
	DWORD cFramesDropped;
} 	ASF_MUX_STATISTICS;


typedef
enum MFASF_STREAMSELECTORFLAGS
{
	MFASF_STREAMSELECTOR_DISABLE_THINNING = 0x1,
	MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE = 0x2
} 	MFASF_STREAMSELECTOR_FLAGS;

typedef
enum ASF_SELECTION_STATUS
{
	ASF_STATUS_NOTSELECTED = 0,
	ASF_STATUS_CLEANPOINTSONLY = 1,
	ASF_STATUS_ALLDATAUNITS = 2
} 	ASF_SELECTION_STATUS;


typedef
enum _MFSINK_WMDRMACTION
{
	MFSINK_WMDRMACTION_UNDEFINED = 0,
	MFSINK_WMDRMACTION_ENCODE = 1,
	MFSINK_WMDRMACTION_TRANSCODE = 2,
	MFSINK_WMDRMACTION_TRANSCRYPT = 3,
	MFSINK_WMDRMACTION_LAST = 3
} 	MFSINK_WMDRMACTION;


//
// ASF Indexer flags
//
typedef enum MFASF_INDEXERFLAGS
{
	MFASF_INDEXER_WRITE_NEW_INDEX = 0x00000001,
	MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK = 0x00000002,
	MFASF_INDEXER_WRITE_FOR_LIVEREAD = 0x00000004,

} MFASF_INDEXER_FLAGS;

//
// Index identifier structure
//
typedef struct ASF_INDEX_IDENTIFIER
{
	//
	// Use the MFASFINDEXER_TYPE values defined below
	//  GUID_NULL: Time indexing
	//  other GUIDs: Other types of indexing not supported yet
	//
	GUID guidIndexType;

	WORD wStreamNumber;

}   ASF_INDEX_IDENTIFIER;

//
// This structure is used for describing the details of indexing corresponding
// to a specific ASF_INDEX_IDENTIFIER
//
typedef struct ASF_INDEX_DESCRIPTOR
{
	//
	// Index identifier for this index
	//
	ASF_INDEX_IDENTIFIER    Identifier;

	//
	// Number of bytes per index entry for this index.
	// MFASFINDEXER_PER_ENTRY_BYTES_DYNAMIC indicates that this number can vary.
	//
	WORD                    cPerEntryBytes;

	//
	// Optional text descriptiong of the index
	//
	WCHAR                   szDescription[32];

	//
	// Indexing interval.  The units of this value depend on the index type.
	// A value of MFASFINDEXER_NO_FIXED_INTERVAL indicates that there is
	// no fixed indexing interval.
	//
	DWORD                   dwInterval;

}   ASF_INDEX_DESCRIPTOR;


interface IMFASFProfile;

[
	odl,
		uuid(B1DCA5CD-D5DA-4451-8E9E-DB5C59914EAD) 
]
interface IMFASFContentInfo : stdole.IUnknown
{
	//
	//  Methods for Parsing & Creating Headers
	//
	HRESULT GetHeaderSize(
		[in]      IMFMediaBuffer* pIStartOfContent,
		[out]     QWORD* cbHeaderSize);

	HRESULT ParseHeader(
		[in]      IMFMediaBuffer* pIHeaderBuffer,
		[in]      QWORD           cbOffsetWithinHeader);

	HRESULT GenerateHeader(
		[in, out] IMFMediaBuffer* pIHeader,
		[out]     DWORD* pcbHeader);

	//
	//  Methods for working with ASF profiles
	//
	HRESULT GetProfile(
		[out]     IMFASFProfile** ppIProfile);

	HRESULT SetProfile(
		[in]      IMFASFProfile* pIProfile);


	//
	//  Methods for use when reading existing content
	//  Generates an IMFPresentationDescriptor describing the content
	// 
	HRESULT GeneratePresentationDescriptor(
		[out]     IMFPresentationDescriptor** ppIPresentationDescriptor);

	//
	//  Methods for configuring encoding
	//  Setting wStreamNumber to 0 retrieves the IPropertyStore for file-wide
	//  encoding settings
	//
	HRESULT GetEncodingConfigurationPropertyStore(
		[in]      WORD           wStreamNumber,
		[out]     IPropertyStore** ppIStore);
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

interface IMFASFStreamConfig;
interface IMFASFMutualExclusion;
interface IMFASFStreamPrioritization;

[
	odl,
		uuid(D267BF6A-028B-4e0d-903D-43F0EF82D0D4) 
]
interface IMFASFProfile : IMFAttributes
{
	HRESULT GetStreamCount(
		[out] DWORD* pcStreams);

	HRESULT GetStream(
		[in]  DWORD                    dwStreamIndex,
		[out] WORD* pwStreamNumber,
		[out] IMFASFStreamConfig** ppIStream);

	HRESULT GetStreamByNumber(
		[in]  WORD                     wStreamNumber,
		[out] IMFASFStreamConfig** ppIStream);

	HRESULT SetStream(
		[in]  IMFASFStreamConfig* pIStream);

	HRESULT RemoveStream(
		[in]  WORD                     wStreamNumber);

	HRESULT CreateStream(
		[in]  IMFMediaType* pIMediaType,
		[out] IMFASFStreamConfig** ppIStream);



	HRESULT GetMutualExclusionCount(
		[out] DWORD* pcMutexs);

	HRESULT GetMutualExclusion(
		[in]  DWORD                    dwMutexIndex,
		[out] IMFASFMutualExclusion** ppIMutex);

	HRESULT AddMutualExclusion(
		[in]  IMFASFMutualExclusion* pIMutex);

	HRESULT RemoveMutualExclusion(
		[in]  DWORD                    dwMutexIndex);

	HRESULT CreateMutualExclusion(
		[out] IMFASFMutualExclusion** ppIMutex);


	HRESULT GetStreamPrioritization(
		[out] IMFASFStreamPrioritization** ppIStreamPrioritization);

	HRESULT AddStreamPrioritization(
		[in]  IMFASFStreamPrioritization* pIStreamPrioritization);

	HRESULT RemoveStreamPrioritization();

	HRESULT CreateStreamPrioritization(
		[out] IMFASFStreamPrioritization** ppIStreamPrioritization);


	HRESULT Clone(
		[out] IMFASFProfile** ppIProfile);
};

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

[
	odl,
		uuid(9E8AE8D2-DBBD-4200-9ACA-06E6DF484913) 
]
//
// The ASF Stream Config object will also QI for IPropertyStore.
// This Property Store is for use when encoding and is for write-only
// properties intended for the ASF Stream Sink's Property Store.
// Most of these are configuration properties intended for the encoder
// MF Transform; see wmcodecdsp.idl for the property definitions.
// Once the ASF Media Sink has been created, these properties should be set
// on the ASF Stream Sink object's IProperty Store interface instead;
// setting them here will have no effect.
//
interface IMFASFStreamConfig : IMFAttributes
{
	HRESULT GetStreamType(
		[out] GUID* pguidStreamType);

	WORD GetStreamNumber();

	HRESULT SetStreamNumber(
		[in]  WORD                wStreamNum);

	HRESULT GetMediaType(
		[out] IMFMediaType** ppIMediaType);

	HRESULT SetMediaType(
		[in]  IMFMediaType* pIMediaType);


	HRESULT GetPayloadExtensionCount(
		[out] WORD* pcPayloadExtensions);

	HRESULT GetPayloadExtension(
		[in]  WORD               wPayloadExtensionNumber,
		[out] GUID* pguidExtensionSystemID,
		[out] WORD* pcbExtensionDataSize,
		[out] void* pbExtensionSystemInfo,
		[in, out, defaultvalue(0)] DWORD* pcbExtensionSystemInfo);

	HRESULT AddPayloadExtension(
		//[in]  GUID               guidExtensionSystemID,
		[in] long guidExtensionSystemID1, [in] long guidExtensionSystemID2, [in] long guidExtensionSystemID3, [in] long guidExtensionSystemID4,
		[in]  WORD               cbExtensionDataSize,
		[in] void* pbExtensionSystemInfo,
		[in]  DWORD              cbExtensionSystemInfo);

	HRESULT RemoveAllPayloadExtensions();



	HRESULT Clone(
		[out] IMFASFStreamConfig** ppIStreamConfig);
};

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

[
	odl,
		uuid(12558291-E399-11D5-BC2A-00B0D0F3F4AB) 
]
interface IMFASFMutualExclusion : stdole.IUnknown
{
	HRESULT GetType(
		[out]    GUID* pguidType);
	HRESULT SetType(
		[in]     REFGUID         guidType);

	HRESULT GetRecordCount(
		[out]    DWORD* pdwRecordCount);

	HRESULT GetStreamsForRecord(
		[in]     DWORD           dwRecordNumber,
		[out]    WORD* pwStreamNumArray,
		[in, out] DWORD* pcStreams);

	HRESULT AddStreamForRecord(
		[in]     DWORD           dwRecordNumber,
		[in]     WORD            wStreamNumber);

	HRESULT RemoveStreamFromRecord(
		[in]     DWORD           dwRecordNumber,
		[in]     WORD            wStreamNumber);

	HRESULT RemoveRecord(
		[in]     DWORD           dwRecordNumber);

	HRESULT AddRecord(
		[out]    DWORD* pdwRecordNumber);



	HRESULT Clone(
		[out] IMFASFMutualExclusion** ppIMutex);
};


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

[
	odl,
		uuid(699bdc27-bbaf-49ff-8e38-9c39c9b5e088) 
]
interface IMFASFStreamPrioritization : stdole.IUnknown
{
	HRESULT GetStreamCount(
		[out]    DWORD* pdwStreamCount);

	HRESULT GetStream(
		[in]     DWORD           dwStreamIndex,
		[out]    WORD* pwStreamNumber,
		[out]    WORD* pwStreamFlags);

	HRESULT AddStream(
		[in]     WORD            wStreamNumber,
		[in]     WORD            wStreamFlags);

	HRESULT RemoveStream(
		[in]     DWORD           dwStreamIndex);


	HRESULT Clone(
		[out] IMFASFStreamPrioritization** ppIStreamPrioritization);
};

//////////////////////////////////////////////////////////////////////////////
//
// ASF indexing/seeking
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



[
	odl,
		uuid(53590F48-DC3B-4297-813F-787761AD7B3E) 
]
interface IMFASFIndexer : stdole.IUnknown
{
	HRESULT SetFlags(
		[in]    DWORD               dwFlags);
	HRESULT GetFlags(
		[out]   DWORD* pdwFlags);

	HRESULT Initialize(
		[in]      IMFASFContentInfo* pIContentInfo);

	HRESULT GetIndexPosition(
		[in]      IMFASFContentInfo* pIContentInfo,
		[out]     QWORD* pcbIndexOffset);

	HRESULT SetIndexByteStreams(
		[in]      IMFByteStream** ppIByteStreams,
		[in]      DWORD              cByteStreams);

	HRESULT GetIndexByteStreamCount(
		[out]       DWORD* pcByteStreams);

	//
	// For GetIndexStatus and SetIndexStatus:
	// pbIndexDescriptor will begin with the ASF_INDEX_DESCRIPTOR structure
	// and may have index-specific data following.
	//
	HRESULT GetIndexStatus(
		[in]      ASF_INDEX_IDENTIFIER* pIndexIdentifier,
		[out]     BOOL* pfIsIndexed,
		[out]     BYTE* pbIndexDescriptor,
		[in, out]  DWORD* pcbIndexDescriptor);

	HRESULT SetIndexStatus(
		[in]      BYTE* pbIndexDescriptor,
		[in]      DWORD           cbIndexDescriptor,
		[in]      BOOL            fGenerateIndex);


	//
	// GetSeekPositionForValue is the method used when seeking according to
	// this index.
	// Input parameters are pvarValue and pIndexIdentifier, which define,
	// respectively, where to seek to and using which stream / index type.
	// The main output parameter is pcbOffsetWithinData, which gives the 
	// offset within the data segment of the ASF Data Object (i.e. from the
	// beginning of packet 0) of the packet from which the caller should start
	// reading.
	// Optional output parameters are as follows:
	//      phnsApproxTime - Specifies an approximate timestamp around where
	//                       this stream will actually begin if the caller
	//                       starts reading from *pcbOffsetWithinData.
	//                       The accuracy of this value is the index interval
	//                       of the index (usually 1sec).
	//                       Example: Caller seeks to t=27sec.
	//                                Nearest previous key frame is at 
	//                                t=25.8sec.
	//                                *phnsApproxTime will be set to 25sec.
	//                       This parameter can be set to a non-NULL value
	//                       only when the guidIndexType field of 
	//                       pIndexIdentifier is GUID_NULL.  Otherwise, an
	//                       error will be returned.
	//                       If this information cannot be determined,
	//                       then this value will be set to 
	//                       MFASFINDEXER_APPROX_SEEK_TIME_UNKNOWN upon return.
	//      pdwPayloadNumberOfStreamWithinPacket - Specifies which payload
	//                                             in the packet at
	//                                             *pcbOffsetWithinData 
	//                                             the indexer is referring to
	HRESULT GetSeekPositionForValue(
		[in]     VARIANT* pvarValue,
		[in]      ASF_INDEX_IDENTIFIER* pIndexIdentifier,
		[out]     QWORD* pcbOffsetWithinData,
		[out, defaultvalue(0)]  MFTIME* phnsApproxTime,
		[out, defaultvalue(0)]  DWORD* pdwPayloadNumberOfStreamWithinPacket);

	//
	// The following methods are useful when generating an index
	//
	HRESULT GenerateIndexEntries(
		[in]      IMFSample* pIASFPacketSample);

	HRESULT CommitIndex(
		[in]      IMFASFContentInfo* pIContentInfo);

	HRESULT GetIndexWriteSpace(
		[out]     QWORD* pcbIndexWriteSpace);

	HRESULT GetCompletedIndex(
		[in]      IMFMediaBuffer* pIIndexBuffer,
		[in]      QWORD           cbOffsetWithinIndex);

};


[
	odl,
		uuid(12558295-E399-11D5-BC2A-00B0D0F3F4AB) 
]
interface IMFASFSplitter : stdole.IUnknown
{

	HRESULT Initialize(
		[in]      IMFASFContentInfo* pIContentInfo);

	HRESULT SetFlags(
		[in]      DWORD               dwFlags);

	HRESULT GetFlags(
		[out]     DWORD* pdwFlags);

	HRESULT SelectStreams(
		[in]      WORD* pwStreamNumbers,
		[in]      WORD                 wNumStreams);

	HRESULT GetSelectedStreams(
		[out]     WORD* pwStreamNumbers,
		[in, out] WORD* pwNumStreams);

	HRESULT ParseData(
		[in]      IMFMediaBuffer* pIBuffer,
		[in]      DWORD                cbBufferOffset,
		[in]      DWORD                cbLength);

	//
	// pdwStatusFlags should be a combination of ASF_STATUSFLAGS
	//
	HRESULT GetNextSample(
		[out]     DWORD* pdwStatusFlags,
		[out]     WORD* pwStreamNumber,
		[out]     IMFSample** ppISample);

	HRESULT Flush();

	HRESULT GetLastSendTime(
		[out]     DWORD* pdwLastSendTime);

};

[
	odl,
		uuid(57BDD80A-9B38-4838-B737-C58F670D7D4F) 
]
interface IMFASFMultiplexer : stdole.IUnknown
{
	HRESULT Initialize(
		[in]      IMFASFContentInfo* pIContentInfo);

	HRESULT SetFlags(
		[in]      DWORD               dwFlags);

	HRESULT GetFlags(
		[out]     DWORD* pdwFlags);

	HRESULT ProcessSample(
		[in]      WORD                 wStreamNumber,
		[in]      IMFSample* pISample,
		[in]      LONGLONG             hnsTimestampAdjust);

	HRESULT GetNextPacket(
		[out]     DWORD* pdwStatusFlags,
		[out]     IMFSample** ppIPacket);

	HRESULT Flush();

	HRESULT End(
		[in, out]  IMFASFContentInfo* pIContentInfo);

	HRESULT GetStatistics(
		[in]      WORD                 wStreamNumber,
		[out]     ASF_MUX_STATISTICS* pMuxStats);

	HRESULT SetSyncTolerance(
		[in]      DWORD                msSyncTolerance);
};

[
	odl,
		uuid(d01bad4a-4fa0-4a60-9349-c27e62da9d41) 
]
interface IMFASFStreamSelector : stdole.IUnknown
{
	HRESULT GetStreamCount([out] DWORD* pcStreams);
	HRESULT GetOutputCount([out] DWORD* pcOutputs);
	HRESULT GetOutputStreamCount([in] DWORD dwOutputNum,
		[out] DWORD* pcStreams);
	HRESULT GetOutputStreamNumbers([in] DWORD dwOutputNum,
		[out] WORD* rgwStreamNumbers);
	HRESULT GetOutputFromStream([in] WORD wStreamNum,
		[out] DWORD* pdwOutput);
	HRESULT GetOutputOverride([in] DWORD dwOutputNum,
		[out] ASF_SELECTION_STATUS* pSelection);
	HRESULT SetOutputOverride([in] DWORD dwOutputNum,
		[in] ASF_SELECTION_STATUS Selection);

	HRESULT GetOutputMutexCount([in] DWORD dwOutputNum,
		[out] DWORD* pcMutexes);
	HRESULT GetOutputMutex([in] DWORD dwOutputNum,
		[in] DWORD dwMutexNum,
		[out] IUnknown** ppMutex);
	HRESULT SetOutputMutexSelection([in] DWORD dwOutputNum,
		[in] DWORD dwMutexNum,
		[in] WORD wSelectedRecord);

	HRESULT GetBandwidthStepCount([out] DWORD* pcStepCount);
	HRESULT GetBandwidthStep([in] DWORD dwStepNum,
		[out] DWORD* pdwBitrate,
		[out] WORD* rgwStreamNumbers,
		[out] ASF_SELECTION_STATUS* rgSelections);
	HRESULT BitrateToStepNumber([in] DWORD dwBitrate,
		[out] DWORD* pdwStepNum);

	//
	// The parameter dwStreamSelectorFlags is a combination of MFASF_STREAMSELECTOR_FLAGS
	//
	HRESULT SetStreamSelectorFlags([in] DWORD dwStreamSelectorFlags);
};

[
	odl,
		uuid(3D1FF0EA-679A-4190-8D46-7FA69E8C7E15)
]
interface IMFDRMNetHelper : stdole.IUnknown
{
	HRESULT ProcessLicenseRequest(
		[in] void* pLicenseRequest,
		[in] DWORD cbLicenseRequest,
		[out] LongPtr* ppLicenseResponse,
		[out] DWORD* pcbLicenseResponse,
		[out] BSTR* pbstrKID
	);

	HRESULT GetChainedLicenseResponse(
		[out] LongPtr* ppLicenseResponse,
		[out] DWORD* pcbLicenseResponse
	);
};





[
	dllname("mf.dll")
]
module MFDLL
{

const int MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS_CROSSPROCESS = 1;
const int MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS_NOPERSIST = 1;
const int MF_USER_MODE_COMPONENT_LOAD       = 0x00000001;
const int MF_KERNEL_MODE_COMPONENT_LOAD     = 0x00000002;
const int MF_GRL_LOAD_FAILED                = 0x00000010;
const int MF_INVALID_GRL_SIGNATURE          = 0x00000020;
const int MF_GRL_ABSENT                     = 0x00001000;
const int MF_COMPONENT_REVOKED              = 0x00002000;
const int MF_COMPONENT_INVALID_EKU          = 0x00004000;
const int MF_COMPONENT_CERT_REVOKED         = 0x00008000;
const int MF_COMPONENT_INVALID_ROOT         = 0x00010000;
const int MF_COMPONENT_HS_CERT_REVOKED      = 0x00020000;
const int MF_COMPONENT_LS_CERT_REVOKED      = 0x00040000;
const int MF_BOOT_DRIVER_VERIFICATION_FAILED = 0x00100000;
const int MF_TEST_SIGNED_COMPONENT_LOADING  = 0x01000000;
const int MF_MINCRYPT_FAILURE               = 0x10000000;

const DWORD MFSEQUENCER_INVALID_ELEMENT_ID = 0xffffffff;

const int MFASF_MIN_HEADER_BYTES = 24; // (sizeof(GUID) + sizeof(QWORD));
const int  MFASF_MAX_STREAM_NUMBER   =    127;
const int  MFASF_INVALID_STREAM_NUMBER = 128; //MFASF_MAX_STREAM_NUMBER + 1)
const int  MFASF_PAYLOADEXTENSION_MAX_SIZE = 0xff;
const int  MFASF_PAYLOADEXTENSION_VARIABLE_SIZE = 0xffff;
const int  MFASF_DEFAULT_BUFFER_WINDOW_MS = 3000;




[entry("MFCreateASFContentInfo")]
long MFCreateASFContentInfo( 
	[out]     IMFASFContentInfo     **ppIContentInfo); 


[entry("MFCreateASFIndexer")]
long MFCreateASFIndexer(
	[out]     IMFASFIndexer** ppIIndexer);
[entry("MFCreateASFIndexerByteStream")]
long MFCreateASFIndexerByteStream(
	[in]      IMFByteStream* pIContentByteStream,
	[in]      QWORD                  cbIndexStartOffset,
	[out]     IMFByteStream** pIIndexByteStream);

[entry("MFCreateASFSplitter")]
long MFCreateASFSplitter(
	[out]     IMFASFSplitter** ppISplitter);

 
[entry("MFCreateASFProfile")]
long MFCreateASFProfile(
	[out]     IMFASFProfile** ppIProfile);
[entry("MFCreateASFProfileFromPresentationDescriptor")]
long MFCreateASFProfileFromPresentationDescriptor(
	[in]     IMFPresentationDescriptor* pIPD,
	[out]     IMFASFProfile** ppIProfile);
[entry("MFCreatePresentationDescriptorFromASFProfile")]
long MFCreatePresentationDescriptorFromASFProfile(
	[in]     IMFASFProfile* pIProfile,
	[out]     IMFPresentationDescriptor** ppIPD);

[entry("MFCreateASFMultiplexer")]
long MFCreateASFMultiplexer(
	[out]     IMFASFMultiplexer** ppIMultiplexer);

[entry("MFCreateASFStreamSelector")]
long MFCreateASFStreamSelector(
	[in] IMFASFProfile* pIASFProfile,
	[out] IMFASFStreamSelector** ppSelector);
[entry("MFCreateASFMediaSink")]
long MFCreateASFMediaSink(
	[in] IMFByteStream* pIByteStream,
	[out] IMFMediaSink** ppIMediaSink
);
[entry("MFCreateASFMediaSinkActivate")]
long MFCreateASFMediaSinkActivate(
	[in] LPCWSTR pwszFileName,
	[in] IMFASFContentInfo* pContentInfo,
	[out] IMFActivate** ppIActivate
);
[entry("MFCreateWMVEncoderActivate")]
long MFCreateWMVEncoderActivate(
	[in] IMFMediaType* pMediaType,
	[in] IPropertyStore* pEncodingConfigurationProperties,
	[out] IMFActivate** ppActivate
);
[entry("MFCreateWMAEncoderActivate")]
long MFCreateWMAEncoderActivate(
	[in] IMFMediaType* pMediaType,
	[in] IPropertyStore* pEncodingConfigurationProperties,
	[out] IMFActivate** ppActivate
);
[entry("MFCreateASFStreamingMediaSink")]
long MFCreateASFStreamingMediaSink(
	[in] IMFByteStream* pIByteStream,
	[out] IMFMediaSink** ppIMediaSink
);
[entry("MFCreateASFStreamingMediaSinkActivate")]
long MFCreateASFStreamingMediaSinkActivate(
	[in] IMFActivate* pByteStreamActivate,
	[in] IMFASFContentInfo* pContentInfo,
	[out] IMFActivate** ppIActivate
);



[entry("MFCreateMediaSession")]
long MFCreateMediaSession([in] IMFAttributes* pConfiguration,[out] IMFMediaSession** ppMediaSession);

[entry("MFCreatePMPMediaSession")]
long MFCreatePMPMediaSession([in] DWORD dwCreationFlags, [in] IMFAttributes* pConfiguration, [out] IMFMediaSession** ppMediaSession, [out] IMFActivate** ppEnablerActivate);

[entry("MFGetSupportedSchemes")]
long MFGetSupportedSchemes([out] VARIANT* pPropVarSchemeArray);

[entry("MFGetSupportedMimeTypes")]
long MFGetSupportedMimeTypes([out] VARIANT* pPropVarMimeTypeArray);

[entry("MFCreateTopologyNode")]
long MFCreateTopologyNode([in] MF_TOPOLOGY_TYPE NodeType, [out] IMFTopologyNode** ppNode);

[entry("MFGetTopoNodeCurrentType")]
long MFGetTopoNodeCurrentType([in] IMFTopologyNode* pNode, [in] DWORD dwStreamIndex, [in] BOOL fOutput, [out] IMFMediaType** ppType);

[entry("MFGetService")]
long MFGetService([in] stdole.IUnknown* punkObject, [in] REFGUID guidService, [in] REFIID riid, [out] LPVOID ppvObject);

[entry("MFCreatePresentationClock")]
long MFCreatePresentationClock([out] IMFPresentationClock** ppPresentationClock);

[entry("MFRequireProtectedEnvironment")]
long MFRequireProtectedEnvironment([in]  IMFPresentationDescriptor* pPresentationDescriptor);

[entry("MFCreateSimpleTypeHandler")]
long MFCreateSimpleTypeHandler([out] IMFMediaTypeHandler** ppHandler);

[entry("MFShutdownObject")]
long MFShutdownObject([in] stdole.IUnknown *pUnk);

[entry("MFCreateAudioRenderer")]
long MFCreateAudioRenderer([in] IMFAttributes* pAudioAttributes, [out] IMFMediaSink** ppSink);

[entry("MFCreateAudioRendererActivate")]
long MFCreateAudioRendererActivate([out] IMFActivate** ppActivate);

[entry("MFCreateVideoRendererActivate")]
long MFCreateVideoRendererActivate([in] HWND hwndVideo, [out] IMFActivate** ppActivate);

[entry("MFCreateMPEG4MediaSink")]
long MFCreateMPEG4MediaSink([in] IMFByteStream* pIByteStream, [in] IMFMediaType* pVideoMediaType, [in] IMFMediaType* pAudioMediaType, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreate3GPMediaSink")]
long MFCreate3GPMediaSink([in] IMFByteStream* pIByteStream, [in] IMFMediaType* pVideoMediaType, [in] IMFMediaType* pAudioMediaType, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreateMP3MediaSink")]
long MFCreateMP3MediaSink([in] IMFByteStream* pTargetByteStream, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreateAC3MediaSink")]
long MFCreateAC3MediaSink([in] IMFByteStream* pIByteStream, [in] IMFMediaType* pAudioMediaType, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreateADTSMediaSink")]
long MFCreateADTSMediaSink([in] IMFByteStream* pIByteStream, [in] IMFMediaType* pAudioMediaType, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreateMuxSink")]
long MFCreateMuxSink([in] long guidOutputSubType1, [in] long guidOutputSubType2, [in] long guidOutputSubType3, [in] long guidOutputSubType4,
					 [in] IMFAttributes* pOutputAttributes, [in] IMFByteStream* pOutputByteStream, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreateFMPEG4MediaSink")]
long MFCreateFMPEG4MediaSink([in] IMFByteStream* pIByteStream, [in] IMFMediaType* pVideoMediaType, [in] IMFMediaType* pAudioMediaType, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreateAVIMediaSink")]
long MFCreateAVIMediaSink([in] IMFByteStream* pIByteStream, [in] IMFMediaType* pVideoMediaType, [in] IMFMediaType* pAudioMediaType, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreateWAVEMediaSink")]
long MFCreateWAVEMediaSink([in] IMFByteStream* pTargetByteStream, [out] IMFMediaSink** ppIMediaSink);

[entry("MFCreateTopoLoader")]
long MFCreateTopoLoader([out] IMFTopoLoader** ppObj);

[entry("MFCreateSampleGrabberSinkActivate")]
long MFCreateSampleGrabberSinkActivate([in] IMFMediaType* pIMFMediaType, [in] IMFSampleGrabberSinkCallback* pIMFSampleGrabberSinkCallback, [out] IMFActivate** ppActivate);

[entry("MFCreateStandardQualityManager")]
long MFCreateStandardQualityManager([out] IMFQualityManager** ppQualityManager);

[entry("MFCreateSequencerSource")]
long MFCreateSequencerSource([in] stdole.IUnknown *pReserved, [out] IMFSequencerSource** ppSequencerSource);

[entry("MFCreateSequencerSegmentOffset")]
long MFCreateSequencerSegmentOffset([in] MFSequencerElementId dwId, [in] MFTIME hnsOffset, [out] VARIANT* pvarSegmentOffset);

[entry("MFCreateAggregateSource")]
long MFCreateAggregateSource([in] IMFCollection* pSourceCollection, [out] IMFMediaSource** ppAggSource);

[entry("MFCreateCredentialCache")]
long MFCreateCredentialCache([out]  IMFNetCredentialCache** ppCache);

[entry("MFCreateProxyLocator")]
long MFCreateProxyLocator([in] LongPtr pszProtocol, [in]  IPropertyStore* pProxyConfig, [out] IMFNetProxyLocator** ppProxyLocator);

[entry("MFCreateNetSchemePlugin")]
long MFCreateNetSchemePlugin([in] REFIID riid, [out] LPVOID ppvHandler);

[entry("MFCreatePMPServer")]
long MFCreatePMPServer([in] DWORD dwCreationFlags, [out] IMFPMPServer** ppPMPServer);

[entry("MFCreateRemoteDesktopPlugin")]
long MFCreateRemoteDesktopPlugin([out] IMFRemoteDesktopPlugin** ppPlugin);

[entry("MFCreateTranscodeProfile")]
long MFCreateTranscodeProfile([out] IMFTranscodeProfile** ppTranscodeProfile);

[entry("MFCreateTranscodeTopology")]
long MFCreateTranscodeTopology([in] IMFMediaSource* pSrc, [in] LongPtr pwszOutputFilePath, [in] IMFTranscodeProfile* pProfile, [out] IMFTopology** ppTranscodeTopo);

[entry("MFCreateTranscodeTopologyFromByteStream")]
long MFCreateTranscodeTopologyFromByteStream([in] IMFMediaSource* pSrc, [in] IMFByteStream* pOutputStream, [in] IMFTranscodeProfile* pProfile, [out] IMFTopology** ppTranscodeTopo);

[entry("MFTranscodeGetAudioOutputAvailableTypes")]
long MFTranscodeGetAudioOutputAvailableTypes([in] REFGUID guidSubType, [in] DWORD dwMFTFlags, [in] IMFAttributes* pCodecConfig, [out] IMFCollection** ppAvailableTypes);

[entry("MFCreateTranscodeSinkActivate")]
long MFCreateTranscodeSinkActivate([out] IMFActivate** ppActivate);

[entry("MFEnumDeviceSources")]
long MFEnumDeviceSources([in] IMFAttributes* pAttributes, [out] LongPtr* pppSourceActivate, [out] UINT32 *pcSourceActivate);

[entry("MFCreateDeviceSource")]
long MFCreateDeviceSource([in] IMFAttributes* pAttributes, [out] IMFMediaSource** ppSource);

[entry("MFCreateDeviceSourceActivate")]
long MFCreateDeviceSourceActivate([in] IMFAttributes* pAttributes, [out] IMFActivate** ppActivate);

[entry("MFCreateProtectedEnvironmentAccess")]
long MFCreateProtectedEnvironmentAccess([out] IMFProtectedEnvironmentAccess** ppAccess);

[entry("MFLoadSignedLibrary")]
long MFLoadSignedLibrary([in] LongPtr pszName, [out] IMFSignedLibrary** ppLib);

[entry("MFGetSystemId")]
long MFGetSystemId([out] IMFSystemId** ppId);

[entry("MFGetLocalId")]
long MFGetLocalId([in] BYTE* verifier, [in] UINT32 size, [out] LongPtr* id);


/// <summary>
///     Creates an EncryptedMediaExtensionsStoreActivate for StoreContentDecryptionModule scenarios.
///     The activate can be created in the protected process and activated in the app process.
/// </summary>
/// <param name="pmpHost">
///     The IMFPMPHostApp with the necessary information to
///     create an EncryptedMediaExtensions Store Object for this app package.
/// </param>
/// <param name="objectStream">
///     The object stream that will be loaded via IMFActivate::Load.
/// </param>
/// <param name="classId">
///     String representing the target object's activatable class id.
/// </param>
/// <param name="activate">
///     Returns pointer to an EncryptedMediaExtensions Store Activate
/// </param>
//cpp_quote("STDAPI MFCreateEncryptedMediaExtensionsStoreActivate(")
//cpp_quote("    _In_ IMFPMPHostApp *pmpHost,")
//cpp_quote("    _In_ IStream *objectStream,")
//cpp_quote("    _In_ LongPtr classId,")
//cpp_quote("    _Outptr_ IMFActivate** activate")
//cpp_quote("    );")
[entry("MFCreateEncryptedMediaExtensionsStoreActivate")]
long MFCreateEncryptedMediaExtensionsStoreActivate([in] IMFPMPHostApp* pmpHost, [in] IStream* objectStream, [in] LPWSTR classId, [out] IMFActivate** activate);

};



[
	dllname("mfplay.dll")
]
module MFPlay
{
[entry("MFPCreateMediaPlayer")]
long MFPCreateMediaPlayer(
	[in] long pwszURL,
	[in]  BOOL fStartPlayback,
	[in] MFP_CREATION_OPTIONS creationOptions,
	[in] IMFPMediaPlayerCallback * pCallback,
	[in] HWND hWnd,
	[out] IMFPMediaPlayer * *ppMediaPlayer);
};

[
	dllname("MFPlat.DLL")
]
module MFPlat{
	[entry("MFStartup")]
long MFStartup(
	[in] long Version,
	[in] long dwFlags);
[entry("MFShutdown")]
long _stdcall MFShutdown();
[entry("MFCreateSourceResolver")]
HRESULT _stdcall MFCreateSourceResolver([out, retval] IMFSourceResolver** ppISourceResolver);
[entry("MFCreateAttributes")]
HRESULT _stdcall MFCreateAttributes(
	[in] IMFAttributes** ppMFAttributes,
	[in] long cInitialSize);
[entry("MFCreateMediaType")]
HRESULT _stdcall MFCreateMediaType([out, retval] IMFMediaType** ppMFType);

[entry("MFSerializeAttributesToStream")]
long MFSerializeAttributesToStream([in] IMFAttributes* pAttr, [in] DWORD dwOptions, [in] IStream* pStm);
[entry("MFDeSerializeAttributesFromStream")]
long MFDeSerializeAttributesFromStream([in] IMFAttributes* pAttr, [in] DWORD dwOptions, [in] IStream* pStm);

[entry("MFGetSystemTime")]
CURRENCY MFGetSystemTime(void);

[entry("MFCreateSystemTimeSource")]
long MFCreateSystemTimeSource([out] IMFPresentationTimeSource** ppSystemTimeSource);

[entry("MFCreatePresentationDescriptor")]
long MFCreatePresentationDescriptor([in] DWORD cStreamDescriptors, [in] IMFStreamDescriptor* apStreamDescriptors, [out] IMFPresentationDescriptor** ppPresentationDescriptor);

[entry("MFSerializePresentationDescriptor")]
long MFSerializePresentationDescriptor([in] IMFPresentationDescriptor* pPD, [out] DWORD* pcbData, [out] LongPtr* ppbData);

[entry("MFDeserializePresentationDescriptor")]
long MFDeserializePresentationDescriptor([in] DWORD cbData, [in] BYTE* pbData, [out] IMFPresentationDescriptor** ppPD);

[entry("MFCreateStreamDescriptor")]
long MFCreateStreamDescriptor([in] DWORD dwStreamIdentifier, [in] DWORD cMediaTypes, [in] IMFMediaType* apMediaTypes, [out] IMFStreamDescriptor** ppDescriptor);

[entry("MFCreateTrackedSample")]
long MFCreateTrackedSample([out] IMFTrackedSample** ppMFSample);

[entry("MFCreateMFByteStreamOnStream")]
long MFCreateMFByteStreamOnStream([in] IStream *pStream, [out] IMFByteStream** ppByteStream);

[entry("MFCreateMFByteStreamOnStreamEx")]
long MFCreateMFByteStreamOnStreamEx([in] stdole.IUnknown *pUnkStream, [out] IMFByteStream** ppByteStream);

[entry("MFCreateStreamOnMFByteStream")]
long MFCreateStreamOnMFByteStream([in] IMFByteStream* pByteStream, [out] IStream** ppStream);

[entry("MFCreateStreamOnMFByteStreamEx")]
long MFCreateStreamOnMFByteStreamEx([in] IMFByteStream* pByteStream, [in] REFIID riid, [out] LPVOID ppv);

[entry("MFCreateMediaTypeFromProperties")]
long MFCreateMediaTypeFromProperties([in] stdole.IUnknown* punkStream, [out] IMFMediaType** ppMediaType);

[entry("MFCreatePropertiesFromMediaType")]
long MFCreatePropertiesFromMediaType([in] IMFMediaType* pMediaType, [in] REFIID riid, [out] LPVOID ppv);

[entry("MFCreateContentProtectionDevice")]
long MFCreateContentProtectionDevice([in] REFGUID ProtectionSystemId, [out] IMFContentProtectionDevice** ContentProtectionDevice);

[entry("MFIsContentProtectionDeviceSupported")]
long MFIsContentProtectionDeviceSupported([in] UUID* ProtectionSystemId, [out] BOOL* isSupported);

[entry("MFCreateContentDecryptorContext")]
long MFCreateContentDecryptorContext([in] REFGUID guidMediaProtectionSystemId, [in] IMFDXGIDeviceManager* pD3DManager, [in] IMFContentProtectionDevice* pContentProtectionDevice, [out] IMFContentDecryptorContext** ppContentDecryptorContext);

[entry("MFCreateTransformActivate")]
long MFCreateTransformActivate([out] IMFActivate** ppActivate);

/// <summary>
///      This function is used to instantiate an MF D3D12 synchronization primitive used to synchronize
//       access to a D3D12 resource stored in an MF object.
/// </summary>
/// <param name="pDevice">
///      The D3D12 device that corresponds to the resource and primitive being created.
/// </param>
/// <param name="riid">
///      The GUID identifying the interface of the synchronization object that will be created.
/// </param>
/// <param name="ppvSyncObject">
///     Specifies a pointer to the pointer to the synchronization object that will be created.
/// </param>
//HRESULT MFCreateD3D12SynchronizationObject([in] ID3D12Device* pDevice, [in] REFIID riid, [out] LPVOID ppvSyncObject);
[entry("MFCreateD3D12SynchronizationObject")]
long MFCreateD3D12SynchronizationObject([in] LPVOID pDevice, [in] REFIID riid, [out] LPVOID ppvSyncObject);

const int MF_VERSION = 0x00020000;
const int MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO = 1;
const int MFASYNC_FAST_IO_PROCESSING_CALLBACK = 1;
const int MFASYNC_SIGNAL_CALLBACK = 2;
const int MFASYNC_BLOCKING_CALLBACK = 4;
const int MFASYNC_REPLY_CALLBACK = 8;
const int MF_EVENT_FLAG_NO_WAIT = 1;
const int MF_SOURCE_READER_FIRST_VIDEO_STREAM = 0xfffffffc;
const int MF_SOURCE_READER_FIRST_AUDIO_STREAM = 0xfffffffd;
const int MF_SOURCE_READER_CURRENT_TYPE_INDEX = 0xffffffff;
const int MF_SOURCE_READER_ANY_STREAM = 0xffffffff;
const int MF_SOURCE_READER_INVALID_STREAM_INDEX = 0xffffffff;
const int MF_SOURCE_READER_ALL_STREAMS = 0xfffffffe;
const int MF_SOURCE_READER_MEDIASOURCE = 0xffffffff;
const int MF_MEDIATYPE_EQUAL_MAJOR_TYPES = 1;
const int MF_MEDIATYPE_EQUAL_FORMAT_TYPES = 2;
const int MF_MEDIATYPE_EQUAL_FORMAT_DATA = 4;
const int MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA = 8;

const int MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL = 1;
const int MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL = 1;


const int MFOUTPUTATTRIBUTE_DIGITAL = 0x00000001;
const int MFOUTPUTATTRIBUTE_NONSTANDARDIMPLEMENTATION = 0x00000002;
const int MFOUTPUTATTRIBUTE_VIDEO = 0x00000004;
const int MFOUTPUTATTRIBUTE_COMPRESSED = 0x00000008;
const int MFOUTPUTATTRIBUTE_SOFTWARE = 0x00000010;
const int MFOUTPUTATTRIBUTE_BUS = 0x00000020;
const int MFOUTPUTATTRIBUTE_BUSIMPLEMENTATION = 0x0000FF00;



};

[
	dllname("MFReadWrite.DLL")
]
module MFReadWrite {
	[entry("MFCreateSourceReaderFromMediaSource")]
HRESULT _stdcall MFCreateSourceReaderFromMediaSource(
	[in] IMFMediaSource* pMediaSource,
	[in] IMFAttributes* pAttributes,
	[out, retval] IMFSourceReader** ppSourceReader);

	[entry("MFCreateSourceReaderFromURL")]
	long MFCreateSourceReaderFromURL([in] LongPtr pwszURL, [in] IMFAttributes* pAttributes, [out] IMFSourceReader** ppSourceReader);

	[entry("MFCreateSourceReaderFromByteStream")]
	long MFCreateSourceReaderFromByteStream([in] IMFByteStream *pByteStream, [in] IMFAttributes* pAttributes, [out] IMFSourceReader** ppSourceReader);

	[entry("MFCreateSinkWriterFromURL")]
	long MFCreateSinkWriterFromURL([in] LongPtr pwszOutputURL, [in] IMFByteStream* pByteStream, [in] IMFAttributes* pAttributes, [out] IMFSinkWriter** ppSinkWriter);

	[entry("MFCreateSinkWriterFromMediaSink")]
	long MFCreateSinkWriterFromMediaSink([in] IMFMediaSink* pMediaSink, [in] IMFAttributes* pAttributes, [out] IMFSinkWriter** ppSinkWriter);



};

//cpp_quote("")
//cpp_quote("STDAPI")
//cpp_quote("MFCreateVirtualCamera(")
//cpp_quote("    _In_ MFVirtualCameraType type,")
//cpp_quote("    _In_ MFVirtualCameraLifetime lifetime,")
//cpp_quote("    _In_ MFVirtualCameraAccess access,")
//cpp_quote("    _In_z_ LPCWSTR friendlyName,")
//cpp_quote("    _In_z_ LPCWSTR sourceId,")
//cpp_quote("    _In_reads_opt_(categoryCount) const GUID* categories,")
//cpp_quote("    _In_ ULONG categoryCount,")
//cpp_quote("    _COM_Outptr_ IMFVirtualCamera** virtualCamera")
//cpp_quote("    );")
//cpp_quote("")
//cpp_quote("")
//cpp_quote("STDAPI")
//cpp_quote("MFIsVirtualCameraTypeSupported(")
//cpp_quote("    _In_ MFVirtualCameraType type,")
//cpp_quote("    _Out_ BOOL* supported")
//cpp_quote("    );")
//cpp_quote("")
//cpp_quote("#endif // (WINVER >= NTDDI_WIN10_CO)")

//cpp_quote("STDAPI")
//cpp_quote("MFCreateSensorGroup(")
//cpp_quote("    _In_z_ LPCWSTR SensorGroupSymbolicLink,")
//cpp_quote("    _COM_Outptr_ IMFSensorGroup** ppSensorGroup")
//cpp_quote("    );")
//cpp_quote("")
//cpp_quote("STDAPI")
//cpp_quote("MFCreateSensorStream(")
//cpp_quote("    _In_ DWORD StreamId,")
//cpp_quote("    _In_opt_ IMFAttributes* pAttributes,")
//cpp_quote("    _In_ IMFCollection* pMediaTypeCollection,")
//cpp_quote("    _COM_Outptr_ IMFSensorStream** ppStream")
//cpp_quote("    );")
//cpp_quote("")



/// <summary>
/// Allows app to create Camera Occlusion State Monitor for the given camera device.
/// The symbolicLink should be from the camera that is already activated, otherwise 
/// the state information is not guaranteed to be correct.
/// </summary>
/// <param name = "symbolicLink">
/// String symbolic link name of the video capture device that is active.
/// </param>
/// <param name = "callback">
/// Pointer to an object that implements the callback interface.
/// </param>
/// <param name = "occlusionStateMonitor">
/// Specifies a pointer to a variable where theIMFCameraOcclusionStateMonitor object
/// will be stored.
/// </param>
//cpp_quote("")
//cpp_quote("STDAPI")
//cpp_quote("MFCreateCameraOcclusionStateMonitor(")
//cpp_quote("    _In_z_ LPCWSTR symbolicLink,")
//cpp_quote("    _In_ IMFCameraOcclusionStateReportCallback* callback,")
//cpp_quote("    _COM_Outptr_ IMFCameraOcclusionStateMonitor** occlusionStateMonitor")
//cpp_quote("    );")
/// <summary>
/// Allows app to create CameraControlMonitor.
/// If provided symbolic link name does not match a camera device, then method will return E_INVALIDARG
/// </summary>
/// <param name = "symbolicLink">
/// String symbolic link name of the video capture device that is active.
/// </param>
/// <param name = "callback">
/// Pointer to an object that implements the callback interface.
/// </param>
/// <param name = "ppCameraControlMonitor">
/// Specifies a pointer to a variable where the IMFCameraControlMonitor object
/// will be stored.
/// </param>
//cpp_quote("")
//cpp_quote("STDAPI")
//cpp_quote("MFCreateCameraControlMonitor(")
//cpp_quote("    _In_z_ LPCWSTR symbolicLink,")
//cpp_quote("    _In_ IMFCameraControlNotify* callback,")
//cpp_quote("    _COM_Outptr_ IMFCameraControlMonitor ** ppCameraControlMonitor")
//cpp_quote("    );")


//cpp_quote("STDAPI")
//cpp_quote("MFCreateSensorProfileCollection(")
//cpp_quote("    _COM_Outptr_ IMFSensorProfileCollection** ppSensorProfile")
//cpp_quote("    );")
//cpp_quote("")

//cpp_quote("STDAPI")
//cpp_quote("MFCreateSensorActivityMonitor(")
//cpp_quote("    _In_ IMFSensorActivitiesReportCallback* pCallback,")
//cpp_quote("    _COM_Outptr_ IMFSensorActivityMonitor** ppActivityMonitor")
//cpp_quote("    );")

/// <summary>
/// Allows an app to create a Relative Panel Watcher
/// </summary>
/// <param name = "videoDeviceId">
/// string symbolic link name of the video capture device
/// </param>
/// <param name = "displayMonitorDeviceId">
/// string symbolic link name of the display monitor device
/// </param>
/// <param name = "ppRelativePanelWatcher"
/// IMFRelativePanelWatcher pointer, representing the watcher
/// </param>
//cpp_quote("")
//cpp_quote("STDAPI")
//cpp_quote("MFCreateRelativePanelWatcher(")
//cpp_quote("    _In_ PCWSTR videoDeviceId,")
//cpp_quote("    _In_ PCWSTR displayMonitorDeviceId,")
//cpp_quote("    _COM_Outptr_ IMFRelativePanelWatcher** ppRelativePanelWatcher")
//cpp_quote("    );")
//cpp_quote("STDAPI")
//cpp_quote("MFCreateSensorProfile(")
//cpp_quote("    _In_ REFGUID ProfileType,")
//cpp_quote("    _In_ UINT32 ProfileIndex,")
//cpp_quote("    _In_opt_z_ LPCWSTR Constraints,")
//cpp_quote("    _COM_Outptr_ IMFSensorProfile** ppProfile")
//cpp_quote("    );")

[
	dllname("mfcore.dll")
]
module MFCore
{
	[entry("MFCreateExtendedCameraIntrinsics")]
	long MFCreateExtendedCameraIntrinsics([out] IMFExtendedCameraIntrinsics** ppExtendedCameraIntrinsics);

	[entry("MFCreateExtendedCameraIntrinsicModel")]
	long MFCreateExtendedCameraIntrinsicModel([in] MFCameraIntrinsic_DistortionModelType distortionModelType, [out] IMFExtendedCameraIntrinsicModel** ppExtendedCameraIntrinsicModel);
}
//cpp_quote("STDAPI")
//cpp_quote("MFCreateExtendedCameraIntrinsics(")
//cpp_quote("    _COM_Outptr_ IMFExtendedCameraIntrinsics** ppExtendedCameraIntrinsics")
//cpp_quote("    );")
//
//cpp_quote("STDAPI")
//cpp_quote("MFCreateExtendedCameraIntrinsicModel(")
//cpp_quote("    const MFCameraIntrinsic_DistortionModelType distortionModelType,")
//cpp_quote("    _COM_Outptr_ IMFExtendedCameraIntrinsicModel** ppExtendedCameraIntrinsicModel")
//cpp_quote("    );")
[
	dllname("mfsensorgroup.dll")
]
module MFSensorGroup
{
	[entry("MFCreateVirtualCamera")]
	long MFCreateVirtualCamera([in] MFVirtualCameraType type, [in] MFVirtualCameraLifetime lifetime, [in] MFVirtualCameraAccess access, [in] LPCWSTR friendlyName, [in] LPCWSTR sourceId, [in] GUID* categories, [in] ULONG categoryCount, [out] IMFVirtualCamera** virtualCamera);

	[entry("MFIsVirtualCameraTypeSupported")]
	long MFIsVirtualCameraTypeSupported([in] MFVirtualCameraType type, [out] BOOL* supported);

	[entry("MFCreateSensorGroup")]
	long MFCreateSensorGroup([in] LPCWSTR SensorGroupSymbolicLink, [out] IMFSensorGroup** ppSensorGroup);

	[entry("MFCreateSensorStream")]
	long MFCreateSensorStream([in] DWORD StreamId, [in] IMFAttributes* pAttributes, [in] IMFCollection* pMediaTypeCollection, [out] IMFSensorStream** ppStream);

	[entry("MFCreateCameraControlMonitor")]
	long MFCreateCameraControlMonitor([in] LPCWSTR symbolicLink, [in] IMFCameraControlNotify* callback, [out] IMFCameraControlMonitor** ppCameraControlMonitor);

	[entry("MFCreateCameraOcclusionStateMonitor")]
	long MFCreateCameraOcclusionStateMonitor([in] LPCWSTR symbolicLink, [in] IMFCameraOcclusionStateReportCallback* callback, [out] IMFCameraOcclusionStateMonitor** occlusionStateMonitor);

	[entry("MFCreateRelativePanelWatcher")]
	long MFCreateRelativePanelWatcher([in] LPCWSTR videoDeviceId, [in] LPCWSTR displayMonitorDeviceId, [out] IMFRelativePanelWatcher** ppRelativePanelWatcher);

	[entry("MFCreateSensorActivityMonitor")]
	long MFCreateSensorActivityMonitor([in] IMFSensorActivitiesReportCallback* pCallback, [out] IMFSensorActivityMonitor** ppActivityMonitor);

	[entry("MFCreateSensorProfileCollection")]
	long MFCreateSensorProfileCollection([out] IMFSensorProfileCollection** ppSensorProfile);

	[entry("MFCreateSensorProfile")]
	long MFCreateSensorProfile([in] REFGUID ProfileType, [in] UINT32 ProfileIndex, [in] LPCWSTR Constraints, [out] IMFSensorProfile** ppProfile);
}

// NOTE: This module has no entry points. There is no way to
//       extract the dllname of a module with no entry points!
// 
[
	dllname("<no entry points>")
]
module MFErrors{
[helpstring("Platform not initialized. Please call MFStartup().")] const int MF_E_PLATFORM_NOT_INITIALIZED = 0xc00d36b0;
[helpstring("The buffer was too small to carry out the requested action.")] const int MF_E_BUFFERTOOSMALL = 0xc00d36b1;
[helpstring("The request is invalid in the current state.")] const int MF_E_INVALIDREQUEST = 0xc00d36b2;
[helpstring("The stream number provided was invalid.")] const int MF_E_INVALIDSTREAMNUMBER = 0xc00d36b3;
[helpstring("The data specified for the media type is invalid, inconsistent, or not supported by this object.")] const int MF_E_INVALIDMEDIATYPE = 0xc00d36b4;
[helpstring("The callee is currently not accepting further input.")] const int MF_E_NOTACCEPTING = 0xc00d36b5;
[helpstring("This object needs to be initialized before the requested operation can be carried out.")] const int MF_E_NOT_INITIALIZED = 0xc00d36b6;
[helpstring("The requested representation is not supported by this object.")] const int MF_E_UNSUPPORTED_REPRESENTATION = 0xc00d36b7;
[helpstring("An object ran out of media types to suggest therefore the requested chain of streaming objects cannot be completed.")] const int MF_E_NO_MORE_TYPES = 0xc00d36b9;
[helpstring("The object does not support the specified service.")] const int MF_E_UNSUPPORTED_SERVICE = 0xc00d36ba;
[helpstring("An unexpected error has occurred in the operation requested.")] const int MF_E_UNEXPECTED = 0xc00d36bb;
[helpstring("Invalid name.")] const int MF_E_INVALIDNAME = 0xc00d36bc;
[helpstring("Invalid type.")] const int MF_E_INVALIDTYPE = 0xc00d36bd;
[helpstring("The file does not conform to the relevant file format specification.")] const int MF_E_INVALID_FILE_FORMAT = 0xc00d36be;
[helpstring("Invalid index.")] const int MF_E_INVALIDINDEX = 0xc00d36bf;
[helpstring("An invalid timestamp was given.")] const int MF_E_INVALID_TIMESTAMP = 0xc00d36c0;
[helpstring("The scheme of the given URL is unsupported.")] const int MF_E_UNSUPPORTED_SCHEME = 0xc00d36c3;
[helpstring("The byte stream type of the given URL is unsupported.")] const int MF_E_UNSUPPORTED_BYTESTREAM_TYPE = 0xc00d36c4;
[helpstring("The given time format is unsupported.")] const int MF_E_UNSUPPORTED_TIME_FORMAT = 0xc00d36c5;
[helpstring("The Media Sample does not have a timestamp.")] const int MF_E_NO_SAMPLE_TIMESTAMP = 0xc00d36c8;
[helpstring("The Media Sample does not have a duration.")] const int MF_E_NO_SAMPLE_DURATION = 0xc00d36c9;
[helpstring("The request failed because the data in the stream is corrupt.")] const int MF_E_INVALID_STREAM_DATA = 0xc00d36cb;
[helpstring("Real time services are not available.")] const int MF_E_RT_UNAVAILABLE = 0xc00d36cf;
[helpstring("The specified rate is not supported.")] const int MF_E_UNSUPPORTED_RATE = 0xc00d36d0;
[helpstring("This component does not support stream-thinning.")] const int MF_E_THINNING_UNSUPPORTED = 0xc00d36d1;
[helpstring("The call failed because no reverse playback rates are available.")] const int MF_E_REVERSE_UNSUPPORTED = 0xc00d36d2;
[helpstring("The requested rate transition cannot occur in the current state.")] const int MF_E_UNSUPPORTED_RATE_TRANSITION = 0xc00d36d3;
[helpstring("The requested rate change has been pre-empted and will not occur.")] const int MF_E_RATE_CHANGE_PREEMPTED = 0xc00d36d4;
[helpstring("The specified object or value does not exist.")] const int MF_E_NOT_FOUND = 0xc00d36d5;
[helpstring("The requested value is not available.")] const int MF_E_NOT_AVAILABLE = 0xc00d36d6;
[helpstring("The specified operation requires a clock and no clock is available.")] const int MF_E_NO_CLOCK = 0xc00d36d7;
[helpstring("This callback and state had already been passed in to this event generator earlier.")] const int MF_S_MULTIPLE_BEGIN = 0x000d36d8;
[helpstring("This callback has already been passed in to this event generator.")] const int MF_E_MULTIPLE_BEGIN = 0xc00d36d9;
[helpstring("Some component is already listening to events on this event generator.")] const int MF_E_MULTIPLE_SUBSCRIBERS = 0xc00d36da;
[helpstring("This timer was orphaned before its callback time arrived.")] const int MF_E_TIMER_ORPHANED = 0xc00d36db;
[helpstring("A state transition is already pending.")] const int MF_E_STATE_TRANSITION_PENDING = 0xc00d36dc;
[helpstring("The requested state transition is unsupported.")] const int MF_E_UNSUPPORTED_STATE_TRANSITION = 0xc00d36dd;
[helpstring("An unrecoverable error has occurred.")] const int MF_E_UNRECOVERABLE_ERROR_OCCURRED = 0xc00d36de;
[helpstring("The provided sample has too many buffers.")] const int MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS = 0xc00d36df;
[helpstring("The provided sample is not writable.")] const int MF_E_SAMPLE_NOT_WRITABLE = 0xc00d36e0;
[helpstring("The specified key is not valid.")] const int MF_E_INVALID_KEY = 0xc00d36e2;
[helpstring("You are calling MFStartup with the wrong MF_VERSION. Mismatched bits?")] const int MF_E_BAD_STARTUP_VERSION = 0xc00d36e3;
[helpstring("The caption of the given URL is unsupported.")] const int MF_E_UNSUPPORTED_CAPTION = 0xc00d36e4;
[helpstring("The operation on the current offset is not permitted.")] const int MF_E_INVALID_POSITION = 0xc00d36e5;
[helpstring("The requested attribute was not found.")] const int MF_E_ATTRIBUTENOTFOUND = 0xc00d36e6;
[helpstring("The specified property type is not allowed in this context.")] const int MF_E_PROPERTY_TYPE_NOT_ALLOWED = 0xc00d36e7;
[helpstring("The specified property type is not supported.")] const int MF_E_PROPERTY_TYPE_NOT_SUPPORTED = 0xc00d36e8;
[helpstring("The specified property is empty.")] const int MF_E_PROPERTY_EMPTY = 0xc00d36e9;
[helpstring("The specified property is not empty.")] const int MF_E_PROPERTY_NOT_EMPTY = 0xc00d36ea;
[helpstring("The vector property specified is not allowed in this context.")] const int MF_E_PROPERTY_VECTOR_NOT_ALLOWED = 0xc00d36eb;
[helpstring("A vector property is required in this context.")] const int MF_E_PROPERTY_VECTOR_REQUIRED = 0xc00d36ec;
[helpstring("The operation is cancelled.")] const int MF_E_OPERATION_CANCELLED = 0xc00d36ed;
[helpstring("The provided bytestream was expected to be seekable and it is not.")] const int MF_E_BYTESTREAM_NOT_SEEKABLE = 0xc00d36ee;
[helpstring("The Media Foundation platform is disabled when the system is running in Safe Mode.")] const int MF_E_DISABLED_IN_SAFEMODE = 0xc00d36ef;
[helpstring("The Media Source could not parse the byte stream.")] const int MF_E_CANNOT_PARSE_BYTESTREAM = 0xc00d36f0;
[helpstring("Mutually exclusive flags have been specified to source resolver. This flag combination is invalid.")] const int MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS = 0xc00d36f1;
[helpstring("MediaProc is in the wrong state")] const int MF_E_MEDIAPROC_WRONGSTATE = 0xc00d36f2;
[helpstring("Real time I/O service can not provide requested throughput.")] const int MF_E_RT_THROUGHPUT_NOT_AVAILABLE = 0xc00d36f3;
[helpstring("The workqueue cannot be registered with more classes.")] const int MF_E_RT_TOO_MANY_CLASSES = 0xc00d36f4;
[helpstring("This operation cannot succeed because another thread owns this object.")] const int MF_E_RT_WOULDBLOCK = 0xc00d36f5;
[helpstring("Internal. Bitpump not found.")] const int MF_E_NO_BITPUMP = 0xc00d36f6;
[helpstring("No more RT memory available.")] const int MF_E_RT_OUTOFMEMORY = 0xc00d36f7;
[helpstring("An MMCSS class has not been set for this work queue.")] const int MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED = 0xc00d36f8;
[helpstring("Insufficient memory for response.")] const int MF_E_INSUFFICIENT_BUFFER = 0xc00d7170;
[helpstring("Activate failed to create mediasink. Call OutputNode::GetUINT32(MF_TOPONODE_MAJORTYPE) for more information. ")] const int MF_E_CANNOT_CREATE_SINK = 0xc00d36fa;
[helpstring("The length of the provided bytestream is unknown.")] const int MF_E_BYTESTREAM_UNKNOWN_LENGTH = 0xc00d36fb;
[helpstring("The media session cannot pause from a stopped state.")] const int MF_E_SESSION_PAUSEWHILESTOPPED = 0xc00d36fc;
[helpstring("The activate could not be created in the remote process for some reason it was replaced with empty one.")] const int MF_S_ACTIVATE_REPLACED = 0x000d36fd;
[helpstring("The data specified for the media type is supported, but would require a format change, which is not supported by this object.")] const int MF_E_FORMAT_CHANGE_NOT_SUPPORTED = 0xc00d36fe;
[helpstring("The operation failed because an invalid combination of workqueue ID and flags was specified.")] const int MF_E_INVALID_WORKQUEUE = 0xc00d36ff;
[helpstring("No DRM support is available.")] const int MF_E_DRM_UNSUPPORTED = 0xc00d3700;
[helpstring("This operation is not authorized.")] const int MF_E_UNAUTHORIZED = 0xc00d3701;
[helpstring("The value is not in the specified or valid range.")] const int MF_E_OUT_OF_RANGE = 0xc00d3702;
[helpstring("The registered codec merit is not valid.")] const int MF_E_INVALID_CODEC_MERIT = 0xc00d3703;
[helpstring("Hardware MFT failed to start streaming due to lack of hardware resources.")] const int MF_E_HW_MFT_FAILED_START_STREAMING = 0xc00d3704;
[helpstring("Parsing is still in progress and is not yet complete.")] const int MF_S_ASF_PARSEINPROGRESS = 0x400d3a98;
[helpstring("Not enough data have been parsed to carry out the requested action.")] const int MF_E_ASF_PARSINGINCOMPLETE = 0xc00d3a98;
[helpstring("There is a gap in the ASF data provided.")] const int MF_E_ASF_MISSINGDATA = 0xc00d3a99;
[helpstring("The data provided are not valid ASF.")] const int MF_E_ASF_INVALIDDATA = 0xc00d3a9a;
[helpstring("The packet is opaque, so the requested information cannot be returned.")] const int MF_E_ASF_OPAQUEPACKET = 0xc00d3a9b;
[helpstring("The requested operation failed since there is no appropriate ASF index.")] const int MF_E_ASF_NOINDEX = 0xc00d3a9c;
[helpstring("The value supplied is out of range for this operation.")] const int MF_E_ASF_OUTOFRANGE = 0xc00d3a9d;
[helpstring("The index entry requested needs to be loaded before it can be available.")] const int MF_E_ASF_INDEXNOTLOADED = 0xc00d3a9e;
[helpstring("The packet has reached the maximum number of payloads.")] const int MF_E_ASF_TOO_MANY_PAYLOADS = 0xc00d3a9f;
[helpstring("Stream type is not supported.")] const int MF_E_ASF_UNSUPPORTED_STREAM_TYPE = 0xc00d3aa0;
[helpstring("One or more ASF packets were dropped.")] const int MF_E_ASF_DROPPED_PACKET = 0xc00d3aa1;
[helpstring("There are no events available in the queue.")] const int MF_E_NO_EVENTS_AVAILABLE = 0xc00d3e80;
[helpstring("A media source cannot go from the stopped state to the paused state.")] const int MF_E_INVALID_STATE_TRANSITION = 0xc00d3e82;
[helpstring("The media stream cannot process any more samples because there are no more samples in the stream.")] const int MF_E_END_OF_STREAM = 0xc00d3e84;
[helpstring("The request is invalid because Shutdown() has been called.")] const int MF_E_SHUTDOWN = 0xc00d3e85;
[helpstring("The MP3 object was not found.")] const int MF_E_MP3_NOTFOUND = 0xc00d3e86;
[helpstring("The MP3 parser ran out of data before finding the MP3 object.")] const int MF_E_MP3_OUTOFDATA = 0xc00d3e87;
[helpstring("The file is not really a MP3 file.")] const int MF_E_MP3_NOTMP3 = 0xc00d3e88;
[helpstring("The MP3 file is not supported.")] const int MF_E_MP3_NOTSUPPORTED = 0xc00d3e89;
[helpstring("The Media stream has no duration.")] const int MF_E_NO_DURATION = 0xc00d3e8a;
[helpstring("The Media format is recognized but is invalid.")] const int MF_E_INVALID_FORMAT = 0xc00d3e8c;
[helpstring("The property requested was not found.")] const int MF_E_PROPERTY_NOT_FOUND = 0xc00d3e8d;
[helpstring("The property is read only.")] const int MF_E_PROPERTY_READ_ONLY = 0xc00d3e8e;
[helpstring("The specified property is not allowed in this context.")] const int MF_E_PROPERTY_NOT_ALLOWED = 0xc00d3e8f;
[helpstring("The media source is not started.")] const int MF_E_MEDIA_SOURCE_NOT_STARTED = 0xc00d3e91;
[helpstring("The Media format is recognized but not supported.")] const int MF_E_UNSUPPORTED_FORMAT = 0xc00d3e98;
[helpstring("The MPEG frame has bad CRC.")] const int MF_E_MP3_BAD_CRC = 0xc00d3e99;
[helpstring("The file is not protected.")] const int MF_E_NOT_PROTECTED = 0xc00d3e9a;
[helpstring("The media source is in the wrong state")] const int MF_E_MEDIA_SOURCE_WRONGSTATE = 0xc00d3e9b;
[helpstring("No streams are selected in source presentation descriptor.")] const int MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED = 0xc00d3e9c;
[helpstring("No key frame sample was found.")] const int MF_E_CANNOT_FIND_KEYFRAME_SAMPLE = 0xc00d3e9d;
[helpstring("An attempt to acquire a network resource failed.")] const int MF_E_NETWORK_RESOURCE_FAILURE = 0xc00d4268;
[helpstring("Error writing to the network.")] const int MF_E_NET_WRITE = 0xc00d4269;
[helpstring("Error reading from the network.")] const int MF_E_NET_READ = 0xc00d426a;
[helpstring("Internal. Entry cannot complete operation without network.")] const int MF_E_NET_REQUIRE_NETWORK = 0xc00d426b;
[helpstring("Internal. Async op is required.")] const int MF_E_NET_REQUIRE_ASYNC = 0xc00d426c;
[helpstring("Internal. Bandwidth levels are not supported.")] const int MF_E_NET_BWLEVEL_NOT_SUPPORTED = 0xc00d426d;
[helpstring("Internal. Stream groups are not supported.")] const int MF_E_NET_STREAMGROUPS_NOT_SUPPORTED = 0xc00d426e;
[helpstring("Manual stream selection is not supported.")] const int MF_E_NET_MANUALSS_NOT_SUPPORTED = 0xc00d426f;
[helpstring("Invalid presentation descriptor.")] const int MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR = 0xc00d4270;
[helpstring("Cannot find cache stream.")] const int MF_E_NET_CACHESTREAM_NOT_FOUND = 0xc00d4271;
[helpstring("The proxy setting is manual.")] const int MF_I_MANUAL_PROXY = 0x400d4272;
[helpstring("Internal. Entry cannot complete operation without input.")] const int MF_E_NET_REQUIRE_INPUT = 0xc00d4274;
[helpstring("The client redirected to another server.")] const int MF_E_NET_REDIRECT = 0xc00d4275;
[helpstring("The client is redirected to a proxy server.")] const int MF_E_NET_REDIRECT_TO_PROXY = 0xc00d4276;
[helpstring("The client reached maximum redirection limit.")] const int MF_E_NET_TOO_MANY_REDIRECTS = 0xc00d4277;
[helpstring("The server, a computer set up to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.")] const int MF_E_NET_TIMEOUT = 0xc00d4278;
[helpstring("The control socket is closed by the client.")] const int MF_E_NET_CLIENT_CLOSE = 0xc00d4279;
[helpstring("The server received invalid data from the client on the control connection.")] const int MF_E_NET_BAD_CONTROL_DATA = 0xc00d427a;
[helpstring("The server is not a compatible streaming media server.")] const int MF_E_NET_INCOMPATIBLE_SERVER = 0xc00d427b;
[helpstring("Url.")] const int MF_E_NET_UNSAFE_URL = 0xc00d427c;
[helpstring("Data is not available.")] const int MF_E_NET_CACHE_NO_DATA = 0xc00d427d;
[helpstring("End of line.")] const int MF_E_NET_EOL = 0xc00d427e;
[helpstring("The request could not be understood by the server.")] const int MF_E_NET_BAD_REQUEST = 0xc00d427f;
[helpstring("The server encountered an unexpected condition which prevented it from fulfilling the request.")] const int MF_E_NET_INTERNAL_SERVER_ERROR = 0xc00d4280;
[helpstring("Session not found.")] const int MF_E_NET_SESSION_NOT_FOUND = 0xc00d4281;
[helpstring("There is no connection established with the Windows Media server. The operation failed.")] const int MF_E_NET_NOCONNECTION = 0xc00d4282;
[helpstring("The network connection has failed.")] const int MF_E_NET_CONNECTION_FAILURE = 0xc00d4283;
[helpstring("The Server service that received the HTTP push request is not a compatible version of Windows Media Services (WMS).")] const int MF_E_NET_INCOMPATIBLE_PUSHSERVER = 0xc00d4284;
[helpstring("The Windows Media server is denying access.  The username and/or password might be incorrect.")] const int MF_E_NET_SERVER_ACCESSDENIED = 0xc00d4285;
[helpstring("The proxy server is denying access.  The username and/or password might be incorrect.")] const int MF_E_NET_PROXY_ACCESSDENIED = 0xc00d4286;
[helpstring("Unable to establish a connection to the server.")] const int MF_E_NET_CANNOTCONNECT = 0xc00d4287;
[helpstring("The specified push template is invalid.")] const int MF_E_NET_INVALID_PUSH_TEMPLATE = 0xc00d4288;
[helpstring("The specified push publishing point is invalid.")] const int MF_E_NET_INVALID_PUSH_PUBLISHING_POINT = 0xc00d4289;
[helpstring("The requested resource is in use.")] const int MF_E_NET_BUSY = 0xc00d428a;
[helpstring("The Publishing Point or file on the Windows Media Server is no longer available.")] const int MF_E_NET_RESOURCE_GONE = 0xc00d428b;
[helpstring("The proxy experienced an error while attempting to contact the media server.")] const int MF_E_NET_ERROR_FROM_PROXY = 0xc00d428c;
[helpstring("The proxy did not receive a timely response while attempting to contact the media server.")] const int MF_E_NET_PROXY_TIMEOUT = 0xc00d428d;
[helpstring("The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.")] const int MF_E_NET_SERVER_UNAVAILABLE = 0xc00d428e;
[helpstring("The encoding process was unable to keep up with the amount of supplied data.")] const int MF_E_NET_TOO_MUCH_DATA = 0xc00d428f;
[helpstring("Session not found.")] const int MF_E_NET_SESSION_INVALID = 0xc00d4290;
[helpstring("The requested URL is not available in offline mode.")] const int MF_E_OFFLINE_MODE = 0xc00d4291;
[helpstring("A device in the network is blocking UDP traffic.")] const int MF_E_NET_UDP_BLOCKED = 0xc00d4292;
[helpstring("The specified configuration value is not supported.")] const int MF_E_NET_UNSUPPORTED_CONFIGURATION = 0xc00d4293;
[helpstring("The networking protocol is disabled.")] const int MF_E_NET_PROTOCOL_DISABLED = 0xc00d4294;
[helpstring("This object has already been initialized and cannot be re-initialized at this time.")] const int MF_E_ALREADY_INITIALIZED = 0xc00d4650;
[helpstring("The amount of data passed in exceeds the given bitrate and buffer window.")] const int MF_E_BANDWIDTH_OVERRUN = 0xc00d4651;
[helpstring("The sample was passed in too late to be correctly processed.")] const int MF_E_LATE_SAMPLE = 0xc00d4652;
[helpstring("The requested action cannot be carried out until the object is flushed and the queue is emptied.")] const int MF_E_FLUSH_NEEDED = 0xc00d4653;
[helpstring("The profile is invalid.")] const int MF_E_INVALID_PROFILE = 0xc00d4654;
[helpstring("The index that is being generated needs to be committed before the requested action can be carried out.")] const int MF_E_INDEX_NOT_COMMITTED = 0xc00d4655;
[helpstring("The index that is necessary for the requested action is not found.")] const int MF_E_NO_INDEX = 0xc00d4656;
[helpstring("The requested index cannot be added in-place to the specified ASF content.")] const int MF_E_CANNOT_INDEX_IN_PLACE = 0xc00d4657;
[helpstring("The ASF leaky bucket parameters must be specified in order to carry out this request.")] const int MF_E_MISSING_ASF_LEAKYBUCKET = 0xc00d4658;
[helpstring("The stream id is invalid. The valid range for ASF stream id is from 1 to 127.")] const int MF_E_INVALID_ASF_STREAMID = 0xc00d4659;
[helpstring("The requested Stream Sink has been removed and cannot be used.")] const int MF_E_STREAMSINK_REMOVED = 0xc00d4a38;
[helpstring("The various Stream Sinks in this Media Sink are too far out of sync for the requested action to take place.")] const int MF_E_STREAMSINKS_OUT_OF_SYNC = 0xc00d4a3a;
[helpstring("Stream Sinks cannot be added to or removed from this Media Sink because its set of streams is fixed.")] const int MF_E_STREAMSINKS_FIXED = 0xc00d4a3b;
[helpstring("The given Stream Sink already exists.")] const int MF_E_STREAMSINK_EXISTS = 0xc00d4a3c;
[helpstring("Sample allocations have been canceled.")] const int MF_E_SAMPLEALLOCATOR_CANCELED = 0xc00d4a3d;
[helpstring("The sample allocator is currently empty, due to outstanding requests.")] const int MF_E_SAMPLEALLOCATOR_EMPTY = 0xc00d4a3e;
[helpstring("When we try to sopt a stream sink, it is already stopped ")] const int MF_E_SINK_ALREADYSTOPPED = 0xc00d4a3f;
[helpstring("The ASF file sink could not reserve AVIO because the bitrate is unknown.")] const int MF_E_ASF_FILESINK_BITRATE_UNKNOWN = 0xc00d4a40;
[helpstring("No streams are selected in sink presentation descriptor.")] const int MF_E_SINK_NO_STREAMS = 0xc00d4a41;
[helpstring("The sink has not been finalized before shut down. This may cause sink generate a corrupted content.")] const int MF_S_SINK_NOT_FINALIZED = 0x000d4a42;
[helpstring("A metadata item was too long to write to the output container.")] const int MF_E_METADATA_TOO_LONG = 0xc00d4a43;
[helpstring("The operation failed because no samples were processed by the sink.")] const int MF_E_SINK_NO_SAMPLES_PROCESSED = 0xc00d4a44;
[helpstring("There is no available procamp hardware with which to perform color correction.")] const int MF_E_VIDEO_REN_NO_PROCAMP_HW = 0xc00d4e20;
[helpstring("There is no available deinterlacing hardware with which to deinterlace the video stream.")] const int MF_E_VIDEO_REN_NO_DEINTERLACE_HW = 0xc00d4e21;
[helpstring("A video stream requires copy protection to be enabled, but there was a failure in attempting to enable copy protection.")] const int MF_E_VIDEO_REN_COPYPROT_FAILED = 0xc00d4e22;
[helpstring("A component is attempting to access a surface for sharing that is not shared.")] const int MF_E_VIDEO_REN_SURFACE_NOT_SHARED = 0xc00d4e23;
[helpstring("A component is attempting to access a shared device that is already locked by another component.")] const int MF_E_VIDEO_DEVICE_LOCKED = 0xc00d4e24;
[helpstring("The device is no longer available. The handle should be closed and a new one opened.")] const int MF_E_NEW_VIDEO_DEVICE = 0xc00d4e25;
[helpstring("A video sample is not currently queued on a stream that is required for mixing.")] const int MF_E_NO_VIDEO_SAMPLE_AVAILABLE = 0xc00d4e26;
[helpstring("No audio playback device was found.")] const int MF_E_NO_AUDIO_PLAYBACK_DEVICE = 0xc00d4e84;
[helpstring("The requested audio playback device is currently in use.")] const int MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE = 0xc00d4e85;
[helpstring("The audio playback device is no longer present.")] const int MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED = 0xc00d4e86;
[helpstring("The audio service is not running.")] const int MF_E_AUDIO_SERVICE_NOT_RUNNING = 0xc00d4e87;
[helpstring("The topology contains an invalid optional node.  Possible reasons are incorrect number of outputs and inputs or optional node is at the beginning or end of a segment. ")] const int MF_E_TOPO_INVALID_OPTIONAL_NODE = 0xc00d520e;
[helpstring("No suitable transform was found to decrypt the content. ")] const int MF_E_TOPO_CANNOT_FIND_DECRYPTOR = 0xc00d5211;
[helpstring("No suitable transform was found to encode or decode the content. ")] const int MF_E_TOPO_CODEC_NOT_FOUND = 0xc00d5212;
[helpstring("Unable to find a way to connect nodes")] const int MF_E_TOPO_CANNOT_CONNECT = 0xc00d5213;
[helpstring("Unsupported operations in topoloader")] const int MF_E_TOPO_UNSUPPORTED = 0xc00d5214;
[helpstring("The topology or its nodes contain incorrectly set time attributes")] const int MF_E_TOPO_INVALID_TIME_ATTRIBUTES = 0xc00d5215;
[helpstring("The topology contains loops, which are unsupported in media foundation topologies")] const int MF_E_TOPO_LOOPS_IN_TOPOLOGY = 0xc00d5216;
[helpstring("A source stream node in the topology does not have a presentation descriptor")] const int MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR = 0xc00d5217;
[helpstring("A source stream node in the topology does not have a stream descriptor")] const int MF_E_TOPO_MISSING_STREAM_DESCRIPTOR = 0xc00d5218;
[helpstring("A stream descriptor was set on a source stream node but it was not selected on the presentation descriptor")] const int MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED = 0xc00d5219;
[helpstring("A source stream node in the topology does not have a source")] const int MF_E_TOPO_MISSING_SOURCE = 0xc00d521a;
[helpstring("The topology loader does not support sink activates on output nodes.")] const int MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED = 0xc00d521b;
[helpstring("The sequencer cannot find a segment with the given ID.")] const int MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID = 0xc00d61ac;
[helpstring("The context was canceled.")] const int MF_S_SEQUENCER_CONTEXT_CANCELED = 0x000d61ad;
[helpstring("Cannot find source in source cache.")] const int MF_E_NO_SOURCE_IN_CACHE = 0xc00d61ae;
[helpstring("Cannot update topology flags.")] const int MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM = 0x000d61af;
[helpstring("A valid type has not been set for this stream or a stream that it depends on.")] const int MF_E_TRANSFORM_TYPE_NOT_SET = 0xc00d6d60;
[helpstring("A stream change has occurred. Output cannot be produced until the streams have been renegotiated.")] const int MF_E_TRANSFORM_STREAM_CHANGE = 0xc00d6d61;
[helpstring("The transform cannot take the requested action until all of the input data it currently holds is processed or flushed.")] const int MF_E_TRANSFORM_INPUT_REMAINING = 0xc00d6d62;
[helpstring("The transform requires a profile but no profile was supplied or found.")] const int MF_E_TRANSFORM_PROFILE_MISSING = 0xc00d6d63;
[helpstring("The transform requires a profile but the supplied profile was invalid or corrupt.")] const int MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT = 0xc00d6d64;
[helpstring("The transform requires a profile but the supplied profile ended unexpectedly while parsing.")] const int MF_E_TRANSFORM_PROFILE_TRUNCATED = 0xc00d6d65;
[helpstring("The property ID does not match any property supported by the transform.")] const int MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED = 0xc00d6d66;
[helpstring("The variant does not have the type expected for this property ID.")] const int MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG = 0xc00d6d67;
[helpstring("An attempt was made to set the value on a read-only property.")] const int MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE = 0xc00d6d68;
[helpstring("The array property value has an unexpected number of dimensions.")] const int MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM = 0xc00d6d69;
[helpstring("The array or blob property value has an unexpected size.")] const int MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG = 0xc00d6d6a;
[helpstring("The property value is out of range for this transform.")] const int MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE = 0xc00d6d6b;
[helpstring("The property value is incompatible with some other property or mediatype set on the transform.")] const int MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE = 0xc00d6d6c;
[helpstring("The requested operation is not supported for the currently set output mediatype.")] const int MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE = 0xc00d6d6d;
[helpstring("The requested operation is not supported for the currently set input mediatype.")] const int MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE = 0xc00d6d6e;
[helpstring("The requested operation is not supported for the currently set combination of mediatypes.")] const int MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION = 0xc00d6d6f;
[helpstring("The requested feature is not supported in combination with some other currently enabled feature.")] const int MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES = 0xc00d6d70;
[helpstring("The transform cannot produce output until it gets more input samples.")] const int MF_E_TRANSFORM_NEED_MORE_INPUT = 0xc00d6d72;
[helpstring("The requested operation is not supported for the current speaker configuration.")] const int MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG = 0xc00d6d73;
[helpstring("The transform cannot accept mediatype changes in the middle of processing.")] const int MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING = 0xc00d6d74;
[helpstring("The caller should not propagate this event to downstream components.")] const int MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT = 0x000d6d75;
[helpstring("The input type is not supported for D3D device.")] const int MF_E_UNSUPPORTED_D3D_TYPE = 0xc00d6d76;
[helpstring("The caller does not appear to support this transform's asynchronous capabilities.")] const int MF_E_TRANSFORM_ASYNC_LOCKED = 0xc00d6d77;
[helpstring("An audio compression manager driver could not be initialized by the transform.")] const int MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER = 0xc00d6d78;
[helpstring("You are not allowed to open this file. Contact the content provider for further assistance.")] const int MF_E_LICENSE_INCORRECT_RIGHTS = 0xc00d7148;
[helpstring("The license for this media file has expired. Get a new license or contact the content provider for further assistance.")] const int MF_E_LICENSE_OUTOFDATE = 0xc00d7149;
[helpstring("You need a license to perform the requested operation on this media file.")] const int MF_E_LICENSE_REQUIRED = 0xc00d714a;
[helpstring("The licenses for your media files are corrupted. Contact Microsoft product support.")] const int MF_E_DRM_HARDWARE_INCONSISTENT = 0xc00d714b;
[helpstring("The APP needs to provide IMFContentProtectionManager callback to access the protected media file.")] const int MF_E_NO_CONTENT_PROTECTION_MANAGER = 0xc00d714c;
[helpstring("Client does not have rights to restore licenses.")] const int MF_E_LICENSE_RESTORE_NO_RIGHTS = 0xc00d714d;
[helpstring("Licenses are restricted and hence can not be backed up.")] const int MF_E_BACKUP_RESTRICTED_LICENSE = 0xc00d714e;
[helpstring("License restore requires machine to be individualized.")] const int MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION = 0xc00d714f;
[helpstring("Protection for stream is not required.")] const int MF_S_PROTECTION_NOT_REQUIRED = 0x000d7150;
[helpstring("Component is revoked.")] const int MF_E_COMPONENT_REVOKED = 0xc00d7151;
[helpstring("Trusted functionality is currently disabled on this component.")] const int MF_E_TRUST_DISABLED = 0xc00d7152;
[helpstring("No Action is set on WMDRM Output Trust Authority.")] const int MF_E_WMDRMOTA_NO_ACTION = 0xc00d7153;
[helpstring("Action is already set on WMDRM Output Trust Authority.")] const int MF_E_WMDRMOTA_ACTION_ALREADY_SET = 0xc00d7154;
[helpstring("DRM Heaader is not available.")] const int MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE = 0xc00d7155;
[helpstring("Current encryption scheme is not supported.")] const int MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED = 0xc00d7156;
[helpstring("Action does not match with current configuration.")] const int MF_E_WMDRMOTA_ACTION_MISMATCH = 0xc00d7157;
[helpstring("Invalid policy for WMDRM Output Trust Authority.")] const int MF_E_WMDRMOTA_INVALID_POLICY = 0xc00d7158;
[helpstring("The policies that the Input Trust Authority requires to be enforced are unsupported by the outputs.")] const int MF_E_POLICY_UNSUPPORTED = 0xc00d7159;
[helpstring("The OPL that the license requires to be enforced are not supported by the Input Trust Authority.")] const int MF_E_OPL_NOT_SUPPORTED = 0xc00d715a;
[helpstring("The topology could not be successfully verified.")] const int MF_E_TOPOLOGY_VERIFICATION_FAILED = 0xc00d715b;
[helpstring("Signature verification could not be completed successfully for this component.")] const int MF_E_SIGNATURE_VERIFICATION_FAILED = 0xc00d715c;
[helpstring("Running this process under a debugger while using protected content is not allowed.")] const int MF_E_DEBUGGING_NOT_ALLOWED = 0xc00d715d;
[helpstring("MF component has expired.")] const int MF_E_CODE_EXPIRED = 0xc00d715e;
[helpstring("The current GRL on the machine does not meet the minimum version requirements.")] const int MF_E_GRL_VERSION_TOO_LOW = 0xc00d715f;
[helpstring("The current GRL on the machine does not contain any renewal entries for the specified revocation.")] const int MF_E_GRL_RENEWAL_NOT_FOUND = 0xc00d7160;
[helpstring("The current GRL on the machine does not contain any extensible entries for the specified extension GUID.")] const int MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND = 0xc00d7161;
[helpstring("The kernel isn't secure for high security level content.")] const int MF_E_KERNEL_UNTRUSTED = 0xc00d7162;
[helpstring("The response from protected environment driver isn't valid.")] const int MF_E_PEAUTH_UNTRUSTED = 0xc00d7163;
[helpstring("A non-PE process tried to talk to PEAuth.")] const int MF_E_NON_PE_PROCESS = 0xc00d7165;
[helpstring("We need to reboot the machine.")] const int MF_E_REBOOT_REQUIRED = 0xc00d7167;
[helpstring("Protection for this stream is not guaranteed to be enforced until the MEPolicySet event is fired.")] const int MF_S_WAIT_FOR_POLICY_SET = 0x000d7168;
[helpstring("This video stream is disabled because it is being sent to an unknown software output.")] const int MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT = 0x000d7169;
[helpstring("The GRL file is not correctly formed, it may have been corrupted or overwritten.")] const int MF_E_GRL_INVALID_FORMAT = 0xc00d716a;
[helpstring("The GRL file is in a format newer than those recognized by this GRL Reader.")] const int MF_E_GRL_UNRECOGNIZED_FORMAT = 0xc00d716b;
[helpstring("The GRL was reloaded and required all processes that can run protected media to restart.")] const int MF_E_ALL_PROCESS_RESTART_REQUIRED = 0xc00d716c;
[helpstring("The GRL was reloaded and the current process needs to restart.")] const int MF_E_PROCESS_RESTART_REQUIRED = 0xc00d716d;
[helpstring("The user space is untrusted for protected content play.")] const int MF_E_USERMODE_UNTRUSTED = 0xc00d716e;
[helpstring("PEAuth communication session hasn't been started.")] const int MF_E_PEAUTH_SESSION_NOT_STARTED = 0xc00d716f;
[helpstring("PEAuth's public key is revoked.")] const int MF_E_PEAUTH_PUBLICKEY_REVOKED = 0xc00d7171;
[helpstring("The GRL is absent.")] const int MF_E_GRL_ABSENT = 0xc00d7172;
[helpstring("The Protected Environment is trusted.")] const int MF_S_PE_TRUSTED = 0x000d7173;
[helpstring("The Protected Environment is untrusted.")] const int MF_E_PE_UNTRUSTED = 0xc00d7174;
[helpstring("The Protected Environment Authorization service (PEAUTH) has not been started.")] const int MF_E_PEAUTH_NOT_STARTED = 0xc00d7175;
[helpstring("The sample protection algorithms supported by components are not compatible.")] const int MF_E_INCOMPATIBLE_SAMPLE_PROTECTION = 0xc00d7176;
[helpstring("No more protected environment sessions can be supported.")] const int MF_E_PE_SESSIONS_MAXED = 0xc00d7177;
[helpstring("WMDRM ITA does not allow protected content with high security level for this release.")] const int MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED = 0xc00d7178;
[helpstring("WMDRM ITA cannot allow the requested action for the content as one or more components is not properly signed.")] const int MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED = 0xc00d7179;
[helpstring("WMDRM ITA does not support the requested action.")] const int MF_E_ITA_UNSUPPORTED_ACTION = 0xc00d717a;
[helpstring("WMDRM ITA encountered an error in parsing the Secure Audio Path parameters.")] const int MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS = 0xc00d717b;
[helpstring("The Policy Manager action passed in is invalid.")] const int MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS = 0xc00d717c;
[helpstring("The structure specifying Output Protection Level is not the correct format.")] const int MF_E_BAD_OPL_STRUCTURE_FORMAT = 0xc00d717d;
[helpstring("WMDRM ITA does not recognize the Explicite Analog Video Output Protection guid specified in the license.")] const int MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID = 0xc00d717e;
[helpstring("IMFPMPHost object not available.")] const int MF_E_NO_PMP_HOST = 0xc00d717f;
[helpstring("WMDRM ITA could not initialize the Output Protection Level data.")] const int MF_E_ITA_OPL_DATA_NOT_INITIALIZED = 0xc00d7180;
[helpstring("WMDRM ITA does not recognize the Analog Video Output specified by the OTA.")] const int MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT = 0xc00d7181;
[helpstring("WMDRM ITA does not recognize the Digital Video Output specified by the OTA.")] const int MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT = 0xc00d7182;
[helpstring("The continuity key supplied is not currently valid.")] const int MF_E_CLOCK_INVALID_CONTINUITY_KEY = 0xc00d9c40;
[helpstring("No Presentation Time Source has been specified.")] const int MF_E_CLOCK_NO_TIME_SOURCE = 0xc00d9c41;
[helpstring("The clock is already in the requested state.")] const int MF_E_CLOCK_STATE_ALREADY_SET = 0xc00d9c42;
[helpstring("The clock has too many advanced features to carry out the request.")] const int MF_E_CLOCK_NOT_SIMPLE = 0xc00d9c43;
[helpstring("Timer::SetTimer returns this success code if called happened while timer is stopped. Timer is not going to be dispatched until clock is running")] const int MF_S_CLOCK_STOPPED = 0x000d9c44;
[helpstring("The component does not support any more drop modes.")] const int MF_E_NO_MORE_DROP_MODES = 0xc00da028;
[helpstring("The component does not support any more quality levels.")] const int MF_E_NO_MORE_QUALITY_LEVELS = 0xc00da029;
[helpstring("The component does not support drop time functionality.")] const int MF_E_DROPTIME_NOT_SUPPORTED = 0xc00da02a;
[helpstring("Quality Manager needs to wait longer before bumping the Quality Level up.")] const int MF_E_QUALITYKNOB_WAIT_LONGER = 0xc00da02b;
[helpstring("Quality Manager is in an invalid state. Quality Management is off at this moment.")] const int MF_E_QM_INVALIDSTATE = 0xc00da02c;
[helpstring("No transcode output container type is specified.")] const int MF_E_TRANSCODE_NO_CONTAINERTYPE = 0xc00da410;
[helpstring("The profile does not have a media type configuration for any selected source streams.")] const int MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS = 0xc00da411;
[helpstring("Cannot find an encoder MFT that accepts the user preferred output type.")] const int MF_E_TRANSCODE_NO_MATCHING_ENCODER = 0xc00da412;
[helpstring("Memory allocator is not initialized.")] const int MF_E_ALLOCATOR_NOT_INITIALIZED = 0xc00da7f8;
[helpstring("Memory allocator is not committed yet.")] const int MF_E_ALLOCATOR_NOT_COMMITED = 0xc00da7f9;
[helpstring("Memory allocator has already been committed.")] const int MF_E_ALLOCATOR_ALREADY_COMMITED = 0xc00da7fa;
[helpstring("An error occurred in media stream.")] const int MF_E_STREAM_ERROR = 0xc00da7fb;
[helpstring("Stream is not in a state to handle the request.")] const int MF_E_INVALID_STREAM_STATE = 0xc00da7fc;
[helpstring("Hardware stream is not connected yet.")] const int MF_E_HW_STREAM_NOT_CONNECTED = 0xc00da7fd;
};