

[
    dllname("dxgi.dll")
]
module DXGI
{
const int FACDXGI = 0x87a;
//#define MAKE_DXGI_HRESULT(code) MAKE_HRESULT(1, _FACDXGI, code)
//#define MAKE_DXGI_STATUS(code)  MAKE_HRESULT(0, _FACDXGI, code)

// DXGI error messages have moved to winerror.h

const int DXGI_CPU_ACCESS_NONE = (0);
const int DXGI_CPU_ACCESS_DYNAMIC = (1);
const int DXGI_CPU_ACCESS_READ_WRITE = (2);
const int DXGI_CPU_ACCESS_SCRATCH = (3);
const int DXGI_CPU_ACCESS_FIELD = 15;
const int DXGI_USAGE_SHADER_INPUT = 0x00000010;
const int DXGI_USAGE_RENDER_TARGET_OUTPUT = 0x00000020;
const int DXGI_USAGE_BACK_BUFFER = 0x00000040;
const int DXGI_USAGE_SHARED = 0x00000080;
const int DXGI_USAGE_READ_ONLY = 0x00000100;
const int DXGI_USAGE_DISCARD_ON_PRESENT = 0x00000200;
const int DXGI_USAGE_UNORDERED_ACCESS = 0x00000400;
const int DXGI_RESOURCE_PRIORITY_MINIMUM = (0x28000000);

const int	DXGI_RESOURCE_PRIORITY_LOW = (0x50000000);

const int	DXGI_RESOURCE_PRIORITY_NORMAL = (0x78000000);

const int	DXGI_RESOURCE_PRIORITY_HIGH = (0xa0000000);

const int	DXGI_RESOURCE_PRIORITY_MAXIMUM = (0xc8000000);

const int DXGI_MAX_SWAP_CHAIN_BUFFERS = (16);
const int DXGI_PRESENT_TEST = 0x00000001;
const int DXGI_PRESENT_DO_NOT_SEQUENCE = 0x00000002;
const int DXGI_PRESENT_RESTART = 0x00000004;
const int DXGI_PRESENT_DO_NOT_WAIT = 0x00000008;
const int DXGI_PRESENT_STEREO_PREFER_RIGHT = 0x00000010;
const int DXGI_PRESENT_STEREO_TEMPORARY_MONO = 0x00000020;
const int DXGI_PRESENT_RESTRICT_TO_OUTPUT = 0x00000040;
const int DXGI_PRESENT_USE_DURATION = 0x00000100;
const int DXGI_PRESENT_ALLOW_TEARING = 0x00000200;

const int DXGI_MWA_NO_WINDOW_CHANGES = 1; //    (1 << 0)
const int DXGI_MWA_NO_ALT_ENTER = 2; //     (1 << 1)
const int DXGI_MWA_NO_PRINT_SCREEN = 4;  //      (1 << 2)
const int DXGI_MWA_VALID = (0x7);

const int	DXGI_ENUM_MODES_STEREO=(4);

const int	DXGI_ENUM_MODES_DISABLED_STEREO=(8);

const int	DXGI_SHARED_RESOURCE_READ=(0x80000000);

const int	DXGI_SHARED_RESOURCE_WRITE=(1);

const int DXGI_STANDARD_MULTISAMPLE_QUALITY_PATTERN = 0xffffffff;
const int DXGI_CENTER_MULTISAMPLE_QUALITY_PATTERN = 0xfffffffe;


[entry("CreateDXGIFactory")]
long CreateDXGIFactory(
    [in] UUID* riid,
    [out] LPVOID ppFactory);

[entry("CreateDXGIFactory1")]
long CreateDXGIFactory1(
    [in] UUID* riid,
    [out] LPVOID ppFactory);

[entry("CreateDXGIFactory2")]
long CreateDXGIFactory2([in] UINT Flags,
    [in] UUID* riid,
    [out] LPVOID ppFactory);

[entry("DXGIGetDebugInterface1")]
long DXGIGetDebugInterface1([in] UINT Flags,
    [in] UUID* riid,
    [out] LPVOID pDebug);
};


interface IDXGIObject;
interface IDXGIDeviceSubObject;
interface IDXGIResource;
interface IDXGIKeyedMutex;
interface IDXGISurface;
interface IDXGISurface1;
interface IDXGIAdapter;
interface IDXGIOutput;
interface IDXGISwapChain;
interface IDXGIFactory;
interface IDXGIDevice;
interface IDXGIFactory1;
interface IDXGIAdapter1;
interface IDXGIDevice1;

interface IDXGIDisplayControl;
interface IDXGIOutputDuplication;
interface IDXGISurface2;
interface IDXGIResource1;
interface IDXGIDevice2;
interface IDXGISwapChain1;
interface IDXGIFactory2;
interface IDXGIAdapter2;
interface IDXGIOutput1;


interface IDXGIDevice3;
interface IDXGISwapChain2;
interface IDXGIOutput2;
interface IDXGIFactory3;
interface IDXGIDecodeSwapChain;
interface IDXGIFactoryMedia;
interface IDXGISwapChainMedia;
interface IDXGIOutput3;

interface IDXGISwapChain3;
interface IDXGIOutput4;
interface IDXGIFactory4;
interface IDXGIAdapter3;

interface IDXGIOutput5;
interface IDXGISwapChain4;
interface IDXGIDevice4;
interface IDXGIFactory5;

interface IDXGIAdapter4;
interface IDXGIOutput6;

typedef struct DXGI_RATIONAL
{
    UINT Numerator;
    UINT Denominator;
} DXGI_RATIONAL;

typedef struct DXGI_SAMPLE_DESC
{
    UINT Count;
    UINT Quality;
} DXGI_SAMPLE_DESC;

typedef enum DXGI_COLOR_SPACE_TYPE
{
    DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709 = 0,
    DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709 = 1,
    DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P709 = 2,
    DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P2020 = 3,
    DXGI_COLOR_SPACE_RESERVED = 4,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601 = 5,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 = 6,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601 = 7,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 = 8,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709 = 9,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020 = 10,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020 = 11,
    DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020 = 12,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_LEFT_P2020 = 13,
    DXGI_COLOR_SPACE_RGB_STUDIO_G2084_NONE_P2020 = 14,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_TOPLEFT_P2020 = 15,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_TOPLEFT_P2020 = 16,
    DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P2020 = 17,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_GHLG_TOPLEFT_P2020 = 18,
    DXGI_COLOR_SPACE_YCBCR_FULL_GHLG_TOPLEFT_P2020 = 19,
    DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P709 = 20,
    DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P2020 = 21,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P709 = 22,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P2020 = 23,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_TOPLEFT_P2020 = 24,
    DXGI_COLOR_SPACE_CUSTOM = 0xFFFFFFFF
} DXGI_COLOR_SPACE_TYPE;

typedef struct DXGI_RGB
{
    float Red;
    float Green;
    float Blue;
} DXGI_RGB;

//#ifndef D3DCOLORVALUE_DEFINED
//typedef struct D3DCOLORVALUE {
//    float r;
//    float g;
//    float b;
//    float a;
//} D3DCOLORVALUE;

//#define D3DCOLORVALUE_DEFINED
//
typedef D3DCOLORVALUE DXGI_RGBA;

typedef struct DXGI_GAMMA_CONTROL
{
    DXGI_RGB Scale;
    DXGI_RGB Offset;
    DXGI_RGB GammaCurve[1025];
} DXGI_GAMMA_CONTROL;

typedef struct DXGI_GAMMA_CONTROL_CAPABILITIES
{
    BOOL ScaleAndOffsetSupported;
    float MaxConvertedValue;
    float MinConvertedValue;
    UINT NumGammaControlPoints;
    float ControlPointPositions[1025];
} DXGI_GAMMA_CONTROL_CAPABILITIES;

typedef enum DXGI_MODE_SCANLINE_ORDER
{
    DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED = 0,
    DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE = 1,
    DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST = 2,
    DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST = 3
} DXGI_MODE_SCANLINE_ORDER;

typedef enum DXGI_MODE_SCALING
{
    DXGI_MODE_SCALING_UNSPECIFIED = 0,
    DXGI_MODE_SCALING_CENTERED = 1,
    DXGI_MODE_SCALING_STRETCHED = 2
} DXGI_MODE_SCALING;

typedef enum DXGI_MODE_ROTATION
{
    DXGI_MODE_ROTATION_UNSPECIFIED = 0,
    DXGI_MODE_ROTATION_IDENTITY = 1,
    DXGI_MODE_ROTATION_ROTATE90 = 2,
    DXGI_MODE_ROTATION_ROTATE180 = 3,
    DXGI_MODE_ROTATION_ROTATE270 = 4
} DXGI_MODE_ROTATION;

typedef struct DXGI_MODE_DESC
{
    UINT Width;
    UINT Height;
    DXGI_RATIONAL RefreshRate;
    DXGI_FORMAT Format;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_MODE_SCALING Scaling;
} DXGI_MODE_DESC;

typedef UINT DXGI_USAGE;

//typedef struct DXGI_JPEG_QUANTIZATION_TABLE
//{
//    BYTE Elements[64];
//} DXGI_JPEG_QUANTIZATION_TABLE;
//
//typedef struct DXGI_JPEG_DC_HUFFMAN_TABLE
//{
//    BYTE CodeCounts[12];
//    BYTE CodeValues[12];
//} DXGI_JPEG_DC_HUFFMAN_TABLE;
//
//typedef struct DXGI_JPEG_AC_HUFFMAN_TABLE
//{
//    BYTE CodeCounts[16];
//    BYTE CodeValues[162];
//} DXGI_JPEG_AC_HUFFMAN_TABLE;


typedef struct DXGI_FRAME_STATISTICS
{
    UINT PresentCount;
    UINT PresentRefreshCount;
    UINT SyncRefreshCount;
    LARGE_INTEGER SyncQPCTime;
    LARGE_INTEGER SyncGPUTime;
} 	DXGI_FRAME_STATISTICS;

typedef struct DXGI_MAPPED_RECT
{
    INT Pitch;
    long pBits;
} 	DXGI_MAPPED_RECT;

typedef struct DXGI_ADAPTER_DESC
{
    short Description[128];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
} 	DXGI_ADAPTER_DESC;

typedef struct DXGI_OUTPUT_DESC
{
    short DeviceName[32];
    RECT DesktopCoordinates;
    BOOL AttachedToDesktop;
    DXGI_MODE_ROTATION Rotation;
    HMONITOR Monitor;
} 	DXGI_OUTPUT_DESC;

typedef struct DXGI_SHARED_RESOURCE
{
    HANDLE Handle;
} 	DXGI_SHARED_RESOURCE;


typedef
enum DXGI_RESIDENCY
{
    DXGI_RESIDENCY_FULLY_RESIDENT = 1,
    DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY = 2,
    DXGI_RESIDENCY_EVICTED_TO_DISK = 3
} 	DXGI_RESIDENCY;

typedef struct DXGI_SURFACE_DESC
{
    UINT Width;
    UINT Height;
    DXGI_FORMAT Format;
    DXGI_SAMPLE_DESC SampleDesc;
} 	DXGI_SURFACE_DESC;

typedef
enum DXGI_SWAP_EFFECT
{
    DXGI_SWAP_EFFECT_DISCARD = 0,
    DXGI_SWAP_EFFECT_SEQUENTIAL = 1,
    DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL = 3,
    DXGI_SWAP_EFFECT_FLIP_DISCARD = 4
} 	DXGI_SWAP_EFFECT;

typedef
enum DXGI_SWAP_CHAIN_FLAG
{
    DXGI_SWAP_CHAIN_FLAG_NONPREROTATED = 1,
    DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH = 2,
    DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE = 4,
    DXGI_SWAP_CHAIN_FLAG_RESTRICTED_CONTENT = 8,
    DXGI_SWAP_CHAIN_FLAG_RESTRICT_SHARED_RESOURCE_DRIVER = 16,
    DXGI_SWAP_CHAIN_FLAG_DISPLAY_ONLY = 32,
    DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT = 64,
    DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER = 128,
    DXGI_SWAP_CHAIN_FLAG_FULLSCREEN_VIDEO = 256,
    DXGI_SWAP_CHAIN_FLAG_YUV_VIDEO = 512,
    DXGI_SWAP_CHAIN_FLAG_HW_PROTECTED = 1024,
    DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING = 2048,
    DXGI_SWAP_CHAIN_FLAG_RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS = 4096
} 	DXGI_SWAP_CHAIN_FLAG;

typedef struct DXGI_SWAP_CHAIN_DESC
{
    DXGI_MODE_DESC BufferDesc;
    DXGI_SAMPLE_DESC SampleDesc;
    DXGI_USAGE BufferUsage;
    UINT BufferCount;
    HWND OutputWindow;
    BOOL Windowed;
    DXGI_SWAP_EFFECT SwapEffect;
    UINT Flags;
} 	DXGI_SWAP_CHAIN_DESC;

typedef
enum DXGI_ADAPTER_FLAG
{
    DXGI_ADAPTER_FLAG_NONE = 0,
    DXGI_ADAPTER_FLAG_REMOTE = 1,
    DXGI_ADAPTER_FLAG_SOFTWARE = 2,
    DXGI_ADAPTER_FLAG_FORCE_DWORD = 0xffffffff
} 	DXGI_ADAPTER_FLAG;

typedef struct DXGI_ADAPTER_DESC1
{
    short Description[128];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
    UINT Flags;
} 	DXGI_ADAPTER_DESC1;

typedef struct DXGI_DISPLAY_COLOR_SPACE
{
    FLOAT PrimaryCoordinates[8][2];
    FLOAT WhitePoints[16][2];
} 	DXGI_DISPLAY_COLOR_SPACE;

typedef struct DXGI_OUTDUPL_MOVE_RECT
{
    POINT SourcePoint;
    RECT DestinationRect;
} 	DXGI_OUTDUPL_MOVE_RECT;

typedef struct DXGI_OUTDUPL_DESC
{
    DXGI_MODE_DESC ModeDesc;
    DXGI_MODE_ROTATION Rotation;
    BOOL DesktopImageInSystemMemory;
} 	DXGI_OUTDUPL_DESC;

typedef struct DXGI_OUTDUPL_POINTER_POSITION
{
    POINT Position;
    BOOL Visible;
} 	DXGI_OUTDUPL_POINTER_POSITION;

typedef
enum DXGI_OUTDUPL_POINTER_SHAPE_TYPE
{
    DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME = 0x1,
    DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR = 0x2,
    DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR = 0x4
} 	DXGI_OUTDUPL_POINTER_SHAPE_TYPE;

typedef struct DXGI_OUTDUPL_POINTER_SHAPE_INFO
{
    UINT Type;
    UINT Width;
    UINT Height;
    UINT Pitch;
    POINT HotSpot;
} 	DXGI_OUTDUPL_POINTER_SHAPE_INFO;

typedef struct DXGI_OUTDUPL_FRAME_INFO
{
    LARGE_INTEGER LastPresentTime;
    LARGE_INTEGER LastMouseUpdateTime;
    UINT AccumulatedFrames;
    BOOL RectsCoalesced;
    BOOL ProtectedContentMaskedOut;
    DXGI_OUTDUPL_POINTER_POSITION PointerPosition;
    UINT TotalMetadataBufferSize;
    UINT PointerShapeBufferSize;
} 	DXGI_OUTDUPL_FRAME_INFO;

typedef
enum DXGI_ALPHA_MODE
{
    DXGI_ALPHA_MODE_UNSPECIFIED = 0,
    DXGI_ALPHA_MODE_PREMULTIPLIED = 1,
    DXGI_ALPHA_MODE_STRAIGHT = 2,
    DXGI_ALPHA_MODE_IGNORE = 3,
    DXGI_ALPHA_MODE_FORCE_DWORD = 0xffffffff
} 	DXGI_ALPHA_MODE;

typedef struct DXGI_MODE_DESC1
{
    UINT Width;
    UINT Height;
    DXGI_RATIONAL RefreshRate;
    DXGI_FORMAT Format;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_MODE_SCALING Scaling;
    BOOL Stereo;
} 	DXGI_MODE_DESC1;

typedef
enum DXGI_SCALING
{
    DXGI_SCALING_STRETCH = 0,
    DXGI_SCALING_NONE = 1,
    DXGI_SCALING_ASPECT_RATIO_STRETCH = 2
} 	DXGI_SCALING;

typedef struct DXGI_SWAP_CHAIN_DESC1
{
    UINT Width;
    UINT Height;
    DXGI_FORMAT Format;
    BOOL Stereo;
    DXGI_SAMPLE_DESC SampleDesc;
    DXGI_USAGE BufferUsage;
    UINT BufferCount;
    DXGI_SCALING Scaling;
    DXGI_SWAP_EFFECT SwapEffect;
    DXGI_ALPHA_MODE AlphaMode;
    UINT Flags;
} 	DXGI_SWAP_CHAIN_DESC1;

typedef struct DXGI_SWAP_CHAIN_FULLSCREEN_DESC
{
    DXGI_RATIONAL RefreshRate;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_MODE_SCALING Scaling;
    BOOL Windowed;
} 	DXGI_SWAP_CHAIN_FULLSCREEN_DESC;

typedef struct DXGI_PRESENT_PARAMETERS
{
    UINT DirtyRectsCount;
    /* [annotation] */
    long pDirtyRects;
    long pScrollRect;
    long pScrollOffset;
} 	DXGI_PRESENT_PARAMETERS;



[
    odl,
    uuid(aec22fb8-76f3-4639-9be0-28eb43a67a2e)
]
interface IDXGIObject : stdole.IUnknown
{
   HRESULT SetPrivateData(
        /* [annotation][in] */
        [in]  REFGUID Name,
        [in] UINT DataSize,
        /* [annotation][in] */
        [in] void* pData);

   HRESULT SetPrivateDataInterface(
        /* [annotation][in] */
        [in]  REFGUID Name,
        /* [annotation][in] */
        [in] IUnknown* pUnknown);

   HRESULT GetPrivateData(
        /* [annotation][in] */
        [in]  REFGUID Name,
        /* [annotation][out][in] */
        [in, out]  UINT* pDataSize,
        /* [annotation][out] */
        [out]  void* pData);

   HRESULT GetParent(
        /* [annotation][in] */
        [in]  REFIID riid,
        /* [annotation][retval][out] */
        [in, out]  void** ppParent);

};

[
    odl,
    uuid(3d3e0379-f9de-4d58-bb6c-18d62992f1a6)
]
interface IDXGIDeviceSubObject : IDXGIObject
{
   HRESULT GetDevice(
        /* [annotation][in] */
        [in]  REFIID riid,
        /* [annotation][retval][out] */
        [in, out]  void** ppDevice);

};

[
    odl,
    uuid(035f3ab4-482e-4e50-b41f-8a7f8bd8960b)
]
interface IDXGIResource : IDXGIDeviceSubObject
{
   HRESULT GetSharedHandle(
        /* [annotation][out] */
        [in, out]  HANDLE * pSharedHandle);

   HRESULT GetUsage(
        [out] DXGI_USAGE* pUsage);

   HRESULT SetEvictionPriority(
        [in] UINT EvictionPriority);

   HRESULT GetEvictionPriority(
        /* [annotation][retval][out] */
        [in, out]  UINT* pEvictionPriority);

};

[
    odl,
    uuid(9d8e1289-d7b3-465f-8126-250e349af85d)
]
interface IDXGIKeyedMutex : IDXGIDeviceSubObject
{
   HRESULT AcquireSync(
        [in] UINT64 Key,
        [in] DWORD dwMilliseconds);

   HRESULT ReleaseSync(
        [in] UINT64 Key);

};

[
    odl,
    uuid(cafcb56c-6ac3-4889-bf47-9e23bbd260ec)
]
interface IDXGISurface : IDXGIDeviceSubObject
{
   HRESULT GetDesc(
        /* [annotation][out] */
        [in, out]  DXGI_SURFACE_DESC * pDesc);

   HRESULT Map(
        /* [annotation][out] */
        [in, out]  DXGI_MAPPED_RECT* pLockedRect,
        [in] UINT MapFlags);

   HRESULT Unmap(void);

};

[
    odl,
    uuid(4AE63092-6327-4c1b-80AE-BFE12EA32B86)
]
interface IDXGISurface1 : IDXGISurface
{
   HRESULT GetDC(
        [in] BOOL Discard,
        /* [annotation][out] */
        [in, out]  HDC * phdc);

   HRESULT ReleaseDC(
        /* [annotation][in] */
        [in]  RECT* pDirtyRect);

};

[
    odl,
    uuid(2411e7e1-12ac-4ccf-bd14-9798e8534dc0)
]
interface IDXGIAdapter : IDXGIObject
{
   HRESULT EnumOutputs(
        [in] UINT Output,
        /* [annotation][out][in] */
        [in, out]  IDXGIOutput * *ppOutput);

   HRESULT GetDesc(
        /* [annotation][out] */
        [in, out]  DXGI_ADAPTER_DESC* pDesc);

   HRESULT CheckInterfaceSupport(
        /* [annotation][in] */
        [in]  REFGUID InterfaceName,
        /* [annotation][out] */
        [in, out]  LARGE_INTEGER* pUMDVersion);

};

[
    odl,
    uuid(ae02eedb-c735-4690-8d52-5a8dc20213aa)
]
interface IDXGIOutput : IDXGIObject
{
   HRESULT GetDesc(
        /* [annotation][out] */
        [in, out]  DXGI_OUTPUT_DESC * pDesc);

   HRESULT GetDisplayModeList(
        [in] DXGI_FORMAT EnumFormat,
        [in] UINT Flags,
        /* [annotation][out][in] */
        [in, out]  UINT* pNumModes,
        /* [annotation][out] */
        [out]  DXGI_MODE_DESC* pDesc);

   HRESULT FindClosestMatchingMode(
        /* [annotation][in] */
        [in] DXGI_MODE_DESC* pModeToMatch,
        /* [annotation][out] */
        [in, out]  DXGI_MODE_DESC* pClosestMatch,
        /* [annotation][in] */
        [in]  IUnknown* pConcernedDevice);

   HRESULT WaitForVBlank(void);

   HRESULT TakeOwnership(
        /* [annotation][in] */
        [in]  IUnknown* pDevice,
        [in] BOOL Exclusive);

    void ReleaseOwnership(void);

   HRESULT GetGammaControlCapabilities(
        /* [annotation][out] */
        [in, out]  DXGI_GAMMA_CONTROL_CAPABILITIES* pGammaCaps);

   HRESULT SetGammaControl(
        /* [annotation][in] */
        [in]  DXGI_GAMMA_CONTROL* pArray);

   HRESULT GetGammaControl(
        /* [annotation][out] */
        [in, out]  DXGI_GAMMA_CONTROL* pArray);

   HRESULT SetDisplaySurface(
        /* [annotation][in] */
        [in]  IDXGISurface* pScanoutSurface);

   HRESULT GetDisplaySurfaceData(
        /* [annotation][in] */
        [in]  IDXGISurface* pDestination);

   HRESULT GetFrameStatistics(
        /* [annotation][out] */
        [in, out]  DXGI_FRAME_STATISTICS* pStats);

};

[
    odl,
    uuid(310d36a0-d2e7-4c0a-aa04-6a9d23b8886a)
]
interface IDXGISwapChain : IDXGIDeviceSubObject
{
   HRESULT Present(
        [in] UINT SyncInterval,
        [in] UINT Flags);

   HRESULT GetBuffer(
        [in] UINT Buffer,
        /* [annotation][in] */
        [in]  REFIID riid,
        /* [annotation][out][in] */
        [in, out] void* ppSurface);

   HRESULT SetFullscreenState(
        [in] BOOL Fullscreen,
        /* [annotation][in] */
        [in]  IDXGIOutput* pTarget);

   HRESULT GetFullscreenState(
        /* [annotation][out] */
        [out]  BOOL* pFullscreen,
        /* [annotation][out] */
        [out]  IDXGIOutput** ppTarget);

   HRESULT GetDesc(
        /* [annotation][out] */
        [in, out]  DXGI_SWAP_CHAIN_DESC* pDesc);

   HRESULT ResizeBuffers(
        [in] UINT BufferCount,
        [in] UINT Width,
        [in] UINT Height,
        [in] DXGI_FORMAT NewFormat,
        [in] UINT SwapChainFlags);

   HRESULT ResizeTarget(
        /* [annotation][in] */
        [in] DXGI_MODE_DESC* pNewTargetParameters);

   HRESULT GetContainingOutput(
        /* [annotation][out] */
        [in, out]  IDXGIOutput** ppOutput);

   HRESULT GetFrameStatistics(
        /* [annotation][out] */
        [in, out]  DXGI_FRAME_STATISTICS* pStats);

   HRESULT GetLastPresentCount(
        /* [annotation][out] */
        [in, out]  UINT* pLastPresentCount);

};

[
    odl,
    uuid(7b7166ec-21c7-44ae-b21a-c9ae321ae369)
]
interface IDXGIFactory : IDXGIObject
{
   HRESULT EnumAdapters(
        [in] UINT Adapter,
        /* [annotation][out] */
        [in, out]  IDXGIAdapter * *ppAdapter);

   HRESULT MakeWindowAssociation(
       [in] HWND WindowHandle,
       [in] UINT Flags);

   HRESULT GetWindowAssociation(
        /* [annotation][out] */
        [in, out]  HWND* pWindowHandle);

   HRESULT CreateSwapChain(
        /* [annotation][in] */
        [in]  IUnknown* pDevice,
        /* [annotation][in] */
        [in]  DXGI_SWAP_CHAIN_DESC* pDesc,
        /* [annotation][out] */
        [in, out]  IDXGISwapChain** ppSwapChain);

   HRESULT CreateSoftwareAdapter(
        [in] HMODULE Module,
        /* [annotation][out] */
        [in, out]  IDXGIAdapter** ppAdapter);

};

[
    odl,
    uuid(54ec77fa-1377-44e6-8c32-88fd5f44c84c)
]
interface IDXGIDevice : IDXGIObject
{
   HRESULT GetAdapter(
        /* [annotation][out] */
        [in, out]  IDXGIAdapter * *pAdapter);

   HRESULT CreateSurface(
        /* [annotation][in] */
        [in] DXGI_SURFACE_DESC* pDesc,
        [in] UINT NumSurfaces,
        [in] DXGI_USAGE Usage,
        /* [annotation][in] */
        [in]  DXGI_SHARED_RESOURCE* pSharedResource,
        /* [annotation][out] */
        [in, out]  IDXGISurface** ppSurface);

   HRESULT QueryResourceResidency(
        /* [annotation][size_is][in] */
        [in] IUnknown* ppResources,
        /* [annotation][size_is][out] */
        [in, out]  DXGI_RESIDENCY* pResidencyStatus,
        [in] UINT NumResources);

   HRESULT SetGPUThreadPriority(
        [in] int Priority);

   HRESULT GetGPUThreadPriority(
        /* [annotation][retval][out] */
        [in, out]  INT* pPriority);

};

[
    odl,
    uuid(770aae78-f26f-4dba-a829-253c83d1b387)
]
interface IDXGIFactory1 : IDXGIFactory
{
   HRESULT EnumAdapters1(
        [in] UINT Adapter,
        /* [annotation][out] */
        [in, out]  IDXGIAdapter1 **ppAdapter);

   BOOL IsCurrent(void);

};

[
    odl,
    uuid(29038f61-3839-4626-91fd-086879011a05)
]
interface IDXGIAdapter1 : IDXGIAdapter
{
   HRESULT GetDesc1(
        /* [annotation][out] */
        [in, out]  DXGI_ADAPTER_DESC1 * pDesc);

};


[
    odl,
    uuid(77db970f-6276-48ba-ba28-070143b4392c)
]
interface IDXGIDevice1 : IDXGIDevice
{
   HRESULT SetMaximumFrameLatency(
        [in] UINT MaxLatency);

   HRESULT GetMaximumFrameLatency(
        /* [annotation][out] */
        [in, out]  UINT* pMaxLatency);

};

[
    odl,
    uuid(ea9dbf1a-c88e-4486-854a-98aa0138f30c)
]
interface IDXGIDisplayControl : stdole.IUnknown
{
   BOOL IsStereoEnabled(void);

    void SetStereoEnabled(
        [in] BOOL enabled);

};

[
    odl,
    uuid(191cfac3-a341-470d-b26e-a864f428319c)
]
interface IDXGIOutputDuplication : IDXGIObject
{
    void GetDesc(
        /* [annotation][out] */
        [in, out]  DXGI_OUTDUPL_DESC * pDesc);

   HRESULT AcquireNextFrame(
        /* [annotation][in] */
        [in]  UINT TimeoutInMilliseconds,
        /* [annotation][out] */
        [in, out]  DXGI_OUTDUPL_FRAME_INFO* pFrameInfo,
        /* [annotation][out] */
        [in, out]  IDXGIResource** ppDesktopResource);

   HRESULT GetFrameDirtyRects(
        /* [annotation][in] */
        [in]  UINT DirtyRectsBufferSize,
        /* [annotation][out] */
       [in, out]  RECT* pDirtyRectsBuffer,
        /* [annotation][out] */
        [in, out]  UINT* pDirtyRectsBufferSizeRequired);

   HRESULT GetFrameMoveRects(
        /* [annotation][in] */
        [in]  UINT MoveRectsBufferSize,
        /* [annotation][out] */
       [in, out]  DXGI_OUTDUPL_MOVE_RECT* pMoveRectBuffer,
        /* [annotation][out] */
        [in, out]  UINT* pMoveRectsBufferSizeRequired);

   HRESULT GetFramePointerShape(
        /* [annotation][in] */
        [in]  UINT PointerShapeBufferSize,
        /* [annotation][out] */
        [in, out]  void* pPointerShapeBuffer,
        /* [annotation][out] */
        [in, out]  UINT* pPointerShapeBufferSizeRequired,
        /* [annotation][out] */
        [in, out]  DXGI_OUTDUPL_POINTER_SHAPE_INFO* pPointerShapeInfo);

   HRESULT MapDesktopSurface(
        /* [annotation][out] */
        [in, out]  DXGI_MAPPED_RECT* pLockedRect);

   HRESULT UnMapDesktopSurface(void);

   HRESULT ReleaseFrame(void);

};


[
    odl,
    uuid(aba496dd-b617-4cb8-a866-bc44d7eb1fa2)
]
interface IDXGISurface2 : IDXGISurface1
{
   HRESULT GetResource(
        /* [annotation][in] */
        [in]  REFIID riid,
        /* [annotation][out] */
        [in, out] LPVOID ppParentResource,
        /* [annotation][out] */
        [in, out]  UINT * pSubresourceIndex);

};

[
    odl,
    uuid(30961379-4609-4a41-998e-54fe567ee0c1)
]
interface IDXGIResource1 : IDXGIResource
{
   HRESULT CreateSubresourceSurface(
        [in] UINT index,
        /* [annotation][out] */
        [in, out]  IDXGISurface2 * *ppSurface);

   HRESULT CreateSharedHandle(
        /* [annotation][in] */
        [in] SECURITY_ATTRIBUTES* pAttributes,
        /* [annotation][in] */
        [in]  DWORD dwAccess,
        /* [annotation][in] */
        [in]  long lpName,
        /* [annotation][out] */
        [in, out]  HANDLE* pHandle);

};

typedef
enum _DXGI_OFFER_RESOURCE_PRIORITY
{
    DXGI_OFFER_RESOURCE_PRIORITY_LOW = 1,
    DXGI_OFFER_RESOURCE_PRIORITY_NORMAL = 2, // (DXGI_OFFER_RESOURCE_PRIORITY_LOW + 1),
    DXGI_OFFER_RESOURCE_PRIORITY_HIGH = 3, //(DXGI_OFFER_RESOURCE_PRIORITY_NORMAL + 1)
} 	DXGI_OFFER_RESOURCE_PRIORITY;

[
    odl,
    uuid(05008617-fbfd-4051-a790-144884b4f6a9)
]
interface IDXGIDevice2 : IDXGIDevice1
{
   HRESULT OfferResources(
        /* [annotation][in] */
        [in]  UINT NumResources,
        /* [annotation][size_is][in] */
        [in]  IDXGIResource* ppResources,
        /* [annotation][in] */
        [in]  DXGI_OFFER_RESOURCE_PRIORITY Priority);

   HRESULT ReclaimResources(
        /* [annotation][in] */
        [in]  UINT NumResources,
        /* [annotation][size_is][in] */
        [in]  IDXGIResource* ppResources,
        /* [annotation][size_is][out] */
        [out]  BOOL* pDiscarded);

   HRESULT EnqueueSetEvent(
        /* [annotation][in] */
        [in]  HANDLE hEvent);

};

[
    odl,
    uuid(790a45f7-0d42-4876-983a-0a55cfe6f4aa)
]
interface IDXGISwapChain1 : IDXGISwapChain
{
   HRESULT GetDesc1(
        /* [annotation][out] */
        [in, out]  DXGI_SWAP_CHAIN_DESC1 * pDesc);

   HRESULT GetFullscreenDesc(
        /* [annotation][out] */
        [in, out]  DXGI_SWAP_CHAIN_FULLSCREEN_DESC* pDesc);

   HRESULT GetHwnd(
        /* [annotation][out] */
        [in, out]  HWND* pHwnd);

   HRESULT GetCoreWindow(
        /* [annotation][in] */
        [in]  REFIID refiid,
        /* [annotation][out] */
        [in, out]  void* ppUnk);

   HRESULT Present1(
        [in] UINT SyncInterval,
        [in] UINT PresentFlags,
        /* [annotation][in] */
        [in]  DXGI_PRESENT_PARAMETERS* pPresentParameters);

   BOOL IsTemporaryMonoSupported(void);

   HRESULT GetRestrictToOutput(
        /* [annotation][out] */
        [in, out]  IDXGIOutput** ppRestrictToOutput);

   HRESULT SetBackgroundColor(
        /* [annotation][in] */
        [in]  DXGI_RGBA* pColor);

   HRESULT GetBackgroundColor(
        /* [annotation][out] */
        [in, out]  DXGI_RGBA* pColor);

   HRESULT SetRotation(
        /* [annotation][in] */
        [in]  DXGI_MODE_ROTATION Rotation);

   HRESULT GetRotation(
        /* [annotation][out] */
        [in, out]  DXGI_MODE_ROTATION* pRotation);

};

[
    odl,
    uuid(50c83a1c-e072-4c48-87b0-3630fa36a6d0)
]
interface IDXGIFactory2 : IDXGIFactory1
{
   BOOL IsWindowedStereoEnabled(void);

   HRESULT CreateSwapChainForHwnd(
        /* [annotation][in] */
        [in]  IUnknown* pDevice,
        /* [annotation][in] */
        [in]  HWND hWnd,
        /* [annotation][in] */
        [in]  DXGI_SWAP_CHAIN_DESC1* pDesc,
        /* [annotation][in] */
        [in]  DXGI_SWAP_CHAIN_FULLSCREEN_DESC* pFullscreenDesc,
        /* [annotation][in] */
        [in]  IDXGIOutput* pRestrictToOutput,
        /* [annotation][out] */
        [in, out]  IDXGISwapChain1** ppSwapChain);

   HRESULT CreateSwapChainForCoreWindow(
        /* [annotation][in] */
        [in]  IUnknown* pDevice,
        /* [annotation][in] */
        [in]  IUnknown* pWindow,
        /* [annotation][in] */
        [in]  DXGI_SWAP_CHAIN_DESC1* pDesc,
        /* [annotation][in] */
        [in] IDXGIOutput* pRestrictToOutput,
        /* [annotation][out] */
        [in, out]  IDXGISwapChain1** ppSwapChain);

   HRESULT GetSharedResourceAdapterLuid(
        /* [annotation] */
        [in]  HANDLE hResource,
        /* [annotation] */
        [in, out]  LUID* pLuid);

   HRESULT RegisterStereoStatusWindow(
        /* [annotation][in] */
        [in]  HWND WindowHandle,
        /* [annotation][in] */
        [in]  UINT wMsg,
        /* [annotation][out] */
        [in, out]  DWORD* pdwCookie);

   HRESULT RegisterStereoStatusEvent(
        /* [annotation][in] */
        [in]  HANDLE hEvent,
        /* [annotation][out] */
        [in, out]  DWORD* pdwCookie);

    void UnregisterStereoStatus(
        /* [annotation][in] */
        [in]  DWORD dwCookie);

   HRESULT RegisterOcclusionStatusWindow(
        /* [annotation][in] */
        [in]  HWND WindowHandle,
        /* [annotation][in] */
        [in]  UINT wMsg,
        /* [annotation][out] */
        [in, out]  DWORD* pdwCookie);

   HRESULT RegisterOcclusionStatusEvent(
        /* [annotation][in] */
        [in]  HANDLE hEvent,
        /* [annotation][out] */
        [in, out]  DWORD* pdwCookie);

    void UnregisterOcclusionStatus(
        /* [annotation][in] */
        [in]  DWORD dwCookie);

   HRESULT CreateSwapChainForComposition(
        /* [annotation][in] */
        [in]  IUnknown* pDevice,
        /* [annotation][in] */
        [in]  DXGI_SWAP_CHAIN_DESC1* pDesc,
        /* [annotation][in] */
        [in]   IDXGIOutput* pRestrictToOutput,
        /* [annotation][out] */
        [in, out]  IDXGISwapChain1** ppSwapChain);

};

typedef
enum DXGI_GRAPHICS_PREEMPTION_GRANULARITY
{
    DXGI_GRAPHICS_PREEMPTION_DMA_BUFFER_BOUNDARY = 0,
    DXGI_GRAPHICS_PREEMPTION_PRIMITIVE_BOUNDARY = 1,
    DXGI_GRAPHICS_PREEMPTION_TRIANGLE_BOUNDARY = 2,
    DXGI_GRAPHICS_PREEMPTION_PIXEL_BOUNDARY = 3,
    DXGI_GRAPHICS_PREEMPTION_INSTRUCTION_BOUNDARY = 4
} 	DXGI_GRAPHICS_PREEMPTION_GRANULARITY;

typedef
enum DXGI_COMPUTE_PREEMPTION_GRANULARITY
{
    DXGI_COMPUTE_PREEMPTION_DMA_BUFFER_BOUNDARY = 0,
    DXGI_COMPUTE_PREEMPTION_DISPATCH_BOUNDARY = 1,
    DXGI_COMPUTE_PREEMPTION_THREAD_GROUP_BOUNDARY = 2,
    DXGI_COMPUTE_PREEMPTION_THREAD_BOUNDARY = 3,
    DXGI_COMPUTE_PREEMPTION_INSTRUCTION_BOUNDARY = 4
} 	DXGI_COMPUTE_PREEMPTION_GRANULARITY;

typedef struct DXGI_ADAPTER_DESC2
{
    short Description[128];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
    UINT Flags;
    DXGI_GRAPHICS_PREEMPTION_GRANULARITY GraphicsPreemptionGranularity;
    DXGI_COMPUTE_PREEMPTION_GRANULARITY ComputePreemptionGranularity;
} 	DXGI_ADAPTER_DESC2;

[
    odl,
    uuid(0AA1AE0A-FA0E-4B84-8644-E05FF8E5ACB5)
]
interface IDXGIAdapter2 : IDXGIAdapter1
{
   HRESULT GetDesc2(
        /* [annotation][out] */
        [in, out]  DXGI_ADAPTER_DESC2 * pDesc);

};

[
    odl,
    uuid(00cddea8-939b-4b83-a340-a685226666cc)
]
interface IDXGIOutput1 : IDXGIOutput
{
   HRESULT GetDisplayModeList1(
        [in] DXGI_FORMAT EnumFormat,
        [in] UINT Flags,
        /* [annotation][out][in] */
        [in, out]  UINT * pNumModes,
        /* [annotation][out] */
        [out]  DXGI_MODE_DESC1 * pDesc);

   HRESULT FindClosestMatchingMode1(
        /* [annotation][in] */
        [in]  DXGI_MODE_DESC1* pModeToMatch,
        /* [annotation][out] */
        [in, out]  DXGI_MODE_DESC1* pClosestMatch,
        /* [annotation][in] */
        [in]  IUnknown* pConcernedDevice);

   HRESULT GetDisplaySurfaceData1(
        /* [annotation][in] */
        [in]  IDXGIResource* pDestination);

   HRESULT DuplicateOutput(
        /* [annotation][in] */
        [in]  IUnknown* pDevice,
        /* [annotation][out] */
        [in, out]  IDXGIOutputDuplication** ppOutputDuplication);

};


[
    odl,
    uuid(6007896c-3244-4afd-bf18-a6d3beda5023)
]
interface IDXGIDevice3 : IDXGIDevice2
{
    void Trim(void);

};


typedef struct DXGI_MATRIX_3X2_F
{
    FLOAT m_11;
    FLOAT m_12;
    FLOAT m_21;
    FLOAT m_22;
    FLOAT m_31;
    FLOAT m_32;
} 	DXGI_MATRIX_3X2_F;

[
    odl,
    uuid(a8be2ac4-199f-4946-b331-79599fb98de7)
]
interface IDXGISwapChain2 : IDXGISwapChain1
{
   HRESULT SetSourceSize(
        [in] UINT Width,
        [in] UINT Height);

   HRESULT GetSourceSize(
        /* [annotation][out] */
        [in, out]  UINT* pWidth,
        /* [annotation][out] */
        [in, out]  UINT* pHeight);

   HRESULT SetMaximumFrameLatency(
        [in] UINT MaxLatency);

   HRESULT GetMaximumFrameLatency(
        /* [annotation][out] */
        [in, out]  UINT* pMaxLatency);

   HANDLE GetFrameLatencyWaitableObject(void);

   HRESULT SetMatrixTransform(
        [in] DXGI_MATRIX_3X2_F* pMatrix);

   HRESULT GetMatrixTransform(
        /* [annotation][out] */
        [in, out]  DXGI_MATRIX_3X2_F* pMatrix);

};

[
    odl,
    uuid(595e39d1-2724-4663-99b1-da969de28364)
]
interface IDXGIOutput2 : IDXGIOutput1
{
   BOOL SupportsOverlays(void);

};

[
    odl,
    uuid(25483823-cd46-4c7d-86ca-47aa95b837bd)
]
interface IDXGIFactory3 : IDXGIFactory2
{
    UINT GetCreationFlags(void);

};

typedef struct DXGI_DECODE_SWAP_CHAIN_DESC
{
    UINT Flags;
} 	DXGI_DECODE_SWAP_CHAIN_DESC;

typedef
enum DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS
{
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_NOMINAL_RANGE = 0x1,
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_BT709 = 0x2,
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_xvYCC = 0x4
} 	DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS;

[
    odl,
    uuid(2633066b-4514-4c7a-8fd8-12ea98059d18)
]
interface IDXGIDecodeSwapChain : stdole.IUnknown
{
   HRESULT PresentBuffer(
        [in] UINT BufferToPresent,
        [in] UINT SyncInterval,
        [in] UINT Flags);

   HRESULT SetSourceRect(
       [in]  RECT* pRect);

   HRESULT SetTargetRect(
       [in]  RECT* pRect);

   HRESULT SetDestSize(
       [in] UINT Width,
       [in] UINT Height);

   HRESULT GetSourceRect(
        /* [annotation][out] */
        [in, out]  RECT* pRect);

   HRESULT GetTargetRect(
        /* [annotation][out] */
        [in, out]  RECT* pRect);

   HRESULT GetDestSize(
        /* [annotation][out] */
        [in, out]  UINT* pWidth,
        /* [annotation][out] */
        [in, out]  UINT* pHeight);

   HRESULT SetColorSpace(
       [in] DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS ColorSpace);

    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS GetColorSpace(void);

};

[
    odl,
    uuid(41e7d1f2-a591-4f7b-a2e5-fa9c843e1c12)
]
interface IDXGIFactoryMedia : stdole.IUnknown
{
   HRESULT CreateSwapChainForCompositionSurfaceHandle(
        /* [annotation][in] */
        [in]  IUnknown * pDevice,
        /* [annotation][in] */
        [in]  HANDLE hSurface,
        /* [annotation][in] */
        [in]  DXGI_SWAP_CHAIN_DESC1 * pDesc,
        /* [annotation][in] */
        [in] IDXGIOutput * pRestrictToOutput,
        /* [annotation][out] */
        [in, out]  IDXGISwapChain1 * *ppSwapChain);

   HRESULT CreateDecodeSwapChainForCompositionSurfaceHandle(
        /* [annotation][in] */
        [in]  IUnknown* pDevice,
        /* [annotation][in] */
        [in] HANDLE hSurface,
        /* [annotation][in] */
        [in]  DXGI_DECODE_SWAP_CHAIN_DESC* pDesc,
        /* [annotation][in] */
        [in]  IDXGIResource* pYuvDecodeBuffers,
        /* [annotation][in] */
        [in]  IDXGIOutput* pRestrictToOutput,
        /* [annotation][out] */
        [in, out]  IDXGIDecodeSwapChain** ppSwapChain);

};

typedef
enum DXGI_FRAME_PRESENTATION_MODE
{
    DXGI_FRAME_PRESENTATION_MODE_COMPOSED = 0,
    DXGI_FRAME_PRESENTATION_MODE_OVERLAY = 1,
    DXGI_FRAME_PRESENTATION_MODE_NONE = 2,
    DXGI_FRAME_PRESENTATION_MODE_COMPOSITION_FAILURE = 3
} 	DXGI_FRAME_PRESENTATION_MODE;

typedef struct DXGI_FRAME_STATISTICS_MEDIA
{
    UINT PresentCount;
    UINT PresentRefreshCount;
    UINT SyncRefreshCount;
    LARGE_INTEGER SyncQPCTime;
    LARGE_INTEGER SyncGPUTime;
    DXGI_FRAME_PRESENTATION_MODE CompositionMode;
    UINT ApprovedPresentDuration;
} 	DXGI_FRAME_STATISTICS_MEDIA;

[
    odl,
    uuid(dd95b90b-f05f-4f6a-bd65-25bfb264bd84)
]
interface IDXGISwapChainMedia : stdole.IUnknown
{
   HRESULT GetFrameStatisticsMedia(
        /* [annotation][out] */
        [in, out]  DXGI_FRAME_STATISTICS_MEDIA * pStats);

   HRESULT SetPresentDuration(
       [in] UINT Duration);

   HRESULT CheckPresentDurationSupport(
        [in] UINT DesiredPresentDuration,
        /* [annotation][out] */
        [in, out]  UINT* pClosestSmallerPresentDuration,
        /* [annotation][out] */
        [in, out]  UINT* pClosestLargerPresentDuration);

};

typedef
enum DXGI_OVERLAY_SUPPORT_FLAG
{
    DXGI_OVERLAY_SUPPORT_FLAG_DIRECT = 0x1,
    DXGI_OVERLAY_SUPPORT_FLAG_SCALING = 0x2
} 	DXGI_OVERLAY_SUPPORT_FLAG;

[
    odl,
    uuid(8a6bb301-7e7e-41F4-a8e0-5b32f7f99b18)
]
interface IDXGIOutput3 : IDXGIOutput2
{
   HRESULT CheckOverlaySupport(
        /* [annotation][in] */
        [in]  DXGI_FORMAT EnumFormat,
        /* [annotation][out] */
        [in]  IUnknown * pConcernedDevice,
        /* [annotation][out] */
        [in, out]  UINT * pFlags);

};

typedef
enum DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG
{
    DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT = 0x1,
    DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_OVERLAY_PRESENT = 0x2
} 	DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG;


[
    odl,
    uuid(94d99bdb-f1f8-4ab0-b236-7da0170edab1)
]
interface IDXGISwapChain3 : IDXGISwapChain2
{
    UINT GetCurrentBackBufferIndex(void);

   HRESULT CheckColorSpaceSupport(
        /* [annotation][in] */
        [in]  DXGI_COLOR_SPACE_TYPE ColorSpace,
        /* [annotation][out] */
        [in, out]  UINT* pColorSpaceSupport);

   HRESULT SetColorSpace1(
        /* [annotation][in] */
        [in]  DXGI_COLOR_SPACE_TYPE ColorSpace);

   HRESULT ResizeBuffers1(
        /* [annotation][in] */
        [in]  UINT BufferCount,
        /* [annotation][in] */
        [in]  UINT Width,
        /* [annotation][in] */
        [in]  UINT Height,
        /* [annotation][in] */
        [in]  DXGI_FORMAT Format,
        /* [annotation][in] */
        [in]  UINT SwapChainFlags,
        /* [annotation][in] */
       [in]  UINT* pCreationNodeMask,
        /* [annotation][in] */
       [in] IUnknown* ppPresentQueue);

};

typedef
enum DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG
{
    DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG_PRESENT = 0x1
} 	DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG;

[
    odl,
    uuid(dc7dca35-2196-414d-9F53-617884032a60)
]
interface IDXGIOutput4 : IDXGIOutput3
{
   HRESULT CheckOverlayColorSpaceSupport(
        /* [annotation][in] */
        [in]  DXGI_FORMAT Format,
        /* [annotation][in] */
        [in]  DXGI_COLOR_SPACE_TYPE ColorSpace,
        /* [annotation][in] */
        [in]  IUnknown * pConcernedDevice,
        /* [annotation][out] */
        [in, out]  UINT * pFlags);

};

[
    odl,
    uuid(1bc6ea02-ef36-464f-bf0c-21ca39e5168a)
]
interface IDXGIFactory4 : IDXGIFactory3
{
   HRESULT EnumAdapterByLuid(
        /* [annotation] */
        [in]  CURRENCY AdapterLuid,
        /* [annotation] */
        [in]  REFIID riid,
        /* [annotation] */
        [in, out]  void** ppvAdapter);

   HRESULT EnumWarpAdapter(
        /* [annotation] */
        [in]  REFIID riid,
        /* [annotation] */
        [in, out] LPVOID ppvAdapter);

};


typedef
enum DXGI_MEMORY_SEGMENT_GROUP
{
    DXGI_MEMORY_SEGMENT_GROUP_LOCAL = 0,
    DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL = 1
} 	DXGI_MEMORY_SEGMENT_GROUP;

typedef struct DXGI_QUERY_VIDEO_MEMORY_INFO
{
    UINT64 Budget;
    UINT64 CurrentUsage;
    UINT64 AvailableForReservation;
    UINT64 CurrentReservation;
} 	DXGI_QUERY_VIDEO_MEMORY_INFO;

[
    odl,
    uuid(645967A4-1392-4310-A798-8053CE3E93FD)
]
interface IDXGIAdapter3 : IDXGIAdapter2
{
   HRESULT RegisterHardwareContentProtectionTeardownStatusEvent(
        /* [annotation][in] */
        [in]  HANDLE hEvent,
        /* [annotation][out] */
        [in, out]  DWORD * pdwCookie);

    void UnregisterHardwareContentProtectionTeardownStatus(
        /* [annotation][in] */
        [in]  DWORD dwCookie);

   HRESULT QueryVideoMemoryInfo(
        /* [annotation][in] */
        [in]  UINT NodeIndex,
        /* [annotation][in] */
        [in]  DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,
        /* [annotation][out] */
        [in, out]  DXGI_QUERY_VIDEO_MEMORY_INFO* pVideoMemoryInfo);

   HRESULT SetVideoMemoryReservation(
        /* [annotation][in] */
        [in]  UINT NodeIndex,
        /* [annotation][in] */
        [in]  DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,
        /* [annotation][in] */
        [in]  UINT64 Reservation);

   HRESULT RegisterVideoMemoryBudgetChangeNotificationEvent(
        /* [annotation][in] */
        [in]  HANDLE hEvent,
        /* [annotation][out] */
        [in, out]  DWORD* pdwCookie);

    void UnregisterVideoMemoryBudgetChangeNotification(
        /* [annotation][in] */
        [in]  DWORD dwCookie);

};

typedef
enum DXGI_OUTDUPL_FLAG
{
    DXGI_OUTDUPL_COMPOSITED_UI_CAPTURE_ONLY = 1
} 	DXGI_OUTDUPL_FLAG;


[
    odl,
    uuid(80A07424-AB52-42EB-833C-0C42FD282D98)
]
interface IDXGIOutput5 : IDXGIOutput4
{
   HRESULT DuplicateOutput1(
        /* [annotation][in] */
        [in]  IUnknown * pDevice,
        [in] UINT Flags,
        /* [annotation][in] */
        [in]  UINT SupportedFormatsCount,
        /* [annotation][in] */
        [in] DXGI_FORMAT * pSupportedFormats,
        /* [annotation][out] */
        [in, out]  IDXGIOutputDuplication * *ppOutputDuplication);

};

typedef
enum DXGI_HDR_METADATA_TYPE
{
    DXGI_HDR_METADATA_TYPE_NONE = 0,
    DXGI_HDR_METADATA_TYPE_HDR10 = 1
} 	DXGI_HDR_METADATA_TYPE;

typedef struct DXGI_HDR_METADATA_HDR10
{
    UINT16 RedPrimary[2];
    UINT16 GreenPrimary[2];
    UINT16 BluePrimary[2];
    UINT16 WhitePoint[2];
    UINT MaxMasteringLuminance;
    UINT MinMasteringLuminance;
    UINT16 MaxContentLightLevel;
    UINT16 MaxFrameAverageLightLevel;
} 	DXGI_HDR_METADATA_HDR10;

[
    odl,
    uuid(3D585D5A-BD4A-489E-B1F4-3DBCB6452FFB)
]
interface IDXGISwapChain4 : IDXGISwapChain3
{
   HRESULT SetHDRMetaData(
        /* [annotation][in] */
        [in]  DXGI_HDR_METADATA_TYPE Type,
        /* [annotation][in] */
        [in]  UINT Size,
        /* [annotation][size_is][in] */
        [in] void* pMetaData);

};

typedef
enum _DXGI_OFFER_RESOURCE_FLAGS
{
    DXGI_OFFER_RESOURCE_FLAG_ALLOW_DECOMMIT = 0x1
} 	DXGI_OFFER_RESOURCE_FLAGS;

typedef
enum _DXGI_RECLAIM_RESOURCE_RESULTS
{
    DXGI_RECLAIM_RESOURCE_RESULT_OK = 0,
    DXGI_RECLAIM_RESOURCE_RESULT_DISCARDED = 1,
    DXGI_RECLAIM_RESOURCE_RESULT_NOT_COMMITTED = 2
} 	DXGI_RECLAIM_RESOURCE_RESULTS;

[
    odl,
    uuid(95B4F95F-D8DA-4CA4-9EE6-3B76D5968A10)
]
interface IDXGIDevice4 : IDXGIDevice3
{
   HRESULT OfferResources1(
        /* [annotation][in] */
        [in]  UINT NumResources,
        /* [annotation][size_is][in] */
       [in]  IDXGIResource* ppResources,
        /* [annotation][in] */
        [in]  DXGI_OFFER_RESOURCE_PRIORITY Priority,
        /* [annotation][in] */
        [in]  UINT Flags);

   HRESULT ReclaimResources1(
        /* [annotation][in] */
        [in]  UINT NumResources,
        /* [annotation][size_is][in] */
       [in]   IDXGIResource* ppResources,
        /* [annotation][size_is][out] */
        [out]  DXGI_RECLAIM_RESOURCE_RESULTS* pResults);

};

typedef
enum DXGI_FEATURE
{
    DXGI_FEATURE_PRESENT_ALLOW_TEARING = 0
} 	DXGI_FEATURE;

[
    odl,
    uuid(7632e1f5-ee65-4dca-87fd-84cd75f8838d)
]
interface IDXGIFactory5 : IDXGIFactory4
{
   HRESULT CheckFeatureSupport(
       [in] DXGI_FEATURE Feature,
        /* [annotation] */
       [in]   void* pFeatureSupportData,
       [in]  UINT FeatureSupportDataSize);

};

typedef
enum DXGI_ADAPTER_FLAG3
{
    DXGI_ADAPTER_FLAG3_NONE = 0,
    DXGI_ADAPTER_FLAG3_REMOTE = 1,
    DXGI_ADAPTER_FLAG3_SOFTWARE = 2,
    DXGI_ADAPTER_FLAG3_ACG_COMPATIBLE = 4,
    DXGI_ADAPTER_FLAG3_SUPPORT_MONITORED_FENCES = 8,
    DXGI_ADAPTER_FLAG3_SUPPORT_NON_MONITORED_FENCES = 0x10,
    DXGI_ADAPTER_FLAG3_KEYED_MUTEX_CONFORMANCE = 0x20,
    DXGI_ADAPTER_FLAG3_FORCE_DWORD = 0xffffffff
} 	DXGI_ADAPTER_FLAG3;

typedef struct DXGI_ADAPTER_DESC3
{
    short Description[128];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
    DXGI_ADAPTER_FLAG3 Flags;
    DXGI_GRAPHICS_PREEMPTION_GRANULARITY GraphicsPreemptionGranularity;
    DXGI_COMPUTE_PREEMPTION_GRANULARITY ComputePreemptionGranularity;
} 	DXGI_ADAPTER_DESC3;

[
    odl,
    uuid(3c8d99d1-4fbf-4181-a82c-af66bf7bd24e)
]
interface IDXGIAdapter4 : IDXGIAdapter3
{
   HRESULT GetDesc3(
        /* [annotation][out] */
        [in, out]  DXGI_ADAPTER_DESC3 * pDesc);

};

typedef struct DXGI_OUTPUT_DESC1
{
    short DeviceName[32];
    RECT DesktopCoordinates;
    BOOL AttachedToDesktop;
    DXGI_MODE_ROTATION Rotation;
    HMONITOR Monitor;
    UINT BitsPerColor;
    DXGI_COLOR_SPACE_TYPE ColorSpace;
    FLOAT RedPrimary[2];
    FLOAT GreenPrimary[2];
    FLOAT BluePrimary[2];
    FLOAT WhitePoint[2];
    FLOAT MinLuminance;
    FLOAT MaxLuminance;
    FLOAT MaxFullFrameLuminance;
} 	DXGI_OUTPUT_DESC1;

typedef
enum DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS
{
    DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_FULLSCREEN = 1,
    DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_WINDOWED = 2,
    DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_CURSOR_STRETCHED = 4
} 	DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS;

[
    odl,
    uuid(068346e8-aaec-4b84-add7-137f513f77a1)
]
interface IDXGIOutput6 : IDXGIOutput5
{
   HRESULT GetDesc1(
        /* [annotation][out] */
        [in, out]  DXGI_OUTPUT_DESC1 * pDesc);

   HRESULT CheckHardwareCompositionSupport(
        /* [annotation][out] */
        [in, out]  UINT* pFlags);

}

typedef enum PageCountType
{
    FinalPageCount = 0,
    IntermediatePageCount,
} PageCountType;


[
    odl,
    uuid(1a6dd0ad-1e2a-4e99-a5ba-91f17818290e),
    helpstring("Print Preview IPrintPreviewDxgiPackageTarget interface.")
]
interface IPrintPreviewDxgiPackageTarget : stdole.IUnknown
{
    HRESULT SetJobPageCount(
        [in] PageCountType countType,
        [in] UINT32 count);

    HRESULT DrawPage(
        [in] UINT32 jobPageNumber,
        [in] IDXGISurface* pageImage,
        [in] FLOAT dpiX,
        [in] FLOAT dpiY);

    HRESULT InvalidatePreview();
}






typedef struct SystemInterruptTime
{
    UINT64 value;
} SystemInterruptTime;

// 3x2 Presentation Transform
typedef struct PresentationTransform
{
    float M11;
    float M12;
    float M21;
    float M22;
    float M31;
    float M32;
} PresentationTransform;

// An identifier for a composition frame. This frame is reported back in composition frame
// statistics and can be passed into other APIs, such as the composition timing API
// (e.g. DCompositionGetTargetStatistics)
typedef UINT64 CompositionFrameId;

// Statistics kind enumeration
typedef enum PresentStatisticsKind
{
    PresentStatisticsKind_PresentStatus = 1,
    PresentStatisticsKind_CompositionFrame = 2,
    PresentStatisticsKind_IndependentFlipFrame = 3,

    // Future versions of the API will extend this enumeration
} PresentStatisticsKind;



[
    odl,
    uuid(2E217D3A-5ABB-4138-9A13-A775593C89CA)
]
interface IPresentationBuffer : stdole.IUnknown
{
    // Return back the available event for the presentation buffer. Callers are responsible
    // for closing the event returned here. An application can wait on and query this event, but
    // it cannot modify its state. The presentation manager controls this event.
    HRESULT GetAvailableEvent(
        [out, retval] HANDLE* availableEventHandle);

    // Return back whether or not this buffer is available for use by the producer.
    HRESULT IsAvailable(
        [out, retval] boolean* isAvailable);
}


// Content marker. All types of presentation content will derive from this interface.
[
    odl,
    uuid(5668BB79-3D8E-415C-B215-F38020F2D252)
]
interface IPresentationContent : stdole.IUnknown
{
    // A user-defined tag to associate with this content. This tag is how the content will be
    // referenced in statistics.
    void SetTag(
        [in] UINT_PTR tag);
}


// Describes an IPresentationContent with a single bound buffer, that can shared with the system
// compositor and displayed as content in the global visual tree
[
    odl,
    uuid(956710FB-EA40-4EBA-A3EB-4375A0EB4EDC)
]
interface IPresentationSurface : IPresentationContent
{
    HRESULT SetBuffer(
        [in] IPresentationBuffer* presentationBuffer);

    HRESULT SetColorSpace(
        [in] DXGI_COLOR_SPACE_TYPE colorSpace);

    HRESULT SetAlphaMode(
        [in] DXGI_ALPHA_MODE alphaMode);

    // Area of source presentation buffer to sample from.
    HRESULT SetSourceRect(
        [in] RECT* sourceRect);

    // Applied to source buffer area to define the area on screen the buffer will appear.
    HRESULT SetTransform(
        [in] PresentationTransform* transform);

    // Display restriction. Currently, an IDXGIOutput is the only accepted form of currency.
    HRESULT RestrictToOutput(
        [in] IUnknown* output);

    // Readback disable flag. Prevents the compositor from ever rendering the buffer into a form
    // of capture (screen capture, window capture, etc.)
    HRESULT SetDisableReadback(
        [in] boolean value);

    // Letterboxing margins. The size, in visual space, that each letterboxing area takes. Margins
    // are not affected by the scale component of the transform, but are affected by every other
    // component. Put another, the margins are applied with the transform applied, but compensate
    // their own size by any scale present in that transform.
    HRESULT SetLetterboxingMargins(
        [in] float leftLetterboxSize,
        [in] float topLetterboxSize,
        [in] float rightLetterboxSize,
        [in] float bottomLetterboxSize);
}


// Describes a single entry in the present statistics queue. All statistics interfaces will inherit
// from this interface. IPresentStatistics can be QI'd to its more specific kind corresponding to
// GetKind().
[
    odl,
    uuid(B44B8BDA-7282-495D-9DD7-CEADD8B4BB86)
]
interface IPresentStatistics : stdole.IUnknown
{
    // Return back the present Id this statistic corresponds to.
    UINT64 GetPresentId();

    // Report the kind of statistic this data corresponds to.
    PresentStatisticsKind GetKind();
}


// Presentation manager - the main presentation management interface.
[
    odl,
    uuid(FB562F82-6292-470A-88B1-843661E7F20C)
]
interface IPresentationManager : stdole.IUnknown
{
    // Add an IUnknown-based buffer resource object to the presentation manager to be tracked as a
    // presentation buffer. Currently, this resource must be a NT-handle shareable DXGI resource.
    // Specifically, we must be able to QueryInterface IDXGIResource from it, and the resource
    // itself must have been created with the D3D11_RESOURCE_MISC_SHARED_NTHANDLE MiscFlag.
    HRESULT AddBufferFromResource(
        [in] IUnknown* resource, // Pointer to an IUnknown-based buffer resource
        [out, retval] IPresentationBuffer** presentationBuffer); // The returned presentation
                                                                  // buffer referencing the DXGI
                                                                  // resource.

    // Create a presentation surface a piece of content that can be hosted in a visual tree,
    // and assigned a single front buffer.
    HRESULT CreatePresentationSurface(
        [in] HANDLE compositionSurfaceHandle, // Composition surface handle to bind to the
                                              // presentation surface to.
        [out, retval] IPresentationSurface** presentationSurface);

    // Return back the Present Id for the next present. All synchronization fences will be signaled
    // to this value when referring to that present.
    UINT64 GetNextPresentId();

    // Set a target time for the next present. The system will attempt to display the present as
    // close to that time as possible. This parameter setting persists across presents.
    HRESULT SetTargetTime(
        [in] SystemInterruptTime targetTime);

    // The preferred frame duration - meant to be used as a hint to the system that it would be
    // preferred to refresh the output at the specified framerate. Displays which support this
    // rate, or a multiple, will be set into that mode if appropriate. This parameter setting
    // persists across presents.
    HRESULT SetPreferredPresentDuration(
        [in] SystemInterruptTime preferredDuration,   // Requested duration, in interrupt time
        [in] SystemInterruptTime deviationTolerance); // The allowed tolerance. If the magnitude
                                                      // of the difference between a supported
                                                      // system duration and the preferredDuration
                                                      // parameter is within the deviationTolerance
                                                      // parameter, that system duration will be used.

    // In order to take advantage of systems with hardware flip queue support, presents can be
    // handled completely by the GPU without CPU involvement. This has power-saving benefits, but
    // also means that buffer available events, the present retiring fence, and present statistics
    // may not update immediately when the present is shown, but instead may update quite a bit later
    // when the GPU periodically updates the CPU regarding what it has done independently.
    //
    // An application can allow certain presents it doesn't need immediate feedback about to
    // participate in this behavior by explicitly controlling whether the GPU should issue a vsync
    // interrupt when each is shown. If not, such presents will result in improved power efficiency,
    // at the cost of delayed feedback.
    //
    // By default, presents will always force a vsync interrupt. Applications can opt into allowing
    // some presents to not force a vsync interrupt by calling this method. If a system does not
    // offer hardware flip queue support, all presents will issue a vsync interrupt and update the
    // CPU, regardless of this setting.
    //
    // This parameter setting persists across presents. 
    HRESULT ForceVSyncInterrupt(
        [in] boolean forceVsyncInterrupt);

    // Present this presentation manager. Note that if the presentation manager has become lost,
    // this call will return PRESENTATION_ERROR_LOST, and upon receiving that error, an application
    // must destroy this presentation manager and create a new one.
    HRESULT Present();

    // This fence will be signaled to the Present Id of each present when that present has begun
    // retiring - that is, a subsequent present has been queued to take its place.
    HRESULT GetPresentRetiringFence(
        [in] REFIID riid,
        [out, retval] LongPtr* fence);

    // Cancel any previously issued and still in-flight presents which have not yet displayed,
    // and whose Present Ids are at least the passed presentIdToCancelFrom. If any presents in
    // the past have already been displayed, this call will not fail - those presents will simply
    // not be canceled. The present retiring fence will not be signaled for any canceled presents,
    // because when presents are canceled, they don't affect the currently displayed present, or
    // cause it to begin the retiring process. For this reason, it is suggested that after
    // performing a present, an application queries buffer available events to find an available
    // buffer to issue on the first present after a cancel. Once that present is queued, it allows
    // the previously displayed present to begin the retiring process, and signal the present
    // retiring fence.
    HRESULT CancelPresentsFrom(
        [in] UINT64 presentIdToCancelFrom);

    // The returned event will be signaled when the presentation manager hits an error it cannot
    // recover from. In this case, the application should release this presentation manager and
    // create a new one. An application can wait on and query this event, but not modify. It is
    // controlled by the presentation manager.
    HRESULT GetLostEvent(
        [out, retval] HANDLE* lostEventHandle);

    // The returned event will be signaled when present statistics are available to report. The
    // caller is responsible for closing the event returned here. An application can wait on and
    // query this event, but cannot modify its state. The presentation API controls this event.
    // The caller is responsible for closing the returned event.
    HRESULT GetPresentStatisticsAvailableEvent(
        [out, retval] HANDLE* presentStatisticsAvailableEventHandle);

    // Enable/disable the specified present statistics kind. Change takes place "as soon as
    // possible", however effects can be delayed. It is suggested that application register all
    // desired present statistics before issuing presents, and not change during usage. This is
    // also how statistics can be extended and changed in the future without breaking backwards
    // compatibility.
    HRESULT EnablePresentStatisticsKind(
        [in] PresentStatisticsKind presentStatisticsKind,
        [in] boolean enabled);

    // Return back the next statistics item in the queue. If the present statistics queue is
    // empty, no error will be returned. Instead, nullptr will be returned in the out parameter.
    HRESULT GetNextPresentStatistics(
        [out, retval] IPresentStatistics** nextPresentStatistics);
}


// Presentation factory - interface used to query system support for presentation, and create a
// presentation manager.
[
    odl,
    uuid(8FB37B58-1D74-4F64-A49C-1F97A80A2EC0)
]
interface IPresentationFactory : stdole.IUnknown
{
    // Indicate whether presentation of any sort (with or without independent flip) is supported
    // on the backing d3d device.
    boolean IsPresentationSupported();

    // Indicate whether independent-flip-enabled presentation is supported on the backing d3d
    // device.
    boolean IsPresentationSupportedWithIndependentFlip();

    // Create a presentation manager.
    HRESULT CreatePresentationManager(
        [out, retval] IPresentationManager** ppPresentationManager);
}


// IPresentStatusStatistics statistic.
// The status of a present - how it was handled based on timing, and whether it was canceled.
typedef enum PresentStatus
{
    // The frame was queued by the system to eventually be shown.
    PresentStatus_Queued = 0,

    // The frame was skipped because a later frame was a better candidate to show.
    PresentStatus_Skipped = 1,

    // The frame arrived, but was canceled by the application, so it was not displayed.
    PresentStatus_Canceled = 2
} PresentStatus;

// Describes how a present was processed during a DWM-composed frame.
[
    odl,
    uuid(C9ED2A41-79CB-435E-964E-C8553055420C)
]
interface IPresentStatusPresentStatistics : IPresentStatistics
{
    // The Composition frame Id on which the present was processed, skipped, or canceled.
    CompositionFrameId GetCompositionFrameId();

    // The status of the frame.
    PresentStatus GetPresentStatus();
}


// ICompositionFramePresentStatistics statistic.
// Instance kind - how the content was used in a composition frame
typedef enum CompositionFrameInstanceKind
{
    // Composed directly to DWM's backbuffer.
    CompositionFrameInstanceKind_ComposedOnScreen = 0,

    // Directly scanned out in an MPO plane.
    CompositionFrameInstanceKind_ScanoutOnScreen = 1,

    // Composed to an intermediate.
    CompositionFrameInstanceKind_ComposedToIntermediate = 2,
} CompositionFrameInstanceKind;

// A single instance of the content shown on a single output.
typedef struct CompositionFrameDisplayInstance
{
    // The output that this instance was displayed on.
    LUID displayAdapterLUID;
    UINT displayVidPnSourceId;
    UINT displayUniqueId;

    // The LUID of the render adapter used to render this instance in the composition frame
    LUID renderAdapterLUID;

    // The kind of instance.
    CompositionFrameInstanceKind instanceKind;

    // Accumulated transform on screen of displayed content, including all transforms of ancestor
    // visuals, if applicable.
    PresentationTransform finalTransform;

    // Whether or not a copy took place to display this instance due to the destination being
    // a different adapter than the allocation's adapter.
    boolean requiredCrossAdapterCopy;

    // Color space of the output this instance was shown on.
    DXGI_COLOR_SPACE_TYPE colorSpace;
} CompositionFrameDisplayInstance;

// Composition frame statistics - describes how the system displayed an instance of a particular
// piece of content within a particular present. Note that there may be many frames for which a
// present is on screen. Statistics are only reported for the first composition frame on which
// a present appears.
[
    odl,
    uuid(AB41D127-C101-4C0A-911D-F9F2E9D08E64)
]
interface ICompositionFramePresentStatistics : IPresentStatistics
{
    // The tag of the content on which we are reporting.
    UINT_PTR GetContentTag();

    // The Id of the composition frame, to be used in other APIs to get more detailed information.
    CompositionFrameId GetCompositionFrameId();

    // The array of display instances and its count. This data is valid for the lifetime of the
    // ICompositionFramePresentStatistics, and should not be read after the
    // ICompositionFramePresentStatistics is released.
    void GetDisplayInstanceArray(
        [out] UINT* displayInstanceArrayCount,
        [out] LongPtr* displayInstanceArray);
        //[out] const CompositionFrameDisplayInstance** displayInstanceArray);
}


// IIndependentFlipFramePresentStatistics statistic.
// A statistic to describe information about an iflip present
[
    odl,
    uuid(8C93BE27-AD94-4DA0-8FD4-2413132D124E)
]
interface IIndependentFlipFramePresentStatistics : IPresentStatistics
{
    // The output that this iflip occurred on.
    LUID GetOutputAdapterLUID();
    UINT GetOutputVidPnSourceId();

    // The tag of the content that is being reported.
    UINT_PTR GetContentTag();

    // The time the present was displayed.
    SystemInterruptTime GetDisplayedTime();

    // Get the actual present duration. Note this may be different than the preferred present
    // duration requested by the application if the system decided not to honor the preferred
    // duration, usually because it was either not supported by the driver, or other content
    // on screen meant the system decided it was best to go with another duration.
    SystemInterruptTime GetPresentDuration();
};







