'*****************************************************************************************
'This file is a part of WinDevLib - Windows Development Library for twinBASIC
'https://github.com/fafalone/WinDevLib
'Code ported by Jon Johnson. 
'"Windows" is a trademark of the Microsoft Corporation.
'Certain Description attributes (c) Microsoft, taken from SDK headers and official docs.
'Licensed under Creative Commons CC0 1.0 Universal
'*****************************************************************************************

'wdDirectShow - quartz.dll plus oleexp additions; includes mDirectShow.bas.
'  Additional tB-only extended DShow coverage
#If WDL_NO_DIRECTX = 0 Then

'QUARTZ
    [InterfaceId("56A868C0-0AD4-11CE-B03A-0020AF0BA770")]
    [Description("IMediaEventEx interface")]
    [OleAutomation(False)]
    Interface IMediaEventEx Extends IMediaEvent
        Sub SetNotifyWindow(ByVal hwnd As LongPtr, ByVal lMsg As Long, ByVal lInstanceData As LongPtr)
        Sub SetNotifyFlags(ByVal lNoNotifyFlags As AM_MEDIAEVENT_FLAGS)
        Sub GetNotifyFlags(ByRef lplNoNotifyFlags As AM_MEDIAEVENT_FLAGS)
    End Interface

   

    [InterfaceId("329BB360-F6EA-11D1-9038-00A0C9697298")]
    [Description("IBasicVideo2")]
    [OleAutomation(False)]
    Interface IBasicVideo2 Extends IBasicVideo
        Sub GetPreferredAspectRatio(ByRef plAspectX As Long, ByRef plAspectY As Long)
    End Interface

    [InterfaceId("56A868B8-0AD4-11CE-B03A-0020AF0BA770")]
    [Description("IDeferredCommand")]
    [OleAutomation(False)]
    Interface IDeferredCommand Extends stdole.IUnknown
        Sub Cancel()
        Sub Confidence(ByRef pConfidence As Long)
        Sub Postpone(ByVal newtime As Double)
        Sub GetHResult(ByRef phrResult As Long)
    End Interface

    [InterfaceId("56A868B7-0AD4-11CE-B03A-0020AF0BA770")]
    [Description("IQueueCommand")]
    [OleAutomation(False)]
    Interface IQueueCommand Extends stdole.IUnknown
        Sub InvokeAtStreamTime(ByRef pCmd As IDeferredCommand, ByVal time As Double, ByRef iid As UUID, ByVal dispidMethod As Long, [TypeHint(DispatchTypes)] ByVal wFlags As Integer, ByVal cArgs As Long, ByRef pDispParams As Variant, ByRef pvarResult As Variant, ByRef puArgErr As Integer)
        Sub InvokeAtPresentationTime(ByRef pCmd As IDeferredCommand, ByVal time As Double, ByRef iid As UUID, ByVal dispidMethod As Long, [TypeHint(DispatchTypes)] ByVal wFlags As Integer, ByVal cArgs As Long, ByRef pDispParams As Variant, ByRef pvarResult As Variant, ByRef puArgErr As Integer)
    End Interface


    [InterfaceId("56A868B9-0AD4-11CE-B03A-0020AF0BA770")]
   ' [ DualInterface, COMExtensible]
    [Description("Collection")]
    [OleAutomation(False)]
    Interface IAMCollection Extends stdole.IDispatch
        [DispId(&H60020000)]
        Property Get Count() As Long
        [DispId(&H60020001)]
        Sub Item(ByVal lItem As Long, ByRef ppUnk As IUnknown)
        [DispId(&H60020002)]
        Property Get _NewEnum() As IUnknown
    End Interface

    [InterfaceId("56A868B1-0AD4-11CE-B03A-0020AF0BA770")]
    '[ DualInterface, COMExtensible]
    [Description("IMediaControl interface")]
    [OleAutomation(False)]
    Interface IMediaControl Extends stdole.IDispatch
        [DispId(&H60020000)]
        Sub Run()
        [DispId(&H60020001)]
        Sub Pause()
        [DispId(&H60020002)]
        Sub Stop()
        [DispId(&H60020003)]
        Sub GetState(ByVal msTimeout As Long, ByRef pfs As FILTER_STATE)
        [DispId(&H60020004)]
        Sub RenderFile(ByVal strFilename As String)
        [DispId(&H60020005)]
        Sub AddSourceFilter(ByVal strFilename As String, ByRef ppUnk As stdole.IDispatch)
        [DispId(&H60020006)]
        Property Get FilterCollection() As stdole.IDispatch
        [DispId(&H60020007)]
        Property Get RegFilterCollection() As stdole.IDispatch
        [DispId(&H60020008)]
        Sub StopWhenReady()
    End Interface

    [InterfaceId("56A868B6-0AD4-11CE-B03A-0020AF0BA770")]
    '[ DualInterface, COMExtensible]
    [Description("IMediaEvent interface")]
    [OleAutomation(False)]
    Interface IMediaEvent Extends stdole.IDispatch
        [DispId(&H60020000)]
        Sub GetEventHandle(ByVal hEvent As LongPtr)
        [DispId(&H60020001)]
        Sub GetEvent(ByRef lEventCode As EC_CODES, ByVal lParam1 As LongPtr, ByVal lParam2 As LongPtr, ByVal msTimeout As Long)
        [DispId(&H60020002)]
        Sub WaitForCompletion(ByVal msTimeout As Long, ByRef pEvCode As EC_CODES)
        [DispId(&H60020003)]
        Sub CancelDefaultHandling(ByVal lEvCode As EC_CODES)
        [DispId(&H60020004)]
        Sub RestoreDefaultHandling(ByVal lEvCode As EC_CODES)
        [DispId(&H60020005)]
        Sub FreeEventParams(ByVal lEvCode As EC_CODES, ByVal lParam1 As LongPtr, ByVal lParam2 As LongPtr)
    End Interface

    [InterfaceId("56A868B2-0AD4-11CE-B03A-0020AF0BA770")]
   ' [ DualInterface, COMExtensible]
    [Description("IMediaPosition interface")]
    [OleAutomation(False)]
    Interface IMediaPosition Extends stdole.IDispatch
        [DispId(&H60020000)]
        Property Get Duration() As Double
        [DispId(&H60020001)]
        Property Let CurrentPosition(ByVal pllTime As Double)
        [DispId(&H60020001)]
        Property Get CurrentPosition() As Double
        [DispId(&H60020003)]
        Property Get StopTime() As Double
        [DispId(&H60020003)]
        Property Let StopTime(ByVal pllTime As Double)
        [DispId(&H60020005)]
        Property Get PrerollTime() As Double
        [DispId(&H60020005)]
        Property Let PrerollTime(ByVal pllTime As Double)
        [DispId(&H60020007)]
        Property Let Rate(ByVal pdRate As Double)
        [DispId(&H60020007)]
        Property Get Rate() As Double
        [DispId(&H60020009)]
        Function CanSeekForward() As Long
        [DispId(&H6002000A)]
        Function CanSeekBackward() As Long
    End Interface

    [InterfaceId("56A868B3-0AD4-11CE-B03A-0020AF0BA770")]
   ' [ DualInterface, COMExtensible]
    [Description("IBasicAudio interface")]
    [OleAutomation(False)]
    Interface IBasicAudio Extends stdole.IDispatch
        [DispId(&H60020000)]
        Property Let Volume(ByVal plVolume As Long)
        [DispId(&H60020000)]
        Property Get Volume() As Long
        [DispId(&H60020002)]
        Property Let Balance(ByVal plBalance As Long)
        [DispId(&H60020002)]
        Property Get Balance() As Long
    End Interface

    [InterfaceId("56A868B4-0AD4-11CE-B03A-0020AF0BA770")]
   ' [ DualInterface, COMExtensible]
    [Description("IVideoWindow interface")]
    [OleAutomation(False)]
    Interface IVideoWindow Extends stdole.IDispatch
        [DispId(&H60020000)]
        Property Let Caption(ByVal strCaption As String)
        [DispId(&H60020000)]
        Property Get Caption() As String
        #If WINDEVLIB_LITE Then
        [DispId(&H60020002)]
        Property Let WindowStyle(ByVal WindowStyle As Long)
        [DispId(&H60020002)]
        Property Get WindowStyle() As Long
        [DispId(&H60020004)]
        Property Let WindowStyleEx(ByVal WindowStyleEx As Long)
        [DispId(&H60020004)]
        Property Get WindowStyleEx() As Long
        #Else
        [DispId(&H60020002)]
        Property Let WindowStyle(ByVal WindowStyle As WindowStyles)
        [DispId(&H60020002)]
        Property Get WindowStyle() As WindowStyles
        [DispId(&H60020004)]
        Property Let WindowStyleEx(ByVal WindowStyleEx As WindowStylesEx)
        [DispId(&H60020004)]
        Property Get WindowStyleEx() As WindowStylesEx
        #End If
        [DispId(&H60020006)]
        Property Let AutoShow(ByVal AutoShow As Long)
        [DispId(&H60020006)]
        Property Get AutoShow() As Long
        [DispId(&H60020008)]
        Property Let WindowState(ByVal WindowState As eSHOWWINDOW)
        [DispId(&H60020008)]
        Property Get WindowState() As eSHOWWINDOW
        [DispId(&H6002000A)]
        Property Let BackgroundPalette(ByVal pBackgroundPalette As Long)
        [DispId(&H6002000A)]
        Property Get BackgroundPalette() As Long
        [DispId(&H6002000C)]
        Property Let Visible(ByVal pVisible As Long)
        [DispId(&H6002000C)]
        Property Get Visible() As Long
        [DispId(&H6002000E)]
        Property Let Left(ByVal pLeft As Long)
        [DispId(&H6002000E)]
        Property Get Left() As Long
        [DispId(&H60020010)]
        Property Let Width(ByVal pWidth As Long)
        [DispId(&H60020010)]
        Property Get Width() As Long
        [DispId(&H60020012)]
        Property Let Top(ByVal pTop As Long)
        [DispId(&H60020012)]
        Property Get Top() As Long
        [DispId(&H60020014)]
        Property Let Height(ByVal pHeight As Long)
        [DispId(&H60020014)]
        Property Get Height() As Long
        [DispId(&H60020016)]
        Property Let Owner(ByVal Owner As LongPtr)
        [DispId(&H60020016)]
        Property Get Owner() As LongPtr
        [DispId(&H60020018)]
        Property Let MessageDrain(ByVal Drain As LongPtr)
        [DispId(&H60020018)]
        Property Get MessageDrain() As LongPtr
        [DispId(&H6002001A)]
        Property Get BorderColor() As Long
        [DispId(&H6002001A)]
        Property Let BorderColor(ByVal Color As Long)
        [DispId(&H6002001C)]
        Property Get FullScreenMode() As Long
        [DispId(&H6002001C)]
        Property Let FullScreenMode(ByVal FullScreenMode As Long)
        [DispId(&H6002001E)]
        Sub SetWindowForeground(ByVal Focus As Long)
        [DispId(&H6002001F)]
        Sub NotifyOwnerMessage(ByVal hwnd As LongPtr, ByVal uMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr)
        [DispId(&H60020020)]
        Sub SetWindowPosition(ByVal Left As Long, ByVal Top As Long, ByVal Width As Long, ByVal Height As Long)
        [DispId(&H60020021)]
        Sub GetWindowPosition(ByRef pLeft As Long, ByRef pTop As Long, ByRef pWidth As Long, ByRef pHeight As Long)
        [DispId(&H60020022)]
        Sub GetMinIdealImageSize(ByRef pWidth As Long, ByRef pHeight As Long)
        [DispId(&H60020023)]
        Sub GetMaxIdealImageSize(ByRef pWidth As Long, ByRef pHeight As Long)
        [DispId(&H60020024)]
        Sub GetRestorePosition(ByRef pLeft As Long, ByRef pTop As Long, ByRef pWidth As Long, ByRef pHeight As Long)
        [DispId(&H60020025)]
        Sub HideCursor(ByVal HideCursor As Long)
        [DispId(&H60020026)]
        Sub IsCursorHidden(ByRef CursorHidden As Long)
    End Interface

    [InterfaceId("56A868B5-0AD4-11CE-B03A-0020AF0BA770")]
   ' [ DualInterface, COMExtensible]
    [Description("IBasicVideo interface")]
    [OleAutomation(False)]
    Interface IBasicVideo Extends stdole.IDispatch
        [DispId(&H60020000)]
        Property Get AvgTimePerFrame() As Double
        [DispId(&H60020001)]
        Property Get BitRate() As Long
        [DispId(&H60020002)]
        Property Get BitErrorRate() As Long
        [DispId(&H60020003)]
        Property Get VideoWidth() As Long
        [DispId(&H60020004)]
        Property Get VideoHeight() As Long
        [DispId(&H60020005)]
        Property Let SourceLeft(ByVal pSourceLeft As Long)
        [DispId(&H60020005)]
        Property Get SourceLeft() As Long
        [DispId(&H60020007)]
        Property Let SourceWidth(ByVal pSourceWidth As Long)
        [DispId(&H60020007)]
        Property Get SourceWidth() As Long
        [DispId(&H60020009)]
        Property Let SourceTop(ByVal pSourceTop As Long)
        [DispId(&H60020009)]
        Property Get SourceTop() As Long
        [DispId(&H6002000B)]
        Property Let SourceHeight(ByVal pSourceHeight As Long)
        [DispId(&H6002000B)]
        Property Get SourceHeight() As Long
        [DispId(&H6002000D)]
        Property Let DestinationLeft(ByVal pDestinationLeft As Long)
        [DispId(&H6002000D)]
        Property Get DestinationLeft() As Long
        [DispId(&H6002000F)]
        Property Let DestinationWidth(ByVal pDestinationWidth As Long)
        [DispId(&H6002000F)]
        Property Get DestinationWidth() As Long
        [DispId(&H60020011)]
        Property Let DestinationTop(ByVal pDestinationTop As Long)
        [DispId(&H60020011)]
        Property Get DestinationTop() As Long
        [DispId(&H60020013)]
        Property Let DestinationHeight(ByVal pDestinationHeight As Long)
        [DispId(&H60020013)]
        Property Get DestinationHeight() As Long
        [DispId(&H60020015)]
        Sub SetSourcePosition(ByVal Left As Long, ByVal Top As Long, ByVal Width As Long, ByVal Height As Long)
        [DispId(&H60020016)]
        Sub GetSourcePosition(ByRef pLeft As Long, ByRef pTop As Long, ByRef pWidth As Long, ByRef pHeight As Long)
        [DispId(&H60020017)]
        Sub SetDefaultSourcePosition()
        [DispId(&H60020018)]
        Sub SetDestinationPosition(ByVal Left As Long, ByVal Top As Long, ByVal Width As Long, ByVal Height As Long)
        [DispId(&H60020019)]
        Sub GetDestinationPosition(ByRef pLeft As Long, ByRef pTop As Long, ByRef pWidth As Long, ByRef pHeight As Long)
        [DispId(&H6002001A)]
        Sub SetDefaultDestinationPosition()
        [DispId(&H6002001B)]
        Sub GetVideoSize(ByRef pWidth As Long, ByRef pHeight As Long)
        [DispId(&H6002001C)]
        Sub GetVideoPaletteEntries(ByVal StartIndex As Long, ByVal Entries As Long, ByRef pRetrieved As Long, ByRef pPalette As Long)
        [DispId(&H6002001D)]
        Sub GetCurrentImage(ByRef pBufferSize As Long, ByRef pDIBImage As Long)
        [DispId(&H6002001E)]
        Sub IsUsingDefaultSource()
        [DispId(&H6002001F)]
        Sub IsUsingDefaultDestination()
    End Interface

    [InterfaceId("56A868BA-0AD4-11CE-B03A-0020AF0BA770")]
   ' [ DualInterface, COMExtensible]
    [Description("FilterInfo")]
    [OleAutomation(False)]
    Interface IFilterInfo Extends stdole.IDispatch
        [DispId(&H60020000)]
        Sub FindPin(ByVal strPinID As String, ByRef ppUnk As stdole.IDispatch)
        [DispId(&H60020001)]
        Property Get Name() As String
        [DispId(&H60020002)]
        Property Get VendorInfo() As String
        [DispId(&H60020003)]
        Property Get Filter() As IUnknown
        [DispId(&H60020004)]
        Property Get Pins() As stdole.IDispatch
        [DispId(&H60020005)]
        Property Get IsFileSource() As Long
        [DispId(&H60020006)]
        Property Get Filename() As String
        [DispId(&H60020006)]
        Property Let Filename(ByVal pstrFilename As String)
    End Interface

    [InterfaceId("56A868BB-0AD4-11CE-B03A-0020AF0BA770")]
   ' [ DualInterface, COMExtensible]
    [Description("Registry Filter Info")]
    [OleAutomation(False)]
    Interface IRegFilterInfo Extends stdole.IDispatch
        [DispId(&H60020000)]
        Property Get Name() As String
        [DispId(&H60020001)]
        Sub Filter(ByRef ppUnk As stdole.IDispatch)
    End Interface

    [InterfaceId("56A868BC-0AD4-11CE-B03A-0020AF0BA770")]
    '[ DualInterface, COMExtensible]
    [Description("Media Type")]
    [OleAutomation(False)]
    Interface IMediaTypeInfo Extends stdole.IDispatch
        [DispId(&H60020000)]
        Property Get Type() As String
        [DispId(&H60020001)]
        Property Get Subtype() As String
    End Interface
 
    [InterfaceId("56A868BD-0AD4-11CE-B03A-0020AF0BA770")]
    '[ DualInterface, COMExtensible]
    [Description("Pin Info")]
    [OleAutomation(False)]
    Interface IPinInfo Extends stdole.IDispatch
        [DispId(&H60020000)]
        Property Get Pin() As IUnknown
        [DispId(&H60020001)]
        Property Get ConnectedTo() As stdole.IDispatch
        [DispId(&H60020002)]
        Property Get ConnectionMediaType() As stdole.IDispatch
        [DispId(&H60020003)]
        Property Get FilterInfo() As stdole.IDispatch
        [DispId(&H60020004)]
        Property Get Name() As String
        [DispId(&H60020005)]
        Property Get Direction() As Long
        [DispId(&H60020006)]
        Property Get PinID() As String
        [DispId(&H60020007)]
        Property Get MediaTypes() As stdole.IDispatch
        [DispId(&H60020008)]
        Sub Connect(ByVal pPin As IUnknown)
        [DispId(&H60020009)]
        Sub ConnectDirect(ByVal pPin As IUnknown)
        [DispId(&H6002000A)]
        Sub ConnectWithType(ByVal pPin As IUnknown, ByVal pMediaType As stdole.IDispatch)
        [DispId(&H6002000B)]
        Sub Disconnect()
        [DispId(&H6002000C)]
        Sub Render()
    End Interface

    [InterfaceId("BC9BCF80-DCD2-11D2-ABF6-00A0C905F375")]
    '[ DualInterface, COMExtensible]
    [Description("Statistics")]
    [OleAutomation(False)]
    Interface IAMStats Extends stdole.IDispatch
        [DispId(&H60020000)]
        Sub Reset()
        [DispId(&H60020001)]
        Property Get Count() As Long
        [DispId(&H60020002)]
        Sub GetValueByIndex(ByVal lIndex As Long, ByRef szName As String, ByRef lCount As Long, ByRef dLast As Double, ByRef dAverage As Double, ByRef dStdDev As Double, ByRef dMin As Double, ByRef dMax As Double)
        [DispId(&H60020003)]
        Sub GetValueByName(ByVal szName As String, ByRef lIndex As Long, ByRef lCount As Long, ByRef dLast As Double, ByRef dAverage As Double, ByRef dStdDev As Double, ByRef dMin As Double, ByRef dMax As Double)
        [DispId(&H60020004)]
        Sub GetIndex(ByVal szName As String, ByVal lCreate As Long, ByRef plIndex As Long)
        [DispId(&H60020005)]
        Sub AddValue(ByVal lIndex As Long, ByVal dValue As Double)
    End Interface

    [CoClassId("E436EBB3-524F-11CE-9F53-0020AF0BA770")]
    [COMCreatable]
    [Description("Filtergraph type info")]
    CoClass FilgraphManager
        [Default] Interface IMediaControl
        Interface IMediaEvent
        Interface IMediaPosition
        Interface IBasicAudio
        Interface IBasicVideo
        Interface IVideoWindow
    End CoClass
'END QUARTZ
'********************************************************************************************************************
    [InterfaceId("89C31040-846B-11CE-97D3-00AA0055595A")]
    [OleAutomation(False)]
    Interface IEnumMediaTypes Extends stdole.IUnknown
        [PreserveSig]
        Function Next(ByVal cMediaTypes As Long, ByRef ppMediaTypes As LongPtr, ByRef pcFetched As Long) As Long
        [PreserveSig]
        Function Skip(ByVal cMediaTypes As Long) As Long
        [PreserveSig]
        Function Reset() As Long
        [PreserveSig]
        Function Clone(ByRef ppenum As IEnumMediaTypes) As Long
    End Interface

    
    [InterfaceId("29840822-5B84-11D0-BD3B-00A0C911CE86")]
    [OleAutomation(False)]
    Interface ICreateDevEnum Extends IUnknown
        Sub CreateClassEnumerator(ByRef clsidDeviceClass As UUID, ByRef ppEnumMoniker As IEnumMoniker, ByVal dwFlags As DShowCreateDevEnumFlags)
    End Interface
    
    [InterfaceId("56A86891-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IPin Extends stdole.IUnknown
        [PreserveSig]
        Function Connect(ByVal pReceivePin As IPin, ByRef pmt As AM_MEDIA_TYPE) As Long
        [PreserveSig]
        Function ReceiveConnection(ByVal pConnector As IPin, ByRef pmt As AM_MEDIA_TYPE) As Long
        [PreserveSig]
        Function Disconnect() As Long
        [PreserveSig]
        Function ConnectedTo(ByRef pPin As IPin) As Long
        [PreserveSig]
        Function ConnectionMediaType(ByRef pmt As AM_MEDIA_TYPE) As Long
        [PreserveSig]
        Function QueryPinInfo(ByRef pInfo As PIN_INFO) As Long
        [PreserveSig]
        Function QueryDirection(ByRef pPinDir As PIN_DIRECTION) As Long
        [PreserveSig]
        Function QueryId(ByRef id As Long) As Long
        [PreserveSig]
        Function QueryAccept(ByRef pmt As AM_MEDIA_TYPE) As Long
        [PreserveSig]
        Function EnumMediaTypes(ByRef ppenum As IEnumMediaTypes) As Long
        [PreserveSig]
        Function QueryInternalConnections(ByRef apPin As IPin, ByRef nPin As Long) As Long
        [PreserveSig]
        Function EndOfStream() As Long
        [PreserveSig]
        Function BeginFlush() As Long
        [PreserveSig]
        Function EndFlush() As Long
        [PreserveSig]
        Function NewSegment(ByVal tStart As LongLong /* REFERENCE_TIME */, ByVal tStop As LongLong /* REFERENCE_TIME */, ByVal dRate As Double) As Long
    End Interface

    [InterfaceId("56A86892-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IEnumPins Extends stdole.IUnknown
        [PreserveSig]
        Function Next(ByVal cPins As Long, ByRef ppPins As IPin, ByRef pcFetched As Long) As Long
        [PreserveSig]
        Function Skip(ByVal cPins As Long) As Long
        [PreserveSig]
        Function Reset() As Long
        [PreserveSig]
        Function Clone(ByRef ppenum As IEnumPins) As Long
    End Interface

    [InterfaceId("56A86897-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IReferenceClock Extends stdole.IUnknown
        [PreserveSig]
        Function GetTime(ByVal pTime As LongLong /* REFERENCE_TIME */) As Long
        [PreserveSig]
        Function AdviseTime(ByVal baseTime As LongLong /* REFERENCE_TIME */, ByVal streamTime As LongLong /* REFERENCE_TIME */, ByVal hEvent As LongPtr, ByRef pdwAdviseCookie As LongPtr) As Long
        [PreserveSig]
        Function AdvisePeriodic(ByVal startTime As LongLong /* REFERENCE_TIME */, ByVal periodTime As LongLong /* REFERENCE_TIME */, ByVal hSemaphore As LongPtr, ByRef pdwAdviseCookie As LongPtr) As Long
        [PreserveSig]
        Function Unadvise(ByVal dwAdviseCookie As LongPtr) As Long
    End Interface
    [InterfaceId("36b73885-c2c8-11cf-8b46-00805f6cef60")]
    [OleAutomation(False)]
    Interface IReferenceClock2 Extends IReferenceClock
    End Interface
            
    [InterfaceId("ebec459c-2eca-4d42-a8af-30df557614b8")]
    [OleAutomation(False)]
    Interface IReferenceClockTimerControl Extends IUnknown
        Sub SetDefaultTimerResolution(ByVal timerResolution As LongLong)
        Sub GetDefaultTimerResolution(ByRef pTimerResolution As LongLong)
    End Interface

    [InterfaceId("56A86899-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IMediaFilter Extends IPersist
        [PreserveSig]
        Function Stop() As Long
        [PreserveSig]
        Function Pause() As Long
        [PreserveSig]
        Function Run(ByVal tStart As LongLong /* REFERENCE_TIME */) As Long
        [PreserveSig]
        Function GetState(ByVal dwMilliSecsTimeout As Long, ByRef State As FILTER_STATE) As Long
        [PreserveSig]
        Function SetSyncSource(ByVal pClock As IReferenceClock) As Long
        [PreserveSig]
        Function GetSyncSource(ByRef pClock As IReferenceClock) As Long
    End Interface

    [InterfaceId("56A86895-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IBaseFilter Extends IMediaFilter
        [PreserveSig]
        Function EnumPins(ByRef ppenum As IEnumPins) As Long
        [PreserveSig]
        Function FindPin(ByVal lpszId As LongPtr, ByRef ppPin As IPin) As Long
        [PreserveSig]
        Function QueryFilterInfo(ByRef pInfo As FILTER_INFO) As Long
        [PreserveSig]
        Function JoinFilterGraph(ByVal pGraph As IFilterGraph, ByVal pName As LongPtr) As Long
        [PreserveSig]
        Function QueryVendorInfo(ByRef pVendorInfo As LongPtr) As Long
    End Interface

    [InterfaceId("56A86893-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IEnumFilters Extends stdole.IUnknown
        [PreserveSig]
        Function Next(ByVal cFilters As Long, ByRef ppFilter As IBaseFilter, ByRef pcFetched As Long) As Long
        [PreserveSig]
        Function Skip(ByVal cFilters As Long) As Long
        [PreserveSig]
        Function Reset() As Long
        [PreserveSig]
        Function Clone(ByRef ppenum As IEnumFilters) As Long
    End Interface

    [InterfaceId("56A8689F-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IFilterGraph Extends stdole.IUnknown
        [PreserveSig]
        Function AddFilter(ByVal pFilter As IBaseFilter, ByVal pName As LongPtr) As Long
        [PreserveSig]
        Function RemoveFilter(ByVal pFilter As IBaseFilter) As Long
        [PreserveSig]
        Function EnumFilters(ByRef ppenum As IEnumFilters) As Long
        [PreserveSig]
        Function FindFilterByName(ByVal pName As LongPtr, ByRef ppFilter As IBaseFilter) As Long
        [PreserveSig]
        Function ConnectDirect(ByVal ppinOut As IPin, ByVal ppinIn As IPin, ByRef pmt As AM_MEDIA_TYPE) As Long
        [PreserveSig]
        Function Reconnect(ByVal pPin As IPin) As Long
        [PreserveSig]
        Function Disconnect(ByVal pPin As IPin) As Long
        [PreserveSig]
        Function SetDefaultSyncSource() As Long
    End Interface

    [InterfaceId("A2104830-7C70-11CF-8BCE-00AA00A3F1A6")]
    [OleAutomation(False)]
    Interface IFileSinkFilter Extends stdole.IUnknown
        [PreserveSig]
        Function SetFileName(ByVal pszFileName As LongPtr, ByRef pmt As AM_MEDIA_TYPE) As Long
        [PreserveSig]
        Function GetCurFile(ByRef ppszFileName As LongPtr, ByRef pmt As AM_MEDIA_TYPE) As Long
    End Interface

    [InterfaceId("670D1D20-A068-11D0-B3F0-00AA003761C5")]
    [OleAutomation(False)]
    Interface IAMCopyCaptureFileProgress Extends stdole.IUnknown
        Sub Progress(ByVal iProgress As Long)
    End Interface

    [InterfaceId("56A868A9-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IGraphBuilder Extends IFilterGraph
        [PreserveSig]
        Function Connect(ByVal ppinOut As IPin, ByVal ppinIn As IPin) As Long
        [PreserveSig]
        Function Render(ByVal ppinOut As IPin) As Long
        [PreserveSig]
        Function RenderFile(ByVal lpcwstrFile As LongPtr, ByVal lpcwstrPlayList As LongPtr) As Long
        [PreserveSig]
        Function AddSourceFilter(ByVal lpcwstrFileName As String, ByVal lpcwstrFilterName As LongPtr, ByRef ppFilter As IBaseFilter) As Long
        [PreserveSig]
        Function SetLogFile(ByVal hFile As LongPtr) As Long
        [PreserveSig]
        Function Abort() As Long
        [PreserveSig]
        Function ShouldOperationContinue() As Long
    End Interface

    [InterfaceId("36B73882-C2C8-11CF-8B46-00805F6CEF60")]
    [OleAutomation(False)]
    Interface IFilterGraph2 Extends IGraphBuilder
        [PreserveSig]
        Function AddSourceFilterForMoniker(ByVal pMoniker As IMoniker, ByVal pCtx As IBindCtx, ByVal lpcwstrFilterName As LongPtr, ByRef ppFilter As IBaseFilter) As Long
        [PreserveSig]
        Function ReconnectEx(ByVal pPin As IPin, ByVal pmt As LongPtr) As Long
        [PreserveSig]
        Function RenderEx(ByVal pPin As IPin, ByVal dwFlags As AM_RENSDEREXFLAGS, ByRef pvContext As Long) As Long
    End Interface

    [InterfaceId("AAF38154-B80B-422F-91E6-B66467509A07")]
    [OleAutomation(False)]
    Interface IFilterGraph3 Extends IFilterGraph2
        [PreserveSig]
        Function SetSyncSourceEx(ByVal pClockForMostOfFilterGraph As IReferenceClock, ByVal pClockForFilter As IReferenceClock, ByVal pFilter As IBaseFilter) As Long
    End Interface

    [InterfaceId("BF87B6E0-8C27-11D0-B3F0-00AA003761C5")]
    [OleAutomation(False)]
    Interface ICaptureGraphBuilder Extends stdole.IUnknown
        [PreserveSig]
        Function SetFiltergraph(ByVal pfg As IGraphBuilder) As Long
        [PreserveSig]
        Function GetFiltergraph(ByRef ppfg As IGraphBuilder) As Long
        [PreserveSig]
        Function SetOutputFileName(ByRef pType As UUID, ByVal lpstrFile As LongPtr, ByRef ppf As IBaseFilter, ByRef ppSink As IFileSinkFilter) As Long
        [PreserveSig]
        Function FindInterface(ByRef pCategory As UUID, ByVal pf As IBaseFilter, ByRef riid As UUID, ByRef ppint As Any) As Long
        [PreserveSig]
        Function RenderStream(ByRef pCategory As UUID, ByVal pSource As IUnknown, ByVal pfCompressor As IBaseFilter, ByVal pfRenderer As IBaseFilter) As Long
        [PreserveSig]
        Function ControlStream(ByRef pCategory As UUID, ByVal pFilter As IBaseFilter, ByVal pStart As LongLong /* REFERENCE_TIME */, ByVal pStop As LongLong /* REFERENCE_TIME */, ByVal wStartCookie As Integer, ByVal wStopCookie As Integer) As Long
        [PreserveSig]
        Function AllocCapFile(ByVal lpStr As LongPtr, ByVal dwlSize As LongLong) As Long
        [PreserveSig]
        Function CopyCaptureFile(ByVal lpwstrOld As LongPtr, ByVal lpwstrNew As LongPtr, ByVal fAllowEscAbort As Long, ByVal pCallback As IAMCopyCaptureFileProgress) As Long
    End Interface

    [InterfaceId("93E5A4E0-2D50-11D2-ABFA-00A0C9C6E38D")]
    [OleAutomation(False)]
    Interface ICaptureGraphBuilder2 Extends stdole.IUnknown
        [PreserveSig]
        Function SetFiltergraph(ByVal pfg As IGraphBuilder) As Long
        [PreserveSig]
        Function GetFiltergraph(ByRef ppfg As IGraphBuilder) As Long
        [PreserveSig]
        Function SetOutputFileName(ByRef pType As UUID, ByVal lpstrFile As LongPtr, ByRef ppf As IBaseFilter, ByRef ppSink As IFileSinkFilter) As Long
        [PreserveSig]
        Function FindInterface(ByRef pCategory As UUID, ByRef pType As UUID, ByVal pf As IBaseFilter, ByRef riid As UUID, ByRef ppint As Any) As Long
        [PreserveSig]
        Function RenderStream(ByRef pCategory As UUID, ByRef pType As UUID, ByVal pSource As IUnknown, ByVal pfCompressor As IBaseFilter, ByVal pfRenderer As IBaseFilter) As Long
        [PreserveSig]
        Function ControlStream(ByRef pCategory As UUID, ByRef pType As UUID, ByVal pFilter As IBaseFilter, ByVal pStart As LongLong /* LongLong */, ByVal pStop As LongLong /* LongLong */, ByVal wStartCookie As Integer, ByVal wStopCookie As Integer) As Long
        [PreserveSig]
        Function AllocCapFile(ByVal lpStr As LongPtr, ByVal dwlSize As LongLong) As Long
        [PreserveSig]
        Function CopyCaptureFile(ByVal lpwstrOld As LongPtr, ByVal lpwstrNew As LongPtr, ByVal fAllowEscAbort As Long, ByVal pCallback As IAMCopyCaptureFileProgress) As Long
        [PreserveSig]
        Function FindPin(ByVal pSource As IUnknown, ByVal pindir As PIN_DIRECTION, ByRef pCategory As UUID, ByRef pType As UUID, ByVal fUnconnected As Long, ByVal num As Long, ByRef ppPin As IPin) As Long
    End Interface

    [InterfaceId("FA2AA8F1-8B62-11D0-A520-000000000000")]
    [OleAutomation(False)]
    Interface IAMNetShowConfig Extends IDispatch
        [PreserveSig]
        Function get_BufferingTime(ByRef pBufferingTime As Double) As Long
        [PreserveSig]
        Function put_BufferingTime(ByVal BufferingTime As Double) As Long
        [PreserveSig]
        Function get_UseFixedUDPPort(ByVal pUseFixedUDPPort As Long) As Long
        [PreserveSig]
        Function put_UseFixedUDPPort(ByVal UseFixedUDPPort As Long) As Long
        [PreserveSig]
        Function get_FixedUDPPort(ByRef pFixedUDPPort As Long) As Long
        [PreserveSig]
        Function put_FixedUDPPort(ByVal FixedUDPPort As Long) As Long
        [PreserveSig]
        Function get_UseHTTPProxy(ByVal pUseHTTPProxy As Long) As Long
        [PreserveSig]
        Function put_UseHTTPProxy(ByVal UseHTTPProxy As Long) As Long
        [PreserveSig]
        Function get_EnableAutoProxy(ByVal pEnableAutoProxy As Long) As Long
        [PreserveSig]
        Function put_EnableAutoProxy(ByVal EnableAutoProxy As Long) As Long
        [PreserveSig]
        Function get_HTTPProxyHost(ByRef pbstrHTTPProxyHost As String) As Long
        [PreserveSig]
        Function put_HTTPProxyHost(ByVal bstrHTTPProxyHost As String) As Long
        [PreserveSig]
        Function get_HTTPProxyPort(ByRef pHTTPProxyPort As Long) As Long
        [PreserveSig]
        Function put_HTTPProxyPort(ByVal HTTPProxyPort As Long) As Long
        [PreserveSig]
        Function get_EnableMulticast(ByVal pEnableMulticast As Long) As Long
        [PreserveSig]
        Function put_EnableMulticast(ByVal EnableMulticast As Long) As Long
        [PreserveSig]
        Function get_EnableUDP(ByVal pEnableUDP As Long) As Long
        [PreserveSig]
        Function put_EnableUDP(ByVal EnableUDP As Long) As Long
        [PreserveSig]
        Function get_EnableTCP(ByVal pEnableTCP As Long) As Long
        [PreserveSig]
        Function put_EnableTCP(ByVal EnableTCP As Long) As Long
        [PreserveSig]
        Function get_EnableHTTP(ByVal pEnableHTTP As Long) As Long
        [PreserveSig]
        Function put_EnableHTTP(ByVal EnableHTTP As Long) As Long
    End Interface

    [InterfaceId("FA2AA8F2-8B62-11D0-A520-000000000000")]
    [OleAutomation(False)]
    Interface IAMChannelInfo Extends IDispatch
        [PreserveSig]
        Function get_ChannelName(ByRef pbstrChannelName As String) As Long
        [PreserveSig]
        Function get_ChannelDescription(ByRef pbstrChannelDescription As String) As Long
        [PreserveSig]
        Function get_ChannelURL(ByRef pbstrChannelURL As String) As Long
        [PreserveSig]
        Function get_ContactAddress(ByRef pbstrContactAddress As String) As Long
        [PreserveSig]
        Function get_ContactPhone(ByRef pbstrContactPhone As String) As Long
        [PreserveSig]
        Function get_ContactEmail(ByRef pbstrContactEmail As String) As Long
    End Interface

    [InterfaceId("FA2AA8F3-8B62-11D0-A520-000000000000")]
    [OleAutomation(False)]
    Interface IAMNetworkStatus Extends IDispatch
        [PreserveSig]
        Function get_ReceivedPackets(ByRef pReceivedPackets As Long) As Long
        [PreserveSig]
        Function get_RecoveredPackets(ByRef pRecoveredPackets As Long) As Long
        [PreserveSig]
        Function get_LostPackets(ByRef pLostPackets As Long) As Long
        [PreserveSig]
        Function get_ReceptionQuality(ByRef pReceptionQuality As Long) As Long
        [PreserveSig]
        Function get_BufferingCount(ByRef pBufferingCount As Long) As Long
        [PreserveSig]
        Function get_IsBroadcast(ByVal pIsBroadcast As Integer) As Long
        [PreserveSig]
        Function get_BufferingProgress(ByRef pBufferingProgress As Long) As Long
    End Interface

    [InterfaceId("FA2AA8F5-8B62-11D0-A520-000000000000")]
    [OleAutomation(False)]
    Interface IAMNetShowExProps Extends IDispatch
        [PreserveSig]
        Function get_SourceProtocol(ByRef pSourceProtocol As Long) As Long
        [PreserveSig]
        Function get_Bandwidth(ByRef pBandwidth As Long) As Long
        [PreserveSig]
        Function get_ErrorCorrection(ByRef pbstrErrorCorrection As String) As Long
        [PreserveSig]
        Function get_CodecCount(ByRef pCodecCount As Long) As Long
        [PreserveSig]
        Function GetCodecInstalled(ByRef CodecNum As Long, ByVal pCodecInstalled As Integer) As Long
        [PreserveSig]
        Function GetCodecDescription(ByRef CodecNum As Long, ByRef pbstrCodecDescription As String) As Long
        [PreserveSig]
        Function GetCodecURL(ByRef CodecNum As Long, ByRef pbstrCodecURL As String) As Long
        [PreserveSig]
        Function get_CreationDate(ByRef pCreationDate As Double) As Long
        [PreserveSig]
        Function get_SourceLink(ByRef pbstrSourceLink As String) As Long
    End Interface

    [InterfaceId("FA2AA8F6-8B62-11D0-A520-000000000000")]
    [OleAutomation(False)]
    Interface IAMExtendedErrorInfo Extends IDispatch
        [PreserveSig]
        Function get_HasError(ByVal pHasError As Long) As Long
        [PreserveSig]
        Function get_ErrorDescription(ByRef pbstrErrorDescription As String) As Long
        [PreserveSig]
        Function get_ErrorCode(ByRef pErrorCode As Long) As Long
    End Interface

    [InterfaceId("AAE7E4E2-6388-11D1-8D93-006097C9A2B2")]
    [OleAutomation(False)]
    Interface IAMNetShowPreroll Extends IDispatch
        [PreserveSig]
        Function put_Preroll(ByVal fPreroll As Long) As Long
        [PreserveSig]
        Function get_Preroll(ByVal pfPreroll As Long) As Long
    End Interface

    [InterfaceId("4746B7C8-700E-11D1-BECC-00C04FB6E937")]
    [OleAutomation(False)]
    Interface IDShowPlugin Extends IUnknown
        [PreserveSig]
        Function get_URL(ByRef pURL As String) As Long
        [PreserveSig]
        Function get_UserAgent(ByRef pUserAgent As String) As Long
    End Interface

    [InterfaceId("FA2AA8F4-8B62-11D0-A520-000000000000")]
    [OleAutomation(False)]
    Interface IAMMediaContent Extends IDispatch
        [PreserveSig]
        Function get_AuthorName(ByRef pbstrAuthorName As String) As Long
        [PreserveSig]
        Function get_Title(ByRef pbstrTitle As String) As Long
        [PreserveSig]
        Function get_Rating(ByRef pbstrRating As String) As Long
        [PreserveSig]
        Function get_Description(ByRef pBstrDescription As String) As Long
        [PreserveSig]
        Function get_Copyright(ByRef pbstrCopyright As String) As Long
        [PreserveSig]
        Function get_BaseURL(ByRef pbstrBaseURL As String) As Long
        [PreserveSig]
        Function get_LogoURL(ByRef pbstrLogoURL As String) As Long
        [PreserveSig]
        Function get_LogoIconURL(ByRef pbstrLogoURL As String) As Long
        [PreserveSig]
        Function get_WatermarkURL(ByRef pbstrWatermarkURL As String) As Long
        [PreserveSig]
        Function get_MoreInfoURL(ByRef pbstrMoreInfoURL As String) As Long
        [PreserveSig]
        Function get_MoreInfoBannerImage(ByRef pbstrMoreInfoBannerImage As String) As Long
        [PreserveSig]
        Function get_MoreInfoBannerURL(ByRef pbstrMoreInfoBannerURL As String) As Long
        [PreserveSig]
        Function get_MoreInfoText(ByRef pbstrMoreInfoText As String) As Long
    End Interface

    [InterfaceId("FA2AA8F9-8B62-11D0-A520-000000000000")]
    [OleAutomation(False)]
    Interface IAMExtendedSeeking Extends IDispatch
        [PreserveSig]
        Function get_ExSeekCapabilities(ByRef pExCapabilities As AMExtendedSeekingCapabilities) As Long
        [PreserveSig]
        Function get_MarkerCount(ByRef pMarkerCount As Long) As Long
        [PreserveSig]
        Function get_CurrentMarker(ByRef pCurrentMarker As Long) As Long
        [PreserveSig]
        Function GetMarkerTime(ByVal MarkerNum As Long, ByRef pMarkerTime As Double) As Long
        [PreserveSig]
        Function GetMarkerName(ByVal MarkerNum As Long, ByRef pbstrMarkerName As String) As Long
        [PreserveSig]
        Function put_PlaybackSpeed(ByVal Speed As Double) As Long
        [PreserveSig]
        Function get_PlaybackSpeed(ByRef pSpeed As Double) As Long
    End Interface

    [InterfaceId("CE8F78C1-74D9-11D2-B09D-00A0C9A81117")]
    [OleAutomation(False)]
    Interface IAMMediaContent2 Extends IDispatch
        [PreserveSig]
        Function get_MediaParameter(ByVal EntryNum As Long, ByVal bstrName As String, ByRef pbstrValue As String) As Long
        [PreserveSig]
        Function get_MediaParameterName(ByVal EntryNum As Long, ByVal index As Long, ByRef pBstrName As String) As Long
        [PreserveSig]
        Function get_PlaylistCount(ByRef pNumberEntries As Long) As Long
    End Interface

    [InterfaceId("C6E13350-30AC-11D0-A18C-00A0C9118956")]
    [OleAutomation(False)]
    Interface IAMAnalogVideoDecoder Extends stdole.IUnknown
        [PreserveSig]
        Function get_AvailableTVFormats(ByRef lAnalogVideoStandard As Long) As Long
        [PreserveSig]
        Function put_TVFormat(ByVal lAnalogVideoStandard As Long) As Long
        [PreserveSig]
        Function get_TVFormat(ByRef plAnalogVideoStandard As Long) As Long
        [PreserveSig]
        Function get_HorizontalLocked(ByRef plLocked As Long) As Long
        [PreserveSig]
        Function put_VCRHorizontalLocking(ByVal lVCRHorizontalLocking As Long) As Long
        [PreserveSig]
        Function get_VCRHorizontalLocking(ByRef plVCRHorizontalLocking As Long) As Long
        [PreserveSig]
        Function get_NumberOfLines(ByRef plNumberOfLines As Long) As Long
        [PreserveSig]
        Function put_OutputEnable(ByVal lOutputEnable As Long) As Long
        [PreserveSig]
        Function get_OutputEnable(ByRef plOutputEnable As Long) As Long
    End Interface
    
    [InterfaceId("C6E13360-30AC-11d0-A18C-00A0C9118956")]
    [OleAutomation(False)]
    Interface IAMVideoProcAmp Extends stdole.IUnknown
        [Description("Returns min, max, step size, and default values")]
        Sub GetRange(ByVal Property As VideoProcAmpProperty, ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlags As VideoProcAmpFlags)
        [Description("Set a VideoProcAmp property")]
        Sub Set(ByVal Property As VideoProcAmpProperty, ByVal lValue As Long, ByVal Flags As VideoProcAmpFlags)
        [Description("Get a VideoProcAmp property")]
        Sub Get(ByVal Property As VideoProcAmpProperty, ByRef lValue As Long, ByRef Flags As VideoProcAmpFlags)
    End Interface

    [InterfaceId("C6E13370-30AC-11d0-A18C-00A0C9118956")]
    [Description("Alternate definition: IAMCameraControlAlt")]
    [OleAutomation(False)]
    Interface IAMCameraControl Extends stdole.IUnknown
        [Description("Returns min, max, step size, and default values")]
        Sub GetRange(ByVal Property As CameraControlProperty, ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlags As CameraControlFlags)
        [Description("Set a CameraControl property")]
        Sub Set(ByVal Property As CameraControlProperty, ByVal lValue As Long, ByVal Flags As CameraControlFlags)
        [Description("Get a CameraControl property")]
        Sub Get(ByVal Property As CameraControlProperty, ByRef lValue As Long, ByRef Flags As CameraControlFlags)
    End Interface
    [InterfaceId("C6E13370-30AC-11D0-A18C-00A0C9118956")]
    [OleAutomation(False)]
    Interface IAMCameraControlAlt Extends stdole.IUnknown
        [PreserveSig]
        Function GetRange(ByVal Property As Long, ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlags As Long) As Long
        [PreserveSig]
        [Description("ccSet renamed from Set; VB keywords can't be function names.")]
        Function ccSet(ByVal Property As Long, ByVal lValue As Long, ByVal flags As Long) As Long
        [PreserveSig]
        [Description("ccGet renamed from Get; VB keywords can't be function names.")]
        Function ccGet(ByVal Property As Long, ByRef lValue As Long, ByRef flags As Long) As Long
    End Interface

    #If TWINBASIC_BUILD >= 896 Then
    [InterfaceId("6a2e0670-28e4-11d0-a18c-00a0c9118956")]
    [OleAutomation(False)]
    Interface IAMVideoControl Extends stdole.IUnknown
        [Description("What can the underlying hardware do?")]
        Sub GetCaps(ByVal pPin As IPin, ByRef pCapsFlags As VideoControlFlags)
        [Description("Set the mode of operation")]
        Sub SetMode(ByVal pPin As IPin, ByVal Mode As VideoControlFlags)
        [Description("Get the mode of operation")]
        Sub GetMode(ByVal pPin As IPin, ByRef Mode As VideoControlFlags)
        [Description("Get actual frame rate info for USB and 1394. This is only available when streaming")]
        Sub GetCurrentActualFrameRate(ByVal pPin As IPin, ByRef ActualFrameRate As LongLong)
        [Description("For Demensions, copy SIZE to LongLong. Get max available frame rate info for USB and 1394. Returns the max frame rate currently available based on bus bandwidth usage")]
        Sub GetMaxAvailableFrameRate(ByVal pPin As IPin, ByVal iIndex As Long, ByVal Dimensions As SIZE, ByRef MaxAvailableFrameRate As LongPtr)
        [Description("For Demensions, copy SIZE to LongLong. Get List of available frame rates")]
        Sub GetFrameRateList(ByVal pPin As IPin, ByVal iIndex As Long, ByVal Dimensions As SIZE, ByRef ListSize As Long, ByRef FrameRates As LongPtr)
    End Interface
    #Else
    [InterfaceId("6a2e0670-28e4-11d0-a18c-00a0c9118956")]
    [OleAutomation(False)]
    Interface IAMVideoControl Extends stdole.IUnknown
        [Description("What can the underlying hardware do?")]
        Sub GetCaps(ByVal pPin As IPin, ByRef pCapsFlags As VideoControlFlags)
        [Description("Set the mode of operation")]
        Sub SetMode(ByVal pPin As IPin, ByVal Mode As VideoControlFlags)
        [Description("Get the mode of operation")]
        Sub GetMode(ByVal pPin As IPin, ByRef Mode As VideoControlFlags)
        [Description("Get actual frame rate info for USB and 1394. This is only available when streaming")]
        Sub GetCurrentActualFrameRate(ByVal pPin As IPin, ByRef ActualFrameRate As LongLong)
        [Description("For Demensions, copy SIZE to LongLong. Get max available frame rate info for USB and 1394. Returns the max frame rate currently available based on bus bandwidth usage")]
        Sub GetMaxAvailableFrameRate(ByVal pPin As IPin, ByVal iIndex As Long, ByVal Dimensions As LongLong /* SIZE */, ByRef MaxAvailableFrameRate As LongPtr)
        [Description("For Demensions, copy SIZE to LongLong. Get List of available frame rates")]
        Sub GetFrameRateList(ByVal pPin As IPin, ByVal iIndex As Long, ByVal Dimensions As LongLong /* SIZE */, ByRef ListSize As Long, ByRef FrameRates As LongPtr)
    End Interface
    #End If
    
    [InterfaceId("211A8761-03AC-11d1-8D13-00AA00BD8339")]
    [OleAutomation(False)]
    Interface IAMTuner Extends stdole.IUnknown
        [Description("Sets and gets the Channel")]
        Sub put_Channel(ByVal lChannel As Long, ByVal lVideoSubChannel As Long, ByVal lAudioSubChannel As Long)
        Sub get_Channel(ByRef plChannel As Long, ByRef plVideoSubChannel As Long, ByRef plAudioSubChannel As Long)
        [Description("Gets the minimum and maximum channel available")]
        Sub ChannelMinMax(ByRef lChannelMin As Long, ByRef lChannelMax As Long)
        [Description("CountryCode is the same as the international long distance telephone dialing prefix")]
        Sub put_CountryCode(ByVal lCountryCode As Long)
        Sub get_CountryCode(ByRef plCountryCode As Long)
        Sub put_TuningSpace(ByVal lTuningSpace As Long)
        Sub get_TuningSpace(ByRef plTuningSpace As Long)
        Sub Logon(ByVal hCurrentUser As LongPtr)
        Sub Logout()
        [Description("Signal status for current channel - signal strength == TUNER_NOSIGNAL, or strength value")]
        Sub SignalPresent(ByRef plSignalStrength As Long)
        [Description("allow multifunction tuner to be switch between modes")]
        Sub put_Mode(ByVal lMode As AMTunerModeType)
        Sub get_Mode(ByRef plMode As AMTunerModeType)
        [Description("retrieve a bitmask of the possible modes")]
        Sub GetAvailableModes(ByRef plModes As Long)
        [Description("allow IAMTuner clients to receive event notification")]
        Sub RegisterNotificationCallBack(ByVal pNotify As IAMTunerNotification, ByVal lEvents As Long)
        Sub UnRegisterNotificationCallBack(ByVal pNotify As IAMTunerNotification)
    End Interface

    [InterfaceId("211A8760-03AC-11d1-8D13-00AA00BD8339")]
    [OleAutomation(False)]
    Interface IAMTunerNotification Extends stdole.IUnknown
        Sub OnEvent(ByVal Event As AMTunerEventType)
    End Interface
    
    [InterfaceId("211A8766-03AC-11d1-8D13-00AA00BD8339")]
    [OleAutomation(False)]
    Interface IAMTVTuner Extends IAMTuner
        [Description("Gets the supported analog video standards (NTSC/M, PAL/B, SECAM/K1, ...)")]
        Sub get_AvailableTVFormats(ByRef lAnalogVideoStandard As AnalogVideoStandard)
        [Description("Gets the current analog video standard (NTSC/M, PAL/B, SECAM/K1, ...)")]
        Sub get_TVFormat(ByRef plAnalogVideoStandard As AnalogVideoStandard)
        [Description("Scans for a signal on a given channel. NOTE: this is equivalent to put_Channel(), SignalStrength()")]
        Sub AutoTune(ByVal lChannel As Long, ByRef plFoundSignal As Long)
        [Description("Saves the fine tuning information for all channels")]
        Sub StoreAutoTune()
        [Description("The number of TV sources plugged into the tuner")]
        Sub get_NumInputConnections(ByRef plNumInputConnections As Long)
        [Description("Sets or gets the tuner input type (Cable or Antenna)")]
        Sub put_InputType(ByVal lIndex As Long, ByVal InputType As TunerInputType)
        Sub get_InputType(ByVal lIndex As Long, ByRef pInputType As TunerInputType)
        [Description("Sets or gets the tuner input")]
        Sub put_ConnectInput(ByVal lIndex As Long)
        Sub get_ConnectInput(ByRef plIndex As Long)
        [Description("Gets the video and audio carrier frequencies")]
        Sub get_VideoFrequency(ByRef lFreq As Long)
        Sub get_AudioFrequency(ByRef lFreq As Long)
    End Interface

    [InterfaceId("211A8765-03AC-11d1-8D13-00AA00BD8339")]
    [OleAutomation(False)]
    Interface IBPCSatelliteTuner Extends IAMTuner
        Sub get_DefaultSubChannelTypes(ByRef plDefaultVideoType As Long, ByRef plDefaultAudioType As Long)
        Sub put_DefaultSubChannelTypes(ByVal lDefaultVideoType As Long, ByVal lDefaultAudioType As Long)
        [PreserveSig] Function IsTapingPermitted() As Long
    End Interface
  
    [InterfaceId("83EC1C30-23D1-11d1-99E6-00A0C9560266")]
    [OleAutomation(False)]
    Interface IAMTVAudio Extends stdole.IUnknown
        [Description("retrieve a bitmask of the formats available in the hardware")]
        Sub GetHardwareSupportedTVAudioModes(ByRef plModes As TVAudioMode)
        [Description("retrieve a bitmask of the possible modes")]
        Sub GetAvailableTVAudioModes(ByRef plModes As TVAudioMode)
        Sub get_TVAudioMode(ByRef plMode As TVAudioMode)
        Sub put_TVAudioMode(ByVal lMode As TVAudioMode)
        [Description("allow IAMTVAudio clients to receive event notification")]
        Sub RegisterNotificationCallBack(ByVal pNotify As IAMTunerNotification, ByVal lEvents As Long)
        Sub UnRegisterNotificationCallBack(ByVal pNotify As IAMTunerNotification)
    End Interface

    [InterfaceId("83EC1C33-23D1-11d1-99E6-00A0C9560266")]
    [OleAutomation(False)]
    Interface IAMTVAudioNotification Extends stdole.IUnknown
        Sub OnEvent(ByVal Event As AMTVAudioEventType)
    End Interface

    [InterfaceId("C6E133B0-30AC-11d0-A18C-00A0C9118956")]
    [OleAutomation(False)]
    Interface IAMAnalogVideoEncoder Extends stdole.IUnknown
        [Description("Gets the supported analog video standards (NTSC/M, PAL/B, SECAM/K1, ...)")]
        Sub get_AvailableTVFormats(ByRef lAnalogVideoStandard As AnalogVideoStandard)
        [Description("Sets or gets the current analog video standard (NTSC/M, PAL/B, SECAM/K1, ...)")]
        Sub put_TVFormat(ByVal lAnalogVideoStandard As AnalogVideoStandard)
        Sub get_TVFormat(ByRef plAnalogVideoStandard As AnalogVideoStandard)
        [Description("Sets or gets the copy protection")]
        Sub put_CopyProtection(ByVal lVideoCopyProtection As AM_COPY_MACROVISION_LEVEL)
        Sub get_CopyProtection(ByRef lVideoCopyProtection As AM_COPY_MACROVISION_LEVEL)
        [Description("Enables and disables close captioning")]
        Sub put_CCEnable(ByVal lCCEnable As Long)
        Sub get_CCEnable(ByRef lCCEnable As Long)
    End Interface
    
    [InterfaceId("6025A880-C0D5-11d0-BD4E-00A0C911CE86")]
    [OleAutomation(False)]
    Interface IMediaPropertyBag Extends IPropertyBag
        [Description("return the i'th element in the property bag")]
        Sub EnumProperty(ByVal iProperty As Long, ByRef pvarPropertyName As Variant, ByRef pvarPropertyValue As Variant)
    End Interface

    [InterfaceId("5738E040-B67F-11d0-BD4D-00A0C911CE86")]
    [OleAutomation(False)]
    Interface IPersistMediaPropertyBag Extends IPersist
        Sub InitNew()
        Sub Load(ByVal pPropBag As IMediaPropertyBag, ByVal pErrorLog As IErrorLog)
        Sub Save(ByVal pPropBag As IMediaPropertyBag, ByVal fClearDirty As BOOL, ByVal fSaveAllProperties As BOOL)
    End Interface

    [InterfaceId("F938C991-3029-11cf-8C44-00AA006B6814")]
    [OleAutomation(False)]
    Interface IAMPhysicalPinInfo Extends stdole.IUnknown
        [Description("Returns VFW_E_NO_ACCEPTABLE_TYPES if not a physical pin")]
        Sub GetPhysicalType(ByRef pType As PhysicalConnectorType, ByRef ppszType As LongPtr)
    End Interface
    
    [InterfaceId("B5730A90-1A2C-11cf-8C23-00AA006B6814")]
    [OleAutomation(False)]
    Interface IAMExtDevice Extends stdole.IUnknown
        [Description("General device capabilities property. See edevdefs.h for supported values")]
        Sub GetCapability(ByVal Capability As AMExtDevCaps, ByRef pValue As Long, ByRef pdblValue As Double)
        [Description("Get external device identification string. Usually the model # of the device")]
        Sub get_ExternalDeviceID(ByRef ppszData As LongPtr)
        Sub get_ExternalDeviceVersion(ByRef ppszData As LongPtr)
        [Description("Controls the external device's power mode")]
        Sub put_DevicePower(ByVal PowerMode As AMDevExtPowerModes)
        Sub get_DevicePower(ByRef pPowerMode As AMDevExtPowerModes)
        [Description("Some devices need to be reset in some way, i.e., rewinding a VCR to the beginning of the tape and resetting the counter to zero.")]
        Sub Calibrate(ByVal hEvent As LongPtr, ByVal Mode As AMDevExtCalibrate, ByRef pStatus As Long)
        [Description("Selects the device's communications port, i.e.,COM1, IEEE1394, etc. See edevdefs.h for enums")]
        Sub put_DevicePort(ByVal DevicePort As Long)
        Sub get_DevicePort(ByRef pDevicePort As Long)
    End Interface

    [InterfaceId("A03CD5F0-3045-11cf-8C44-00AA006B6814")]
    [OleAutomation(False)]
    Interface IAMExtTransport Extends stdole.IUnknown
        [Description("General transport capabilities property. See edevdefs.h for enums")]
        Sub GetCapability(ByVal Capability As AMDevExtTransportCaps, ByRef pValue As Long, ByRef pdblValue As Double)
        [Description("For disc-based devices: spinning, or not spinning. For tape-based device: threaded, unthreaded or ejected")]
        Sub put_MediaState(ByVal State As AMDevExtTransportMediaStates)
        Sub get_MediaState(ByRef pState As AMDevExtTransportMediaStates)
        [Description("Determines state of unit's front panel")]
        Sub put_LocalControl(ByVal State As Long)
        Sub get_LocalControl(ByRef pState As Long)
        [Description("Transport status such as Play, Stop, etc. More extensive than AM states.")]
        Sub GetStatus(ByVal StatusItem As AMDevExtTransportMediaModes, ByRef pValue As AmExtTransportStatusParamsAndValues)
        [Description("Parameters such as recording speed, servo reference, ballistics, etc.")]
        Sub GetTransportBasicParameters(ByVal Param As AmExtTransportBasicParamsAndValues, ByRef pValue As AmExtTransportBasicParamsAndValues, ByRef ppszData As LongPtr)
        Sub SetTransportBasicParameters(ByVal Param As AmExtTransportBasicParamsAndValues, ByVal Value As AmExtTransportBasicParamsAndValues, ByVal pszData As LongPtr)
        [Description("Parameters such as video output mode")]
        Sub GetTransportVideoParameters(ByVal Param As AmExtTransportVideoParamsAndValues, ByRef pValue As AmExtTransportVideoParamsAndValues)
        Sub SetTransportVideoParameters(ByVal Param As AmExtTransportVideoParamsAndValues, ByVal Value As AmExtTransportVideoParamsAndValues)
        [Description("Parameters such as audio channel enable")]
        Sub GetTransportAudioParameters(ByVal Param As AmExtTransportAudioParamsAndValues, ByRef pValue As Long)
        Sub SetTransportAudioParameters(ByVal Param As AmExtTransportAudioParamsAndValues, ByVal Value As Long)
        [Description("Mode is the movement of the transport, i.e., Play, Stop, Record, Edit, etc.")]
        Sub put_Mode(ByVal Mode As AMDevExtTransportMediaModes)
        Sub get_Mode(ByRef pMode As AMDevExtTransportMediaModes)
        [Description("Rate is for variable speed control of the the device. This can be linked to IMediaControl::Rate() in the implementation if desired.")]
        Sub put_Rate(ByVal dblRate As Double)
        Sub get_Rate(ByRef pdblRate As Double)
        [Description("This is a lengthy method, that is, it is in effect until canceled or complete and requires housekeeping by the filter. It puts transport in play mode and maintains fixed relationship between master time reference and transport position.")]
        Sub GetChase(ByRef pEnabled As Long, ByRef pOffset As Long, ByRef phEvent As LongPtr)
        Sub SetChase(ByVal Enable As Long, ByVal Offset As Long, ByVal hEvent As LongPtr)
        [Description("Also a lengthy method: temporarily change transport speed (for synchronizing).")]
        Sub GetBump(ByRef pSpeed As Long, ByRef pDuration As Long)
        Sub SetBump(ByVal Speed As Long, ByVal Duration As Long)
        [Description("Enable/Disable transport anti-headclog control.")]
        Sub get_AntiClogControl(ByRef pEnabled As Long)
        Sub put_AntiClogControl(ByVal Enable As Long)
   ' // The following group of properties describes edit events.  An edit event can be a
    ' // standard insert or assemble edit or a memorized position called a bookmark.
    ' // A NOTE ABOUT EVENTS: as with all lengthy commands, event objects must be created to
    ' // signal completion or error.

    ' // Intended usage: an edit event is prepared for use by:
    ' // 1. Registering an edit property set and getting an EditID
    ' // 2. Setting the necessary edit properties
    ' // 3. Setting the edit property set active

    ' // Please see edevdefs.h for properties and values

    ' // The reference clock's advance is the mechanism that puts an edit in motion (see
    ' // ED_EDIT_REC_INPOINT).
        [Description("Property set methods")]
        Sub GetEditPropertySet(ByVal EditID As Long, ByRef pState As AmExtEditParamsAndValues)
        Sub SetEditPropertySet(ByRef pEditID As Long, ByVal State As AmExtEditParamsAndValues)
        [Description("the following properties define an edit event such as a bookmark, seek point, or actual edit")]
        Sub GetEditProperty(ByVal EditID As Long, ByVal Param As Long, ByRef pValue As Long)
        Sub SetEditProperty(ByVal EditID As Long, ByVal Param As Long, ByVal Value As Long)
        [Description("Activates a capable transport's edit control (typically used for on the fly editing).")]
        Sub get_EditStart(ByRef pValue As Long)
        Sub put_EditStart(ByVal Value As Long)
    End Interface
    
    [InterfaceId("9B496CE1-811B-11cf-8C77-00AA006B6814")]
    [OleAutomation(False)]
    Interface IAMTimecodeReader
        [Description("Timecode Reader Mode - gets/sets the following properties - ED_TCR_SOURCE - timecode gen (readback), LTC, VITC, or Control Track")]
        Sub GetTCRMode(ByVal Param As AMTimecodeReaderModeParamsAndValues, ByRef pValue As AMTimecodeReaderModeParamsAndValues)
        Sub SetTCRMode(ByVal Param As AMTimecodeReaderModeParamsAndValues, ByVal Value As AMTimecodeReaderModeParamsAndValues)
        [Description("Select which line of the vertical interval timecode will be read from (if VITC). To read VITC on specific multiple lines, the caller would make successive calls to put_VITCLine(), once for each line desired.")]
        Sub put_VITCLine(ByVal Line As Long)
        Sub get_VITCLine(ByRef pLine As Long)
        [Description("GetTimecode can be used to obtain the most recent timecode value available in the stream. The client can use this to monitor the timecode, parse duplicates and discontinuities. The source filter supplying the timecode or possibly a down stream filter might want to parse for discontinuities or errors since you have to look at every sample to do this properly.")]
        Sub GetTimecode(pTimecodeSample As TIMECODE_SAMPLE)
    End Interface
    
    [InterfaceId("9B496CE0-811B-11cf-8C77-00AA006B6814")]
    [OleAutomation(False)]
    Interface IAMTimecodeGenerator
        [Description("Timecode Generator Mode - gets/sets the following properties (see vcrdefss.h for detailed values): ED_TCG_TIMECODE_TYPE - LTC, VITC, or MIDI; ED_TCG_FRAMERATE - 24, 25, 30 drop or 30 nondrop; ED_TCG_SYNC_SOURCE - what is driving the bitclock; ED_TCG_REFERENCE_SOURCE - what is driving the count value")]
        Sub GetTCGMode(ByVal Param As AMTimegenModeParamsAndValues, ByRef pValue As AMTimegenModeParamsAndValues)
        Sub SetTCGMode(ByVal Param As AMTimegenModeParamsAndValues, ByVal Value As AMTimegenModeParamsAndValues)
        [Description("Select into which line(s) of the vertical interval timecode will be inserted (if VITC). Hi bit set means add this line to any previously set lines. To generate VITC on specific multiple lines, the caller would make successive calls to put_VITCLine(), once for each line desired.")]
        Sub put_VITCLine(ByVal Line As Long)
        Sub get_VITCLine(ByRef pLine As Long)
        [Description("Sets timecode and/or userbit value. If generator is running, takes effect immediately. If caller wants to set only timecode, set userbit value to -1L (and same for setting userbits only)")]
        Sub SetTimecode(ByRef pTimecodeSample As TIMECODE_SAMPLE)
        [Description("GetTimecode can be used to obtain the most recent timecode value available in the stream. The client can use this to monitor the timecode and verify the generator is working properly")]
        Sub GetTimecode(ByRef pTimecodeSample As TIMECODE_SAMPLE)
    End Interface
    
    [InterfaceId("9B496CE2-811B-11cf-8C77-00AA006B6814")]
    [OleAutomation(False)]
    Interface IAMTimecodeDisplay
        [Description("Enable/disable external device's timecode reader's character generator output. Some readers have this feature - this is not intended for rendering inside the PC!")]
        Sub GetTCDisplayEnable(ByRef pState As Long)
        Sub SetTCDisplayEnable(ByVal State As Long)
        [Description("Timecode reader's character generator output characteristics (size, position, intensity, etc.).")]
        Sub GetTCDisplay(ByVal Param As AMTimecodeDispModeParamsAndValues, ByRef pValue As AMTimecodeDispModeParamsAndValues)
        Sub SetTCDisplay(ByVal Param As AMTimecodeDispModeParamsAndValues, ByVal Value As AMTimecodeDispModeParamsAndValues)
    End Interface
    
    [InterfaceId("c6545bf0-e76b-11d0-bd52-00a0c911ce86")]
    [OleAutomation(False)]
    Interface IAMDevMemoryAllocator
        Sub GetInfo(ByRef pdwcbTotalFree As Long, ByRef pdwcbLargestFree As Long, ByRef pdwcbTotalMemory As Long, ByRef pdwcbMinimumChunk As Long)
        Sub CheckMemory(ByVal pBuffer As LongPtr)
        Sub Alloc(ByRef ppBuffer As LongPtr, ByRef pdwcbBuffer As Long)
        Sub Free(ByVal pBuffer As LongPtr)
        Sub GetDevMemoryObject(ByRef ppUnkInnner As IUnknown, ByVal pUnkOuter As IUnknown)
    End Interface
    
    [InterfaceId("c6545bf1-e76b-11d0-bd52-00a0c911ce86")]
    [OleAutomation(False)]
    Interface IAMDevMemoryControl
        Sub QueryWriteSync()
        Sub WriteSync()
        Sub GetDevId(ByRef pdwDevId As Long)
    End Interface
    
    [InterfaceId("c1960960-17f5-11d1-abe1-00a0c905f375")]
    [OleAutomation(False)]
    Interface IAMStreamSelect
        [Description("Returns total count of streams")]
        Sub Count(ByRef pcStreams As Long)
        [Description("Return info for a given stream - S_FALSE if iIndex out of range. The first steam in each group is the default")]
        Sub Info(ByVal lIndex As Long, ByRef ppmt As LongPtr, ByRef pdwFlags As _AMSTREAMSELECTINFOFLAGS, ByRef plcid As Long, ByRef pdwGroup As Long, ByRef ppszName As LongPtr, ByRef ppObject As IUnknown, ByRef ppUnk As IUnknown)
        [Description("Enable or disable a given stream")]
        Sub Enable(ByVal lIndex As Long, ByVal dwFlags As _AMSTREAMSELECTENABLEFLAGS)
    End Interface
    
    [InterfaceId("8389d2d0-77d7-11d1-abe6-00a0c905f375")]
    [OleAutomation(False)]
    Interface IAMResourceControl
        [Description("The reserve count is incremented/decremented if and only if S_OK is returned. Unreserve once for every Reserve call")]
        Sub Reserve(ByVal dwFlags As _AMRESCTL_RESERVEFLAGS, ByVal pvReserved As LongPtr)
    End Interface
    
    [InterfaceId("4D5466B0-A49C-11D1-ABE8-00A0C905F375")]
    [OleAutomation(False)]
    Interface IAMClockAdjust Extends stdole.IUnknown
        [PreserveSig]
        Function SetClockDelta(ByVal rtDelta As LongLong /* LongLong */) As Long
    End Interface
    
    [InterfaceId("2dd74950-a890-11d1-abe8-00a0c905f375")]
    [OleAutomation(False)]
    Interface IAMFilterMiscFlags
        [Description("Get miscellaneous property flags")]
        [PreserveSig] Function GetMiscFlags() As _AM_FILTER_MISC_FLAGS
    End Interface
    
    [InterfaceId("48efb120-ab49-11d2-aed2-00a0c995e8d5")]
    [OleAutomation(False)]
    Interface IDrawVideoImage
        Sub DrawVideoImageBegin()
        Sub DrawVideoImageEnd()
        Sub DrawVideoImageDraw(ByVal hdc As LongPtr, ByRef lprcSrc As RECT, ByRef lprcDst As RECT)
    End Interface
    
    [InterfaceId("2e5ea3e0-e924-11d2-b6da-00a0c995e8df")]
    [OleAutomation(False)]
    Interface IDecimateVideoImage
        [Description("Informs the decoder that it should decimate its output image to the specified width and height. If the decoder can decimate to this size it should return S_OK. If the decoder can't perform the requested decimation or wants to stop performing the decimation that it is currently doing it should return E_FAIL.")]
        Sub SetDecimationImageSize(ByVal lWidth As Long, ByVal lHeight As Long)
        [Description("Informs the decoder that it should stop decimating its output image and resume normal output.")]
        Sub ResetDecimationImageSize()
    End Interface
    
    [InterfaceId("60d32930-13da-11d3-9ec6-c4fcaef5c7be")]
    [OleAutomation(False)]
    Interface IAMVideoDecimationProperties
        [Description("Queries the current usage of the above IDecimateVideoImage interface.")]
        Sub QueryDecimationUsage(ByRef lpUsage As DECIMATION_USAGE)
        [Description("Sets the current usage of the above IDecimateVideoImage interface.")]
        Sub SetDecimationUsage(ByVal Usage As DECIMATION_USAGE)
    End Interface
    
    [InterfaceId("e46a9787-2b71-444d-a4b5-1fab7b708d6a")]
    [OleAutomation(False)]
    Interface IVideoFrameStep
        Sub Step(ByVal dwFrames As Long, ByVal pStepObject As IUnknown)
        [Description("Can step? Returns S_OK if it can, S_FALSE if it can't or error code. bMultiple - if TRUE return whether can step n > 1")]
        Sub CanStep(ByVal bMultiple As Long, ByVal pStepObject As IUnknown)
        [Description("Cancel stepping")]
        Sub CancelStep()
    End Interface
    
    [InterfaceId("F185FE76-E64E-11d2-B76E-00C04FB6BD3D")]
    [OleAutomation(False)]
    Interface IAMPushSource
        [Description("Used to discover push source's capabilities. May be any combination of the AM_PUSHSOURCE_FLAGS flags.")]
        Sub GetPushSourceFlags(ByRef pFlags As _AM_PUSHSOURCE_FLAGS)
        [Description("Used to set request flags for a push source. May be a combination of the AM_PUSHSOURCE_REQS_xxx flags.")]
        Sub SetPushSourceFlags(ByVal Flags As _AM_PUSHSOURCE_FLAGS)
        [Description("Specify an offset for push source time stamps")]
        Sub SetStreamOffset(ByVal rtOffset As LongLong /* REFERENCE_TIME */)
        [Description("Retrieve the offset this push source is using")]
        Sub GetStreamOffset(ByRef prtOffset As LongLong /* REFERENCE_TIME */)
        [Description("Retrieve the maximum stream offset this push source thinks it can support")]
        Sub GetMaxStreamOffset(ByRef prtMaxOffset As LongLong /* REFERENCE_TIME */)
        [Description("Allows the filter graph to tell a push source the maximum latency allowed on the graph. This allows pins like the video capture preview pin to be more efficient with the amount of buffering required to support the maximum graph latency")]
        Sub SetMaxStreamOffset(ByVal rtMaxOffset As LongLong /* REFERENCE_TIME */)
    End Interface
    
    [InterfaceId("f90a6130-b658-11d2-ae49-0000f8754b99")]
    [OleAutomation(False)]
    Interface IAMDeviceRemoval
        Sub DeviceInfo(ByRef pclsidInterfaceClass As UUID, ByRef pwszSymbolicLink As LongPtr)
        Sub Reassociate()
        Sub Disassociate()
    End Interface
    
    [InterfaceId("d18e17a0-aacb-11d0-afb0-00aa00b67a42")]
    [OleAutomation(False)]
    Interface IDVEnc
        Sub get_IFormatResolution(ByRef VideoFormat As _DVENCODERVIDEOFORMAT, ByRef DVFormat As _DVENCODERFORMAT, ByRef Resolution As _DVENCODERRESOLUTION, ByVal fDVInfo As Byte, ByRef sDVInfo As DVINFO)
        Sub put_IFormatResolution(ByVal VideoFormat As _DVENCODERVIDEOFORMAT, ByVal DVFormat As _DVENCODERFORMAT, ByVal Resolution As _DVENCODERRESOLUTION, ByVal fDVInfo As Byte, ByRef sDVInfo As DVINFO)
    End Interface
    
    [InterfaceId("b8e8bd60-0bfe-11d0-af91-00aa00b67a42")]
    [OleAutomation(False)]
    Interface IIPDVDec
        Sub get_IPDisplay(ByRef displayPix As Long)
        Sub put_IPDisplay(ByVal displayPix As Long)
    End Interface
    
    [InterfaceId("58473A19-2BC8-4663-8012-25F81BABDDD1")]
    [OleAutomation(False)]
    Interface IDVRGB219
        [Description("State = True Turn 219 mode on else turn it off.")]
        Sub SetRGB219(ByVal bState As BOOL)
    End Interface
    
    [InterfaceId("92a3a302-da7c-4a1f-ba7e-1802bb5d2d02")]
    [OleAutomation(False)]
    Interface IDVSplitter
        Sub DiscardAlternateVideoFrames(ByVal nDiscard As Long)
    End Interface
    
    [InterfaceId("22320CB2-D41A-11d2-BF7C-D7CB9DF0BF93")]
    [OleAutomation(False)]
    Interface IAMAudioRendererStats
        [Description("Get value corresponding to the passed in parameter id")]
        Sub GetStatParam(ByVal dwParam As _AM_AUDIO_RENDERER_STAT_PARAM, ByRef pdwParam1 As Long, ByRef pdwParam2 As Long)
    End Interface
    
    [InterfaceId("62EA93BA-EC62-11d2-B770-00C04FB6BD3D")]
    [OleAutomation(False)]
    Interface IAMLatency
        Sub GetLatency(ByRef prtLatency As LongLong /* REFERENCE_TIME */)
    End Interface
    
    [InterfaceId("632105FA-072E-11d3-8AF9-00C04FB6BD3D")]
    [OleAutomation(False)]
    Interface IAMGraphStreams
        [Description("Search upstream from the current pin, for the specified interface. dwFlags can be any combination of the AM_INTF_SEARCH_FLAGS, and allows control over what objects to search. A value of 0 means to search all.")]
        Sub FindUpstreamInterface(ByVal pPin As IPin, ByRef riid As UUID, ByRef ppvInterface As Any, ByVal dwFlags As _AM_INTF_SEARCH_FLAGS)
        [Description("Enable or disable the graph's setting of a timestamp offset on push sources.")]
        Sub SyncUsingStreamOffset(ByVal bUseStreamOffset As BOOL)
        [Description("Allow an app to set the maximum offset used on push source filters")]
        Sub SetMaxGraphLatency(ByVal rtMaxGraphLatency As LongLong /* REFERENCE_TIME */)
    End Interface
    
    [InterfaceId("62fae250-7e65-4460-bfc9-6398b322073c")]
    [OleAutomation(False)]
    Interface IAMOverlayFX
        [Description("Use this method to determine what overlay effects are currently available for the overlay surface used by the overlay mixer filter.")]
        Sub QueryOverlayFXCaps(ByRef lpdwOverlayFXCaps As AMOVERLAYFX)
        [Description("Use this method to apply a new overlay effect to the overlay surface used by the overlay mixer filter. This method can be called while the filter graph is running, the effect is applied immediately")]
        Sub SetOverlayFX(ByVal dwOverlayFX As AMOVERLAYFX)
        [Description("Use this method to determine what effect (if any) is currently being applied to the overlay surface by the overlay mixer filter.")]
        Sub GetOverlayFX(ByRef lpdwOverlayFX As AMOVERLAYFX)
    End Interface
    
    [InterfaceId("8E1C39A1-DE53-11cf-AA63-0080C744528D")]
    [OleAutomation(False)]
    Interface IAMOpenProgress
        [Description("QueryProgress can be used to query the source filter which supports this interface for progress information during a renderfile operation.")]
        Sub QueryProgress(ByRef pllTotal As LongLong, ByRef pllCurrent As LongLong)
        [Description("AbortOperation can be used to request an abort of RenderFile operation causing it to stop downloading. This methods instructs the exporter of the IAMOpenProgress interface to hold up their internal abort flag until further notice.")]
        Sub AbortOperation()
    End Interface
    
    [InterfaceId("436eee9c-264f-4242-90e1-4e330c107512")]
    [OleAutomation(False)]
    Interface IMpeg2Demultiplexer
        [Description("Creates an output pin of the specified media type.")]
        Sub CreateOutputPin(ByRef pMediaType As AM_MEDIA_TYPE, ByVal pszPinName As LongPtr, ByRef ppIPin As IPin)
        [Description("Updates the media type of the specified output pin. If no connection exists, the media type is updated always. If the pin is connected, the success/failure of the call will depend on downstream input pin's accetance/rejection of the specified media type, and subsequent success/failure of a reconnect.")]
        Sub SetOutputPinMediaType(ByVal pszPinName As LongPtr, ByRef pMediaType As AM_MEDIA_TYPE)
        [Description("Deletes the specified output pin.")]
        Sub DeleteOutputPin(ByVal pszPinName As LongPtr)
    End Interface
    
    [InterfaceId("945C1566-6202-46fc-96C7-D87F289C6534")]
    [OleAutomation(False)]
    Interface IEnumStreamIdMap Extends IUnknown
        [Description("Retrieves the next set of stream ID mappings")]
        Sub Next(ByVal cRequest As Long, ByRef pStreamIdMap As STREAM_ID_MAP, Optional ByRef pcReceived As Long)
        [Description("Skips the specified number of records")]
        Sub Skip(ByVal cRecords As Long)
        [Description("Resets the enumeration to the beginning")]
        Sub Reset()
        [Description("Creates a copy of the enumerator")]
        Sub Clone(ByRef ppIEnumStreamIdMap As IEnumStreamIdMap)
    End Interface

    [InterfaceId("D0E04C47-25B8-4369-925A-362A01D95444")]
    [OleAutomation(False)]
    Interface IMPEG2StreamIdMap Extends IUnknown
        [Description("Maps an MPEG-2 stream ID to media sample content")]
        Sub MapStreamId(ByVal ulStreamId As Long, ByVal MediaSampleContent As Long, ByVal ulSubstreamFilterValue As Long, ByVal iDataOffset As Long)
        [Description("Unmaps one or more MPEG-2 stream IDs")]
        Sub UnmapStreamId(ByVal culStreamId As Long, ByRef pulStreamId As Long)
        [Description("Creates an enumerator for the stream ID mappings")]
        Sub EnumStreamIdMap(ByRef ppIEnumStreamIdMap As IEnumStreamIdMap)
    End Interface

    [InterfaceId("7B3A2F01-0751-48DD-B556-004785171C54")]
    [OleAutomation(False)]
    Interface IRegisterServiceProvider Extends IUnknown
        [Description("Registers one service into its internal table. Object is refcounted. Register a NULL value to remove the service")]
        Sub RegisterService(ByRef guidService As UUID, ByVal pUnkObject As IUnknown)
    End Interface
    
    [InterfaceId("4995f511-9ddb-4f12-bd3b-f04611807b79")]
    Interface IAMGraphBuilderCallback Extends IUnknown
        [Description("Graph builder selected a filter to create and attempt to connect. Failure indicates filter should be rejected")]
        Sub SelectedFilter(ByVal pMon As IMoniker)
        [Description("App configures filter during this call. Failure indicates filter should be rejected")]
        Sub CreatedFilter(ByVal pFil As IBaseFilter)
    End Interface
    
    [InterfaceId("56A868FD-0AD4-11CE-B0A3-0020AF0BA770")]
    Interface IAMFilterGraphCallback Extends IUnknown
        [Description("S_OK means rendering complete, S_FALSE means retry now.")]
        [PreserveSig] Function UnableToRender CDecl(ByVal pPin As IPin) As Long
    End Interface

    [InterfaceId("a8809222-07bb-48ea-951c-33158100625b")]
    Interface IGetCapabilitiesKey Extends IUnknown
        [Description("Gets the capabilities key")]
        Sub GetCapabilitiesKey(ByRef pHKey As LongPtr)
    End Interface

    [InterfaceId("70423839-6ACC-4b23-B079-21DBF08156A5")]
    Interface IEncoderAPI Extends IUnknown
        [Description("Checks if the specified API is supported")]
        Sub IsSupported(ByRef Api As UUID)
        [Description("Checks if the specified API is available")]
        Sub IsAvailable(ByRef Api As UUID)
        [Description("Gets the parameter range for the specified API")]
        Sub GetParameterRange(ByRef Api As UUID, ByRef ValueMin As Variant, ByRef ValueMax As Variant, ByRef SteppingDelta As Variant)
        [Description("Gets the parameter values for the specified API")]
        Sub GetParameterValues(ByRef Api As UUID, ByRef Values As Variant, ByRef ValuesCount As Long)
        [Description("Gets the default value for the specified API")]
        Sub GetDefaultValue(ByRef Api As UUID, ByRef Value As Variant)
        [Description("Gets the current value for the specified API")]
        Sub GetValue(ByRef Api As UUID, ByRef Value As Variant)
        [Description("Sets the value for the specified API")]
        Sub SetValue(ByRef Api As UUID, ByRef Value As Variant)
    End Interface

    [InterfaceId("02997C3B-8E1B-460e-9270-545E0DE9563E")]
    Interface IVideoEncoder Extends IEncoderAPI
    End Interface
    
    [InterfaceId("CF7B26FC-9A00-485B-8147-3E789D5E8F67")]
    [OleAutomation(False)]
    Interface IAMAsyncReaderTimestampScaling Extends stdole.IUnknown
        [PreserveSig]
        Function GetTimestampMode(ByRef pfRaw As BOOL) As Long
        [PreserveSig]
        Function SetTimestampMode(ByVal fRaw As BOOL) As Long
    End Interface

    [InterfaceId("54C39221-8380-11D0-B3F0-00AA003761C5")]
    [OleAutomation(False)]
    Interface IAMAudioInputMixer Extends stdole.IUnknown
        [PreserveSig]
        Function put_Enable(ByVal fEnable As BOOL) As Long
        [PreserveSig]
        Function get_Enable(ByRef pfEnable As BOOL) As Long
        [PreserveSig]
        Function put_Mono(ByVal fMono As BOOL) As Long
        [PreserveSig]
        Function get_Mono(ByRef pfMono As BOOL) As Long
        [PreserveSig]
        Function put_MixLevel(ByVal Level As Double) As Long
        [PreserveSig]
        Function get_MixLevel(ByRef pLevel As Double) As Long
        [PreserveSig]
        Function put_Pan(ByVal Pan As Double) As Long
        [PreserveSig]
        Function get_Pan(ByRef pPan As Double) As Long
        [PreserveSig]
        Function put_Loudness(ByVal fLoudness As BOOL) As Long
        [PreserveSig]
        Function get_Loudness(ByRef pfLoudness As BOOL) As Long
        [PreserveSig]
        Function put_Treble(ByVal Treble As Double) As Long
        [PreserveSig]
        Function get_Treble(ByRef pTreble As Double) As Long
        [PreserveSig]
        Function get_TrebleRange(ByRef pRange As Double) As Long
        [PreserveSig]
        Function put_Bass(ByVal Bass As Double) As Long
        [PreserveSig]
        Function get_Bass(ByRef pBass As Double) As Long
        [PreserveSig]
        Function get_BassRange(ByRef pRange As Double) As Long
    End Interface
 
    [InterfaceId("56ED71A0-AF5F-11D0-B3F0-00AA003761C5")]
    [OleAutomation(False)]
    Interface IAMBufferNegotiation Extends stdole.IUnknown
        [PreserveSig]
        Function SuggestAllocatorProperties(ByRef pprop As ALLOCATOR_PROPERTIES) As Long
        [PreserveSig]
        Function GetAllocatorProperties(ByRef pprop As ALLOCATOR_PROPERTIES) As Long
    End Interface


    [InterfaceId("6FEDED3E-0FF1-4901-A2F1-43F7012C8515")]
    [OleAutomation(False)]
    Interface IAMCertifiedOutputProtection Extends stdole.IUnknown
        [PreserveSig]
        Function KeyExchange(ByRef pRandom As UUID, ByRef VarLenCertGH As LongPtr, ByRef pdwLengthCertGH As Long) As Long
        [PreserveSig]
        Function SessionSequenceStart(ByRef pSig As AMCOPPSignature) As Long
        [PreserveSig]
        Function ProtectionCommand(ByRef cmd As AMCOPPCommand) As Long
        [PreserveSig]
        Function ProtectionStatus(ByRef pStatusInput As AMCOPPStatusInput, ByRef pStatusOutput As AMCOPPStatusOutput) As Long
    End Interface


    [InterfaceId("9FD52741-176D-4B36-8F51-CA8F933223BE")]
    [OleAutomation(False)]
    Interface IAMClockSlave Extends stdole.IUnknown
        [PreserveSig]
        Function SetErrorTolerance(ByVal dwTolerance As Long) As Long
        [PreserveSig]
        Function GetErrorTolerance(ByRef pdwTolerance As Long) As Long
    End Interface
    
    [InterfaceId("0e26a181-f40c-4635-8786-976284b52981")]
    [OleAutomation(False)]
    Interface IAMPluginControl Extends IUnknown
        [Description("Gets the preferred CLSID for the specified subtype")]
        Sub GetPreferredClsid(ByRef subType As UUID, ByRef clsid As UUID)
        [Description("Gets the preferred CLSID by index")]
        Sub GetPreferredClsidByIndex(ByVal index As Long, ByRef subType As UUID, ByRef clsid As UUID)
        [Description("Sets the preferred CLSID for the specified subtype")]
        Sub SetPreferredClsid(ByRef subType As UUID, ByRef clsid As UUID)
        [Description("Checks if the specified CLSID is disabled")]
        Sub IsDisabled(ByRef clsid As UUID)
        [Description("Gets the disabled CLSID by index")]
        Sub GetDisabledByIndex(ByVal index As Long, ByRef clsid As UUID)
        [Description("Sets the disabled state for the specified CLSID")]
        Sub SetDisabled(ByRef clsid As UUID, ByVal disabled As BOOL)
        [Description("Checks if the specified DLL name is legacy disabled")]
        Sub IsLegacyDisabled(ByVal dllName As LongPtr)
    End Interface
     

    [InterfaceId("C6E13380-30AC-11D0-A18C-00A0C9118956")]
    [OleAutomation(False)]
    Interface IAMCrossbar Extends stdole.IUnknown
        [PreserveSig]
        Function get_PinCounts(ByRef OutputPinCount As Long, ByRef InputPinCount As Long) As Long
        [PreserveSig]
        Function CanRoute(ByVal OutputPinIndex As Long, ByVal InputPinIndex As Long) As Long
        [PreserveSig]
        Function Route(ByVal OutputPinIndex As Long, ByVal InputPinIndex As Long) As Long
        [PreserveSig]
        Function get_IsRoutedTo(ByVal OutputPinIndex As Long, ByRef InputPinIndex As Long) As Long
        [PreserveSig]
        Function get_CrossbarPinInfo(ByVal IsInputPin As Long, ByVal PinIndex As Long, ByRef PinIndexRelated As Long, ByRef PhysicalType As Long) As Long
    End Interface

    [InterfaceId("C0DFF467-D499-4986-972B-E1D9090FA941")]
    [OleAutomation(False)]
    Interface IAMDecoderCaps Extends stdole.IUnknown
        [PreserveSig]
        Function GetDecoderCaps(ByVal dwCapIndex As AMDecoderCapQueryIndex, ByRef lpdwCap As AMDecoderCapQueryResult) As Long
    End Interface

    [InterfaceId("56A8689A-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IMediaSample Extends stdole.IUnknown
        [PreserveSig]
        Function GetPointer(ByRef pBuffer As LongPtr) As Long
        [PreserveSig]
        Function GetSize() As Long
        [PreserveSig]
        Function GetTime(ByVal pTimeStart As REFERENCE_TIME, ByVal pTimeEnd As REFERENCE_TIME) As Long
        [PreserveSig]
        Function SetTime(ByVal pTimeStart As REFERENCE_TIME, ByVal pTimeEnd As REFERENCE_TIME) As Long
        [PreserveSig]
        Function IsSyncPoint() As Long
        [PreserveSig]
        Function SetSyncPoint(ByVal bIsSyncPoint As BOOL) As Long
        [PreserveSig]
        Function IsPreroll() As Long
        [PreserveSig]
        Function SetPreroll(ByVal bIsPreroll As BOOL) As Long
        [PreserveSig]
        Function GetActualDataLength() As Long
        [PreserveSig]
        Function SetActualDataLength(ByVal cb As Long) As Long
        [PreserveSig]
        Function GetMediaType(ByRef ppMediaType As LongPtr) As Long
        [PreserveSig]
        Function SetMediaType(ByRef pMediaType As AM_MEDIA_TYPE) As Long
        [PreserveSig]
        Function IsDiscontinuity() As Long
        [PreserveSig]
        Function SetDiscontinuity(ByVal bDiscontinuity As Long) As Long
        [PreserveSig]
        Function GetMediaTime(ByVal pTimeStart As LongLong, ByVal pTimeEnd As LongLong) As Long
        [PreserveSig]
        Function SetMediaTime(ByVal pTimeStart As LongLong, ByVal pTimeEnd As LongLong) As Long
    End Interface
    
    [InterfaceId("36B73884-C2C8-11CF-8B46-00805F6CEF60")]
    [OleAutomation(False)]
    Interface IMediaSample2 Extends IMediaSample
        [PreserveSig]
        Function GetProperties(ByVal cbProperties As Long, ByRef pbProperties As Any) As Long
        [PreserveSig]
        Function SetProperties(ByVal cbProperties As Long, ByRef pbProperties As Any) As Long
    End Interface

    [InterfaceId("68961E68-832B-41EA-BC91-63593F3E70E3")]
    [OleAutomation(False)]
    Interface IMediaSample2Config Extends stdole.IUnknown
        Sub GetSurface(ByRef ppDirect3DSurface9 As IUnknown)
    End Interface

    [InterfaceId("56A8689C-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IMemAllocator Extends stdole.IUnknown
        Sub SetProperties(ByRef pRequest As ALLOCATOR_PROPERTIES, ByRef pActual As ALLOCATOR_PROPERTIES)
        Sub GetProperties(ByRef pProps As ALLOCATOR_PROPERTIES)
        Sub Commit()
        Sub Decommit()
        Sub GetBuffer(ByRef ppBuffer As IMediaSample, ByVal pStartTime As LongLong /* REFERENCE_TIME */, ByVal pEndTime As LongLong /* REFERENCE_TIME */)
        Sub ReleaseBuffer(ByVal pBuffer As IMediaSample)
    End Interface
    [InterfaceId("379a0cf0-c1de-11d2-abf5-00a0c905f375")]
    [OleAutomation(False)]
    Interface IMemAllocatorCallbackTemp Extends IMemAllocator
        Sub SetNotify(ByVal pNotify As IMemAllocatorNotifyCallbackTemp)
        Sub GetFreeCount(ByRef plBuffersFree As Long)
    End Interface
    [InterfaceId("92980b30-c1de-11d2-abf5-00a0c905f375")]
    [OleAutomation(False)]
    Interface IMemAllocatorNotifyCallbackTemp Extends stdole.IUnknown
        Sub NotifyRelease()
    End Interface
    
    [InterfaceId("56a8689d-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IMemInputPin Extends IUnknown
        Sub GetAllocator(ByRef ppAllocator As IMemAllocator)
        Sub NotifyAllocator(ByVal pAllocator As IMemAllocator, bReadOnly As BOOL)
        Sub GetAllocatorRequirements(ByRef pProps As ALLOCATOR_PROPERTIES)
        Sub Receive(ByVal pSample As IMediaSample)
        Sub ReceiveMultiple(pSamples As IMediaSample, ByVal nSamples As Long, ByRef nSamplesProcessed As Long)
        Sub ReceiveCanBlock()
    End Interface
    
    [InterfaceId("a3d8cec0-7e5a-11cf-bbc5-00805f6cef20")]
    [OleAutomation(False)]
    Interface IAMovieSetup Extends IUnknown
        Sub Register()
        Sub Unregister()
    End Interface
    
    [InterfaceId("36b73880-c2c8-11cf-8b46-00805f6cef60")]
    [OleAutomation(False)]
    Interface IMediaSeeking Extends IUnknown
        Sub GetCapabilities(ByRef pCapabilities As AM_SEEKING_SEEKING_CAPABILITIES)
        Sub CheckCapabilities(ByRef pCapabilities As AM_SEEKING_SEEKING_CAPABILITIES)
        Sub IsFormatSupported(ByRef pFormat As UUID)
        Sub QueryPreferredFormat(ByRef pFormat As UUID)
        Sub GetTimeFormat(ByRef pFormat As UUID)
        Sub IsUsingTimeFormat(ByRef pFormat As UUID)
        Sub SetTimeFormat(ByRef pFormat As UUID)
        Sub GetDuration(ByRef pDuration As LongLong)
        Sub GetStopPosition(ByRef pStop As LongLong)
        Sub GetCurrentPosition(ByRef pCurrent As LongLong)
        Sub ConvertTimeFormat(ByRef pTarget As LongLong, ByRef pTargetFormat As UUID, ByVal Source As LongLong, ByRef pSourceFormat As UUID)
        Sub SetPositions(ByRef pCurrent As LongLong, ByVal dwCurrentFlags As AM_SEEKING_SEEKING_FLAGS, ByRef pStop As LongLong, ByVal dwStopFlags As AM_SEEKING_SEEKING_FLAGS)
        Sub GetPositions(ByRef pCurrent As LongLong, ByRef pStop As LongLong)
        Sub GetAvailable(ByRef pEarliest As LongLong, ByRef pLatest As LongLong)
        Sub SetRate(ByVal dRate As Double)
        Sub GetRate(ByRef pdRate As Double)
        Sub GetPreroll(ByRef pllPreroll As LongLong)
    End Interface
    
    [InterfaceId("901db4c7-31ce-41a2-85dc-8fa0bf41b8da")]
    [OleAutomation(False)]
    Interface ICodecAPI Extends IUnknown
        Sub IsSupported(ByRef Api As UUID)
        Sub IsModifiable(ByRef Api As UUID)
        Sub GetParameterRange(ByRef Api As UUID, ByRef ValueMin As Variant, ByRef ValueMax As Variant, ByRef SteppingDelta As Variant)
        Sub GetParameterValues(ByRef Api As UUID, ByRef Values As LongPtr, ByRef ValuesCount As Long)
        Sub GetDefaultValue(ByRef Api As UUID, ByRef Value As Variant)
        Sub GetValue(ByRef Api As UUID, ByRef Value As Variant)
        Sub SetValue(ByRef Api As UUID, ByRef Value As Variant)
        Sub RegisterForEvent(ByRef Api As UUID, ByVal userData As LongPtr)
        Sub UnregisterForEvent(ByRef Api As UUID)
        Sub SetAllDefaults()
        Sub SetValueWithNotify(ByRef Api As UUID, ByRef Value As Variant, ByRef ChangedParam As LongPtr, ByRef ChangedParamCount As Long)
        Sub SetAllDefaultsWithNotify(ByRef ChangedParam As LongPtr, ByRef ChangedParamCount As Long)
        Sub GetAllSettings(ByVal pStream As IStream)
        Sub SetAllSettings(ByVal pStream As IStream)
        Sub SetAllSettingsWithNotify(ByVal pStream As IStream, ByRef ChangedParam As LongPtr, ByRef ChangedParamCount As Long)
    End Interface
    
    [InterfaceId("56a868a4-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IEnumRegFilters Extends IUnknown
        [PreserveSig] Function Next(ByVal cFilters As Long, ByRef apRegFilter As LongPtr, ByRef pcFetched As Long) As Long
        Sub Skip(ByVal cFilters As Long)
        Sub Reset()
        Sub Clone(ByRef ppEnum As IEnumRegFilters)
    End Interface
    
    #If TWINBASIC_BUILD >= 896 Then
    [InterfaceId("56a868a3-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IFilterMapper Extends IUnknown
        Sub RegisterFilter(ByVal clsid As UUID, ByVal Name As LongPtr, ByVal dwMerit As DShowFilterMapperMeritFlags)
        Sub RegisterFilterInstance(ByVal clsid As UUID, ByVal Name As LongPtr, ByRef MRId As UUID)
        Sub RegisterPin(ByVal Filter As UUID, ByVal Name As LongPtr, ByVal bRendered As BOOL, ByVal bOutput As BOOL, ByVal bZero As BOOL, ByVal bMany As BOOL, ByVal ConnectsToFilter As UUID, ByVal ConnectsToPin As LongPtr)
        Sub RegisterPinType(ByVal clsFilter As UUID, ByVal strName As LongPtr, ByVal clsMajorType As UUID, ByVal clsSubType As UUID)
        Sub UnregisterFilter(ByVal Filter As UUID)
        Sub UnregisterFilterInstance(ByVal MRId As UUID)
        Sub UnregisterPin(ByVal Filter As UUID, ByVal Name As LongPtr)
        Sub EnumMatchingFilters(ByRef ppEnum As IEnumRegFilters, ByVal dwMerit As DShowFilterMapperMeritFlags, ByVal bInputNeeded As BOOL, ByVal clsInMaj As UUID, ByVal clsInSub As UUID, ByVal bRender As BOOL, ByVal bOututNeeded As BOOL, ByVal clsOutMaj As UUID, ByVal clsOutSub As UUID)
    End Interface
    [InterfaceId("56a868a5-0ad4-11ce-b03a-0020af0ba770")]
     [OleAutomation(False)]
     Interface IQualityControl Extends IUnknown
         Sub Notify(ByVal pSelf As IBaseFilter, ByVal q As Quality)
         Sub SetSink(ByVal piqc As IQualityControl)
     End Interface
    #Else 
     [InterfaceId("56a868a3-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IFilterMapper Extends IUnknown
        #If Win64 Then
        Sub RegisterFilter(clsid As UUID, ByVal Name As LongPtr, ByVal dwMerit As DShowFilterMapperMeritFlags)
        Sub RegisterFilterInstance(clsid As UUID, ByVal Name As LongPtr, ByRef MRId As UUID)
        Sub RegisterPin(Filter As UUID, ByVal Name As LongPtr, ByVal bRendered As BOOL, ByVal bOutput As BOOL, ByVal bZero As BOOL, ByVal bMany As BOOL, ConnectsToFilter As UUID, ByVal ConnectsToPin As LongPtr)
        Sub RegisterPinType(clsFilter As UUID, ByVal strName As LongPtr, clsMajorType As UUID, clsSubType As UUID)
        Sub UnregisterFilter(Filter As UUID)
        Sub UnregisterFilterInstance(MRId As UUID)
        Sub UnregisterPin(Filter As UUID, ByVal Name As LongPtr)
        Sub EnumMatchingFilters(ByRef ppEnum As IEnumRegFilters, ByVal dwMerit As DShowFilterMapperMeritFlags, ByVal bInputNeeded As BOOL, clsInMaj As UUID, clsInSub As UUID, ByVal bRender As BOOL, ByVal bOututNeeded As BOOL, clsOutMaj As UUID, clsOutSub As UUID)
        #Else
        Sub RegisterFilter(ByVal clsid1 As Long, ByVal clsid2 As Long, ByVal clsid3 As Long, ByVal clsid4 As Long, ByVal Name As LongPtr, ByVal dwMerit As DShowFilterMapperMeritFlags)
        Sub RegisterFilterInstance(ByVal clsid1 As Long, ByVal clsid2 As Long, ByVal clsid3 As Long, ByVal clsid4 As Long, ByVal Name As LongPtr, ByRef MRId As UUID)
        Sub RegisterPin(ByVal Filter1 As Long, ByVal Filter2 As Long, ByVal Filter3 As Long, ByVal Filter4 As Long, ByVal Name As LongPtr, ByVal bRendered As BOOL, ByVal bOutput As BOOL, ByVal bZero As BOOL, ByVal bMany As BOOL, ByVal ConnectsToFilter1 As Long, ByVal ConnectsToFilter2 As Long, ByVal ConnectsToFilter3 As Long, ByVal ConnectsToFilter4 As Long, ByVal ConnectsToPin As LongPtr)
        Sub RegisterPinType(ByVal clsFilter1 As Long, ByVal clsFilter2 As Long, ByVal clsFilter3 As Long, ByVal clsFilter4 As Long, ByVal strName As LongPtr, ByVal clsMajorType1 As Long, ByVal clsMajorType2 As Long, ByVal clsMajorType3 As Long, ByVal clsMajorType4 As Long, ByVal clsSubType1 As Long, ByVal clsSubType2 As Long, ByVal clsSubType3 As Long, ByVal clsSubType4 As Long)
        Sub UnregisterFilter(ByVal Filter1 As Long, ByVal Filter2 As Long, ByVal Filter3 As Long, ByVal Filter4 As Long)
        Sub UnregisterFilterInstance(ByVal MRId1 As Long, ByVal MRId2 As Long, ByVal MRId3 As Long, ByVal MRId4 As Long)
        Sub UnregisterPin(ByVal Filter1 As Long, ByVal Filter2 As Long, ByVal Filter3 As Long, ByVal Filter4 As Long, ByVal Name As LongPtr)
        Sub EnumMatchingFilters(ByRef ppEnum As IEnumRegFilters, ByVal dwMerit As DShowFilterMapperMeritFlags, ByVal bInputNeeded As BOOL, ByVal clsInMaj1 As Long, ByVal clsInMaj2 As Long, ByVal clsInMaj3 As Long, ByVal clsInMaj4 As Long, ByVal clsInSub1 As Long, ByVal clsInSub2 As Long, ByVal clsInSub3 As Long, ByVal clsInSub4 As Long, ByVal bRender As BOOL, ByVal bOututNeeded As BOOL, ByVal clsOutMaj1 As Long, ByVal clsOutMaj2 As Long, ByVal clsOutMaj3 As Long, ByVal clsOutMaj4 As Long, ByVal clsOutSub1 As Long, ByVal clsOutSub2 As Long, ByVal clsOutSub3 As Long, ByVal clsOutSub4 As Long)
        #End If
    End Interface
   [InterfaceId("56a868a5-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IQualityControl Extends IUnknown
        #If Win64 Then
        Sub Notify(ByVal pSelf As IBaseFilter, q As Quality)
        #Else
        Sub Notify(ByVal pSelf As IBaseFilter, ByVal q_Type As QualityMessageType, ByVal q_Proportion As Long, ByVal q_Late As LongLong, ByVal q_TimeStamp As LongLong)
        #End If
        Sub SetSink(ByVal piqc As IQualityControl)
    End Interface
    #End If
    
    [InterfaceId("b79bb0b0-33c1-11d1-abe1-00a0c905f375")]
    [OleAutomation(False)]
    Interface IFilterMapper2 Extends IUnknown
        Sub CreateCategory(ByRef clsidCategory As UUID, ByVal dwCategoryMerit As DShowFilterMapperMeritFlags, ByVal Description As LongPtr)
        Sub UnregisterFilter(ByRef pclsidCategory As UUID, ByVal szInstance As LongPtr, ByRef Filter As UUID)
        Sub RegisterFilter(ByRef clsidFilter As UUID, ByVal Name As LongPtr, ByRef ppMoniker As IMoniker, ByRef pclsidCategory As UUID, ByVal szInstance As LongPtr, prf2 As REGFILTER2)
        Sub EnumMatchingFilters(ByRef ppEnum As IEnumMoniker, ByVal dwFlags As Long, ByVal bExactMatch As BOOL, ByVal dwMerit As DShowFilterMapperMeritFlags, ByVal bInputNeeded As BOOL, ByVal cInputTypes As Long, ByVal pInputTypes As LongPtr, pMedIn As REGPINMEDIUM, pPinCategoryIn As UUID, ByVal bRender As BOOL, ByVal bOutputNeeded As BOOL, ByVal cOutputTypes As Long, pOutputTypes As UUID, pMedOut As REGPINMEDIUM, pPinCategoryOut As UUID)
    End Interface
    [InterfaceId("b79bb0b1-33c1-11d1-abe1-00a0c905f375")]
    [OleAutomation(False)]
    Interface IFilterMapper3 Extends IFilterMapper2
        Sub GetICreateDevEnum(ByRef ppEnum As ICreateDevEnum)
    End Interface
    
     
    [InterfaceId("56a868a0-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IOverlayNotify Extends IUnknown
        Sub OnPaletteChange(ByVal dwColors As Long, ByRef pPalette As PALETTEENTRY)
        Sub OnClipChange(ByRef pSourceRect As RECT, ByRef pDestinationRect As RECT, ByRef pRgnData As Any)
        Sub OnColorKeyChange(ByRef pColorKey As COLORKEY)
        Sub OnPositionChange(ByRef pSourceRect As RECT, ByRef pDestinationRect As RECT)
    End Interface
    [InterfaceId("680EFA10-D535-11D1-87C8-00A0C9223196")]
    [OleAutomation(False)]
    Interface IOverlayNotify2 Extends IOverlayNotify
        Sub OnDisplayChange(ByVal hMonitor As LongPtr)
    End Interface
    
    [InterfaceId("56a868a1-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IOverlay Extends IUnknown
        Sub GetPalette(ByRef pdwColors As Long, ByRef ppPalette As LongPtr)
        Sub SetPalette(ByVal dwColors As Long, ByRef pPalette As PALETTEENTRY)
        Sub GetDefaultColorKey(ByRef pColorKey As COLORKEY)
        Sub GetColorKey(ByRef pColorKey As COLORKEY)
        Sub SetColorKey(ByRef pColorKey As COLORKEY)
        Sub GetWindowHandle(ByRef pHwnd As LongPtr)
        Sub GetClipList(ByRef pSourceRect As RECT, ByRef pDestinationRect As RECT, ByRef ppRgnData As LongPtr)
        Sub GetVideoPosition(ByRef pSourceRect As RECT, ByRef pDestinationRect As RECT)
        Sub Advise(ByVal pOverlayNotify As IOverlayNotify, ByVal dwInterests As Long)
        Sub Unadvise()
    End Interface
    
    [InterfaceId("56A868A2-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IMediaEventSink Extends IUnknown
        Sub Notify(ByVal EventCode As EC_CODES, ByVal EventParam1 As LongPtr, ByVal EventParam2 As LongPtr)
    End Interface
    
    [InterfaceId("56A868A6-0AD4-11CE-B03A-0020AF0BA770")]
    [OleAutomation(False)]
    Interface IFileSourceFilter Extends IUnknown
        Sub Load(ByVal pszFileName As LongPtr, pmt As AM_MEDIA_TYPE)
        Sub GetCurFile(ppszFileName As LongPtr, pmt As AM_MEDIA_TYPE)
    End Interface
    
    [InterfaceId("00855B90-CE1B-11d0-BD4F-00A0C911CE86")]
    [OleAutomation(False)]
    Interface IFileSinkFilter2 Extends IFileSinkFilter
        Sub SetMode(ByVal dwFlags As AM_FILESINK_FLAGS)
        Sub GetMode(ByRef pdwFlags As AM_FILESINK_FLAGS)
    End Interface
    
    [InterfaceId("56a868bf-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IStreamBuilder Extends IUnknown
        Sub Render(ByVal ppinOut As IPin, ByVal pGraph As IGraphBuilder)
        Sub Backout(ByVal ppinOut As IPin, ByVal pGraph As IGraphBuilder)
    End Interface
    
    [InterfaceId("56a868aa-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IAsyncReader Extends IUnknown
        Sub RequestAllocator(ByVal pPreferred As IMemAllocator, ByRef pProps As ALLOCATOR_PROPERTIES, ByRef ppActual As IMemAllocator)
        Sub Request(ByVal pSample As IMediaSample, ByVal dwUser As LongPtr)
        Sub WaitForNext(ByVal dwTimeout As Long, ByRef ppSample As IMediaSample, ByRef pdwUser As LongPtr)
        Sub SyncReadAligned(ByVal pSample As IMediaSample)
        Sub SyncRead(ByVal llPosition As LongLong, ByVal lLength As Long, ByRef pBuffer As Any)
        Sub Length(ByRef pTotal As LongLong, ByRef pAvailable As LongLong)
        Sub BeginFlush()
        Sub EndFlush()
    End Interface
    
    [InterfaceId("56a868ab-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IGraphVersion Extends IUnknown
        Sub QueryVersion(ByRef pVersion As Long)
    End Interface

    [InterfaceId("56a868ad-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IResourceConsumer Extends IUnknown
        Sub AcquireResource(ByVal idResource As Long)
        Sub ReleaseResource(ByVal idResource As Long)
    End Interface

    [InterfaceId("56a868ac-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IResourceManager Extends IUnknown
        Sub Register(ByVal pName As String, ByVal cResource As Long, ByRef plToken As Long)
        Sub RegisterGroup(ByVal pName As String, ByVal cResource As Long, ByRef palTokens As Long, ByRef plToken As Long)
        Sub RequestResource(ByVal idResource As Long, ByVal pFocusObject As IUnknown, ByVal pConsumer As IResourceConsumer)
        Sub NotifyAcquire(ByVal idResource As Long, ByVal pConsumer As IResourceConsumer, ByVal hr As Long)
        Sub NotifyRelease(ByVal idResource As Long, ByVal pConsumer As IResourceConsumer, ByVal bStillWant As BOOL)
        Sub CancelRequest(ByVal idResource As Long, ByVal pConsumer As IResourceConsumer)
        Sub SetFocus(ByVal pFocusObject As IUnknown)
        Sub ReleaseFocus(ByVal pFocusObject As IUnknown)
    End Interface
    
    [InterfaceId("56a868af-0ad4-11ce-b03a-0020af0ba770")]
    [OleAutomation(False)]
    Interface IDistributorNotify Extends IUnknown
        Sub Stop()
        Sub Pause()
        Sub Run(ByVal tStart As LongLong)
        Sub SetSyncSource(ByVal pClock As IReferenceClock)
        Sub NotifyGraphChange()
    End Interface

    [InterfaceId("36b73881-c2c8-11cf-8b46-00805f6cef60")]
    [OleAutomation(False)]
    Interface IAMStreamControl Extends IUnknown
        Sub StartAt(ByRef ptStart As LongLong, ByVal dwCookie As Long)
        Sub StopAt(ByRef ptStop As LongLong, ByVal bSendExtra As BOOL, ByVal dwCookie As Long)
        Sub GetInfo(ByRef pInfo As AM_STREAM_INFO)
    End Interface
    
    [InterfaceId("36b73883-c2c8-11cf-8b46-00805f6cef60")]
    [OleAutomation(False)]
    Interface ISeekingPassThru Extends IUnknown
        Sub Init(ByVal bSupportRendering As BOOL, ByVal pPin As IPin)
    End Interface

    [InterfaceId("C6E13340-30AC-11d0-A18C-00A0C9118956")]
    [OleAutomation(False)]
    Interface IAMStreamConfig Extends IUnknown
        Sub SetFormat(ByRef pmt As AM_MEDIA_TYPE)
        Sub GetFormat(ByRef ppmt As AM_MEDIA_TYPE)
        Sub GetNumberOfCapabilities(ByRef piCount As Long, ByRef piSize As Long)
        Sub GetStreamCaps(ByVal iIndex As Long, ByRef ppmt As AM_MEDIA_TYPE, ByRef pSCC As Byte)
    End Interface

    [InterfaceId("BEE3D220-157B-11d0-BD23-00A0C911CE86")]
    [OleAutomation(False)]
    Interface IConfigInterleaving Extends IUnknown
        Sub put_Mode(ByVal mode As InterleavingMode)
        Sub get_Mode(ByRef pMode As InterleavingMode)
        Sub put_Interleaving(ByRef prtInterleave As LongLong, ByRef prtPreroll As LongLong)
        Sub get_Interleaving(ByRef prtInterleave As LongLong, ByRef prtPreroll As LongLong)
    End Interface

    [InterfaceId("5ACD6AA0-F482-11ce-8B67-00AA00A3F1A6")]
    [OleAutomation(False)]
    Interface IConfigAviMux Extends IUnknown
        Sub SetMasterStream(ByVal iStream As Long)
        Sub GetMasterStream(ByRef pStream As Long)
        Sub SetOutputCompatibilityIndex(ByVal fOldIndex As BOOL)
        Sub GetOutputCompatibilityIndex(ByRef pfOldIndex As BOOL)
    End Interface
    
    [InterfaceId("C6E13343-30AC-11d0-A18C-00A0C9118956")]
    [OleAutomation(False)]
    Interface IAMVideoCompression Extends IUnknown
        Sub put_KeyFrameRate(ByVal KeyFrameRate As Long)
        Sub get_KeyFrameRate(ByRef pKeyFrameRate As Long)
        Sub put_PFramesPerKeyFrame(ByVal PFramesPerKeyFrame As Long)
        Sub get_PFramesPerKeyFrame(ByRef pPFramesPerKeyFrame As Long)
        Sub put_Quality(ByVal Quality As Double)
        Sub get_Quality(ByRef pQuality As Double)
        Sub put_WindowSize(ByVal WindowSize As LongLong)
        Sub get_WindowSize(ByRef pWindowSize As LongLong)
        Sub GetInfo(ByVal pszVersion As LongPtr, ByRef pcbVersion As Long, ByVal pszDescription As LongPtr, ByRef pcbDescription As Long, ByRef pDefaultKeyFrameRate As Long, ByRef pDefaultPFramesPerKey As Long, ByRef pDefaultQuality As Double, ByRef pCapabilities As CompressionCaps)
        Sub OverrideKeyFrame(ByVal FrameNumber As Long)
        Sub OverrideFrameSize(ByVal FrameNumber As Long, ByVal Size As Long)
    End Interface
    
    [InterfaceId("D8D715A0-6E5E-11D0-B3F0-00AA003761C5")]
    [OleAutomation(False)]
    Interface IAMVfwCaptureDialogs Extends IUnknown
        Sub HasDialog(ByVal iDialog As Long)
        Sub ShowDialog(ByVal iDialog As Long, ByVal hwnd As LongPtr)
        Sub SendDriverMessage(ByVal iDialog As Long, ByVal uMsg As Long, ByVal dw1 As Long, ByVal dw2 As Long)
    End Interface

    [InterfaceId("D8D715A3-6E5E-11D0-B3F0-00AA003761C5")]
    [OleAutomation(False)]
    Interface IAMVfwCompressDialogs Extends IUnknown
        Sub ShowDialog(ByVal iDialog As Long, ByVal hwnd As LongPtr)
        Sub GetState(ByRef pState As Any, ByRef pcbState As Long)
        Sub SetState(ByRef pState As Any, ByVal cbState As Long)
        Sub SendDriverMessage(ByVal uMsg As Long, ByVal dw1 As Long, ByVal dw2 As Long)
    End Interface

    [InterfaceId("C6E13344-30AC-11d0-A18C-00A0C9118956")]
    [OleAutomation(False)]
    Interface IAMDroppedFrames Extends IUnknown
        Sub GetNumDropped(ByRef plDropped As Long)
        Sub GetNumNotDropped(ByRef plNotDropped As Long)
        Sub GetDroppedInfo(ByVal lSize As Long, ByRef plArray As Long, ByRef plNumCopied As Long)
        Sub GetAverageFrameSize(ByRef plAverageSize As Long)
    End Interface
    
    
    
    

 
    [InterfaceId("0579154A-2B53-4994-B0D0-E773148EFF85")]
    [OleAutomation(False)]
    Interface ISampleGrabberCB Extends stdole.IUnknown
        Sub SampleCB(ByVal SampleTime As Double, ByVal pSample As IMediaSample)
        Sub BufferCB(ByVal SampleTime As Double, ByRef pBuffer As Any, ByVal BufferLen As Long)
    End Interface

    [InterfaceId("6B652FFF-11FE-4FCE-92AD-0266B5D7C78F")]
    [OleAutomation(False)]
    Interface ISampleGrabber Extends stdole.IUnknown
        Sub SetOneShot(ByVal OneShot As Long)
        Sub SetMediaType(ByRef pType As AM_MEDIA_TYPE)
        Sub GetConnectedMediaType(ByRef pType As AM_MEDIA_TYPE)
        Sub SetBufferSamples(ByVal BufferThem As Long)
        Sub GetCurrentBuffer(ByRef pBufferSize As Long, ByRef pBuffer As Any)
        Sub GetCurrentSample(ByRef ppSample As IMediaSample)
        Sub SetCallback(ByVal pCallback As ISampleGrabberCB, ByVal WhichMethodToCallback As Long)
    End Interface

    [InterfaceId("7FA864F8-EBEF-4D07-97E8-A410D7CEEDEB")]
    [Description("User callback object interface")]
    [OleAutomation(False)]
    Interface ISampleGrabberBuffer Extends ISampleGrabberCB
        [Description("Reset current time of sample")]
        Sub Reset()
        [PreserveSig]
        [Description("Calculate offset (in bytes) by specified time of sample")]
        Function GetOffsetByTime(ByVal SampleTime As Double) As Long
    End Interface

    [InterfaceId("B502D1BC-9A57-11D0-8FDE-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IMultiMediaStream Extends stdole.IUnknown
        Sub GetInformation(ByRef pdwFlags As MMSTRM_INFO_FLAGS, ByRef pStreamType As DDS_STREAM_TYPE)
        Sub GetMediaStream(ByRef idPurpose As UUID, ByRef ppMediaStream As IMediaStream)
        Sub EnumMediaStreams(ByVal index As Long, ByRef ppMediaStream As IMediaStream)
        Sub GetState(ByRef pCurrentState As DDS_STREAM_STATE)
        Sub SetState(ByVal NewState As DDS_STREAM_STATE)
        Sub GetTime(ByRef pCurrentTime As LongLong)
        Sub GetDuration(ByRef pDuration As LongLong)
        Sub Seek(ByVal SeekTime As LongLong)
        Sub GetEndOfStreamEventHandle(ByRef phEOS As LongPtr)
    End Interface

    [InterfaceId("B502D1BD-9A57-11D0-8FDE-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IMediaStream Extends stdole.IUnknown
        Sub GetMultiMediaStream(ByRef ppMultiMediaStream As IMultiMediaStream)
        Sub GetInformation(ByRef pPurposeId As UUID, ByRef pType As DDS_STREAM_TYPE)
        Sub SetSameFormat(ByVal pStreamThatHasDesiredFormat As IMediaStream, ByVal dwFlags As Long)
        Sub AllocateSample(ByVal dwFlags As Long, ByRef ppSample As IStreamSample)
        Sub CreateSharedSample(ByVal pExistingSample As IStreamSample, ByVal dwFlags As Long, ByRef ppNewSample As IStreamSample)
        Sub SendEndOfStream(ByVal dwFlags As Long)
    End Interface

    [InterfaceId("B502D1BE-9A57-11D0-8FDE-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IStreamSample Extends stdole.IUnknown
        Sub GetMediaStream(ByRef ppMediaStream As IMediaStream)
        Sub GetSampleTimes(ByRef pStartTime As LongLong, ByRef pEndTime As LongLong, ByRef pCurrentTime As LongLong)
        Sub SetSampleTimes(ByRef pStartTime As LongLong, ByRef pEndTime As LongLong)
        Sub Update(ByVal dwFlags As SSUPDATE_FLAGS, ByVal hEvent As LongPtr, ByVal pfnAPC As LongPtr, ByVal dwAPCData As LongPtr)
        Sub CompletionStatus(ByVal dwFlags As COMPLETION_STATUS_FLAGS, ByVal dwMilliseconds As Long)
    End Interface

    [InterfaceId("BEBE595C-9A6F-11D0-8FDE-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IAMMultiMediaStream Extends IMultiMediaStream
        Sub Initialize(ByVal StreamType As DDS_STREAM_TYPE, ByVal dwFlags As AMMSF_FLAGS, ByVal pFilterGraph As IGraphBuilder)
        Sub GetFiltergraph(ByRef ppGraphBuilder As IGraphBuilder)
        Sub GetFilter(ByRef ppFilter As IMediaStreamFilter)
        Sub AddMediaStream(ByVal pStreamObject As stdole.IUnknown, ByRef PurposeId As UUID, ByVal dwFlags As Long, ByRef ppNewStream As IMediaStream)
        Sub OpenFile(ByVal pszFileName As LongPtr, ByVal dwFlags As AMMSF_RENDERFLAGS)
        Sub OpenMoniker(ByVal pCtx As IBindCtx, ByVal pMoniker As IMoniker, ByVal dwFlags As AMMSF_RENDERFLAGS)
        Sub Render(ByVal dwFlags As AMMSF_RENDERFLAGS)
    End Interface

    [InterfaceId("BEBE595D-9A6F-11D0-8FDE-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IAMMediaStream Extends IMediaStream
        Sub Initialize(ByVal pSourceObject As stdole.IUnknown, ByVal dwFlags As AMS_INIT_FLAGS, ByRef PurposeId As UUID, ByVal StreamType As DDS_STREAM_TYPE)
        Sub SetState(ByVal State As FILTER_STATE)
        Sub JoinAMMultiMediaStream(ByVal pAMMultiMediaStream As IAMMultiMediaStream)
        Sub JoinFilter(ByVal pMediaStreamFilter As IMediaStreamFilter)
        Sub JoinFilterGraph(ByVal pFilterGraph As IFilterGraph)
    End Interface

    [InterfaceId("BEBE595E-9A6F-11D0-8FDE-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IMediaStreamFilter Extends IBaseFilter
        Sub AddMediaStream(ByVal pAMMediaStream As IAMMediaStream)
        Sub GetMediaStream(ByRef idPurpose As UUID, ByRef ppMediaStream As IMediaStream)
        Sub EnumMediaStreams(ByVal index As Long, ByRef ppMediaStream As IMediaStream)
        Sub SupportSeeking(ByVal bRenderer As BOOL)
        Sub ReferenceTimeToStreamTime(ByVal pTime As LongLong)
        Sub GetCurrentStreamTime(ByVal pCurrentStreamTime As LongLong)
        Sub WaitUntil(ByVal WaitStreamTime As LongLong)
        Sub Flush(ByVal bCancelEOS As BOOL)
        Sub EndOfStream()
    End Interface

    [InterfaceId("AB6B4AFC-F6E4-11D0-900D-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IDirectDrawMediaSampleAllocator Extends stdole.IUnknown
        Sub GetDirectDraw(ByRef ppDirectDraw As stdole.IUnknown)
    End Interface

    [InterfaceId("AB6B4AFE-F6E4-11D0-900D-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IDirectDrawMediaSample Extends stdole.IUnknown
        Sub GetSurfaceAndReleaseLock(ByRef ppDirectDrawSurface As stdole.IUnknown, ByRef pRect As RECT)
        Sub LockMediaSamplePointer()
    End Interface

    [InterfaceId("AB6B4AFA-F6E4-11D0-900D-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IAMMediaTypeStream Extends IMediaStream
        Sub GetFormat(ByRef pMediaType As AM_MEDIA_TYPE, ByVal dwFlags As Long)
        Sub SetFormat(ByRef pMediaType As AM_MEDIA_TYPE, ByVal dwFlags As Long)
        Sub CreateSample(ByVal lSampleSize As Long, ByRef pbBuffer As Any, ByVal dwFlags As Long, ByVal pUnkOuter As stdole.IUnknown, ByRef ppAMMediaTypeSample As IAMMediaTypeSample)
        Sub GetStreamAllocatorRequirements(ByRef pProps As ALLOCATOR_PROPERTIES)
        Sub SetStreamAllocatorRequirements(ByRef pProps As ALLOCATOR_PROPERTIES)
    End Interface

    [InterfaceId("AB6B4AFB-F6E4-11D0-900D-00C04FD9189D")]
    [OleAutomation(False)]
    Interface IAMMediaTypeSample Extends IStreamSample
        Sub SetPointer(ByRef pBuffer As Any, ByVal lSize As Long)
        Sub GetPointer(ByRef ppBuffer As LongPtr)
        [PreserveSig]
        Function GetSize() As Long
        Sub GetTime(ByVal pTimeStart As LongLong, ByVal pTimeEnd As LongLong)
        Sub SetTime(ByVal pTimeStart As LongLong, ByVal pTimeEnd As LongLong)
        Sub IsSyncPoint()
        Sub SetSyncPoint(ByVal bIsSyncPoint As BOOL)
        Sub IsPreroll()
        Sub SetPreroll(ByVal bIsPreroll As BOOL)
        [PreserveSig]
        Function GetActualDataLength() As Long
        Sub SetActualDataLength(ByVal Value As Long)
        Sub GetMediaType(ByRef ppMediaType As AM_MEDIA_TYPE)
        Sub SetMediaType(ByRef pMediaType As AM_MEDIA_TYPE)
        Sub IsDiscontinuity()
        Sub SetDiscontinuity(ByVal bDiscontinuity As BOOL)
        Sub GetMediaTime(ByRef pTimeStart As LongLong, ByRef pTimeEnd As LongLong)
        Sub SetMediaTime(ByRef pTimeStart As LongLong, ByRef pTimeEnd As LongLong)
    End Interface

    [InterfaceId("F7537560-A3BE-11D0-8212-00C04FC32C45")]
    [OleAutomation(False)]
    Interface IAudioMediaStream Extends IMediaStream
        Sub GetFormat(ByRef pWaveFormatCurrent As WAVEFORMATEX)
        Sub SetFormat(ByRef lpWaveFormat As WAVEFORMATEX)
        Sub CreateSample(ByVal pAudioData As IAudioData, ByVal dwFlags As Long, ByRef ppSample As IAudioStreamSample)
    End Interface

    [InterfaceId("345FEE00-ABA5-11D0-8212-00C04FC32C45")]
    [OleAutomation(False)]
    Interface IAudioStreamSample Extends IStreamSample
        Sub GetAudioData(ByRef ppAudio As IAudioData)
    End Interface

    [InterfaceId("327FC560-AF60-11D0-8212-00C04FC32C45")]
    [OleAutomation(False)]
    Interface IMemoryData Extends stdole.IUnknown
        Sub SetBuffer(ByVal cbSize As Long, ByRef pbData As Any, ByVal dwFlags As Long)
        Sub GetInfo(ByRef pdwLength As Long, ByRef ppbData As LongPtr, ByRef pcbActualData As Long)
        Sub SetActual(ByVal cbDataValid As Long)
    End Interface

    [InterfaceId("54C719C0-AF60-11D0-8212-00C04FC32C45")]
    [OleAutomation(False)]
    Interface IAudioData Extends IMemoryData
        Sub GetFormat(ByRef pWaveFormatCurrent As WAVEFORMATEX)
        Sub SetFormat(ByRef lpWaveFormat As WAVEFORMATEX)
    End Interface
    
    'dyngraph.idl
    [InterfaceId("4A9A62D3-27D4-403D-91E9-89F540E55534")]
    Interface IPinConnection Extends IUnknown
        [Description("Do you accept this type change in your current state?")]
        Sub DynamicQueryAccept(ByRef pmt As AM_MEDIA_TYPE)
        [Description("Set event when EndOfStream receive - do NOT pass it on. This condition is cancelled by a flush or Stop")]
        Sub NotifyEndOfStream(ByVal hNotifyEvent As LongPtr)
        [Description("Are you an 'end pin'")]
        Sub IsEndPin()
        [Description("Dynamic disconnect")]
        Sub DynamicDisconnect()
    End Interface
 
    [InterfaceId("c56e9858-dbf3-4f6b-8119-384af2060deb")]
    Interface IPinFlowControl Extends stdole.IUnknown
        [Description("Block processing on this pin")]
        Sub Block(ByVal dwBlockFlags As AM_PIN_FLOW_CONTROL_BLOCK_FLAGS, ByVal hEvent As LongPtr)
    End Interface

    [InterfaceId("03A1EB8E-32BF-4245-8502-114D08A9CB88")]
    Interface IGraphConfig Extends stdole.IUnknown
        Sub Reconnect(ByVal pOutputPin As IPin, ByVal pInputPin As IPin, ByRef pmtFirstConnection As AM_MEDIA_TYPE, ByVal pUsingFilter As IBaseFilter, ByVal hAbortEvent As LongPtr, ByVal dwFlags As AM_GRAPH_CONFIG_RECONNECT_FLAGS)
        Sub Reconfigure(ByVal pCallback As IGraphConfigCallback, ByVal pvContext As LongPtr, ByVal dwFlags As Long, ByVal hAbortEvent As LongPtr)
        Sub AddFilterToCache(ByVal pFilter As IBaseFilter)
        Sub EnumCacheFilter(ByRef pEnum As IEnumFilters)
        Sub RemoveFilterFromCache(ByVal pFilter As IBaseFilter)
        [Description("Get the start time associated with the last Run() call. If the graph is not running returns VFW_E_WRONG_STATE")]
        Sub GetStartTime(ByRef prtStart As LongLong)
        Sub PushThroughData(ByVal pOutputPin As IPin, ByVal pConnection As IPinConnection, ByVal hEventAbort As LongPtr)
        Sub SetFilterFlags(ByVal pFilter As IBaseFilter, ByVal dwFlags As AM_FILTER_FLAGS)
        Sub GetFilterFlags(ByVal pFilter As IBaseFilter, ByRef pdwFlags As AM_FILTER_FLAGS)
        Sub RemoveFilterEx(ByVal pFilter As IBaseFilter, ByVal Flags As REM_FILTER_FLAGS)
    End Interface

    [InterfaceId("ade0fd60-d19d-11d2-abf6-00a0c905f375")]
    Interface IGraphConfigCallback Extends stdole.IUnknown
        Sub Reconfigure(ByVal pvContext As LongPtr, ByVal dwFlags As Long)
    End Interface

    [InterfaceId("DCFBDCF6-0DC2-45f5-9AB2-7C330EA09C29")]
    Interface IFilterChain Extends stdole.IUnknown
        Sub StartChain(ByVal pStartFilter As IBaseFilter, ByVal pEndFilter As IBaseFilter)
        Sub PauseChain(ByVal pStartFilter As IBaseFilter, ByVal pEndFilter As IBaseFilter)
        Sub StopChain(ByVal pStartFilter As IBaseFilter, ByVal pEndFilter As IBaseFilter)
        Sub RemoveChain(ByVal pStartFilter As IBaseFilter, ByVal pEndFilter As IBaseFilter)
    End Interface
    
    
    [CoClassId("49C47CE5-9BA4-11D0-8212-00C04FC32C45")]
    [COMCreatable]
    [Description("CLSID_AMMultiMediaStream")]
    CoClass AMMultiMediaStream
        [Default] Interface IAMMultiMediaStream
        Interface IAMMediaTypeStream
        Interface IAMMediaStream
    End CoClass

    [CoClassId("49C47CE4-9BA4-11D0-8212-00C04FC32C45")]
    [COMCreatable]
    CoClass AMDirectDrawStream
        [Default] Interface IDirectDrawMediaStream
        Interface IAMMediaStream
        Interface IMediaStream
    End CoClass

    [CoClassId("8496E040-AF4C-11D0-8212-00C04FC32C45")]
    [COMCreatable]
    CoClass AMAudioStream
        [Default] Interface IAudioMediaStream
    End CoClass

    [CoClassId("F2468580-AF8A-11D0-8212-00C04FC32C45")]
    [COMCreatable]
    CoClass AMAudioData
        [Default] Interface IAudioData
    End CoClass

    [CoClassId("CF0F2F7C-F7BF-11D0-900D-00C04FD9189D")]
    [COMCreatable]
    CoClass AMMediaTypeStream
        [Default] Interface IAMMediaStream
        Interface IMediaStream
        Interface IPin
    End CoClass


    [CoClassId("C1F400A0-3F08-11D3-9F0B-006008039E37")]
    [COMCreatable]
    [Description("SampleGrabber")]
    CoClass SampleGrabber
        [Default] Interface ISampleGrabber
    End CoClass

    [CoClassId("E436EBB5-524F-11CE-9F53-0020AF0BA770")]
    [COMCreatable]
    [Description("File Source Filter")]
    CoClass AsyncReader
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("1B544C20-FD0B-11CE-8C63-00AA0044B51E")]
    [COMCreatable]
    [Description("AVI Splitter")]
    CoClass AviSplitter
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("336475D0-942A-11CE-A870-00AA002FEAB5")]
    [COMCreatable]
    [Description("MPEG-I Stream Splitter")]
    CoClass MPEG1Splitter
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("CF49D4E0-1115-11CE-B03A-0020AF0BA770")]
    [COMCreatable]
    [Description("AVI Decompressor")]
    CoClass AVIDec
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("79376820-07D0-11CF-A24D-0020AFD79767")]
    [COMCreatable]
    [Description("DirectSound Audio Renderer")]
    CoClass DSoundRender
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("E30629D1-27E5-11CE-875D-00608CB78066")]
    [COMCreatable]
    [Description("Wave Audio Renderer")]
    CoClass AudioRender
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("C1F400A4-3F08-11D3-9F0B-006008039E37")]
    [COMCreatable]
    [Description("Null Renderer")]
    CoClass NullRenderer
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("70E102B0-5556-11CE-97C0-00AA0055595A")]
    [COMCreatable]
    [Description("Video Renderer")]
    CoClass VideoRenderer
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50")]
    [COMCreatable]
    [Description("Default Video Renderer")]
    CoClass VideoRendererDefault
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("6A08CF80-0E18-11CF-A24D-0020AFD79767")]
    [COMCreatable]
    [Description("ACM wrapper")]
    CoClass ACMWrapper
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("D51BD5A1-7548-11CF-A520-0080C77EF58A")]
    [COMCreatable]
    [Description("Wave Parser")]
    CoClass WAVEParser
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("B87BEB7B-8D29-423F-AE4D-6582C10175AC")]
    [COMCreatable]
    [Description("Video Mixing Renderer")]
    CoClass VideoMixingRenderer
        [Default] Interface IBaseFilter
    End CoClass

    [CoClassId("51B4ABF3-748F-4E3B-A276-C828330E926A")]
    [COMCreatable]
    [Description("Video Mixing Renderer 9 (CLSID_VideoMixingRenderer9)")]
    CoClass VideoMixingRenderer9
        [Default] Interface IBaseFilter
    End CoClass
        
    'CLSID_FilterGraph
    [CoClassId("E436EBB3-524F-11CE-9F53-0020AF0BA770")]
    CoClass FilterGraph
        [Default] Interface IFilterGraph2
    End CoClass
    
    
    
    
    [InterfaceId("6d6cbb60-a223-44aa-842f-a2f06750be6d")]
    [OleAutomation(False)]
    Interface IMediaParamInfo Extends IUnknown
        Sub GetParamCount(ByRef pdwParams As Long)
        Sub GetParamInfo(ByVal dwParamIndex As Long, ByRef pInfo As MP_PARAMINFO)
        Sub GetParamText(ByVal dwParamIndex As Long, ByRef ppwchText As LongPtr)
        Sub GetNumTimeFormats(ByRef pdwNumTimeFormats As Long)
        Sub GetSupportedTimeFormat(ByVal dwFormatIndex As Long, ByRef pguidTimeFormat As UUID)
        Sub GetCurrentTimeFormat(ByRef pguidTimeFormat As UUID, ByRef pTimeData As Long)
    End Interface

    #If TWINBASIC_BUILD >= 896 Then
    [InterfaceId("6d6cbb61-a223-44aa-842f-a2f06750be6e")]
    [OleAutomation(False)]
    Interface IMediaParams Extends IUnknown
        Sub GetParam(ByVal dwParamIndex As Long, ByRef pValue As Single)
        Sub SetParam(ByVal dwParamIndex As Long, ByVal value As Single)
        Sub AddEnvelope(ByVal dwParamIndex As Long, ByVal cSegments As Long, ByRef pEnvelopeSegments As MP_ENVELOPE_SEGMENT)
        Sub FlushEnvelope(ByVal dwParamIndex As Long, ByVal refTimeStart As LongLong, ByVal refTimeEnd As LongLong)
        Sub SetTimeFormat(ByVal guidTimeFormat As UUID, ByVal mpTimeData As Long)
    End Interface
    #Else
    [InterfaceId("6d6cbb61-a223-44aa-842f-a2f06750be6e")]
    [OleAutomation(False)]
    Interface IMediaParams Extends IUnknown
        Sub GetParam(ByVal dwParamIndex As Long, ByRef pValue As Single)
        Sub SetParam(ByVal dwParamIndex As Long, ByVal value As Single)
        Sub AddEnvelope(ByVal dwParamIndex As Long, ByVal cSegments As Long, ByRef pEnvelopeSegments As MP_ENVELOPE_SEGMENT)
        Sub FlushEnvelope(ByVal dwParamIndex As Long, ByVal refTimeStart As LongLong, ByVal refTimeEnd As LongLong)
        #If Win64 Then
        Sub SetTimeFormat(guidTimeFormat As UUID, ByVal mpTimeData As Long)
        #Else
        Sub SetTimeFormat(ByVal guidTimeFormat1 As Long, ByVal guidTimeFormat2 As Long, ByVal guidTimeFormat3 As Long, ByVal guidTimeFormat4 As Long, ByVal mpTimeData As Long)
        #End If
    End Interface
    #End If
         
    
    
    
    
    
    
    
    
    
    
    
    
    'amvideo.h
    [InterfaceId("36d39eb0-dd75-11ce-bf0e-00aa0055595a")]
    [OleAutomation(False)]
    Interface IDirectDrawVideo Extends IUnknown
        Sub GetSwitches(ByRef pSwitches As AMDDSFLAGS)
        Sub SetSwitches(ByVal Switches As AMDDSFLAGS)
        Sub GetCaps(ByRef pCaps As DDCAPS)
        Sub GetEmulatedCaps(ByRef pCaps As DDCAPS)
        Sub GetSurfaceDesc(ByRef pSurfaceDesc As DDSURFACEDESC)
        Sub GetFourCCCodes(ByRef pCount As Long, ByRef pCodes As Long)
        Sub SetDirectDraw(ByVal pDirectDraw As IDirectDraw)
        Sub GetDirectDraw(ByRef ppDirectDraw As IDirectDraw)
        Sub GetSurfaceType(ByRef pSurfaceType As AMDDSFLAGS)
        Sub SetDefault()
        Sub UseScanLine(ByVal UseScanLine As Long)
        Sub CanUseScanLine(ByRef UseScanLine As Long)
        Sub UseOverlayStretch(ByVal UseOverlayStretch As Long)
        Sub CanUseOverlayStretch(ByRef UseOverlayStretch As Long)
        Sub UseWhenFullScreen(ByVal UseWhenFullScreen As Long)
        Sub WillUseFullScreen(ByRef UseWhenFullScreen As Long)
    End Interface
    
    [InterfaceId("1bd0ecb0-f8e2-11ce-aac6-0020af0b99a3")]
    [OleAutomation(False)]
    Interface IQualProp Extends IUnknown
        Sub get_FramesDroppedInRenderer(ByRef pcFrames As Long)
        Sub get_FramesDrawn(ByRef pcFramesDrawn As Long)
        Sub get_AvgFrameRate(ByRef piAvgFrameRate As Long)
        Sub get_Jitter(ByRef iJitter As Long)
        Sub get_AvgSyncOffset(ByRef piAvg As Long)
        Sub get_DevSyncOffset(ByRef piDev As Long)
    End Interface

    [InterfaceId("dd1d7110-7836-11cf-bf47-00aa0055595a")]
    [OleAutomation(False)]
    Interface IFullScreenVideo Extends IUnknown
        Sub CountModes(ByRef pModes As Long)
        Sub GetModeInfo(ByVal Mode As Long, ByRef pWidth As Long, ByRef pHeight As Long, ByRef pDepth As Long)
        Sub GetCurrentMode(ByRef pMode As Long)
        [PreserveSig] Function IsModeAvailable(ByVal Mode As Long) As Long
        [PreserveSig] Function IsModeEnabled(ByVal Mode As Long) As Long
        Sub SetEnabled(ByVal Mode As Long, ByVal bEnabled As Long)
        Sub GetClipFactor(ByRef pClipFactor As Long)
        Sub SetClipFactor(ByVal ClipFactor As Long)
        Sub SetMessageDrain(ByVal hwnd As LongPtr)
        Sub GetMessageDrain(ByRef hwnd As LongPtr)
        Sub SetMonitor(ByVal Monitor As Long)
        Sub GetMonitor(ByRef Monitor As Long)
        Sub HideOnDeactivate(ByVal Hide As Long)
        [PreserveSig] Function IsHideOnDeactivate() As Long
        Sub SetCaption(ByVal strCaption As String)
        Sub GetCaption(ByRef pstrCaption As String)
        Sub SetDefault()
    End Interface

    [InterfaceId("53479470-f1dd-11cf-bc42-00aa00ac74f6")]
    [OleAutomation(False)]
    Interface IFullScreenVideoEx Extends IFullScreenVideo
        Sub SetAcceleratorTable(ByVal hwnd As LongPtr, ByVal hAccel As LongPtr)
        Sub GetAcceleratorTable(ByRef phwnd As LongPtr, ByRef phAccel As LongPtr)
        Sub KeepPixelAspectRatio(ByVal KeepAspect As Long)
        Sub IsKeepPixelAspectRatio(ByRef pKeepAspect As Long)
    End Interface

    [InterfaceId("61ded640-e912-11ce-a099-00aa00479a58")]
    [OleAutomation(False)]
    Interface IBaseVideoMixer Extends IUnknown
        Sub SetLeadPin(ByVal iPin As Long)
        Sub GetLeadPin(ByRef piPin As Long)
        Sub GetInputPinCount(ByRef piPinCount As Long)
        Sub IsUsingClock(ByRef pbValue As Long)
        Sub SetUsingClock(ByVal bValue As Long)
        Sub GetClockPeriod(ByRef pbValue As Long)
        Sub SetClockPeriod(ByVal bValue As Long)
    End Interface
    
    'dvp.h
    [InterfaceId("6C142760-A733-11CE-A521-0020AF0BE560")]
    [OleAutomation(False)]
    Interface IDDVideoPortContainer Extends IUnknown
        Sub CreateVideoPort(ByVal dwFlags As DDVPCREATEFLAGS, ByRef lpVideoPortDesc As DDVIDEOPORTDESC, ByRef lplpVideoPort As IDirectDrawVideoPort, ByVal pUnkOuter As IUnknown)
        ' #If WDL_NO_DELEGATES Then
        Sub EnumVideoPorts(ByVal dwFlags As Long, ByRef lpVideoPortCaps As DDVIDEOPORTCAPS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
        ' #Else
        ' Sub EnumVideoPorts(ByVal dwFlags As Long, ByRef lpVideoPortCaps As DDVIDEOPORTCAPS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMVIDEOCALLBACK)
        ' #End If
        Sub GetVideoPortConnectInfo(ByVal dwPortId As Long, ByRef pcInfo As Long, ByRef lpConnectInfo As DDVIDEOPORTCONNECT)
        Sub QueryVideoPortStatus(ByVal dwPortId As Long, ByRef lpVideoPortStatus As DDVIDEOPORTSTATUS)
    End Interface

    [InterfaceId("B36D93E0-2B43-11CF-A2DE-00AA00B93356")]
    [OleAutomation(False)]
    Interface IDirectDrawVideoPort Extends IUnknown
        Sub Flip(ByVal lpSurface As IDirectDrawSurface, ByVal dwFlags As DDVPFLIPFLAGS)
        Sub GetBandwidthInfo(ByRef lpPixelFormat As DDPIXELFORMAT, ByVal dwWidth As Long, ByVal dwHeight As Long, ByVal dwFlags As DDVPBFLAGS, ByRef lpBandwidth As DDVIDEOPORTBANDWIDTH)
        Sub GetColorControls(ByRef lpColorControl As DDCOLORCONTROL)
        Sub GetInputFormats(ByRef lpNumFormats As Long, ByRef lpFormats As DDPIXELFORMAT, ByVal dwFlags As DDVPFORMATFLAGS)
        Sub GetOutputFormats(ByRef lpInputFormat As DDPIXELFORMAT, ByRef lpNumFormats As Long, ByRef lpOutputFormats As DDPIXELFORMAT, ByVal dwFlags As DDVPFORMATFLAGS)
        Sub GetFieldPolarity(ByRef lpbFieldPolarity As BOOL)
        Sub GetVideoLine(ByRef lpdwLine As Long)
        Sub GetVideoSignalStatus(ByRef lpdwStatus As DDVPSQFLAGS)
        Sub SetColorControls(ByRef lpColorControl As DDCOLORCONTROL)
        Sub SetTargetSurface(ByVal lpSurface As IDirectDrawSurface, ByVal dwFlags As DDVPTARGETFLAGS)
        Sub StartVideo(ByRef lpVideoInfo As DDVIDEOPORTINFO)
        Sub StopVideo()
        Sub UpdateVideo(ByRef lpVideoInfo As DDVIDEOPORTINFO)
        Sub WaitForSync(ByVal dwFlags As DDVPWAITFLAGS, ByVal dwLine As Long, ByVal dwTimeout As Long)
    End Interface

    [InterfaceId("A655FB94-0589-4E57-B333-567A89468C88")]
    [OleAutomation(False)]
    Interface IDirectDrawVideoPortNotify Extends IUnknown
        Sub AcquireNotification(ByRef phEvent As LongPtr, ByRef lpNotify As DDVIDEOPORTNOTIFY)
        Sub ReleaseNotification(ByVal hEvent As LongPtr)
    End Interface
    
    'amaudio.h
    [InterfaceId("546F4260-D53E-11CF-B3F0-00AA003761C5")]
    [OleAutomation(False)]
    Interface IAMDirectSound Extends IUnknown
        Sub GetDirectSoundInterface(ByRef lplpds As IDirectSound)
        Sub GetPrimaryBufferInterface(ByRef lplpdsb As IDirectSoundBuffer)
        Sub GetSecondaryBufferInterface(ByRef lplpdsb As IDirectSoundBuffer)
        Sub ReleaseDirectSoundInterface(ByVal lpds As IDirectSound)
        Sub ReleasePrimaryBufferInterface(ByVal lpdsb As IDirectSoundBuffer)
        Sub ReleaseSecondaryBufferInterface(ByVal lpdsb As IDirectSoundBuffer)
        Sub SetFocusWindow(ByVal hwnd As LongPtr, ByVal bFocus As BOOL)
        Sub GetFocusWindow(ByRef phwnd As LongPtr, ByRef pbFocus As BOOL)
    End Interface
    
    'MpegType.h
    [InterfaceId("B45DD570-3C77-11D1-ABE1-00A0C905F375")]
    [OleAutomation(False)]
    Interface IMpegAudioDecoder Extends IUnknown
        Sub get_FrequencyDivider(ByRef pDivider As Long)
        Sub put_FrequencyDivider(ByVal Divider As Long)
        Sub get_DecoderAccuracy(ByRef pAccuracy As Long)
        Sub put_DecoderAccuracy(ByVal Accuracy As Long)
        Sub get_Stereo(ByRef pStereo As Long)
        Sub put_Stereo(ByVal Stereo As Long)
        Sub get_DecoderWordSize(ByRef pWordSize As Long)
        Sub put_DecoderWordSize(ByVal WordSize As Long)
        Sub get_IntegerDecode(ByRef pIntDecode As Long)
        Sub put_IntegerDecode(ByVal IntDecode As Long)
        Sub get_DualMode(ByRef pIntDecode As Long)
        Sub put_DualMode(ByVal IntDecode As Long)
        Sub get_AudioFormat(ByRef lpFmt As MPEG1WAVEFORMAT)
    End Interface
    
    'VpConfig.h
    
    [InterfaceId("BC29A660-30E3-11D0-9E69-00C04FD7C15B")]
    [OleAutomation(False)]
    Interface IVPBaseConfig Extends IUnknown
        Sub GetConnectInfo(ByRef pdwNumConnectInfo As Long, ByRef pddVPConnectInfo As DDVIDEOPORTCONNECT)
        Sub SetConnectInfo(ByVal dwChosenEntry As Long)
        Sub GetVPDataInfo(ByRef pamvpDataInfo As AMVPDATAINFO)
        Sub GetMaxPixelRate(ByRef pamvpSize As AMVPSIZE, ByRef pdwMaxPixelsPerSecond As Long)
        Sub InformVPInputFormats(ByVal dwNumFormats As Long, ByRef pDDPixelFormats As DDPIXELFORMAT)
        Sub GetVideoFormats(ByRef pdwNumFormats As Long, ByRef pddPixelFormats As DDPIXELFORMAT)
        Sub SetVideoFormat(ByVal dwChosenEntry As Long)
        Sub SetInvertPolarity()
        Sub GetOverlaySurface(ByRef ppddOverlaySurface As IDirectDrawSurface)
        Sub SetDirectDrawKernelHandle(ByVal dwDDKernelHandle As LongPtr)
        Sub SetVideoPortID(ByVal dwVideoPortID As Long)
        Sub SetDDSurfaceKernelHandles(ByVal cHandles As Long, ByRef rgDDKernelHandles As LongPtr)
        Sub SetSurfaceParameters(ByVal dwPitch As Long, ByVal dwXOrigin As Long, ByVal dwYOrigin As Long)
    End Interface

    [InterfaceId("BC29A660-30E3-11D0-9E69-00C04FD7C15B")]
    [OleAutomation(False)]
    Interface IVPConfig Extends IVPBaseConfig
        Sub IsVPDecimationAllowed(ByRef pbIsDecimationAllowed As BOOL)
        Sub SetScalingFactors(ByRef pamvpSize As AMVPSIZE)
    End Interface

    [InterfaceId("EC529B00-1A1F-11D1-BAD9-00609744111A")]
    [OleAutomation(False)]
    Interface IVPVBIConfig Extends IVPBaseConfig
        ' Inherits all methods from IVPBaseConfig
    End Interface
    
    'VpNotify.h
    [InterfaceId("C76794A1-D6C5-11d0-9E69-00C04FD7C15B")]
    [OleAutomation(False)]
    Interface IVPBaseNotify Extends IUnknown
        [Description("Initializes the reconnection to the decoder.")]
        Sub RenegotiateVPParameters()
    End Interface
 
    [InterfaceId("C76794A1-D6C5-11d0-9E69-00C04FD7C15B")]
    [OleAutomation(False)]
    Interface IVPNotify Extends IVPBaseNotify
        [Description("Sets the mode (bob, weave etc)")]
        Sub SetDeinterlaceMode(ByVal mode As AMVP_MODE)
        [Description("Gets the mode (bob, weave etc)")]
        Sub GetDeinterlaceMode(ByRef pMode As AMVP_MODE)
    End Interface

 
    [InterfaceId("EBF47183-8764-11d1-9E69-00C04FD7C15B")]
    [OleAutomation(False)]
    Interface IVPNotify2 Extends IVPNotify
        [Description("Sets the VPSyncMaster mode")]
        Sub SetVPSyncMaster(ByVal bVPSyncMaster As BOOL)
        [Description("Gets the VPSyncMaster mode")]
        Sub GetVPSyncMaster(ByRef pbVPSyncMaster As BOOL)
    End Interface
    
    [InterfaceId("EC529B01-1A1F-11D1-BAD9-00609744111A")]
    Interface IVPVBINotify Extends IVPBaseNotify
        ' (No additional methods)
    End Interface
    
    'mpconfig.h
    [InterfaceId("593CDDE1-0759-11d1-9E69-00C04FD7C15B")]
    [OleAutomation(False)]
    Interface IMixerPinConfig Extends IUnknown
        [Description("Sets the position of the stream in the display window, assuming that the window coordinates are {0, 0, 10000, 10000}. Thus giving arguments (0, 0, 5000, 5000) will put the stream in the top-left quarter. Any value greater than 10000 is invalid.")]
        Sub SetRelativePosition(ByVal dwLeft As Long, ByVal dwTop As Long, ByVal dwRight As Long, ByVal dwBottom As Long)
        [Description("Gets the position of the stream in the display window, assuming that the window coordinates are {0, 0, 10000, 10000}. Thus if the values returned are (0, 0, 5000, 5000), then it means that the stream is in the top-left quarter.")]
        Sub GetRelativePosition(ByRef pdwLeft As Long, ByRef pdwTop As Long, ByRef pdwRight As Long, ByRef pdwBottom As Long)
        [Description("Sets the ZOrder of the stream. The ZOrder of 0 is the closest to the eyes of the user, and increasing values imply greater distance.")]
        Sub SetZOrder(ByVal dwZOrder As Long)
        [Description("Gets the ZOrder of the stream. The ZOrder of 0 is the closest to the eyes of the user, and increasing values imply greater distance.")]
        Sub GetZOrder(ByRef pdwZOrder As Long)
        [Description("Sets the colorkey being used by the stream. Setting this value on the primary stream sets the destination colorkey being used by the overlay surface. Setting this value on the secondary pin makes sense only if the stream is transparent.")]
        Sub SetColorKey(ByRef pColorKey As COLORKEY)
        [Description("Gets the colorkey being used by the stream. Getting this value on the primary stream gets the destination colorkey being used by the overlay surface. When using this method, you are allowed to pass NULL for either pColorKey or pColor but not both.")]
        Sub GetColorKey(ByRef pColorKey As COLORKEY, ByRef pColor As Long)
        [Description("Sets the blending parameter which defines how the secondary stream is going to be blended with the primary stream. A value of 0 makes the secondary stream invisible, a value of 255 makes the primary stream invisible in that region, and any value inbetween blends the streams. Calling this function on the primary stream returns E_UNEXPECTED.")]
        Sub SetBlendingParameter(ByVal dwBlendingParameter As Long)
        [Description("Gets the blending parameter which defines how the secondary stream is currently being blended with the primary stream.")]
        Sub GetBlendingParameter(ByRef pdwBlendingParameter As Long)
        [Description("Sets the Aspect Ratio Correction mode on the pin. If the mode is set to letter box, black color is painted on the excess region.")]
        Sub SetAspectRatioMode(ByVal amAspectRatioMode As AM_ASPECT_RATIO_MODE)
        [Description("Gets the Aspect Ratio Correction mode on the pin.")]
        Sub GetAspectRatioMode(ByRef pamAspectRatioMode As AM_ASPECT_RATIO_MODE)
        [Description("Sets the stream to be transparent. That means that the stream is not going to occupy the whole of the rectangle, some of the region is going to be transparent. Calling this function on the primary stream returns E_UNEXPECTED.")]
        Sub SetStreamTransparent(ByVal bStreamTransparent As BOOL)
        [Description("Gets whether the stream is transparent or not.")]
        Sub GetStreamTransparent(ByRef pbStreamTransparent As BOOL)
    End Interface

    ' {EBF47182-8764-11d1-9E69-00C04FD7C15B}
    [InterfaceId("EBF47182-8764-11d1-9E69-00C04FD7C15B")]
    [OleAutomation(False)]
    Interface IMixerPinConfig2 Extends IMixerPinConfig
        [Description("Sets the color-controls, if the vga chip supports it.")]
        Sub SetOverlaySurfaceColorControls(pColorControl As DDCOLORCONTROL)
        [Description("Gets the color-controls. It also returns the capability of the vga hardware in the dwFlags value of the struct.")]
        Sub GetOverlaySurfaceColorControls(pColorControl As DDCOLORCONTROL)
    End Interface
    
    'amparse.h
    [InterfaceId("C47A3420-005C-11D2-9038-00A0C9697298")]
    [OleAutomation(False)]
    Interface IAMParse Extends IUnknown
        Sub GetParseTime(prtCurrent As LongLong /* REFERENCE_TIME */)
        Sub SetParseTime(ByVal rtCurrent As LongLong /* REFERENCE_TIME */)
        Sub Flush()
    End Interface
    
    'videoaccel.h/.idl
    [InterfaceId("256A6A21-FBAD-11d1-82BF-00A0C9696C8F")]
    [OleAutomation(False)]
    Interface IAMVideoAcceleratorNotify Extends IUnknown
        [Description("Get information necessary to allocate uncompressed data buffers which is not part of the mediatype format")]
        Sub GetUncompSurfacesInfo(ByRef pGuid As UUID, ByRef pUncompBufferInfo As AMVAUncompBufferInfo)
        [Description("Set information regarding allocated uncompressed data buffers")]
        Sub SetUncompSurfacesInfo(ByVal dwActualUncompSurfacesAllocated As Long)
        [Description("Get information necessary to create video accelerator object")]
        Sub GetCreateVideoAcceleratorData(ByRef pGuid As UUID, ByRef pdwSizeMiscData As Long, ByRef ppMiscData As LongPtr)
    End Interface

    [InterfaceId("256A6A22-FBAD-11d1-82BF-00A0C9696C8F")]
    [OleAutomation(False)]
    Interface IAMVideoAccelerator Extends IUnknown
        [Description("Gets the supported video accelerator GUIDs")]
        Sub GetVideoAcceleratorGUIDs(ByRef pdwNumGuidsSupported As Long, ByRef pGuidsSupported As UUID)
        [Description("Gets the uncompressed pixel formats supported for the specified GUID")]
        Sub GetUncompFormatsSupported(ByRef pGuid As UUID, ByRef pdwNumFormatsSupported As Long, ByRef pFormatsSupported As DDPIXELFORMAT)
        [Description("Gets info about how much scratch memory the HAL will allocate for its private use")]
        Sub GetInternalMemInfo(ByRef pGuid As UUID, ByRef pamvaUncompDataInfo As AMVAUncompDataInfo, ByRef pamvaInternalMemInfo As AMVAInternalMemInfo)
        [Description("Gets information about compressed buffer types")]
        Sub GetCompBufferInfo(ByRef pGuid As UUID, ByRef pamvaUncompDataInfo As AMVAUncompDataInfo, ByRef pdwNumTypesCompBuffers As Long, ByRef pamvaCompBufferInfo As AMVACompBufferInfo)
        [Description("Gets internal compressed buffer information - only valid after pins are connected")]
        Sub GetInternalCompBufferInfo(ByRef pdwNumTypesCompBuffers As Long, ByRef pamvaCompBufferInfo As AMVACompBufferInfo)
        [Description("Begin a frame - only valid after pins are connected")]
        Sub BeginFrame(ByRef amvaBeginFrameInfo As AMVABeginFrameInfo)
        [Description("End a frame - only valid after pins are connected")]
        Sub EndFrame(ByRef pEndFrameInfo As AMVAEndFrameInfo)
        [Description("Lock and obtain access to a single buffer - only valid after pins are connected")]
        Sub GetBuffer(ByVal dwTypeIndex As Long, ByVal dwBufferIndex As Long, ByVal bReadOnly As BOOL, ByRef ppBuffer As LongPtr, ByRef lpStride As Long)
        [Description("Unlock a single buffer - only valid after pins are connected")]
        Sub ReleaseBuffer(ByVal dwTypeIndex As Long, ByVal dwBufferIndex As Long)
        [Description("Perform a decompression operation - only valid after pins are connected")]
        Sub Execute(ByVal dwFunction As Long, lpPrivateInputData As Any, ByVal cbPrivateInputData As Long, lpPrivateOutputDat As Any, ByVal cbPrivateOutputData As Long, ByVal dwNumBuffers As Long, ByRef pamvaBufferInfo As AMVABUFFERINFO)
        [Description("Query the decode status of a particular decompression operation")]
        Sub QueryRenderStatus(ByVal dwTypeIndex As Long, ByVal dwBufferIndex As Long, ByVal dwFlags As AMQueryRenderStatusFlags)
        [Description("Display a frame - non-blocking call, only valid after pins are connected")]
        Sub DisplayFrame(ByVal dwFlipToIndex As Long, ByVal pMediaSample As IMediaSample)
    End Interface
    
    
    
    'vidcap.h/.idl
    [InterfaceId("720D4AC0-7533-11D0-A5D6-28DB04C10000")]
    [OleAutomation(False)]
    Interface IKsTopologyInfo Extends IUnknown
        Sub get_NumCategories(ByRef pdwNumCategories As Long)
        Sub get_Category(ByVal dwIndex As Long, ByRef pCategory As UUID)
        Sub get_NumConnections(ByRef pdwNumConnections As Long)
        Sub get_ConnectionInfo(ByVal dwIndex As Long, ByRef pConnectionInfo As KSTOPOLOGY_CONNECTION)
        Sub get_NodeName(ByVal dwNodeId As Long, ByVal pwchNodeName As LongPtr, ByVal dwBufSize As Long, ByRef pdwNameLen As Long)
        Sub get_NumNodes(ByRef pdwNumNodes As Long)
        Sub get_NodeType(ByVal dwNodeId As Long, ByRef pNodeType As UUID)
        Sub CreateNodeInstance(ByVal dwNodeId As Long, ByRef iid As UUID, ByRef ppvObject As Any)
    End Interface
 
    [InterfaceId("1ABDAECA-68B6-4F83-9371-B413907C7B9F")]
    [OleAutomation(False)]
    Interface ISelector Extends IUnknown
        Sub get_NumSources(ByRef pdwNumSources As Long)
        Sub get_SourceNodeId(ByRef pdwPinId As Long)
        Sub put_SourceNodeId(ByVal dwPinId As Long)
    End Interface
 
    [InterfaceId("2BA1785D-4D1B-44EF-85E8-C7F1D3F20184")]
    [OleAutomation(False)]
    Interface ICameraControl Extends IUnknown
        Sub get_Exposure(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Exposure(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Exposure(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Focus(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Focus(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Focus(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Iris(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Iris(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Iris(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Zoom(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Zoom(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Zoom(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_FocalLengths(ByRef plOcularFocalLength As Long, ByRef plObjectiveFocalLengthMin As Long, ByRef plObjectiveFocalLengthMax As Long)
        Sub get_Pan(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Pan(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Pan(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Tilt(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Tilt(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Tilt(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_PanTilt(ByRef pPanValue As Long, ByRef pTiltValue As Long, ByRef pFlags As Long)
        Sub put_PanTilt(ByVal PanValue As Long, ByVal TiltValue As Long, ByVal Flags As Long)
        Sub get_Roll(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Roll(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Roll(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_ExposureRelative(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_ExposureRelative(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_ExposureRelative(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_FocusRelative(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_FocusRelative(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_FocusRelative(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_IrisRelative(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_IrisRelative(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_IrisRelative(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_ZoomRelative(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_ZoomRelative(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_ZoomRelative(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_PanRelative(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_PanRelative(ByVal Value As Long, ByVal Flags As Long)
        Sub get_TiltRelative(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_TiltRelative(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_TiltRelative(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_PanTiltRelative(ByRef pPanValue As Long, ByRef pTiltValue As Long, ByRef pFlags As Long)
        Sub put_PanTiltRelative(ByVal PanValue As Long, ByVal TiltValue As Long, ByVal Flags As Long)
        Sub getRange_PanRelative(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_RollRelative(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_RollRelative(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_RollRelative(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_ScanMode(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_ScanMode(ByVal Value As Long, ByVal Flags As Long)
        Sub get_PrivacyMode(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_PrivacyMode(ByVal Value As Long, ByVal Flags As Long)
    End Interface
 
    [InterfaceId("4050560E-42A7-413a-85C2-09269A2D0F44")]
    [OleAutomation(False)]
    Interface IVideoProcAmp Extends IUnknown
        Sub get_BacklightCompensation(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_BacklightCompensation(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_BacklightCompensation(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Brightness(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Brightness(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Brightness(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_ColorEnable(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_ColorEnable(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_ColorEnable(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Contrast(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Contrast(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Contrast(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Gamma(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Gamma(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Gamma(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Saturation(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Saturation(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Saturation(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Sharpness(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Sharpness(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Sharpness(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_WhiteBalance(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_WhiteBalance(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_WhiteBalance(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Gain(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Gain(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Gain(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_Hue(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_Hue(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_Hue(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_DigitalMultiplier(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_DigitalMultiplier(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_DigitalMultiplier(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_PowerlineFrequency(ByRef pValue As Long, ByRef pFlags As Long)
        Sub put_PowerlineFrequency(ByVal Value As Long, ByVal Flags As Long)
        Sub getRange_PowerlineFrequency(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
        Sub get_WhiteBalanceComponent(ByRef pValue1 As Long, ByRef pValue2 As Long, ByRef pFlags As Long)
        Sub put_WhiteBalanceComponent(ByVal Value1 As Long, ByVal Value2 As Long, ByVal Flags As Long)
        Sub getRange_WhiteBalanceComponent(ByRef pMin As Long, ByRef pMax As Long, ByRef pSteppingDelta As Long, ByRef pDefault As Long, ByRef pCapsFlag As Long)
    End Interface
 
    [InterfaceId("11737C14-24A7-4bb5-81A0-0D003813B0C4")]
    [OleAutomation(False)]
    Interface IKsNodeControl Extends IUnknown
        Sub put_NodeId(ByVal dwNodeId As Long)
        Sub put_KsControl(pKsControl As Any)
    End Interface
    
    'dmodshow.h/.idl
    [InterfaceId("52d6f586-9f0f-4824-8fc8-e32ca04930c2")]
    [OleAutomation(False)]
    Interface IDMOWrapperFilter Extends IUnknown
        Sub Init(clsidDMO As UUID, catDMO As UUID)
    End Interface
    
    'CameraUIControl.h/.idl
    [Description("NOTE: Problems may arise from missing PreserveSig. V-table swap if neccessary.")]
    [InterfaceId("1BFA0C2C-FBCD-4776-BDA4-88BF974E74F4")]
    [OleAutomation(False)]
    Interface ICameraUIControlEventCallback Extends IUnknown
        /* [PreserveSig] */ Sub OnStartupComplete()
        /* [PreserveSig] */ Sub OnSuspendComplete()
        /* [PreserveSig] */ Sub OnItemCaptured(ByVal pszPath As LongPtr)
        /* [PreserveSig] */ Sub OnItemDeleted(ByVal pszPath As LongPtr)
        /* [PreserveSig] */ Sub OnClosed()
    End Interface
    
    [InterfaceId("B8733ADF-3D68-4b8f-BB08-E28A0BED0376")]
    [OleAutomation(False)]
    Interface ICameraUIControl Extends IUnknown
        Sub Show(ByVal pWindow As IUnknown, _
                    ByVal mode As CameraUIControlMode, _
                    ByVal selectionMode As CameraUIControlLinearSelectionMode, _
                    ByVal captureMode As CameraUIControlCaptureMode, _
                    ByVal photoFormat As CameraUIControlPhotoFormat, _
                    ByVal videoFormat As CameraUIControlVideoFormat, _
                    ByVal bHasCloseButton As BOOL, _
                    ByVal pEventCallback As ICameraUIControlEventCallback)
        Sub Close()
        Sub Suspend(pbDeferralRequired As BOOL)
        Sub Resume()
        Sub GetCurrentViewType(pViewType As CameraUIControlViewType)
        Sub GetActiveItem(pbstrActiveItemPath As String)
        Sub GetSelectedItems(ppSelectedItemPaths As LongPtr)
        Sub RemoveCapturedItem(ByVal pszPath As LongPtr)
    End Interface
    
    [CoClassId("16D5A2BE-B1C5-47b3-8EAE-CCBCF452C7E8")]
    [Description("CameraUIControl Class (CLSID_CameraUIControl)")]
    CoClass CameraUIControl
        [Default] Interface ICameraUIControl
    End CoClass
    
    'il21dec.h
    [InterfaceId("6E8D4A21-310C-11D0-B79A-00AA003767A7")]
    [OleAutomation(False)]
    Interface IAMLine21Decoder Extends IUnknown
        Sub GetDecoderLevel(lpLevel As AM_LINE21_CCLEVEL)
        Sub GetCurrentService(lpService As AM_LINE21_CCSERVICE)
        Sub SetCurrentService(ByVal Service As AM_LINE21_CCSERVICE)
        Sub GetServiceState(lpState As AM_LINE21_CCSTATE)
        Sub SetServiceState(ByVal State As AM_LINE21_CCSTATE)
        Sub GetOutputFormat(lpbmih As BITMAPINFOHEADER)
        Sub SetOutputFormat(lpbmi As BITMAPINFO)
        Sub GetBackgroundColor(pdwPhysColor As Long)
        Sub SetBackgroundColor(ByVal dwPhysColor As Long)
        Sub GetRedrawAlways(pbOption As BOOL)
        Sub SetRedrawAlways(ByVal bOption As BOOL)
        Sub GetDrawBackgroundMode(lpMode As AM_LINE21_DRAWBGMODE)
        Sub SetDrawBackgroundMode(ByVal Mode As AM_LINE21_DRAWBGMODE)
    End Interface
    
    'iwstdec.h
    [InterfaceId("C056DE21-75C2-11D3-A184-00105AEF9F33")]
    [OleAutomation(False)]
    Interface IAMWstDecoder Extends IUnknown
        Sub GetDecoderLevel(lpLevel As AM_WST_LEVEL)
        Sub GetCurrentService(lpService As AM_WST_SERVICE)
        ' Sub SetCurrentService(ByVal Service As AM_WST_SERVICE)
        Sub GetServiceState(lpState As AM_WST_STATE)
        Sub SetServiceState(ByVal State As AM_WST_STATE)
        Sub GetOutputFormat(lpbmih As BITMAPINFOHEADER)
        Sub SetOutputFormat(lpbmi As BITMAPINFO)
        Sub GetBackgroundColor(pdwPhysColor As Long)
        Sub SetBackgroundColor(ByVal dwPhysColor As Long)
        Sub GetRedrawAlways(pbOption As BOOL)
        Sub SetRedrawAlways(ByVal bOption As BOOL)
        Sub GetDrawBackgroundMode(lpMode As AM_WST_DRAWBGMODE)
        Sub SetDrawBackgroundMode(ByVal Mode As AM_WST_DRAWBGMODE)
        Sub SetAnswerMode(ByVal bAnswer As BOOL)
        Sub GetAnswerMode(pbAnswer As BOOL)
        Sub SetHoldPage(ByVal bHoldPage As BOOL)
        Sub GetHoldPage(pbHoldPage As BOOL)
        Sub GetCurrentPage(pWstPage As AM_WST_PAGE)
        #If Win64 Then
        Sub SetCurrentPage(WstPage As AM_WST_PAGE)
        #Else
        Sub SetCurrentPage(ByVal WstPage_dwPageNr As Long, ByVal WstPage_dwSubPageNr As Long, ByVal WstPage_pucPageData As LongPtr)
        #End If
    End Interface
    
    
'dvdif.idl

#If TWINBASIC_BUILD >= 896 Then
[InterfaceId("A70EFE61-E2A3-11d0-A9BE-00AA0061BE93")]
[OleAutomation(False)]
Interface IDvdControl Extends IUnknown
    [Description("Start playing the specified title number. Title numbers range between 1 and 99.")]
    Sub TitlePlay(ByVal ulTitle As Long)
    [Description("Start playing at the specified chapter (or part-of-title) within the specified title. Chapters range from 1 to 999.")]
    Sub ChapterPlay(ByVal ulTitle As Long, ByVal ulChapter As Long)
    [Description("Start playing at the specified time within the specified title. NOTE: the actual start time will be the closest sync point before or equal to the specified frame number.")]
    Sub TimePlay(ByVal ulTitle As Long, ByVal bcdTime As Long)
    [Description("Stop playback after saving resume information. DVD Navigator transfers to the DVD 'Stop State' and (same as DVD_DOMAIN_Stop), but filter graph remains in DirectShow's Run state.")]
    Sub StopForResume()
    [Description("Start playback of the program chain currently authored as the 'GoUp_PGCN'.")]
    Sub GoUp()
    [Description("Start playing at the specified time within the current title. NOTE: the actual start time will be the closest sync point before or equal to the specified frame number.")]
    Sub TimeSearch(ByVal bcdTime As Long)
    [Description("Start playing at the specified chapter (or part-of-title) within the current title.")]
    Sub ChapterSearch(ByVal ulChapter As Long)
    [Description("Start playing at the beginning of the previous DVD 'program'. For One-Sequential_PGC_Titles (which includes most titles) a program is equivalent to a chapter, otherwise a program is part of a chapter.")]
    Sub PrevPGSearch()
    [Description("Start playing from the beginning of they current program.")]
    Sub TopPGSearch()
    [Description("Start playing from the beginning of the next program.")]
    Sub NextPGSearch()
    [Description("Set forward play at the specified speed.")]
    Sub ForwardScan(ByVal dwSpeed As Double)
    [Description("Set reverse play at the specified speed. For reverse play, audio and subpicture are always muted.")]
    Sub BackwardScan(ByVal dwSpeed As Double)
    [Description("Start playback of the Menu specified by an enum DVD_MENU_ID.")]
    Sub MenuCall(ByVal MenuID As DVD_MENU_ID)
    [Description("Returns to title playback in DVD_DOMAIN_Title. This is typically done after MenuCall which puts the DVD Navigator in DVD_DOMAIN_VideoTitleSetMenu or DVD_DOMAIN_VideoManagerMenu.")]
    Sub Resume()
    [Description("Selects the button above the current button.")]
    Sub UpperButtonSelect()
    [Description("Selects the button below the current button.")]
    Sub LowerButtonSelect()
    [Description("Selects the button to the left of the current button.")]
    Sub LeftButtonSelect()
    [Description("Selects the button to the right of the current button.")]
    Sub RightButtonSelect()
    [Description("Activates current button.")]
    Sub ButtonActivate()
    [Description("Selects and then activates the button specified by the user. ulButton is intended to be a number entered by a user corresponding to button numbers currently displayed on screen. Button numbers range from 1 to 36.")]
    Sub ButtonSelectAndActivate(ByVal ulButton As Long)
    [Description("Releases any current still if there are no available buttons. This includes VOBU stills, Cell stills, and PGC stills, whether the still is infinite. When buttons are available, stills are released by activating a button. Note this does not release a Pause.")]
    Sub StillOff()
    [Description("Freezes playback and any internal timers. This is similar to IMediaControl::Pause()")]
    Sub PauseOn()
    [Description("Releases a Pause.")]
    Sub PauseOff()
    [Description("Selects the default language for menus. Languages are specified with Windows standard LCIDs. LCIDs can be created from ISO-639 codes with MAKELCID( MAKELANGID(wISO639LangID ,SUBLANG_DEFAULT ), SORT_DEFAULT ) MenuLanguageSelect may only called from the DVD Stop state (DVD_DOMAIN_Stop).")]
    Sub MenuLanguageSelect(ByVal Language As Long)
    [Description("Changes the current audio stream.")]
    Sub AudioStreamChange(ByVal ulAudio As Long)
    [Description("Changes the current subpicture stream number to nSubpic, and toggles its display.")]
    Sub SubpictureStreamChange(ByVal ulSubPicture As Long, ByVal bDisplay As BOOL)
    [Description("Changes the current angle number.")]
    Sub AngleChange(ByVal ulAngle As Long)
    [Description("Selects the current player parental level between 1 and 8.")]
    Sub ParentalLevelSelect(ByVal ulParentalLevel As Long)
    [Description("Sets the country/region in which to interpret the the Parental Level. The country/region specified using the Alpha-2 code of the ISO-3166 standard, with the addition of 'ZZ'")]
    Sub ParentalCountrySelect(ByVal wCountry As Integer)
    [Description("Sets the Karaoke audio mode. NOTE: This and all other Karoke support is currently not implemented.")]
    Sub KaraokeAudioPresentationModeChange(ByVal ulMode As Long)
    [Description("The user can specify the preferred display mode that should be used to display content. The parameter is a ULONG that has one of the values defined in DVD_PREFERRED_DISPLAY_MODE")]
    Sub VideoModePreferrence(ByVal ulPreferredDisplayMode As Long)
    [Description("Sets the root directory containing the DVD-Video volume. Can only be called from the DVD Stop State (DVD_DOMAIN_Stop). If the root directory is not successfully set before IMediaControl::Play is called, the first drive starting from c: containing a VIDEO_TS directory in the top level directory will be used as the root.")]
    Sub SetRoot(ByVal pszPath As LongPtr)
    [Description("Use PointToLongLong(). This is typically called in response to a mouse click. The specified point within the display window is to see if it is within a current DVD button's highlight rect. If it is, that button is first selected, then activated. NOTE: DVD Buttons do not all necessarily have highlight rects, button rects can overlap, and button rects do not always correspond to the visual representation of DVD buttons.")]
    Sub MouseActivate(ByVal point As POINT)
    [Description("Use PointToLongLong(). This is typically called in response to a mouse move within the display window.")]
    Sub MouseSelect(ByVal point As POINT)
    [Description("Start playing at the specified chapter within the specified title and play the number of chapters specified by the third parameter. Chapters range from 1 to 999.")]
    Sub ChapterPlayAutoStop(ByVal ulTitle As Long, ByVal ulChapter As Long, ByVal ulChaptersToPlay As Long)
End Interface
#Else
[InterfaceId("A70EFE61-E2A3-11d0-A9BE-00AA0061BE93")]
[OleAutomation(False)]
Interface IDvdControl Extends IUnknown
    [Description("Start playing the specified title number. Title numbers range between 1 and 99.")]
    Sub TitlePlay(ByVal ulTitle As Long)
    [Description("Start playing at the specified chapter (or part-of-title) within the specified title. Chapters range from 1 to 999.")]
    Sub ChapterPlay(ByVal ulTitle As Long, ByVal ulChapter As Long)
    [Description("Start playing at the specified time within the specified title. NOTE: the actual start time will be the closest sync point before or equal to the specified frame number.")]
    Sub TimePlay(ByVal ulTitle As Long, ByVal bcdTime As Long)
    [Description("Stop playback after saving resume information. DVD Navigator transfers to the DVD 'Stop State' and (same as DVD_DOMAIN_Stop), but filter graph remains in DirectShow's Run state.")]
    Sub StopForResume()
    [Description("Start playback of the program chain currently authored as the 'GoUp_PGCN'.")]
    Sub GoUp()
    [Description("Start playing at the specified time within the current title. NOTE: the actual start time will be the closest sync point before or equal to the specified frame number.")]
    Sub TimeSearch(ByVal bcdTime As Long)
    [Description("Start playing at the specified chapter (or part-of-title) within the current title.")]
    Sub ChapterSearch(ByVal ulChapter As Long)
    [Description("Start playing at the beginning of the previous DVD 'program'. For One-Sequential_PGC_Titles (which includes most titles) a program is equivalent to a chapter, otherwise a program is part of a chapter.")]
    Sub PrevPGSearch()
    [Description("Start playing from the beginning of they current program.")]
    Sub TopPGSearch()
    [Description("Start playing from the beginning of the next program.")]
    Sub NextPGSearch()
    [Description("Set forward play at the specified speed.")]
    Sub ForwardScan(ByVal dwSpeed As Double)
    [Description("Set reverse play at the specified speed. For reverse play, audio and subpicture are always muted.")]
    Sub BackwardScan(ByVal dwSpeed As Double)
    [Description("Start playback of the Menu specified by an enum DVD_MENU_ID.")]
    Sub MenuCall(ByVal MenuID As DVD_MENU_ID)
    [Description("Returns to title playback in DVD_DOMAIN_Title. This is typically done after MenuCall which puts the DVD Navigator in DVD_DOMAIN_VideoTitleSetMenu or DVD_DOMAIN_VideoManagerMenu.")]
    Sub Resume()
    [Description("Selects the button above the current button.")]
    Sub UpperButtonSelect()
    [Description("Selects the button below the current button.")]
    Sub LowerButtonSelect()
    [Description("Selects the button to the left of the current button.")]
    Sub LeftButtonSelect()
    [Description("Selects the button to the right of the current button.")]
    Sub RightButtonSelect()
    [Description("Activates current button.")]
    Sub ButtonActivate()
    [Description("Selects and then activates the button specified by the user. ulButton is intended to be a number entered by a user corresponding to button numbers currently displayed on screen. Button numbers range from 1 to 36.")]
    Sub ButtonSelectAndActivate(ByVal ulButton As Long)
    [Description("Releases any current still if there are no available buttons. This includes VOBU stills, Cell stills, and PGC stills, whether the still is infinite. When buttons are available, stills are released by activating a button. Note this does not release a Pause.")]
    Sub StillOff()
    [Description("Freezes playback and any internal timers. This is similar to IMediaControl::Pause()")]
    Sub PauseOn()
    [Description("Releases a Pause.")]
    Sub PauseOff()
    [Description("Selects the default language for menus. Languages are specified with Windows standard LCIDs. LCIDs can be created from ISO-639 codes with MAKELCID( MAKELANGID(wISO639LangID ,SUBLANG_DEFAULT ), SORT_DEFAULT ) MenuLanguageSelect may only called from the DVD Stop state (DVD_DOMAIN_Stop).")]
    Sub MenuLanguageSelect(ByVal Language As Long)
    [Description("Changes the current audio stream.")]
    Sub AudioStreamChange(ByVal ulAudio As Long)
    [Description("Changes the current subpicture stream number to nSubpic, and toggles its display.")]
    Sub SubpictureStreamChange(ByVal ulSubPicture As Long, ByVal bDisplay As BOOL)
    [Description("Changes the current angle number.")]
    Sub AngleChange(ByVal ulAngle As Long)
    [Description("Selects the current player parental level between 1 and 8.")]
    Sub ParentalLevelSelect(ByVal ulParentalLevel As Long)
    [Description("Sets the country/region in which to interpret the the Parental Level. The country/region specified using the Alpha-2 code of the ISO-3166 standard, with the addition of 'ZZ'")]
    Sub ParentalCountrySelect(ByVal wCountry As Integer)
    [Description("Sets the Karaoke audio mode. NOTE: This and all other Karoke support is currently not implemented.")]
    Sub KaraokeAudioPresentationModeChange(ByVal ulMode As Long)
    [Description("The user can specify the preferred display mode that should be used to display content. The parameter is a ULONG that has one of the values defined in DVD_PREFERRED_DISPLAY_MODE")]
    Sub VideoModePreferrence(ByVal ulPreferredDisplayMode As Long)
    [Description("Sets the root directory containing the DVD-Video volume. Can only be called from the DVD Stop State (DVD_DOMAIN_Stop). If the root directory is not successfully set before IMediaControl::Play is called, the first drive starting from c: containing a VIDEO_TS directory in the top level directory will be used as the root.")]
    Sub SetRoot(ByVal pszPath As LongPtr)
    [Description("Use PointToLongLong(). This is typically called in response to a mouse click. The specified point within the display window is to see if it is within a current DVD button's highlight rect. If it is, that button is first selected, then activated. NOTE: DVD Buttons do not all necessarily have highlight rects, button rects can overlap, and button rects do not always correspond to the visual representation of DVD buttons.")]
    Sub MouseActivate(ByVal point As LongLong /* POINT */)
    [Description("Use PointToLongLong(). This is typically called in response to a mouse move within the display window.")]
    Sub MouseSelect(ByVal point As LongLong /* POINT */)
    [Description("Start playing at the specified chapter within the specified title and play the number of chapters specified by the third parameter. Chapters range from 1 to 999.")]
    Sub ChapterPlayAutoStop(ByVal ulTitle As Long, ByVal ulChapter As Long, ByVal ulChaptersToPlay As Long)
End Interface
#End If

[InterfaceId("A70EFE60-E2A3-11d0-A9BE-00AA0061BE93")]
[OleAutomation(False)]
Interface IDvdInfo Extends IUnknown
    [Description("Returns the current DVD Domain of the DVD player.")]
    Sub GetCurrentDomain(ByRef pDomain As DVD_DOMAIN)
    [Description("Returns information sufficient to restart playback of a video from the current playback location in titles that don't explicitly disable seeking to the current location.")]
    Sub GetCurrentLocation(ByRef pLocation As DVD_PLAYBACK_LOCATION)
    [Description("Return the total playback time for the current title. Only works for One_Sequential_PGC_Titles.")]
    Sub GetTotalTitleTime(ByRef pulTotalTime As Long)
    [Description("Indicates the number of currently available buttons and the current selected button number. If buttons are not present it returns 0 for both pulButtonsAvailable and pulCurrentButton")]
    Sub GetCurrentButton(ByRef pulButtonsAvailable As Long, ByRef pulCurrentButton As Long)
    [Description("Indicates the number of currently available angles and the current selected angle number. If *pnAnglesAvailable==1, then the current video is not multiangle.")]
    Sub GetCurrentAngle(ByRef pulAnglesAvailable As Long, ByRef pulCurrentAngle As Long)
    [Description("Indicates the number of currently available audio streams and the current selected audio stream number. This only work when in DVD_DOMAIN_Title.")]
    Sub GetCurrentAudio(ByRef pulStreamsAvailable As Long, ByRef pulCurrentStream As Long)
    [Description("Indicates the number of currently available subpicture streams, the current selected subpicture stream number, and if the subpicture display is currently disabled.")]
    Sub GetCurrentSubpicture(ByRef pulStreamsAvailable As Long, ByRef pulCurrentStream As Long, ByRef pIsDisabled As BOOL)
    [Description("Indicates which IDVDControl methods are currently valid. DVD titles can enable or disable individual user operations at almost any point during playback.")]
    Sub GetCurrentUOPS(ByRef pUOP As Long)
    [Description("Returns the current contents of all System Parameter Registers. See DVD-Video spec for use of individual registers.")]
    Sub GetAllSPRMs(ByRef pRegisterArray As SPRMARRAY)
    [Description("Returns the current contents of all General Parameter Registers. Use of GPRMs is title specific.")]
    Sub GetAllGPRMs(ByRef pRegisterArray As GPRMARRAY)
    [Description("Returns the language of the specified stream within the current title. Does not return languages for menus. Sets *pLanguage=0 if if the stream does not include language.")]
    Sub GetAudioLanguage(ByVal ulStream As Long, ByRef pLanguage As Long)
    [Description("Returns the language of the specified stream within the current title. Does not return languages for menus. Sets *pLanguage=0 if if the stream does not include language.")]
    Sub GetSubpictureLanguage(ByVal ulStream As Long, ByRef pLanguage As Long)
    [Description("Returns attributes of all video, audio, and subpicture streams for the specified title including menus. If nTitle == 0xffffffff, attributes for the current title are returned.")]
    Sub GetTitleAttributes(ByVal ulTitle As Long, ByRef pATR As DVD_ATR)
    [Description("Returns attributes of all video, audio, and subpicture streams for Video Manager Menus. Some menus, such as the DVD_MENU_Title are in a separate group of streams called the VMG (Video Manager) and are not associated with any particular title number.")]
    Sub GetVMGAttributes(ByRef pATR As DVD_ATR)
    [Description("Returns the video attributes for the current title or menu.")]
    Sub GetCurrentVideoAttributes(ByRef pATR As DVD_VideoATR)
    [Description("Returns the video attributes for the stream in the current title or menu.")]
    Sub GetCurrentAudioAttributes(ByRef pATR As DVD_AudioATR)
    [Description("Returns the video attributes for the stream in the current title or menu.")]
    Sub GetCurrentSubpictureAttributes(ByRef pATR As DVD_SubpictureATR)
    [Description("Returns current DVD volume info.")]
    Sub GetCurrentVolumeInfo(ByRef pulNumOfVol As Long, ByRef pulThisVolNum As Long, ByRef pSide As DVD_DISC_SIDE, ByRef pulNumOfTitles As Long)
    [Description("Returns the TXTDT_MG structure, which can contain text descriptions for title name, volume name, producer name, vocalist name, etc. in various languages.")]
    Sub GetDVDTextInfo(ByVal pTextManager As LongPtr, ByVal ulBufSize As Long, ByRef pulActualSize As Long)
    [Description("Returns the current parental level and the current country/region code that has been set in the system registers in player.")]
    Sub GetPlayerParentalLevel(ByRef pulParentalLevel As Long, ByRef pulCountryCode As Long)
    [Description("Returns the number of chapters that are defined for a given title.")]
    Sub GetNumberOfChapters(ByVal ulTitle As Long, ByRef pulNumberOfChapters As Long)
    [Description("Returns the parental levels that are defined for a particular title. pParentalLevels will be combination of DVD_PARENTAL_LEVEL_8, DVD_PARENTAL_LEVEL_6, or DVD_PARENTAL_LEVEL_1 ORed together")]
    Sub GetTitleParentalLevels(ByVal ulTitle As Long, ByRef pulParentalLevels As Long)
    [Description("Returns the root directory that is set in the player.")]
    Sub GetRoot(ByVal pRoot As LongPtr, ByVal ulBufSize As Long, ByRef pulActualSize As Long)
End Interface

[InterfaceId("5a4a97e4-94ee-4a55-9751-74b5643aa27d")]
[OleAutomation(False)]
Interface IDvdCmd Extends IUnknown
    [Description("Blocks the application until the command has begun.")]
    Sub WaitForStart()
    [Description("Blocks until the command has completed or has been cancelled.")]
    Sub WaitForEnd()
End Interface

[InterfaceId("86303d6d-1c4a-4087-ab42-f711167048ef")]
[OleAutomation(False)]
Interface IDvdState Extends IUnknown
    [Description("Returns the disc ID from which the bookmark was made.")]
    Sub GetDiscID(ByRef pullUniqueID As LongLong)
    [Description("Returns the state's parental level")]
    Sub GetParentalLevel(ByRef pulParentalLevel As Long)
End Interface

#If TWINBASIC_BUILD >= 896 Then
[InterfaceId("33BC7430-EEC0-11D2-8201-00A0C9D74842")]
[OleAutomation(False)]
Interface IDvdControl2 Extends IUnknown
    [Description("Start playing from the beginning of the specified title number. Annex J: Title_Play. Title numbers range between 1 and 99.")]
    Sub PlayTitle(ByVal ulTitle As Long, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the beginning of the given chapter (or part-of-title) number within the specified title number. Annex J: PTT_Play. Title numbers range between 1 and 99. Chapters range from 1 to 999.")]
    Sub PlayChapterInTitle(ByVal ulTitle As Long, ByVal ulChapter As Long, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the specified time within the specified title number. NOTE: the actual start time will be the closest sync point before or equal to the specified frame number. Annex J: Time_Play Title numbers range between 1 and 99.")]
    Sub PlayAtTimeInTitle(ByVal ulTitle As Long, ByRef pStartTime As DVD_HMSF_TIMECODE, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Stop playback by transferring DVD Navigator to the DVD Stop State (same as DVD_DOMAIN_Stop), but filter graph remains in DirectShow's Run state. Annex J: Stop")]
    Sub Stop()
    [Description("Stop playback of current program chain (PGC) and start playing the PGC specified by GoUp_PGCN in the PGCI. If the GoUp_PGCN value is 0xFFFF the Resume() operation is carried out. Annex J: GoUp")]
    Sub ReturnFromSubmenu(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing at the specified time within the current title. NOTE: the actual start time will be the closest sync point before or equal to the specified frame number. Annex J: Time_Search The time is in BCD format, passed in as a ULONG.")]
    Sub PlayAtTime(ByRef pTime As DVD_HMSF_TIMECODE, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing at the specified chapter (or part-of-title) within the current title. Annex J: PTT_Search Chapters range from 1 to 999.")]
    Sub PlayChapter(ByVal ulChapter As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing at the beginning of the previous DVD program . For One-Sequential_PGC_Titles (which includes most titles) a program is equivalent to a chapter, otherwise a program is part of a chapter. Annex J: PrevPG_Search")]
    Sub PlayPrevChapter(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the beginning of they current program. Annex J: TopPG_Search")]
    Sub ReplayChapter(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the beginning of the next program. Annex J: NextPG_Search")]
    Sub PlayNextChapter(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Set forward play at the specified speed.")]
    Sub PlayForwards(ByVal dSpeed As Double, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Set reverse play at the specified speed.")]
    Sub PlayBackwards(ByVal dSpeed As Double, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playback of the Menu specified by an enum DVD_MENU_ID. Annex J: Menu_Call")]
    Sub ShowMenu(ByVal MenuID As DVD_MENU_ID, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Returns to title playback in DVD_DOMAIN_Title. This is typically done after MenuCall which puts the DVD Navigator in DVD_DOMAIN_VideoTitleSetMenu or DVD_DOMAIN_VideoManagerMenu. Annex J: Resume")]
    Sub Resume(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Moves the selection highlight above, below, to the left of, or to the right of the currently selected.")]
    Sub SelectRelativeButton(ByVal buttonDir As DVD_RELATIVE_BUTTON)
    [Description("Activates current button. Annex J: Button_Activate")]
    Sub ActivateButton()
    [Description("Selects a specific button (with the index from 1 to 36). ulButton is intended to be a number entered by a user corresponding to button numbers currently displayed on screen. Button numbers range from 1 to 36.")]
    Sub SelectButton(ByVal ulButton As Long)
    [Description("Selects and then activates the button specified by the user. ulButton is intended to be a number entered by a user corresponding to button numbers currently displayed on screen. Annex J: Button_Select_And_Activate Button numbers range from 1 to 36.")]
    Sub SelectAndActivateButton(ByVal ulButton As Long)
    [Description("Releases any current still if there are no available buttons. This includes VOBU stills, Cell stills, and PGC stills, whether the still is infinite. When buttons are available, stills are released by activating a button. Note this does not release a Pause. Annex J: Still_Off")]
    Sub StillOff()
    [Description("Freezes / unfreezes playback and any internal timers. This is similar to IMediaControl::Pause(), but not the same in effect as IMediaControl::Pause puts the filter (all filters, if done to the graph) in paused state. Annex J: Pause_On and Pause_Off")]
    Sub Pause(ByVal bState As BOOL)
    [Description("Changes the current audio stream to ulAudio. Annex J: Audio_Stream_Change Audio stream number ranges between 0 and 7 or DEFAULT_AUDIO_STREAM (15 - default based on default language & language extension)")]
    Sub SelectAudioStream(ByVal ulAudio As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Changes the current subpicture stream number to ulSubPicture Annex J: Sub-picture_Stream_Change (first param) Subpicture stream number should be between 0 and 31 or 63.")]
    Sub SelectSubpictureStream(ByVal ulSubPicture As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Turns on/off current subpicture stream display. Annex J: Sub-picture_Stream_Change (second param) Subpicture state is On or Off (TRUE or FALSE)")]
    Sub SetSubpictureState(ByVal bState As BOOL, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Changes the current angle number. Annex J: Angle_Change Angle number is between 1 and 9.")]
    Sub SelectAngle(ByVal ulAngle As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Selects the current player parental level. Annex J: Parental_Level_Select Parental level ranges between 1 and 8. (G-NC17)")]
    Sub SelectParentalLevel(ByVal ulParentalLevel As Long)
    [Description("Sets the country/region in which to interpret the Parental Level. Annex J: Parental_Country_Select The country/region specified using the Alpha-2 code of the ISO-3166 standard,")]
    Sub SelectParentalCountry(ByRef bCountry As Byte)
    [Description("Sets the Karaoke audio mode. Annex J: Karaoke_Audio_Presentation_Mode_Change")]
    Sub SelectKaraokeAudioPresentationMode(ByVal ulMode As Long)
    [Description("The user can specify the (initial) preferred display mode (aspect ratio) (wide / letterbox / pan-scan) that should be used to display content (16 : 9). Annex J: Video_Presentation_Mode_Change")]
    Sub SelectVideoModePreference(ByVal ulPreferredDisplayMode As DVD_PREFERRED_DISPLAY_MODE)
    [Description("Sets the root directory containing the DVD-Video volume. Can only be called from the DVD Stop State (DVD_DOMAIN_Stop).")]
    Sub SetDVDDirectory(ByVal pszwPath As LongPtr)
    [Description("This is typically called in response to a mouse click.")]
    Sub ActivateAtPosition(ByVal point As POINT)
    [Description("This is typically called in response to a mouse move within the display window.")]
    Sub SelectAtPosition(ByVal point As POINT)
    [Description("Start playing at the specified chapter within the specified title and play the number of chapters specified by the third parameter. Then the playback stops by sending an event EC_DVD_CHAPTER_AUTOSTOP. Title ranges from 1 to 99. Chapter (and number of chapters to play) ranges from 1 to 999.")]
    Sub PlayChaptersAutoStop(ByVal ulTitle As Long, ByVal ulChapter As Long, ByVal ulChaptersToPlay As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Application's way of informing the Navigator that the required parental level change indicated through a previous event was accepted or rejected by the app (and unblock the Navigator).")]
    Sub AcceptParentalLevelChange(ByVal bAccept As BOOL)
    Sub SetOption(ByVal flag As DVD_OPTION_FLAG, ByVal fState As BOOL)
    [Description("The navigator will use the location information in the given state object to restore the navigator's position to a specific location on the disc. A valid state object is returned by either calling GetState(), or by using `CoCreateInstance ( CLSID_DVDState, NULL, CLSCTX_INPROC_SERVER, IID_IDvdState, (void **) ppState )` to create a state object, followed by `pState->IPersist::Load()` to read it from memory or disk.")]
    Sub SetState(ByVal pState As IDvdState, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the specified time within the specified title number until the specified end time. NOTE: the actual start and end times will be the closest sync points before or equal to the specified frame number. Annex J: Time_Play for a limited range Title numbers range between 1 and 99.")]
    Sub PlayPeriodInTitleAutoStop(ByVal ulTitle As Long, ByRef pStartTime As DVD_HMSF_TIMECODE, ByRef pEndTime As DVD_HMSF_TIMECODE, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Sets the current contents of a DVD General Parameter Register. Use of GPRMs is title specific.")]
    Sub SetGPRM(ByVal ulIndex As Long, ByVal wValue As Integer, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Selects the default language for menus. Languages are specified with Windows standard LCIDs.")]
    Sub SelectDefaultMenuLanguage(ByVal Language As Long)
    [Description("Selects the default audio language. Languages are specified with Windows standard LCIDs.")]
    Sub SelectDefaultAudioLanguage(ByVal Language As Long, ByVal audioExtension As DVD_AUDIO_LANG_EXT)
    [Description("Selects the default subpicture language. Languages are specified with Windows standard LCIDs.")]
    Sub SelectDefaultSubpictureLanguage(ByVal Language As Long, ByVal subpictureExtension As DVD_SUBPICTURE_LANG_EXT)
End Interface
[InterfaceId("34151510-EEC0-11D2-8201-00A0C9D74842")]
[OleAutomation(False)]
Interface IDvdInfo2 Extends IUnknown
    [Description("Returns the current DVD Domain of the DVD player.")]
    Sub GetCurrentDomain(ByRef pDomain As DVD_DOMAIN)
    [Description("Returns information sufficient to restart playback of a video from the current playback location in titles that don't explicitly disable seeking to the current location.")]
    Sub GetCurrentLocation(ByRef pLocation As DVD_PLAYBACK_LOCATION2)
    [Description("Returns the total playback time for the current title. Only works for One_Sequential_PGC_Titles.")]
    Sub GetTotalTitleTime(ByRef pTotalTime As DVD_HMSF_TIMECODE, ByRef ulTimeCodeFlags As Long)
    [Description("Indicates the number of currently available buttons and the current selected button number.")]
    Sub GetCurrentButton(ByRef pulButtonsAvailable As Long, ByRef pulCurrentButton As Long)
    [Description("Indicates the number of currently available angles and the current selected angle number. If *pulAnglesAvailable is returned as 1 then the current content is not multiangle.")]
    Sub GetCurrentAngle(ByRef pulAnglesAvailable As Long, ByRef pulCurrentAngle As Long)
    [Description("Indicates the number of currently available audio streams and the currently selected audio stream number. This only works inside the Title domain.")]
    Sub GetCurrentAudio(ByRef pulStreamsAvailable As Long, ByRef pulCurrentStream As Long)
    [Description("Indicates the number of currently available subpicture streams, the currently selected subpicture stream number, and if the subpicture display is currently disabled.")]
    Sub GetCurrentSubpicture(ByRef pulStreamsAvailable As Long, ByRef pulCurrentStream As Long, ByRef pbIsDisabled As BOOL)
    [Description("Indicates which IDVDControl methods (Annex J user operations) are currently valid. DVD titles can enable or disable individual user operations at almost any point during playback.")]
    Sub GetCurrentUOPS(ByRef pulUOPs As Long)
    [Description("Returns the current contents of all DVD System Parameter Registers.")]
    Sub GetAllSPRMs(ByRef pRegisterArray As SPRMARRAY)
    [Description("Returns the current contents of all DVD General Parameter Registers.")]
    Sub GetAllGPRMs(ByRef pRegisterArray As GPRMARRAY)
    [Description("Returns the language of the specified stream within the current title. Does not return languages for menus.")]
    Sub GetAudioLanguage(ByVal ulStream As Long, ByRef pLanguage As Long)
    [Description("Returns the language of the specified stream within the current title. Does not return languages for menus.")]
    Sub GetSubpictureLanguage(ByVal ulStream As Long, ByRef pLanguage As Long)
    [Description("Returns attributes of all video, audio, and subpicture streams for the specified title including menus. If 0xffffffff is specified as ulTitle, attributes for the current title are returned.")]
    Sub GetTitleAttributes(ByVal ulTitle As Long, ByRef pMenu As DVD_MenuAttributes, ByRef pTitle As DVD_TitleAttributes)
    [Description("Returns attributes of all video, audio, and subpicture streams for Video Manager Menus. This method suppliments GetTitleAttributes() for some menus, such as the Title menu, which are in a separate group of streams called the VMG (Video Manager) and are not associated with any particular title number.")]
    Sub GetVMGAttributes(ByRef pATR As DVD_MenuAttributes)
    [Description("Returns the video attributes for the current title or menu.")]
    Sub GetCurrentVideoAttributes(ByRef pATR As DVD_VideoAttributes)
    [Description("Returns the audio attributes for the specified stream in the current title or menu.")]
    Sub GetAudioAttributes(ByVal ulStream As Long, ByRef pATR As DVD_AudioAttributes)
    [Description("Returns the karaoke contents of each channel of the specified stream in the current title or menu.")]
    Sub GetKaraokeAttributes(ByVal ulStream As Long, ByRef pAttributes As DVD_KaraokeAttributes)
    [Description("Returns the subpicture attributes for the specified stream in the current title or menu.")]
    Sub GetSubpictureAttributes(ByVal ulStream As Long, ByRef pATR As DVD_SubpictureAttributes)
    [Description("Returns current DVD volume information.")]
    Sub GetDVDVolumeInfo(ByRef pulNumOfVolumes As Long, ByRef pulVolume As Long, ByRef pSide As DVD_DISC_SIDE, ByRef pulNumOfTitles As Long)
    [Description("Returns the number of text languages for the current DVD directory.")]
    Sub GetDVDTextNumberOfLanguages(ByRef pulNumOfLangs As Long)
    [Description("Returns the text languages information (number of strings, language code, char set) for the specified language index.")]
    Sub GetDVDTextLanguageInfo(ByVal ulLangIndex As Long, ByRef pulNumOfStrings As Long, ByRef pLangCode As Long, ByRef pbCharacterSet As DVD_TextCharSet)
    [Description("Returns the text string as an array of bytes for the specified language index.and string index.")]
    Sub GetDVDTextStringAsNative(ByVal ulLangIndex As Long, ByVal ulStringIndex As Long, ByRef pbBuffer As Byte, ByVal ulMaxBufferSize As Long, ByRef pulActualSize As Long, ByRef pType As DVD_TextStringType)
    [Description("Returns the text string in Unicode for the specified language index.and string index. Should return some error code if an invalid text or string index is specified. It also just returns the length of the string if pchBuffer is specified as NULL.")]
    Sub GetDVDTextStringAsUnicode(ByVal ulLangIndex As Long, ByVal ulStringIndex As Long, ByRef pchwBuffer As Integer, ByVal ulMaxBufferSize As Long, ByRef pulActualSize As Long, ByRef pType As DVD_TextStringType)
    [Description("Returns the current parental level and the current country/region code that has been set in the system registers in player. See Table 3.3.4-1 of the DVD-Video spec for the defined parental levels. Valid Parental Levels range from 1 to 8 if parental management is enabled. Returns 0xffffffff if parental management is disabled See ISO3166 : Alpha-2 Code for the country/region codes.")]
    Sub GetPlayerParentalLevel(ByRef pulParentalLevel As Long, ByRef pbCountryCode As Byte)
    [Description("Returns the number of chapters that are defined for a given title.")]
    Sub GetNumberOfChapters(ByVal ulTitle As Long, ByRef pulNumOfChapters As Long)
    [Description("Returns the parental levels that are defined for a particular title. pulParentalLevels will be combination of DVD_PARENTAL_LEVEL_8, DVD_PARENTAL_LEVEL_6, or DVD_PARENTAL_LEVEL_1 OR-ed together")]
    Sub GetTitleParentalLevels(ByVal ulTitle As Long, ByRef pulParentalLevels As Long)
    [Description("Returns the root directory that is set in the player. If a valid root has been found, it returns the root string. Otherwise, it returns 0 for pcbActualSize indicating that a valid root directory has not been found or initialized.")]
    Sub GetDVDDirectory(ByRef pszwPath As Integer, ByVal ulMaxSize As Long, ByRef pulActualSize As Long)
    [Description("Determines if the specified audio stream is enabled/disabled in the current PGC.")]
    Sub IsAudioStreamEnabled(ByVal ulStreamNum As Long, ByRef pbEnabled As BOOL)
    [Description("Returns a 64-bit identification number for the specified DVD disc.")]
    Sub GetDiscID(ByVal pszwPath As LongPtr, ByRef pullDiscID As LongLong)
    [Description("The navigator will create a new state object and save the current location into it. The state object can be used to restore the navigator the saved location at a later time. A new IDvdState object is created (with a single AddRef) and returned in *pStateData. The object must be Released() when the application is finished with it.")]
    Sub GetState(ByRef pStateData As IDvdState)
    [Description("Navigator gets all of the menu languages for the VMGM and VTSM domains.")]
    Sub GetMenuLanguages(ByRef pLanguages As Long, ByVal ulMaxLanguages As Long, ByRef pulActualLanguages As Long)
    [Description("Use PointToLongLong(). This is typically called in response to a mouse move within the display window. It returns the button located at the specified point within the display window. If no button is present at that position, then VFW_E_DVD_NO_BUTTON is returned. Button indices start at 1.")]
    Sub GetButtonAtPosition(ByVal point As POINT, ByRef pulButtonIndex As Long)
    [Description("This method maps an EC_DVD_CMD_BEGIN/COMPLETE/CANCEL event's lParam1 into an AddRef'd IDvdCmd pointer. You must Release the returned pointer. NULL is returned if the function fails.")]
    Sub GetCmdFromEvent(ByVal lParam1 As LongPtr, ByRef pCmdObj As IDvdCmd)
    [Description("Returns the default language for menus.")]
    Sub GetDefaultMenuLanguage(ByRef pLanguage As Long)
    [Description("Gets the default audio language. Languages are specified with Windows standard LCIDs.")]
    Sub GetDefaultAudioLanguage(ByRef pLanguage As Long, ByRef pAudioExtension As DVD_AUDIO_LANG_EXT)
    [Description("Gets the default subpicture language. Languages are specified with Windows standard LCIDs.")]
    Sub GetDefaultSubpictureLanguage(ByRef pLanguage As Long, ByRef pSubpictureExtension As DVD_SUBPICTURE_LANG_EXT)
    [Description("Retrieves the DVD decoder's details about max data rate for video, audio and subpicture (going backward and forward) as well as support for various types of audio (AC3, MPEG2, DTS, SDDS, LPCM).")]
    Sub GetDecoderCaps(ByRef pCaps As DVD_DECODER_CAPS)
    [Description("Retrieves the coordinates for a given button number")]
    Sub GetButtonRect(ByVal ulButton As Long, ByRef pRect As RECT)
    [Description("Determines if the specified subpicture stream is enabled/disabled in the current PGC.")]
    Sub IsSubpictureStreamEnabled(ByVal ulStreamNum As Long, ByRef pbEnabled As BOOL)
End Interface
#Else
[InterfaceId("33BC7430-EEC0-11D2-8201-00A0C9D74842")]
[OleAutomation(False)]
Interface IDvdControl2 Extends IUnknown
    [Description("Start playing from the beginning of the specified title number. Annex J: Title_Play. Title numbers range between 1 and 99.")]
    Sub PlayTitle(ByVal ulTitle As Long, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the beginning of the given chapter (or part-of-title) number within the specified title number. Annex J: PTT_Play. Title numbers range between 1 and 99. Chapters range from 1 to 999.")]
    Sub PlayChapterInTitle(ByVal ulTitle As Long, ByVal ulChapter As Long, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the specified time within the specified title number. NOTE: the actual start time will be the closest sync point before or equal to the specified frame number. Annex J: Time_Play Title numbers range between 1 and 99.")]
    Sub PlayAtTimeInTitle(ByVal ulTitle As Long, ByRef pStartTime As DVD_HMSF_TIMECODE, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Stop playback by transferring DVD Navigator to the DVD Stop State (same as DVD_DOMAIN_Stop), but filter graph remains in DirectShow's Run state. Annex J: Stop")]
    Sub Stop()
    [Description("Stop playback of current program chain (PGC) and start playing the PGC specified by GoUp_PGCN in the PGCI. If the GoUp_PGCN value is 0xFFFF the Resume() operation is carried out. Annex J: GoUp")]
    Sub ReturnFromSubmenu(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing at the specified time within the current title. NOTE: the actual start time will be the closest sync point before or equal to the specified frame number. Annex J: Time_Search The time is in BCD format, passed in as a ULONG.")]
    Sub PlayAtTime(ByRef pTime As DVD_HMSF_TIMECODE, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing at the specified chapter (or part-of-title) within the current title. Annex J: PTT_Search Chapters range from 1 to 999.")]
    Sub PlayChapter(ByVal ulChapter As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing at the beginning of the previous DVD program . For One-Sequential_PGC_Titles (which includes most titles) a program is equivalent to a chapter, otherwise a program is part of a chapter. Annex J: PrevPG_Search")]
    Sub PlayPrevChapter(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the beginning of they current program. Annex J: TopPG_Search")]
    Sub ReplayChapter(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the beginning of the next program. Annex J: NextPG_Search")]
    Sub PlayNextChapter(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Set forward play at the specified speed.")]
    Sub PlayForwards(ByVal dSpeed As Double, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Set reverse play at the specified speed.")]
    Sub PlayBackwards(ByVal dSpeed As Double, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Start playback of the Menu specified by an enum DVD_MENU_ID. Annex J: Menu_Call")]
    Sub ShowMenu(ByVal MenuID As DVD_MENU_ID, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Returns to title playback in DVD_DOMAIN_Title. This is typically done after MenuCall which puts the DVD Navigator in DVD_DOMAIN_VideoTitleSetMenu or DVD_DOMAIN_VideoManagerMenu. Annex J: Resume")]
    Sub Resume(ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Moves the selection highlight above, below, to the left of, or to the right of the currently selected.")]
    Sub SelectRelativeButton(ByVal buttonDir As DVD_RELATIVE_BUTTON)
    [Description("Activates current button. Annex J: Button_Activate")]
    Sub ActivateButton()
    [Description("Selects a specific button (with the index from 1 to 36). ulButton is intended to be a number entered by a user corresponding to button numbers currently displayed on screen. Button numbers range from 1 to 36.")]
    Sub SelectButton(ByVal ulButton As Long)
    [Description("Selects and then activates the button specified by the user. ulButton is intended to be a number entered by a user corresponding to button numbers currently displayed on screen. Annex J: Button_Select_And_Activate Button numbers range from 1 to 36.")]
    Sub SelectAndActivateButton(ByVal ulButton As Long)
    [Description("Releases any current still if there are no available buttons. This includes VOBU stills, Cell stills, and PGC stills, whether the still is infinite. When buttons are available, stills are released by activating a button. Note this does not release a Pause. Annex J: Still_Off")]
    Sub StillOff()
    [Description("Freezes / unfreezes playback and any internal timers. This is similar to IMediaControl::Pause(), but not the same in effect as IMediaControl::Pause puts the filter (all filters, if done to the graph) in paused state. Annex J: Pause_On and Pause_Off")]
    Sub Pause(ByVal bState As BOOL)
    [Description("Changes the current audio stream to ulAudio. Annex J: Audio_Stream_Change Audio stream number ranges between 0 and 7 or DEFAULT_AUDIO_STREAM (15 - default based on default language & language extension)")]
    Sub SelectAudioStream(ByVal ulAudio As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Changes the current subpicture stream number to ulSubPicture Annex J: Sub-picture_Stream_Change (first param) Subpicture stream number should be between 0 and 31 or 63.")]
    Sub SelectSubpictureStream(ByVal ulSubPicture As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Turns on/off current subpicture stream display. Annex J: Sub-picture_Stream_Change (second param) Subpicture state is On or Off (TRUE or FALSE)")]
    Sub SetSubpictureState(ByVal bState As BOOL, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Changes the current angle number. Annex J: Angle_Change Angle number is between 1 and 9.")]
    Sub SelectAngle(ByVal ulAngle As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Selects the current player parental level. Annex J: Parental_Level_Select Parental level ranges between 1 and 8. (G-NC17)")]
    Sub SelectParentalLevel(ByVal ulParentalLevel As Long)
    [Description("Sets the country/region in which to interpret the Parental Level. Annex J: Parental_Country_Select The country/region specified using the Alpha-2 code of the ISO-3166 standard,")]
    Sub SelectParentalCountry(ByRef bCountry As Byte)
    [Description("Sets the Karaoke audio mode. Annex J: Karaoke_Audio_Presentation_Mode_Change")]
    Sub SelectKaraokeAudioPresentationMode(ByVal ulMode As Long)
    [Description("The user can specify the (initial) preferred display mode (aspect ratio) (wide / letterbox / pan-scan) that should be used to display content (16 : 9). Annex J: Video_Presentation_Mode_Change")]
    Sub SelectVideoModePreference(ByVal ulPreferredDisplayMode As DVD_PREFERRED_DISPLAY_MODE)
    [Description("Sets the root directory containing the DVD-Video volume. Can only be called from the DVD Stop State (DVD_DOMAIN_Stop).")]
    Sub SetDVDDirectory(ByVal pszwPath As LongPtr)
    [Description("This is typically called in response to a mouse click.")]
    Sub ActivateAtPosition(ByVal point As LongLong /* POINT */)
    [Description("This is typically called in response to a mouse move within the display window.")]
    Sub SelectAtPosition(ByVal point As LongLong /* POINT */)
    [Description("Start playing at the specified chapter within the specified title and play the number of chapters specified by the third parameter. Then the playback stops by sending an event EC_DVD_CHAPTER_AUTOSTOP. Title ranges from 1 to 99. Chapter (and number of chapters to play) ranges from 1 to 999.")]
    Sub PlayChaptersAutoStop(ByVal ulTitle As Long, ByVal ulChapter As Long, ByVal ulChaptersToPlay As Long, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Application's way of informing the Navigator that the required parental level change indicated through a previous event was accepted or rejected by the app (and unblock the Navigator).")]
    Sub AcceptParentalLevelChange(ByVal bAccept As BOOL)
    Sub SetOption(ByVal flag As DVD_OPTION_FLAG, ByVal fState As BOOL)
    [Description("The navigator will use the location information in the given state object to restore the navigator's position to a specific location on the disc. A valid state object is returned by either calling GetState(), or by using `CoCreateInstance ( CLSID_DVDState, NULL, CLSCTX_INPROC_SERVER, IID_IDvdState, (void **) ppState )` to create a state object, followed by `pState->IPersist::Load()` to read it from memory or disk.")]
    Sub SetState(ByVal pState As IDvdState, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Start playing from the specified time within the specified title number until the specified end time. NOTE: the actual start and end times will be the closest sync points before or equal to the specified frame number. Annex J: Time_Play for a limited range Title numbers range between 1 and 99.")]
    Sub PlayPeriodInTitleAutoStop(ByVal ulTitle As Long, ByRef pStartTime As DVD_HMSF_TIMECODE, ByRef pEndTime As DVD_HMSF_TIMECODE, ByVal dwFlags As DVD_CMD_FLAGS, ByRef ppCmd As IDvdCmd)
    [Description("Sets the current contents of a DVD General Parameter Register. Use of GPRMs is title specific.")]
    Sub SetGPRM(ByVal ulIndex As Long, ByVal wValue As Integer, ByVal dwFlags As Long, ByRef ppCmd As IDvdCmd)
    [Description("Selects the default language for menus. Languages are specified with Windows standard LCIDs.")]
    Sub SelectDefaultMenuLanguage(ByVal Language As Long)
    [Description("Selects the default audio language. Languages are specified with Windows standard LCIDs.")]
    Sub SelectDefaultAudioLanguage(ByVal Language As Long, ByVal audioExtension As DVD_AUDIO_LANG_EXT)
    [Description("Selects the default subpicture language. Languages are specified with Windows standard LCIDs.")]
    Sub SelectDefaultSubpictureLanguage(ByVal Language As Long, ByVal subpictureExtension As DVD_SUBPICTURE_LANG_EXT)
End Interface
[InterfaceId("34151510-EEC0-11D2-8201-00A0C9D74842")]
[OleAutomation(False)]
Interface IDvdInfo2 Extends IUnknown
    [Description("Returns the current DVD Domain of the DVD player.")]
    Sub GetCurrentDomain(ByRef pDomain As DVD_DOMAIN)
    [Description("Returns information sufficient to restart playback of a video from the current playback location in titles that don't explicitly disable seeking to the current location.")]
    Sub GetCurrentLocation(ByRef pLocation As DVD_PLAYBACK_LOCATION2)
    [Description("Returns the total playback time for the current title. Only works for One_Sequential_PGC_Titles.")]
    Sub GetTotalTitleTime(ByRef pTotalTime As DVD_HMSF_TIMECODE, ByRef ulTimeCodeFlags As Long)
    [Description("Indicates the number of currently available buttons and the current selected button number.")]
    Sub GetCurrentButton(ByRef pulButtonsAvailable As Long, ByRef pulCurrentButton As Long)
    [Description("Indicates the number of currently available angles and the current selected angle number. If *pulAnglesAvailable is returned as 1 then the current content is not multiangle.")]
    Sub GetCurrentAngle(ByRef pulAnglesAvailable As Long, ByRef pulCurrentAngle As Long)
    [Description("Indicates the number of currently available audio streams and the currently selected audio stream number. This only works inside the Title domain.")]
    Sub GetCurrentAudio(ByRef pulStreamsAvailable As Long, ByRef pulCurrentStream As Long)
    [Description("Indicates the number of currently available subpicture streams, the currently selected subpicture stream number, and if the subpicture display is currently disabled.")]
    Sub GetCurrentSubpicture(ByRef pulStreamsAvailable As Long, ByRef pulCurrentStream As Long, ByRef pbIsDisabled As BOOL)
    [Description("Indicates which IDVDControl methods (Annex J user operations) are currently valid. DVD titles can enable or disable individual user operations at almost any point during playback.")]
    Sub GetCurrentUOPS(ByRef pulUOPs As Long)
    [Description("Returns the current contents of all DVD System Parameter Registers.")]
    Sub GetAllSPRMs(ByRef pRegisterArray As SPRMARRAY)
    [Description("Returns the current contents of all DVD General Parameter Registers.")]
    Sub GetAllGPRMs(ByRef pRegisterArray As GPRMARRAY)
    [Description("Returns the language of the specified stream within the current title. Does not return languages for menus.")]
    Sub GetAudioLanguage(ByVal ulStream As Long, ByRef pLanguage As Long)
    [Description("Returns the language of the specified stream within the current title. Does not return languages for menus.")]
    Sub GetSubpictureLanguage(ByVal ulStream As Long, ByRef pLanguage As Long)
    [Description("Returns attributes of all video, audio, and subpicture streams for the specified title including menus. If 0xffffffff is specified as ulTitle, attributes for the current title are returned.")]
    Sub GetTitleAttributes(ByVal ulTitle As Long, ByRef pMenu As DVD_MenuAttributes, ByRef pTitle As DVD_TitleAttributes)
    [Description("Returns attributes of all video, audio, and subpicture streams for Video Manager Menus. This method suppliments GetTitleAttributes() for some menus, such as the Title menu, which are in a separate group of streams called the VMG (Video Manager) and are not associated with any particular title number.")]
    Sub GetVMGAttributes(ByRef pATR As DVD_MenuAttributes)
    [Description("Returns the video attributes for the current title or menu.")]
    Sub GetCurrentVideoAttributes(ByRef pATR As DVD_VideoAttributes)
    [Description("Returns the audio attributes for the specified stream in the current title or menu.")]
    Sub GetAudioAttributes(ByVal ulStream As Long, ByRef pATR As DVD_AudioAttributes)
    [Description("Returns the karaoke contents of each channel of the specified stream in the current title or menu.")]
    Sub GetKaraokeAttributes(ByVal ulStream As Long, ByRef pAttributes As DVD_KaraokeAttributes)
    [Description("Returns the subpicture attributes for the specified stream in the current title or menu.")]
    Sub GetSubpictureAttributes(ByVal ulStream As Long, ByRef pATR As DVD_SubpictureAttributes)
    [Description("Returns current DVD volume information.")]
    Sub GetDVDVolumeInfo(ByRef pulNumOfVolumes As Long, ByRef pulVolume As Long, ByRef pSide As DVD_DISC_SIDE, ByRef pulNumOfTitles As Long)
    [Description("Returns the number of text languages for the current DVD directory.")]
    Sub GetDVDTextNumberOfLanguages(ByRef pulNumOfLangs As Long)
    [Description("Returns the text languages information (number of strings, language code, char set) for the specified language index.")]
    Sub GetDVDTextLanguageInfo(ByVal ulLangIndex As Long, ByRef pulNumOfStrings As Long, ByRef pLangCode As Long, ByRef pbCharacterSet As DVD_TextCharSet)
    [Description("Returns the text string as an array of bytes for the specified language index.and string index.")]
    Sub GetDVDTextStringAsNative(ByVal ulLangIndex As Long, ByVal ulStringIndex As Long, ByRef pbBuffer As Byte, ByVal ulMaxBufferSize As Long, ByRef pulActualSize As Long, ByRef pType As DVD_TextStringType)
    [Description("Returns the text string in Unicode for the specified language index.and string index. Should return some error code if an invalid text or string index is specified. It also just returns the length of the string if pchBuffer is specified as NULL.")]
    Sub GetDVDTextStringAsUnicode(ByVal ulLangIndex As Long, ByVal ulStringIndex As Long, ByRef pchwBuffer As Integer, ByVal ulMaxBufferSize As Long, ByRef pulActualSize As Long, ByRef pType As DVD_TextStringType)
    [Description("Returns the current parental level and the current country/region code that has been set in the system registers in player. See Table 3.3.4-1 of the DVD-Video spec for the defined parental levels. Valid Parental Levels range from 1 to 8 if parental management is enabled. Returns 0xffffffff if parental management is disabled See ISO3166 : Alpha-2 Code for the country/region codes.")]
    Sub GetPlayerParentalLevel(ByRef pulParentalLevel As Long, ByRef pbCountryCode As Byte)
    [Description("Returns the number of chapters that are defined for a given title.")]
    Sub GetNumberOfChapters(ByVal ulTitle As Long, ByRef pulNumOfChapters As Long)
    [Description("Returns the parental levels that are defined for a particular title. pulParentalLevels will be combination of DVD_PARENTAL_LEVEL_8, DVD_PARENTAL_LEVEL_6, or DVD_PARENTAL_LEVEL_1 OR-ed together")]
    Sub GetTitleParentalLevels(ByVal ulTitle As Long, ByRef pulParentalLevels As Long)
    [Description("Returns the root directory that is set in the player. If a valid root has been found, it returns the root string. Otherwise, it returns 0 for pcbActualSize indicating that a valid root directory has not been found or initialized.")]
    Sub GetDVDDirectory(ByRef pszwPath As Integer, ByVal ulMaxSize As Long, ByRef pulActualSize As Long)
    [Description("Determines if the specified audio stream is enabled/disabled in the current PGC.")]
    Sub IsAudioStreamEnabled(ByVal ulStreamNum As Long, ByRef pbEnabled As BOOL)
    [Description("Returns a 64-bit identification number for the specified DVD disc.")]
    Sub GetDiscID(ByVal pszwPath As LongPtr, ByRef pullDiscID As LongLong)
    [Description("The navigator will create a new state object and save the current location into it. The state object can be used to restore the navigator the saved location at a later time. A new IDvdState object is created (with a single AddRef) and returned in *pStateData. The object must be Released() when the application is finished with it.")]
    Sub GetState(ByRef pStateData As IDvdState)
    [Description("Navigator gets all of the menu languages for the VMGM and VTSM domains.")]
    Sub GetMenuLanguages(ByRef pLanguages As Long, ByVal ulMaxLanguages As Long, ByRef pulActualLanguages As Long)
    [Description("Use PointToLongLong(). This is typically called in response to a mouse move within the display window. It returns the button located at the specified point within the display window. If no button is present at that position, then VFW_E_DVD_NO_BUTTON is returned. Button indices start at 1.")]
    Sub GetButtonAtPosition(ByVal point As LongLong /* POINT */, ByRef pulButtonIndex As Long)
    [Description("This method maps an EC_DVD_CMD_BEGIN/COMPLETE/CANCEL event's lParam1 into an AddRef'd IDvdCmd pointer. You must Release the returned pointer. NULL is returned if the function fails.")]
    Sub GetCmdFromEvent(ByVal lParam1 As LongPtr, ByRef pCmdObj As IDvdCmd)
    [Description("Returns the default language for menus.")]
    Sub GetDefaultMenuLanguage(ByRef pLanguage As Long)
    [Description("Gets the default audio language. Languages are specified with Windows standard LCIDs.")]
    Sub GetDefaultAudioLanguage(ByRef pLanguage As Long, ByRef pAudioExtension As DVD_AUDIO_LANG_EXT)
    [Description("Gets the default subpicture language. Languages are specified with Windows standard LCIDs.")]
    Sub GetDefaultSubpictureLanguage(ByRef pLanguage As Long, ByRef pSubpictureExtension As DVD_SUBPICTURE_LANG_EXT)
    [Description("Retrieves the DVD decoder's details about max data rate for video, audio and subpicture (going backward and forward) as well as support for various types of audio (AC3, MPEG2, DTS, SDDS, LPCM).")]
    Sub GetDecoderCaps(ByRef pCaps As DVD_DECODER_CAPS)
    [Description("Retrieves the coordinates for a given button number")]
    Sub GetButtonRect(ByVal ulButton As Long, ByRef pRect As RECT)
    [Description("Determines if the specified subpicture stream is enabled/disabled in the current PGC.")]
    Sub IsSubpictureStreamEnabled(ByVal ulStreamNum As Long, ByRef pbEnabled As BOOL)
End Interface
#End If


[InterfaceId("FCC152B6-F372-11d0-8E00-00C04FD7C08B")]
[OleAutomation(False)]
Interface IDvdGraphBuilder Extends IUnknown
    [Description("Returns the IGraphBuilder interface for the filtergraph used by the CDvdGraphBuilder object.")]
    Sub GetFiltergraph(ByRef ppGB As IGraphBuilder)
    [Description("Gets specific interface pointers in the DVD-Video playback graph to make DVD-Video playback development easier.")]
    Sub GetDvdInterface(riid As UUID, ByRef ppvIF As Any)
    [Description("Builds a filter graph according to user specs for playing back a DVD-Video volume.")]
    Sub RenderDvdVideoVolume(ByVal lpcwszPathName As LongPtr, ByVal dwFlags As AM_DVD_GRAPH_FLAGS, ByRef pStatus As AM_DVD_RENDERSTATUS)
End Interface

[InterfaceId("153ACC21-D83B-11d1-82BF-00A0C9696C8F")]
[OleAutomation(False)]
Interface IDDrawExclModeVideo Extends IUnknown
    [Description("set a ddraw object to be used by the overlay mixer. If even one of the pins of the ovmixer is connected, then it won't start using the new ddraw obect immediately but just cache it. It will start using it the next time, all its pins are disconnected.")]
    Sub SetDDrawObject(ByVal pDDrawObject As IDirectDraw)
    [Description("gets the ddraw object currently being used by the overlay mixer. If the app has not set any ddraw object and the ovmixer has not yet allocated one, then *ppDDrawObject will be set to NULL and *pbUsingExternal will be set TO FALSE. Otherwise *pbUsingExternal will be set to TRUE if the ovmixer is currently USING an app given ddraw object and FALSE othewise")]
    Sub GetDDrawObject(ByRef ppDDrawObject As IDirectDraw, ByRef pbUsingExternal As BOOL)
    [Description("set a primary surface to be used by the overlay mixer. If even one of the pins of the ovmixer is connected, then it won't start using the new primary surface immediately but just cache it. It will start using it the next time, all its pins are disconnected.")]
    Sub SetDDrawSurface(ByVal pDDrawSurface As IDirectDrawSurface)
    [Description("gets the ddraw surface currently being used by the overlay mixer. If the app has not set any ddraw surface and the ovmixer has not yet allocated one, then *ppDDrawSurface will be set to NULL and *pbUsingExternal will be set to FALSE. Otherwise *pbUsingExternal will be set to TRUE if the ovmixer is curretnly USING an app given ddraw surface and FALSE otherwise")]
    Sub GetDDrawSurface(ByRef ppDDrawSurface As IDirectDrawSurface, ByRef pbUsingExternal As BOOL)
    [Description("set draw paramters on the ovmixer (src and dest rect). Note that if the mode of the ovmixer is set to LETTER_BOX, then the ovmixer might show the video in only a subrect of *prcTarget (see IMixerPinConfig for details).")]
    Sub SetDrawParameters(ByRef prcSource As RECT, ByRef prcTarget As RECT)
    [Description("gets the current video size and picture aspect ratio of the primary stream of the overlay mixer The app should look for the evene EC_VIDEO_SIZE_AR_CHANGED and on its receipt call this function again")]
    Sub GetNativeVideoProps(ByRef pdwVideoWidth As Long, ByRef pdwVideoHeight As Long, ByRef pdwPictAspectRatioX As Long, ByRef pdwPictAspectRatioY As Long)
    [Description("Set the callback interface - the callback interface will be defined in a later release Currently returns E_NOTIMPL")]
    Sub SetCallbackInterface(ByVal pCallback As IDDrawExclModeVideoCallback, ByVal dwFlags As Long)
End Interface

[InterfaceId("913c24a0-20ab-11d2-9038-00a0c9697298")]
[OleAutomation(False)]
Interface IDDrawExclModeVideoCallback Extends IUnknown
    [Description("Called once before UpdateOverlay is called with bBefore == TRUE and once after it is called with bBefore == FALSE and otherwise identical parameters")]
    Sub OnUpdateOverlay(ByVal bBefore As BOOL, ByVal dwFlags As _AM_OVERLAY_NOTIFY_FLAGS, ByVal bOldVisible As BOOL, ByRef prcOldSrc As RECT, ByRef prcOldDest As RECT, ByVal bNewVisible As BOOL, ByRef prcNewSrc As RECT, ByRef prcNewDest As RECT)
    [Description("Called when the surface color key is changed")]
    Sub OnUpdateColorKey(ByRef pKey As COLORKEY, ByVal dwColor As Long)
    [Description("Called when the video size or aspect ratio changes")]
    Sub OnUpdateSize(ByVal dwWidth As Long, ByVal dwHeight As Long, ByVal dwARWidth As Long, ByVal dwARHeight As Long)
End Interface



'mixerocx.idl

[InterfaceId("81A3BD31-DEE1-11d1-8508-00A0C91F9CA0")]
[OleAutomation(False)]
Interface IMixerOCXNotify Extends IUnknown
    Sub OnInvalidateRect(lpcRect As RECT)
    Sub OnStatusChange(ByVal ulStatusFlags As MixerOcxStatusFlags)
    Sub OnDataChange(ByVal ulDataFlags As MixerOcxDataFlags)
End Interface

[InterfaceId("81A3BD32-DEE1-11d1-8508-00A0C91F9CA0")]
[OleAutomation(False)]
Interface IMixerOCX Extends IUnknown
    Sub OnDisplayChange(ByVal ulBitsPerPixel As Long, ByVal ulScreenWidth As Long, ByVal ulScreenHeight As Long)
    Sub GetAspectRatio(ByRef pdwPictAspectRatioX As Long, ByRef pdwPictAspectRatioY As Long)
    Sub GetVideoSize(ByRef pdwVideoWidth As Long, ByRef pdwVideoHeight As Long)
    Sub GetStatus(ByRef pdwStatus As Long)
    Sub OnDraw(ByVal hdcDraw As LongPtr, ByRef prcDraw As RECT)
    Sub SetDrawRegion(ByRef lpptTopLeftSC As POINT, ByRef prcDrawCC As RECT, ByRef lprcClip As RECT)
    Sub Advise(ByVal pmdns As IMixerOCXNotify)
    Sub UnAdvise()
End Interface


#If WDL_QUALIFY Then
[MustBeQualified]
#End If
Module wdDirectShow
    


Public Const sCLSID_FilgraphManager = "new: {E436EBB3-524F-11CE-9F53-0020AF0BA770}"
Public Const sCLSID_VideoMixingRenderer9 = "new: {51B4ABF3-748F-4E3B-A276-C828330E926A}"
Public Const sCLSID_VideoMixingRenderer = "new: {B87BEB7B-8D29-423F-AE4D-6582C10175AC}"
Public Const sCLSID_WAVEParser = "new: {D51BD5A1-7548-11CF-A520-0080C77EF58A}"
Public Const sCLSID_ACMWrapper = "new: {6A08CF80-0E18-11CF-A24D-0020AFD79767}"
Public Const sCLSID_VideoRendererDefault = "new: {6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50}"
Public Const sCLSID_VideoRenderer = "new: {70E102B0-5556-11CE-97C0-00AA0055595A}"
Public Const sCLSID_NullRenderer = "new: {C1F400A4-3F08-11D3-9F0B-006008039E37}"
Public Const sCLSID_AudioRender = "new: {E30629D1-27E5-11CE-875D-00608CB78066}"
Public Const sCLSID_DSoundRender = "new: {79376820-07D0-11CF-A24D-0020AFD79767}"
Public Const sCLSID_AVIDec = "new: {CF49D4E0-1115-11CE-B03A-0020AF0BA770}"
Public Const sCLSID_MPEG1Splitter = "new: {336475D0-942A-11CE-A870-00AA002FEAB5}"
Public Const sCLSID_AVISplitter = "new: {1B544C20-FD0B-11CE-8C63-00AA0044B51E}"
Public Const sCLSID_AsyncReader = "new: {E436EBB5-524F-11CE-9F53-0020AF0BA770}"
Public Const sCLSID_SampleGrabber = "new: {C1F400A0-3F08-11D3-9F0B-006008039E37}"

 
Public Function CLSID_AMDirectDrawStream() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H49c47ce4, &H9ba4, &H11d0, &H82, &H12, &H00, &Hc0, &H4f, &Hc3, &H2c, &H45)
CLSID_AMDirectDrawStream = iid
End Function
Public Function CLSID_AMAudioStream() As UUID
'{8496E040-AF4C-11D0-8212-00C04FC32C45}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H8496E040, CInt(&HAF4C), CInt(&H11D0), &H82, &H12, &H00, &HC0, &H4F, &HC3, &H2C, &H45)
 CLSID_AMAudioStream = iid
End Function
Public Function CLSID_AMAudioData() As UUID
'{F2468580-AF8A-11D0-8212-00C04FC32C45}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HF2468580, CInt(&HAF8A), CInt(&H11D0), &H82, &H12, &H00, &HC0, &H4F, &HC3, &H2C, &H45)
 CLSID_AMAudioData = iid
End Function
Public Function CLSID_AMMediaTypeStream() As UUID
'{CF0F2F7C-F7BF-11D0-900D-00C04FD9189D}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCF0F2F7C, CInt(&HF7BF), CInt(&H11D0), &H90, &H0D, &H00, &HC0, &H4F, &HD9, &H18, &H9D)
 CLSID_AMMediaTypeStream = iid
End Function
Public Function CLSID_SampleGrabber() As UUID
'{C1F400A0-3F08-11D3-9F0B-006008039E37}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HC1F400A0, CInt(&H3F08), CInt(&H11D3), &H9F, &H0B, &H00, &H60, &H08, &H03, &H9E, &H37)
 CLSID_SampleGrabber = iid
End Function
Public Function CLSID_AVISplitter() As UUID
'{1B544C20-FD0B-11CE-8C63-00AA0044B51E}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1B544C20, CInt(&HFD0B), CInt(&H11CE), &H8C, &H63, &H00, &HAA, &H00, &H44, &HB5, &H1E)
 CLSID_AVISplitter = iid
End Function
Public Function CLSID_NullRenderer() As UUID
'{C1F400A4-3F08-11D3-9F0B-006008039E37}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HC1F400A4, CInt(&H3F08), CInt(&H11D3), &H9F, &H0B, &H00, &H60, &H08, &H03, &H9E, &H37)
 CLSID_NullRenderer = iid
End Function
Public Function CLSID_WAVEParser() As UUID
'{D51BD5A1-7548-11CF-A520-0080C77EF58A}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD51BD5A1, CInt(&H7548), CInt(&H11CF), &HA5, &H20, &H00, &H80, &HC7, &H7E, &HF5, &H8A)
 CLSID_WAVEParser = iid
End Function
Public Function CLSID_VideoRendererDefault() As UUID
'{6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6BC1CFFA, CInt(&H8FC1), CInt(&H4261), &HAC, &H22, &HCF, &HB4, &HCC, &H38, &HDB, &H50)
 CLSID_VideoRendererDefault = iid
End Function
Public Enum OABOOL
            OATRUE = -1
            OAFALSE = 0
End Enum

Public Enum EC_CODES
    EC_SYSTEMBASE = &H00
    EC_USER = &H8000&
'  System-defined event codes
'  ==========================
'  There are three types of system-defined event codes:
'  1.  Those which are always passed through to the application
'      (To be collected by calls to GetEvent or within WaitForCompletion.)
'      (e.g. EC_ERRORABORT, EC_USERABORT.)
'  2.  Those which are pure internal and will never be passed to
'      the application.  (e.g. EC_SHUTDOWN)
'  3.  Those which have default handling.  Default handing implies that
'      the event is not passed to the application.  However, default
'      handling may be canceled by calling
'      IMediaEvent::CancelDefaultHandling.  If the default handling is
'      cancelled in this way, then the message will be delivered to the
'      application and the application must action it appropriately.
'      Default handling can be restored by calling RestoreDefaultHandling.
'  We will refer to these events as application, internal and defaulted
'  events respectively.
'  System-defined events may have interface pointers, BSTR's, etc passed
'  as parameters.  It is therefore essential that, for any message
'  retrieved using GetEvent, a matching call to FreeEventParams is made
'  to ensure that relevant interfaces are released and storage freed.
'  Failure to call FreeEventParams will result in memory leaks, if not
'  worse.
'  Filters sending these messages to the filter graph should not AddRef()
'  any interfaces that they may pass as parameters.  The filter graph
'  manager will AddRef them if required.  E.g. if the event is to be queued
'  for the application or queued to a worker thread.
'  Each event listed below is immediately followed by a parameter list
'  detailing the types of the parameters associated with the message,
'  and an indication of whether the message is an application, internal
'  or defaulted message.  This is then followed by a short description.
'  The use of "void" in the parameter list implies that the parameter is not
'  used.  Such parameters should be zero.
'  Other defined EC_ regions:
'  DVD event codes              0x0100 - 0x0150 (dvdevcod.h)
'  audio device event codes     0x0200 - 0x0250 (audevcod.h)
'  WindowsMedia SDK-originated events 0x0251 - 0x0300 (see below)
'  MSVIDCTL                     0x0301 - 0x0325 (msvidctl.idl)
'  stream buffer engine (PVR)   0x0326 - 0x0350 (sbe.idl)
    EC_COMPLETE = &H01
'  ( HRESULT, void ) : defaulted (special)
'  Signals the completed playback of a stream within the graph.  This message
'  is sent by renderers when they receive end-of-stream.  The default handling
'  of this message results in a _SINGLE_ EC_COMPLETE being sent to the
'  application when ALL of the individual renderers have signaled EC_COMPLETE
'  to the filter graph.  If the default handing is canceled, the application
'  will see all of the individual EC_COMPLETEs.
    EC_USERABORT = &H02
'  ( void, void ) : application
'  In some sense, the user has requested that playback be terminated.
'  This message is typically sent by renderers that render into a
'  window if the user closes the window into which it was rendering.
'  It is up to the application to decide if playback should actually
'  be stopped.
    EC_ERRORABORT = &H03
'  ( HRESULT, void ) : application
'  Operation aborted because of error
    EC_TIME = &H04
'  ( DWORD, DWORD ) : application
'  The requested reference time occurred.  (This event is currently not used).
'  lParam1 is low dword of ref time, lParam2 is high dword of reftime.
    EC_REPAINT = &H05
'  ( IPin * (could be NULL), void ) : defaulted
'  A repaint is required - lParam1 contains the (IPin *) that needs the data
'  to be sent again. Default handling is: if the output pin which the IPin is
'  attached  to supports the IMediaEventSink interface then it will be called
'  with the EC_REPAINT first.  If that fails then normal repaint processing is
'  done by the filter graph.
'  Stream error notifications
    EC_STREAM_ERROR_STOPPED = &H06
    EC_STREAM_ERROR_STILLPLAYING = &H07
'  ( HRESULT, DWORD ) : application
'  lParam 1 is major code, lParam2 is minor code, either may be zero.
    EC_ERROR_STILLPLAYING = &H08
'  ( HRESULT, void ) : application
'  The filter graph manager may issue Run's to the graph asynchronously.
'  If such a Run fails, EC_ERROR_STILLPLAYING is issued to notify the
'  application of the failure.  The state of the underlying filters
'  at such a time will be indeterminate - they will all have been asked
'  to run, but some are almost certainly not.
    EC_PALETTE_CHANGED = &H09
'  ( void, void ) : application
'  notify application that the video palette has changed
    EC_VIDEO_SIZE_CHANGED = &H0A
'  ( DWORD, void ) : application
'  Sent by video renderers.
'  Notifies the application that the native video size has changed.
'  LOWORD of the DWORD is the new width, HIWORD is the new height.
    EC_QUALITY_CHANGE = &H0B
'  ( void, void ) : application
'  Notify application that playback degradation has occurred
    EC_SHUTTING_DOWN = &H0C
'  ( void, void ) : internal
'  This message is sent by the filter graph manager to any plug-in
'  distributors which support IMediaEventSink to notify them that
'  the filter graph is starting to shutdown.
    EC_CLOCK_CHANGED = &H0D
'  ( void, void ) : application
'  Notify application that the clock has changed.
'  (i.e. SetSyncSource has been called on the filter graph and has been
'  distributed successfully to the filters in the graph.)
    EC_PAUSED = &H0E
'  ( HRESULT, void ) : application
'  Notify application the previous pause request has completed
    EC_OPENING_FILE = &H10
    EC_BUFFERING_DATA = &H11
'  ( BOOL, void ) : application
'  lParam1 == 1   --> starting to open file or buffer data
'  lParam1 == 0   --> not opening or buffering any more
'  (This event does not appear to be used by ActiveMovie.)
    EC_FULLSCREEN_LOST = &H12
'  ( void, IBaseFilter * ) : application
'  Sent by full screen renderers when switched away from full screen.
'  IBaseFilter may be NULL.
    EC_ACTIVATE = &H13
'  ( BOOL, IBaseFilter * ) : internal
'  Sent by video renderers when they lose or gain activation.
'  lParam1 is set to 1 if gained or 0 if lost
'  lParam2 is the IBaseFilter* for the filter that is sending the message
'  Used for sound follows focus and full-screen switching
    EC_NEED_RESTART = &H14
'  ( void, void ) : defaulted
'  Sent by renderers when they regain a resource (e.g. audio renderer).
'  Causes a restart by Pause/put_Current/Run (if running).
    EC_WINDOW_DESTROYED = &H15
'  ( IBaseFilter *, void ) : internal
'  Sent by video renderers when the window has been destroyed. Handled
'  by the filter graph / distributor telling the resource manager.
'  lParam1 is the IBaseFilter* of the filter whose window is being destroyed
    EC_DISPLAY_CHANGED = &H16
'  ( IPin *, void ) : internal
'  Sent by renderers when they detect a display change. the filter graph
'  will arrange for the graph to be stopped and the pin send in lParam1
'  to be reconnected. by being reconnected it allows a renderer to reset
'  and connect with a more appropriate format for the new display mode
'  lParam1 contains an (IPin *) that should be reconnected by the graph
    EC_STARVATION = &H17
'  ( void, void ) : defaulted
'  Sent by a filter when it detects starvation. Default handling (only when
'  running) is for the graph to be paused until all filters enter the
'  paused state and then run. Normally this would be sent by a parser or source
'  filter when too little data is arriving.
    EC_OLE_EVENT = &H18
'  ( BSTR, BSTR ) : application
'  Sent by a filter to pass a text string to the application.
'  Conventionally, the first string is a type, and the second a parameter.
    EC_NOTIFY_WINDOW = &H19
'  ( HWND, void ) : internal
'  Pass the window handle around during pin connection.
    EC_STREAM_CONTROL_STOPPED = &H1A
'  ( IPin * pSender, DWORD dwCookie )
'  Notification that an earlier call to IAMStreamControl::StopAt
'  has now take effect.  Calls to the method can be marked
'  with a cookie which is passed back in the second parameter,
'  allowing applications to easily tie together request
'  and completion notifications.
'  NB: IPin will point to the pin that actioned the Stop.  This
'  may not be the pin that the StopAt was sent to.
    EC_STREAM_CONTROL_STARTED = &H1B
'  ( IPin * pSender, DWORD dwCookie )
'  Notification that an earlier call to IAMStreamControl::StartAt
'  has now take effect.  Calls to the method can be marked
'  with a cookie which is passed back in the second parameter,
'  allowing applications to easily tie together request
'  and completion notifications.
'  NB: IPin will point to the pin that actioned the Start.  This
'  may not be the pin that the StartAt was sent to.
    EC_END_OF_SEGMENT = &H1C
'  ( const REFERENCE_TIME *pStreamTimeAtEndOfSegment, DWORD dwSegmentNumber )
'  pStreamTimeAtEndOfSegment
'      pointer to the accumulated stream clock
'      time since the start of the segment - this is directly computable
'      as the sum of the previous and current segment durations (Stop - Start)
'      and the rate applied to each segment
'      The source add this time to the time within each segment to get
'      a total elapsed time
'  dwSegmentNumber
'      Segment number - starts at 0
'  Notifies that a segment end has been reached when the
'  AM_SEEKING_Segment flags was set for IMediaSeeking::SetPositions
'  Passes in an IMediaSeeking interface to allow the next segment
'  to be defined by the application
    EC_SEGMENT_STARTED = &H1D
'  ( const REFERENCE_TIME *pStreamTimeAtStartOfSegment, DWORD dwSegmentNumber)
'  pStreamTimeAtStartOfSegment
'      pointer to the accumulated stream clock
'      time since the start of the segment - this is directly computable
'      as the sum of the previous segment durations (Stop - Start)
'      and the rate applied to each segment
'  dwSegmentNumber
'      Segment number - starts at 0
'  Notifies that a new segment has been started.
'  This is sent synchronously by any entity that will issue
'  EC_END_OF_SEGMENT when a new segment is started
'  (See IMediaSeeking::SetPositions - AM_SEEKING_Segment flag)
'  It is used to compute how many EC_END_OF_SEGMENT notifications
'  to expect at the end of a segment and as a consitency check
    EC_LENGTH_CHANGED = &H1E
'  (void, void)
'  sent to indicate that the length of the "file" has changed
    EC_DEVICE_LOST = &H1f
'  (IUnknown, 0)
'  request window notification when the device is available again
'  (through WM_DEVICECHANGED messages registered with
'  RegisterDeviceNotification; see IAMDeviceRemoval interface)
    EC_SAMPLE_NEEDED = &H20
'  (PinID, 0)
'  Indication that a sample is needed on the specified input pin
'  of the filter in order to produce a new sample on the output.
    EC_PROCESSING_LATENCY = &H21
'  (const REFERENCE_TIME *pLatency, 0)
'  Indication that the firing component is currently taking the specified
'  amount of time to process a sample.
    EC_SAMPLE_LATENCY = &H22
'  (const REFERENCE_TIME *pLatency, 0)
'  Indication that the firing component is that amount of time behind in
'  processing samples coming in. A negative time indicates that the component
'  is running ahead of schedule.
    EC_SCRUB_TIME = &H23
'  (DWORD, DWORD)
'  To be sent immediately after the EC_STEP_COMPLETE notification
'  when a step completes and the rate is 0.
'  This is the timestamp of the frame that was displayed.
'  lParam1 is the low DWORD of the time; lParam2 is the high DWORD
    EC_STEP_COMPLETE = &H24
'  (BOOL bCancelled, void)
'  Step request complete
'  if bCancelled is TRUE the step was cancelled.  This can happen
'  if the application issued some control request or because there
'  was a mode change etc etc
'  Event code 25 is reserved for future use.
    EC_TIMECODE_AVAILABLE = &H30
'  Sent by filter supporting timecode
'  Param1 has a pointer to the sending object
'  Param2 has the device ID of the sending object
    EC_EXTDEVICE_MODE_CHANGE = &H31
'  Sent by filter supporting IAMExtDevice
'  Param1 has the new mode
'  Param2 has the device ID of the sending object
    EC_STATE_CHANGE = &H32
'  ( FILTER_STATE, BOOL bInternal)
'  Used to notify the application of any state changes in the filter graph.
'  lParam1  is of type enum FILTER_STATE (defined in strmif.h) and indicates
'           the state of the filter graph.
'  lParam2 == 0 indicates that the previous state change request has completed
'               & a change in application state.
'  lParam2 == 1 reserved for future use to indicate internal state changes.
    EC_GRAPH_CHANGED = &H50
'  Sent by filter to notify interesting graph changes
    EC_CLOCK_UNSET = &H51
'  ( void, void ) : application
'  Used to notify the filter graph to unset the current graph clock.
'  Has the affect of forcing the filter graph to reestablish the graph clock
'  on the next Pause/Run (note that this is only used by ksproxy, when the pin
'  of a clock providing filter is disconnected)
    EC_VMR_RENDERDEVICE_SET = &H53
'  (Render_Device type, void)
'  Identifies the type of rendering mechanism the VMR
'  is using to display video.  Types used include:
    ' VMR_RENDER_DEVICE_OVERLAY = &H01
    ' VMR_RENDER_DEVICE_VIDMEM = &H02
    ' VMR_RENDER_DEVICE_SYSMEM = &H04
    EC_VMR_SURFACE_FLIPPED = &H54
'  (hr - Flip return code, void)
'  Identifies the VMR's allocator-presenter has called the DDraw flip api on
'  the surface being presented.   This allows the VMR to keep its DX-VA table
'  of DDraw surfaces in sync with DDraws flipping chain.
    EC_VMR_RECONNECTION_FAILED = &H55
'  (hr - ReceiveConnection return code, void)
'  Identifies that an upstream decoder tried to perform a dynamic format
'  change and the VMR was unable to accept the new format.
    EC_PREPROCESS_COMPLETE = &H56
'  Sent by the WM ASF writer filter (WMSDK V9 version) to signal the completion
'  of a pre-process run when running in multipass encode mode.
'  Param1 = 0, Param2 = IBaseFilter ptr of sending filter
    EC_CODECAPI_EVENT = &H57
'  Sent by the Codec API when an event is encountered.  Both the Data
'  must be freed by the recipient using CoTaskMemFree
'  Param1 = UserDataPointer, Param2 = VOID* Data
    EC_WMT_EVENT_BASE = &H0251
    EC_WMT_INDEX_EVENT = EC_WMT_EVENT_BASE
'  WindowsMedia SDK-originated file indexing status, sent by WMSDK-based filters
'  lParam1 is one of the enum WMT_STATUS messages listed below, sent by the WindowsMedia SDK
'  lParam2 is specific to the lParam event
'      the following WMT_STATUS messages are sent for this event:
'          WMT_STARTED        - lParam2 is 0
'          WMT_CLOSED         - lParam2 is 0
'          WMT_INDEX_PROGRESS - lParam2 is a DWORD containing the progress percent complete
    EC_WMT_EVENT = EC_WMT_EVENT_BASE + 1
'  WindowsMedia SDK-originated event, sent by WMSDK-based filters
'  lParam1 is one of the enum WMT_STATUS messages listed below, sent by the WindowsMedia SDK
'  lParam2 is a pointer an AM_WMT_EVENT_DATA structure where,
'                           hrStatus is the status code sent by the wmsdk
'                           pData is specific to the lParam1 event
'      the following WMT_STATUS messages are sent by the WMSDK Reader filter for this event:
'          WMT_NO_RIGHTS        - pData is a pointer to a WCHAR string containing a challenge URL
'          WMT_ACQUIRE_LICENSE  - lParam2 is a pointer to a WM_GET_LICENSE_DATA struct
'          WMT_NO_RIGHTS_EX     - lParam2 is a pointer to a WM_GET_LICENSE_DATA struct
'          WMT_NEEDS_INDIVIDUALIZATION - lParam2 is NULL
'          WMT_INDIVIDUALIZE    - lParam2 is a pointer to a WM_INDIVIDUALIZE_STATUS struct
'      the WMSDK (V9) ASF Writer filter will send this event in response to a wmsdk-signaled error during file
'          writing, along with the wmsdk WMT_STATUS error as the lParam1 and hrStatus embedded in the
'          AM_WMT_EVENT_DATA struct pointed to by the lParam2 pointer.
'  end WMSDK-originated events
' -----------------------------------------
    EC_BUILT = &H300
'  Sent to notify transition from unbuilt to built state
    EC_UNBUILT = &H301
'  Sent to notify transtion from built to unbuilt state
' -------------------------------------------------------------------------------------------------
'    Other miscellaneous events used by various componnents
'    Published here to assist debugging
' -------------------------------------------------------------------------------------------------
    EC_SKIP_FRAMES = &H25
'  ( nFramesToSkip, IFrameSkipResultCallback)
'  Get the filter graph to skip nFramesToSkip and notify.
    EC_PLEASE_REOPEN = &H40
'  (void, void) : application
'  Something has changed enough that the graph should be re-rendered.
    EC_STATUS = &H41
'  ( BSTR, BSTR) : application
'  Two arbitrary strings, a short one and a long one.
    EC_MARKER_HIT = &H42
'  (int, void) : application
'  The specified "marker #" has just been passed
    EC_LOADSTATUS = &H43
'  (int, void) : application
'  Sent when various points during the loading of a network file are reached
    EC_FILE_CLOSED = &H44
'  (void, void) : application
'  Sent when the file is involuntarily closed, i.e. by a network server shutdown
    EC_ERRORABORTEX = &H45
'  ( HRESULT, BSTR ) : application
'  Operation aborted because of error.  Additional information available.
    EC_NEW_PIN = &H20
    EC_RENDER_FINISHED = &H21
    EC_EOS_SOON = &H046
'  (void, void) : application
'  sent when the source filter is about to deliver an EOS downstream....
    EC_CONTENTPROPERTY_CHANGED = &H47
'  (ULONG, void)
'  Sent when a streaming media filter recieves a change in stream description information.
'  the UI is expected to re-query for the changed property in response 
    EC_BANDWIDTHCHANGE = &H48
 
    EC_VIDEOFRAMEREADY = &H49
'  (void, void) : application
'  sent to notify the application that the first video frame is about to be drawn
End Enum

Public Enum DShowCreateDevEnumFlags
    CDEF_CLASS_DEFAULT = &H0001
    CDEF_BYPASS_CLASS_MANAGER = &H0002
    CDEF_MERIT_ABOVE_DO_NOT_USE = &H0008
    CDEF_DEVMON_CMGR_DEVICE = &H0010
    CDEF_DEVMON_DMO = &H0020
    CDEF_DEVMON_PNP_DEVICE = &H0040
    CDEF_DEVMON_FILTER = &H0080
    CDEF_DEVMON_SELECTIVE_MASK = &H00f0
End Enum

Public Enum VMR_RENDER_DEVICE_TYPE
    VMR_RENDER_DEVICE_OVERLAY = 1
    VMR_RENDER_DEVICE_VIDMEM = 2
    VMR_RENDER_DEVICE_SYSMEM = 4
End Enum

Public Enum AM_LOADSTATUS
    AM_LOADSTATUS_CLOSED = 0
    AM_LOADSTATUS_LOADINGDESCR = 1
    AM_LOADSTATUS_LOADINGMCAST = 2
    AM_LOADSTATUS_LOCATING = 3
    AM_LOADSTATUS_CONNECTING = 4
    AM_LOADSTATUS_OPENING = 5
    AM_LOADSTATUS_OPEN = 6
End Enum

Public Enum AM_CONTENTPROPERTY
    AM_CONTENTPROPERTY_TITLE = 1
    AM_CONTENTPROPERTY_AUTHOR = 2
    AM_CONTENTPROPERTY_COPYRIGHT = 4
    AM_CONTENTPROPERTY_DESCRIPTION = 8
End Enum

Public Type AM_WMT_EVENT_DATA
    hrStatus As Long
    pData As LongPtr
End Type

Public Enum AMExtendedSeekingCapabilities
    None = 0
    CanSeek = 1
    CanScan = 2
    MarkerSeek = 4
    ScanWithoutClock = 8
    NoStandardRepaint = 16
    Buffering = 32
    SendsVideoFrameReady = 64
End Enum

Public Type ALLOCATOR_PROPERTIES
    cBuffers As Long
    cbBuffer As Long
    cbAlign As Long
    cbPrefix As Long
End Type
Public Enum AM_STREAM_INFO_FLAGS
    AM_STREAM_INFO_START_DEFINED = &H00000001
    AM_STREAM_INFO_STOP_DEFINED = &H00000002
    AM_STREAM_INFO_DISCARDING = &H00000004
    AM_STREAM_INFO_STOP_SEND_EXTRA = &H00000010
End Enum
Public Type AM_STREAM_INFO
    tStart As LongLong 'REFERENCE_TIME
    tStop As LongLong 'REFERENCE_TIME
    dwStartCookie As Long
    dwStopCookie As Long
    dwFlags As Long
End Type

Public Type VIDEO_STREAM_CONFIG_CAPS
    guid As UUID
    VideoStandard As Long
    InputSize As SIZE
    MinCroppingSize As SIZE
    MaxCroppingSize As SIZE
    CropGranularityX As Long
    CropGranularityY As Long
    CropAlignX As Long
    CropAlignY As Long
    MinOutputSize As SIZE
    MaxOutputSize As SIZE
    OutputGranularityX As Long
    OutputGranularityY As Long
    StretchTapsX As Long
    StretchTapsY As Long
    ShrinkTapsX As Long
    ShrinkTapsY As Long
    MinFrameInterval As LongLong
    MaxFrameInterval As LongLong
    MinBitsPerSecond As Long
    MaxBitsPerSecond As Long
End Type
Public Type AUDIO_STREAM_CONFIG_CAPS
    guid As UUID
    MinimumChannels As Long
    MaximumChannels As Long
    ChannelsGranularity As Long
    MinimumBitsPerSample As Long
    MaximumBitsPerSample As Long
    BitsPerSampleGranularity As Long
    MinimumSampleFrequency As Long
    MaximumSampleFrequency As Long
    SampleFrequencyGranularity As Long
End Type

Public Enum InterleavingMode
    '  uninterleaved - samples written out in the order they
    '  arrive.
    INTERLEAVE_NONE
    '  approximate interleaving with less overhead for video
    '  capture
    INTERLEAVE_CAPTURE
    '  full, precise interleaving. slower.
    INTERLEAVE_FULL
    '  samples written out in the order they arrive. writes are
    '  buffered
    INTERLEAVE_NONE_BUFFERED
End Enum

Public Enum CompressionCaps
    CompressionCaps_CanQuality = &H01
    CompressionCaps_CanCrunch = &H02
    CompressionCaps_CanKeyFrame = &H04
    CompressionCaps_CanBFrame = &H08
    CompressionCaps_CanWindow = &H10
End Enum

Public Enum VfwCaptureDialogs
    VfwCaptureDialog_Source = &H1
    VfwCaptureDialog_Format = &H2
    VfwCaptureDialog_Display = &H4
End Enum

Public Enum VfwCompressDialogs
    VfwCompressDialog_Config = &H1
    VfwCompressDialog_About = &H2
    VfwCompressDialog_QueryConfig = &H4
    VfwCompressDialog_QueryAbout = &H8
End Enum

Public Enum AnalogVideoStandard
    AnalogVideo_None = &H00000000 ' This is a digital sensor
    AnalogVideo_NTSC_M = &H00000001 '        75 IRE Setup
    AnalogVideo_NTSC_M_J = &H00000002 ' Japan,  0 IRE Setup
    AnalogVideo_NTSC_433 = &H00000004
    AnalogVideo_PAL_B = &H00000010
    AnalogVideo_PAL_D = &H00000020
    AnalogVideo_PAL_G = &H00000040
    AnalogVideo_PAL_H = &H00000080
    AnalogVideo_PAL_I = &H00000100
    AnalogVideo_PAL_M = &H00000200
    AnalogVideo_PAL_N = &H00000400
    AnalogVideo_PAL_60 = &H00000800
    AnalogVideo_SECAM_B = &H00001000
    AnalogVideo_SECAM_D = &H00002000
    AnalogVideo_SECAM_G = &H00004000
    AnalogVideo_SECAM_H = &H00008000&
    AnalogVideo_SECAM_K = &H00010000
    AnalogVideo_SECAM_K1 = &H00020000
    AnalogVideo_SECAM_L = &H00040000
    AnalogVideo_SECAM_L1 = &H00080000
    AnalogVideo_PAL_N_COMBO = &H00100000 ' Argentina
    AnalogVideoMask_MCE_NTSC = AnalogVideo_NTSC_M Or AnalogVideo_NTSC_M_J Or AnalogVideo_NTSC_433 Or AnalogVideo_PAL_M Or AnalogVideo_PAL_N Or AnalogVideo_PAL_60 Or AnalogVideo_PAL_N_COMBO
    AnalogVideoMask_MCE_PAL = AnalogVideo_PAL_B Or AnalogVideo_PAL_D Or AnalogVideo_PAL_G Or AnalogVideo_PAL_H Or AnalogVideo_PAL_I
    AnalogVideoMask_MCE_SECAM = AnalogVideo_SECAM_B Or AnalogVideo_SECAM_D Or AnalogVideo_SECAM_G Or AnalogVideo_SECAM_H Or AnalogVideo_SECAM_K Or AnalogVideo_SECAM_K1 Or AnalogVideo_SECAM_L Or AnalogVideo_SECAM_L1
    AnalogVideo_NTSC_Mask = &H00000007
    AnalogVideo_PAL_Mask = &H00100FF0
    AnalogVideo_SECAM_Mask = &H000FF000
End Enum

Public Enum TunerInputType
    TunerInputCable = 0
    TunerInputAntenna = 1
End Enum

Public Enum VideoCopyProtectionType
    VideoCopyProtectionMacrovisionBasic
    VideoCopyProtectionMacrovisionCBI
End Enum

Public Enum PhysicalConnectorType
    PhysConn_Video_Tuner = 1
    PhysConn_Video_Composite
    PhysConn_Video_SVideo
    PhysConn_Video_RGB
    PhysConn_Video_YRYBY
    PhysConn_Video_SerialDigital
    PhysConn_Video_ParallelDigital
    PhysConn_Video_SCSI
    PhysConn_Video_AUX
    PhysConn_Video_1394
    PhysConn_Video_USB
    PhysConn_Video_VideoDecoder
    PhysConn_Video_VideoEncoder
    PhysConn_Video_SCART
    PhysConn_Video_Black


    PhysConn_Audio_Tuner = &H1000
    PhysConn_Audio_Line
    PhysConn_Audio_Mic
    PhysConn_Audio_AESDigital
    PhysConn_Audio_SPDIFDigital
    PhysConn_Audio_SCSI
    PhysConn_Audio_AUX
    PhysConn_Audio_1394
    PhysConn_Audio_USB
    PhysConn_Audio_AudioDecoder
End Enum


Public Const AMF_AUTOMATICGAIN As Single = -1.0

Public Enum VideoProcAmpProperty
    VideoProcAmp_Brightness = 0
    VideoProcAmp_Contrast = 1
    VideoProcAmp_Hue = 2
    VideoProcAmp_Saturation = 3
    VideoProcAmp_Sharpness = 4
    VideoProcAmp_Gamma = 5
    VideoProcAmp_ColorEnable = 6
    VideoProcAmp_WhiteBalance = 7
    VideoProcAmp_BacklightCompensation = 8
    VideoProcAmp_Gain = 9
End Enum

Public Enum VideoProcAmpFlags
    VideoProcAmp_Flags_Auto = &H0001
    VideoProcAmp_Flags_Manual = &H0002
End Enum

Public Enum CameraControlProperty
    CameraControl_Pan
    CameraControl_Tilt
    CameraControl_Roll
    CameraControl_Zoom
    CameraControl_Exposure
    CameraControl_Iris
    CameraControl_Focus
End Enum

Public Enum CameraControlFlags
    CameraControl_Flags_Auto = &H0001
    CameraControl_Flags_Manual = &H0002
End Enum

Public Enum VideoControlFlags
    VideoControlFlag_FlipHorizontal = &H0001
    VideoControlFlag_FlipVertical = &H0002
    VideoControlFlag_ExternalTriggerEnable = &H0004
    VideoControlFlag_Trigger = &H0008
End Enum

Public Enum TVAudioMode
    AMTVAUDIO_MODE_MONO = &H0001 ' Mono
    AMTVAUDIO_MODE_STEREO = &H0002 ' Stereo
    AMTVAUDIO_MODE_LANG_A = &H0010 ' Primary language
    AMTVAUDIO_MODE_LANG_B = &H0020 ' 2nd avail language
    AMTVAUDIO_MODE_LANG_C = &H0040 ' 3rd avail language
    AMTVAUDIO_PRESET_STEREO = &H0200 ' is present, stereo
    AMTVAUDIO_PRESET_LANG_A = &H1000 ' if present, Language A
    AMTVAUDIO_PRESET_LANG_B = &H2000 ' if present, Language B
    AMTVAUDIO_PRESET_LANG_C = &H4000 ' if present, Language C
End Enum

Public Enum AMTVAudioEventType
    AMTVAUDIO_EVENT_CHANGED = &H0001 ' mode changed
End Enum




Public Enum AM_SEEKING_SEEKING_FLAGS
    AM_SEEKING_NoPositioning = 0
    AM_SEEKING_AbsolutePositioning = &H1
    AM_SEEKING_RelativePositioning = &H2
    AM_SEEKING_IncrementalPositioning = &H3
    AM_SEEKING_PositioningBitsMask = &H3
    AM_SEEKING_SeekToKeyFrame = &H4
    AM_SEEKING_ReturnTime = &H8
    AM_SEEKING_Segment = &H10
    AM_SEEKING_NoFlush = &H20
End Enum
Public Enum AM_SEEKING_SEEKING_CAPABILITIES
    AM_SEEKING_CanSeekAbsolute = &H1
    AM_SEEKING_CanSeekForwards = &H2
    AM_SEEKING_CanSeekBackwards = &H4
    AM_SEEKING_CanGetCurrentPos = &H8
    AM_SEEKING_CanGetStopPos = &H10
    AM_SEEKING_CanGetDuration = &H20
    AM_SEEKING_CanPlayBackwards = &H40
    AM_SEEKING_CanDoSegments = &H80
    AM_SEEKING_Source = &H100
End Enum

Public Enum AM_MEDIAEVENT_FLAGS
    AM_MEDIAEVENT_NONOTIFY = &H01
End Enum

Public Type CodecAPIEventData
    guid As UUID
    dataLength As Long
    reserved(0 To 2) As Long
End Type

Public Type REGFILTER
    Clsid As UUID
    Name As LongPtr
End Type

Public Enum DShowFilterMapperMeritFlags
    MERIT_PREFERRED = &H800000
    MERIT_NORMAL = &H600000
    MERIT_UNLIKELY = &H400000
    MERIT_DO_NOT_USE = &H200000
    MERIT_SW_COMPRESSOR = &H100000
    MERIT_HW_COMPRESSOR = &H100050
End Enum

Public Type REGPINTYPES
    clsMajorType As LongPtr 'const CLSID*
    clsMinorType As LongPtr 'const CLSID*
End Type

Public Type REGFILTERPINS
    strName As LongPtr
    bRendered As BOOL
    bOutput As BOOL
    bZero As BOOL
    bMany As BOOL
    clsConnectsToFilter As LongPtr 'const CLSID*
    strConnectsToPin As LongPtr 'const WCHAR*
    nMediaTypes As Long
    lpMediaType As LongPtr 'const REGPINTYPES *
End Type

Public Type REGPINMEDIUM
    clsMedium As UUID
    dw1 As Long
    dw2 As Long
End Type

Public Enum DShowRegPinFlags
    REG_PINFLAG_B_ZERO = &H1
    REG_PINFLAG_B_RENDERER = &H2
    REG_PINFLAG_B_MANY = &H4
    REG_PINFLAG_B_OUTPUT = &H8
End Enum

Public Type REGFILTERPINS2
    dwFlags As DShowRegPinFlags
    cInstances As Long
    nMediaTypes As Long
    lpMediaType As LongPtr 'const REGPINTYPES *
    nMediums As Long
    lpMedium As LongPtr 'const REGPINMEDIUM *
    clsPinCategory As LongPtr 'const CLSID*
End Type

Public Type REGFILTER2
    dwVersion As Long
    dwMerit As DShowFilterMapperMeritFlags
    ' /* [switch_type][switch_is] */ union 
        ' {
        ' /* [case()] */ struct 
            ' {
            ' ULONG cPins;
            ' /* [size_is] */ const REGFILTERPINS *rgPins;
            ' }     DUMMYSTRUCTNAME;
        ' /* [case()] */ struct 
            ' {
            ' ULONG cPins2;
            ' /* [size_is] */ const REGFILTERPINS2 *rgPins2;
            ' }     DUMMYSTRUCTNAME2;
        ' }     DUMMYUNIONNAME;
    cPins As Long
    rgPins As LongPtr
End Type

Public Enum QualityMessageType
    Famine = 0
    Flood = (Famine + 1)
End Enum
Public Type Quality
    Type As QualityMessageType
    Proportion As Long
    Late As LongLong 'REFERENCE_TIME
    TimeStamp As LongLong 'REFERENCE_TIME
End Type

Public Enum DShowColorKeyType
    CK_NOCOLORKEY = &H0 ' No color key is required
    CK_INDEX = &H1 ' Index into the current system palette
    CK_RGB = &H2 ' Color key is an RGB value (or range)
End Enum

Public Type COLORKEY
    KeyType As DShowColorKeyType ' Explains meaning of the structure
    PaletteIndex As Long ' Palette index if available
    LowColorValue As Long ' Low colour space RGB value
    HighColorValue As Long ' Defines the high RGB value
End Type

Public Enum DShowAdviceFlags
    ADVISE_NONE = &H0 ' No notifications required
    ADVISE_CLIPPING = &H1 ' Synchronous clip information
    ADVISE_PALETTE = &H2 ' Palette change notifications
    ADVISE_COLORKEY = &H4 ' Called when colour key changes
    ADVISE_POSITION = &H8 ' Likewise when window moves etc
    ADVISE_DISPLAY_CHANGE = &H10 ' Called on WM_DISPLAYCHANGE
    ADVISE_ALL = ADVISE_CLIPPING Or ADVISE_PALETTE Or ADVISE_COLORKEY Or ADVISE_POSITION
    ADVISE_ALL2 = ADVISE_ALL Or ADVISE_DISPLAY_CHANGE
End Enum

Public Enum AM_FILESINK_FLAGS
    AM_FILE_OVERWRITE = &H1
End Enum
















Public Type AMCOPPSignature
	Signature(0 To 255) As Byte
End Type

Public Type AMCOPPCommand
	macKDI As UUID
	guidCommandID As UUID
	dwSequence As Long
	cbSizeData As Long
	CommandData(0 To 4055) As Byte
End Type

Public Type AMCOPPStatusInput
	rApp As UUID
	guidStatusRequestID As UUID
	dwSequence As Long
	cbSizeData As Long
	StatusData(0 To 4055) As Byte
End Type

Public Type AMCOPPStatusOutput
	macKDI As UUID
	cbSizeData As Long
	COPPStatus(0 To 4075) As Byte
End Type

Public Enum AM_SAMPLE_PROPERTY_FLAGS
    AM_SAMPLE_SPLICEPOINT = &H01 /* Is this a splice point
                                    IE can it be decoded
                                    without reference to
                                    previous data */
      AM_SAMPLE_PREROLL = &H02 /* Is this a preroll sample */
      AM_SAMPLE_DATADISCONTINUITY = &H04 /* Set if start of new segment */
      AM_SAMPLE_TYPECHANGED = &H08 /* Has the type changed */
      AM_SAMPLE_TIMEVALID = &H10 /* Set if time is valid */
      AM_SAMPLE_TIMEDISCONTINUITY = &H40 /* time gap in data starts after
                                                this sample - pbBuffer can
                                                be NULL
                                             */
    AM_SAMPLE_FLUSH_ON_PAUSE = &H80 /*  For live data - discard
                                                 in paused state
                                             */
      AM_SAMPLE_STOPVALID = &H100 /*  Stop time is valid */
      AM_SAMPLE_ENDOFSTREAM = &H200 /*  End of stream after
                                        this data
                                        This is reserved for
                                        kernel streaming and is
                                        not currently used by
                                        ActiveMovie
                                    */
      AM_STREAM_MEDIA = 0 /*  Normal data stream id */
      AM_STREAM_CONTROL = 1 /*  Control stream id */
                                /*  > 7FFFFFFF is application
                                    defined stream
                                */
End Enum

Public Type AM_SAMPLE2_PROPERTIES
	cbData As Long
	dwTypeSpecificFlags As AMVideoSampleFlags
	dwSampleFlags As AM_SAMPLE_PROPERTY_FLAGS
	lActual As Long
	tStart As LongLong ' REFERENCE_TIME
	tStop As LongLong ' REFERENCE_TIME
	dwStreamId As Long
	pMediaType As LongPtr ' was AM_MEDIA_TYPE *pMediaType; VB6 can't do that, so instead, pass the pointer from VarPtr
	pbBuffer As LongPtr ' was BYTE *pbBuffer; same issue as above
	cbBuffer As Long
End Type

Public Const CHARS_IN_GUID = 39
Public Type AM_MEDIA_TYPE
    majortype As UUID
    Subtype As UUID
    bFixedSizeSamples As Long
    bTemporalCompression As Long
    lSampleSize As Long
    formattype As UUID
    pUnk As LongPtr
    cbFormat As Long
    pbFormat As LongPtr
End Type

Public Enum FILTER_STATE
	State_Stopped = 0
	State_Paused = 1
	State_Running = 2
End Enum

Public Type FILTER_INFO
	achName(0 To 127) As Integer
	pGraph As IFilterGraph
End Type

Public Const MAX_PIN_NAME  = 128
Public Const MAX_FILTER_NAME  = 128

Public Enum PIN_DIRECTION
	PINDIR_INPUT = 0
	PINDIR_OUTPUT = 1
End Enum

Public Type PIN_INFO
	pFilter As IBaseFilter 'IBaseFilter *pFilter;
	dir As PIN_DIRECTION
	achName(0 To 127) As Integer
End Type

Public Enum AM_RENSDEREXFLAGS
    AM_RENDEREX_RENDERTOEXISTINGRENDERERS = 1            ' &H00000001&
End Enum

Public Enum DDS_STREAM_TYPE
    STREAMTYPE_READ = 0
    STREAMTYPE_WRITE = 1
    STREAMTYPE_TRANSFORM = 2
End Enum

Public Enum DDS_STREAM_STATE
    STREAMSTATE_STOP = 0
    STREAMSTATE_RUN = 1
End Enum

Public Enum COMPLETION_STATUS_FLAGS
    COMPSTAT_NOUPDATEOK = &H00000001
    COMPSTAT_WAIT = &H00000002
    COMPSTAT_ABORT = &H00000004
End Enum

Public Enum MMSTRM_INFO_FLAGS
    MMSSF_HASCLOCK = &H00000001
    MMSSF_SUPPORTSEEK = &H00000002
    MMSSF_ASYNCHRONOUS = &H00000004
End Enum

Public Enum SSUPDATE_FLAGS
    SSUPDATE_ASYNC = &H00000001
    SSUPDATE_CONTINUOUS = &H00000002
End Enum

Public Enum AMMSF_FLAGS
    AMMSF_NOGRAPHTHREAD = &H00000001
End Enum

Public Enum AMS_INIT_FLAGS
    '   Don't add a stream - create a default renderer instead
    '   for the supplied purpose id
    AMMSF_ADDDEFAULTRENDERER = &H00000001
    AMMSF_CREATEPEER = &H00000002
    '   If no samples are created when we run or the last sample
    '   is deleted then terminate this stream
    AMMSF_STOPIFNOSAMPLES = &H00000004
    '   If Update is not called keep going
    AMMSF_NOSTALL = &H00000008
End Enum

Public Enum AMMSF_RENDERFLAGS
    AMMSF_RENDERTYPEMASK = &H00000003
    AMMSF_RENDERTOEXISTING = &H00000000
    AMMSF_RENDERALLSTREAMS = &H00000001
    AMMSF_NORENDER = &H00000002
    AMMSF_NOCLOCK = &H00000004
    AMMSF_RUN = &H00000008
End Enum

Public Enum AMMSF_OUTPUT_STATE
    ammsfosDisabled = 0
    ammsfosReadData = 1
    ammsfosRenderData = 2
End Enum



Public Enum AM_GBF_Flags
    AM_GBF_PREVFRAMESKIPPED = 1
    AM_GBF_NOTASYNCPOINT = 2
    AM_GBF_NOWAIT = 4
    AM_GBF_NODDSURFACELOCK = 8
End Enum

Public Enum MP_Type
    MPT_INT   ' data is signed 23 bit integer (mantissa)
    MPT_FLOAT   ' data is 32bit IEEE float
    MPT_BOOL   ' data is true or false (using ANSI C++ definition)
    MPT_ENUM   ' data is a set (represented by consecutive integers)
    MPT_MAX
End Enum

Public Enum MP_CURVE_TYPE
    MP_CURVE_JUMP = &H0001 ' No interpolation, just jump to next point
    MP_CURVE_LINEAR = &H0002 ' Linear interpolation (y follows x from 0.0 to 1.0)
    MP_CURVE_SQUARE = &H0004 ' y follow x^2 from 0.0 to 1.0
    MP_CURVE_INVSQUARE = &H0008 ' y follows 1-(x^2) from 0.0 to 1.0
    MP_CURVE_SINE = &H0010 ' y follows sin(x) from -pi/2 to pi/2
End Enum

Public Enum MP_CAPS
    '  Curve capabilities - If the cap bit is set, that type of curve is supported
    MP_CAPS_CURVE_JUMP = MP_CURVE_JUMP
    MP_CAPS_CURVE_LINEAR = MP_CURVE_LINEAR
    MP_CAPS_CURVE_SQUARE = MP_CURVE_SQUARE
    MP_CAPS_CURVE_INVSQUARE = MP_CURVE_INVSQUARE
    MP_CAPS_CURVE_SINE = MP_CURVE_SINE
End Enum

Public Const DWORD_ALLPARAMS = -1

Public Type MP_PARAMINFO
    mpType As MP_Type ' One of MP_TYPE_xxx codes
    mopCaps As MP_CAPS ' A collection of MP_CAPS flags
    ' Minimum and maximum values
    mpdMinValue As Single 'MP_DATA ' minimum legal value
    mpdMaxValue As Single 'MP_DATA ' maximum legal value
    mpdNeutralValue As Single 'MP_DATA ' default or 'center' value
    ' Defualt Unit and Label text. These strings will ALWAYS be English
    ' strings in the UNICODE character set. For international text
    ' use the GetParamText member function
    szUnitText(0 To 31) As Integer ' units of the parameter
    szLabel(0 To 31) As Integer ' name of the parameter
End Type

Public Enum MP_FLAGS
    MPF_ENVLP_STANDARD = 0
    MPF_ENVLP_BEGIN_CURRENTVAL = &H1
    MPF_ENVLP_BEGIN_NEUTRALVAL = &H2
End Enum

Public Type MP_ENVELOPE_SEGMENT
    rtStart As LongLong 'REFERENCE_TIME
    rtEnd As LongLong 'REFERENCE_TIME
    valStart As Single 'MP_DATA
    valEnd As Single 'MP_DATA
    iCurve As MP_CURVE_TYPE
    flags As MP_FLAGS
End Type

Public Enum MPF_PUNCHIN
    MPF_PUNCHIN_REFTIME = 0
    MPF_PUNCHIN_NOW = &H1
    MPF_PUNCHIN_STOPPED = &H2
End Enum


'amvideo.h

Public Enum AMDDSFLAGS
    AMDDS_NONE = &H00  ' No use for DCI/DirectDraw
    AMDDS_DCIPS = &H01  ' Use DCI primary surface
    AMDDS_PS = &H02  ' Use DirectDraw primary
    AMDDS_RGBOVR = &H04  ' RGB overlay surfaces
    AMDDS_YUVOVR = &H08  ' YUV overlay surfaces
    AMDDS_RGBOFF = &H10  ' RGB offscreen surfaces
    AMDDS_YUVOFF = &H20  ' YUV offscreen surfaces
    AMDDS_RGBFLP = &H40  ' RGB flipping surfaces
    AMDDS_YUVFLP = &H80  ' YUV flipping surfaces
    AMDDS_ALL = &HFF  ' ALL the previous flags
    AMDDS_DEFAULT = AMDDS_ALL  ' Use all available surfaces
    AMDDS_YUV = (AMDDS_YUVOFF Or AMDDS_YUVOVR Or AMDDS_YUVFLP)
    AMDDS_RGB = (AMDDS_RGBOFF Or AMDDS_RGBOVR Or AMDDS_RGBFLP)
    AMDDS_PRIMARY = (AMDDS_DCIPS Or AMDDS_PS)
End Enum

Public Const iPALETTE_COLORS  = 256  ' Maximum colours in palette
Public Const iEGA_COLORS  = 16  ' Number colours in EGA palette
Public Const iMASK_COLORS  = 3  ' Maximum three components
Public Const iTRUECOLOR  = 16  ' Minimum true colour device
Public Const iRED  = 0  ' Index position for RED mask
Public Const iGREEN  = 1  ' Index position for GREEN mask
Public Const iBLUE  = 2  ' Index position for BLUE mask
Public Const iPALETTE  = 8  ' Maximum colour depth using a palette
Public Const iMAXBITS  = 8  ' Maximum bits per colour component

Public Type TRUECOLORINFO
    dwBitMasks(0 To (iMASK_COLORS - 1)) As Long
    bmiColors(0 To (iPALETTE_COLORS - 1)) As RGBQUAD
End Type

Public Type VIDEOINFO
    rcSource As RECT ' The bit we really want to use
    rcTarget As RECT ' Where the video should go
    dwBitRate As Long ' Approximate bit data rate
    dwBitErrorRate As Long ' Bit error rate for this stream
    AvgTimePerFrame As LongLong 'REFERENCE_TIME ' Average time per frame (100ns units)
    bmiHeader As BITMAPINFOHEADER
    'union {
    '    RGBQUAD         bmiColors[iPALETTE_COLORS];     // Colour palette
    '    DWORD           dwBitMasks[iMASK_COLORS];       // True colour masks
    '    TRUECOLORINFO   TrueColorInfo;                  // Both of the above
    '};
    u(1035) As Byte
End Type


Public Const MAX_SIZE_MPEG1_SEQUENCE_INFO = 140

Public Type ANALOGVIDEOINFO
    rcSource As RECT ' Width max is 720, height varies w/ TransmissionStd
    rcTarget As RECT ' Where the video should go
    dwActiveWidth As Long ' Always 720 (CCIR-601 active samples per line)
    dwActiveHeight As Long ' 483 for NTSC, 575 for PAL/SECAM
    AvgTimePerFrame As LongLong 'REFERENCE_TIME ' Normal ActiveMovie units (100 nS)
End Type

Public Enum AM_PROPERTY_FRAMESTEP
    '   Step
    AM_PROPERTY_FRAMESTEP_STEP = &H01
    AM_PROPERTY_FRAMESTEP_CANCEL = &H02
    '   S_OK for these 2 means we can - S_FALSE if we can't
    AM_PROPERTY_FRAMESTEP_CANSTEP = &H03
    AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE = &H04
End Enum

Public Type AM_FRAMESTEP_STEP
    '  1 means step 1 frame forward
    '  0 is invalid
    '  n (n > 1) means skip n - 1 frames and show the nth
    dwFramesToStep As Long
End Type

'dvp.h

Public Delegate Function DDENUMVIDEOCALLBACK (lpCaps As DDVIDEOPORTCAPS, ByVal lpConext As LongPtr) As Long

Public Type DDVIDEOPORTCONNECT
    dwSize As Long ' size of the DDVIDEOPORTCONNECT structure
    dwPortWidth As Long ' Width of the video port
    guidTypeID As UUID ' Description of video port connection
    dwFlags As DDVPCONNECTFLAGS ' Connection flags
    dwReserved1 As LongPtr ' Reserved, set to zero.
End Type

Public Type DDVIDEOPORTCAPS
    dwSize As Long ' size of the DDVIDEOPORTCAPS structure
    dwFlags As DDVPDFLAGS ' indicates which fields contain data
    dwMaxWidth As Long ' max width of the video port field
    dwMaxVBIWidth As Long ' max width of the VBI data
    dwMaxHeight As Long ' max height of the video port field
    dwVideoPortID As Long ' Video port ID (0 - (dwMaxVideoPorts -1))
    dwCaps As DDVPCAPSFLAGS ' Video port capabilities
    dwFX As DDVPFXFLAGS ' More video port capabilities
    dwNumAutoFlipSurfaces As Long ' Max number of autoflippable surfaces allowed
    dwAlignVideoPortBoundary As Long ' Byte restriction of placement within the surface
    dwAlignVideoPortPrescaleWidth As Long ' Byte restriction of width after prescaling
    dwAlignVideoPortCropBoundary As Long ' Byte restriction of left cropping
    dwAlignVideoPortCropWidth As Long ' Byte restriction of cropping width
    dwPreshrinkXStep As Long ' Width can be shrunk in steps of 1/x
    dwPreshrinkYStep As Long ' Height can be shrunk in steps of 1/x
    dwNumVBIAutoFlipSurfaces As Long ' Max number of VBI autoflippable surfaces allowed
    dwNumPreferredAutoflip As Long ' Optimal number of autoflippable surfaces for hardware
    wNumFilterTapsX As Integer ' Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    wNumFilterTapsY As Integer ' Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)
End Type
Public Enum DDVPDFLAGS
    DDVPD_WIDTH = &H00000001
    DDVPD_HEIGHT = &H00000002
    DDVPD_ID = &H00000004
    DDVPD_CAPS = &H00000008
    DDVPD_FX = &H00000010
    DDVPD_AUTOFLIP = &H00000020
    DDVPD_ALIGN = &H00000040
    DDVPD_PREFERREDAUTOFLIP = &H00000080
    DDVPD_FILTERQUALITY = &H00000100
End Enum

Public Type DDVIDEOPORTDESC
    dwSize As Long ' size of the DDVIDEOPORTDESC structure
    dwFieldWidth As Long ' width of the video port field
    dwVBIWidth As Long ' width of the VBI data
    dwFieldHeight As Long ' height of the video port field
    dwMicrosecondsPerField As Long ' Microseconds per video field
    dwMaxPixelsPerSecond As Long ' Maximum pixel rate per second
    dwVideoPortID As Long ' Video port ID (0 - (dwMaxVideoPorts -1))
    dwReserved1 As Long ' Reserved for future use - set to zero (struct padding)
    VideoPortType As DDVIDEOPORTCONNECT ' Description of video port connection
    dwReserved2 As LongPtr ' Reserved for future use - set to zero
    dwReserved3 As LongPtr ' Reserved for future use - set to zero
End Type

Public Type DDVIDEOPORTINFO
    dwSize As Long ' Size of the structure
    dwOriginX As Long ' Placement of the video data within the surface.
    dwOriginY As Long ' Placement of the video data within the surface.
    dwVPFlags As DDVPFLAGS ' Video port options
    rCrop As RECT ' Cropping rectangle (optional).
    dwPrescaleWidth As Long ' Determines pre-scaling/zooming in the X direction (optional).
    dwPrescaleHeight As Long ' Determines pre-scaling/zooming in the Y direction (optional).
    lpddpfInputFormat As LongPtr 'LPDDPIXELFORMAT ' Video format written to the video port
    lpddpfVBIInputFormat As LongPtr 'LPDDPIXELFORMAT ' Input format of the VBI data
    lpddpfVBIOutputFormat As LongPtr 'LPDDPIXELFORMAT ' Output format of the data
    dwVBIHeight As Long ' Specifies the number of lines of data within the vertical blanking interval.
    dwReserved1 As LongPtr ' Reserved for future use - set to zero
    dwReserved2 As LongPtr ' Reserved for future use - set to zero
End Type

Public Type DDVIDEOPORTBANDWIDTH
    dwSize As Long ' Size of the structure
    dwCaps As DDVPBCAPSFLAGS
    dwOverlay As Long ' Zoom factor at which overlay is supported
    dwColorkey As Long ' Zoom factor at which overlay w/ colorkey is supported
    dwYInterpolate As Long ' Zoom factor at which overlay w/ Y interpolation is supported
    dwYInterpAndColorkey As Long ' Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported
    dwReserved1 As LongPtr ' Reserved for future use - set to zero
    dwReserved2 As LongPtr ' Reserved for future use - set to zero
End Type

Public Type DDVIDEOPORTSTATUS
    dwSize As Long ' Size of the structure
    bInUse As BOOL ' TRUE if video port is currently being used
    dwFlags As DDVPSTATUSFLAGS ' Currently not used
    dwReserved1 As Long ' Reserved for future use
    VideoPortType As DDVIDEOPORTCONNECT ' Information about the connection
    dwReserved2 As LongPtr ' Reserved for future use
    dwReserved3 As LongPtr ' Reserved for future use
End Type

Public Type DDVIDEOPORTNOTIFY
    ApproximateTimeStamp As LARGE_INTEGER ' Timestamp in the event notification
    lField As Long ' 0 if even, 1 if odd, -1 if unknown
    dwSurfaceIndex As Long ' Index in the surface chain of the surface that received the sample
    lDone As Long ' Call InterlockedIncrement on this when done with sample
End Type

Public Enum DDVPCONNECTFLAGS
    /*
    * When this is set by the driver and passed to the client, this
    * indicates that the video port is capable of double clocking the data.
    * When this is set by the client, this indicates that the video port
    * should enable double clocking.  This flag is only valid with external
    * syncs.
    */
   DDVPCONNECT_DOUBLECLOCK = &H00000001

   /*
    * When this is set by the driver and passed to the client, this
    * indicates that the video port is capable of using an external VACT
    * signal. When this is set by the client, this indicates that the
    * video port should use the external VACT signal.
    */
   DDVPCONNECT_VACT = &H00000002

   /*
    * When this is set by the driver and passed to the client, this
    * indicates that the video port is capable of treating even fields
    * like odd fields and visa versa.  When this is set by the client,
    * this indicates that the video port should treat even fields like odd
    * fields.
    */
   DDVPCONNECT_INVERTPOLARITY = &H00000004

   /*
    * Indicates that any data written to the video port during the VREF
    * period will not be written into the frame buffer. This flag is read only.
    */
   DDVPCONNECT_DISCARDSVREFDATA = &H00000008

   /*
    * When this is set be the driver and passed to the client, this
    * indicates that the device will write half lines into the frame buffer
    * if half lines are provided by the decoder.  If this is set by the client,
    * this indicates that the decoder will be supplying half lines.
    */
   DDVPCONNECT_HALFLINE = &H00000010

   /*
    * Indicates that the signal is interlaced. This flag is only
    * set by the client.
    */
   DDVPCONNECT_INTERLACED = &H00000020

   /*
    * Indicates that video port is shareable and that this video port
    * will use the even fields.  This flag is only set by the client.
    */
   DDVPCONNECT_SHAREEVEN = &H00000040

   /*
    * Indicates that video port is shareable and that this video port
    * will use the odd fields.  This flag is only set by the client.
    */
   DDVPCONNECT_SHAREODD = &H00000080
    
End Enum

Public Enum DDVPCAPSFLAGS
    /*
    * Flip can be performed automatically to avoid tearing.
    */
   DDVPCAPS_AUTOFLIP = &H00000001

   /*
    * Supports interlaced video
    */
   DDVPCAPS_INTERLACED = &H00000002

   /*
    * Supports non-interlaced video
    */
   DDVPCAPS_NONINTERLACED = &H00000004

   /*
    * Indicates that the device can return whether the current field
    * of an interlaced signal is even or odd.
    */
   DDVPCAPS_READBACKFIELD = &H00000008

   /*
    * Indicates that the device can return the current line of video
    * being written into the frame buffer.
    */
   DDVPCAPS_READBACKLINE = &H00000010

   /*
    * Allows two gen-locked video streams to share a single video port,
    * where one stream uses the even fields and the other uses the odd
    * fields. Separate parameters (including address, scaling,
    * cropping, etc.) are maintained for both fields.)
    */
   DDVPCAPS_SHAREABLE = &H00000020

   /*
    * Even fields of video can be automatically discarded.
    */
   DDVPCAPS_SKIPEVENFIELDS = &H00000040

   /*
    * Odd fields of video can be automatically discarded.
    */
   DDVPCAPS_SKIPODDFIELDS = &H00000080

   /*
    * Indicates that the device is capable of driving the graphics
    * VSYNC with the video port VSYNC.
    */
   DDVPCAPS_SYNCMASTER = &H00000100

   /*
    * Indicates that data within the vertical blanking interval can
    * be written to a different surface.
    */
   DDVPCAPS_VBISURFACE = &H00000200

   /*
    * Indicates that the video port can perform color operations
    * on the incoming data before it is written to the frame buffer.
    */
   DDVPCAPS_COLORCONTROL = &H00000400

   /*
    * Indicates that the video port can accept VBI data in a different
    * width or format than the regular video data.
    */
   DDVPCAPS_OVERSAMPLEDVBI = &H00000800

   /*
    * Indicates that the video port can write data directly to system memory
    */
   DDVPCAPS_SYSTEMMEMORY = &H00001000

   /*
    * Indicates that the VBI and video portions of the video stream can
    * be controlled by an independent processes.
    */
   DDVPCAPS_VBIANDVIDEOINDEPENDENT = &H00002000

   /*
    * Indicates that the video port contains high quality hardware
    * de-interlacing hardware that should be used instead of the
    * bob/weave algorithms.
    */
   DDVPCAPS_HARDWAREDEINTERLACE = &H00004000

    
End Enum

Public Enum DDVPFXFLAGS
    /*
    * Limited cropping is available to crop out the vertical interval data.
    */
   DDVPFX_CROPTOPDATA = &H00000001

   /*
    * Incoming data can be cropped in the X direction before it is written
    * to the surface.
    */
   DDVPFX_CROPX = &H00000002

   /*
    * Incoming data can be cropped in the Y direction before it is written
    * to the surface.
    */
   DDVPFX_CROPY = &H00000004

   /*
    * Supports interleaving interlaced fields in memory.
    */
   DDVPFX_INTERLEAVE = &H00000008

   /*
    * Supports mirroring left to right as the video data is written
    * into the frame buffer.
    */
   DDVPFX_MIRRORLEFTRIGHT = &H00000010

   /*
    * Supports mirroring top to bottom as the video data is written
    * into the frame buffer.
    */
   DDVPFX_MIRRORUPDOWN = &H00000020

   /*
    * Data can be arbitrarily shrunk in the X direction before it
    * is written to the surface.
    */
   DDVPFX_PRESHRINKX = &H00000040

   /*
    * Data can be arbitrarily shrunk in the Y direction before it
    * is written to the surface.
    */
   DDVPFX_PRESHRINKY = &H00000080

   /*
    * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the X
    * direction before it is written to the surface.
    */
   DDVPFX_PRESHRINKXB = &H00000100

   /*
    * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the Y
    * direction before it is written to the surface.
    */
   DDVPFX_PRESHRINKYB = &H00000200

   /*
    * Data can be shrunk in increments of 1/x in the X direction
    * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep)
    * before it is written to the surface.
    */
   DDVPFX_PRESHRINKXS = &H00000400

   /*
    * Data can be shrunk in increments of 1/x in the Y direction
    * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep)
    * before it is written to the surface.
    */
   DDVPFX_PRESHRINKYS = &H00000800

   /*
    * Data can be arbitrarily stretched in the X direction before
    * it is written to the surface.
    */
   DDVPFX_PRESTRETCHX = &H00001000

   /*
    * Data can be arbitrarily stretched in the Y direction before
    * it is written to the surface.
    */
   DDVPFX_PRESTRETCHY = &H00002000

   /*
    * Data can be integer stretched in the X direction before it is
    * written to the surface.
    */
   DDVPFX_PRESTRETCHXN = &H00004000

   /*
    * Data can be integer stretched in the Y direction before it is
    * written to the surface.
    */
   DDVPFX_PRESTRETCHYN = &H00008000&

   /*
    * Indicates that data within the vertical blanking interval can
    * be converted independently of the remaining video data.
    */
   DDVPFX_VBICONVERT = &H00010000

   /*
    * Indicates that scaling can be disabled for data within the
    * vertical blanking interval.
    */
   DDVPFX_VBINOSCALE = &H00020000

   /*
    * Indicates that the video data can ignore the left and right
    * cropping coordinates when cropping oversampled VBI data.
    */
   DDVPFX_IGNOREVBIXCROP = &H00040000

   /*
    * Indicates that interleaving can be disabled for data within the
    * vertical blanking interval.
    */
   DDVPFX_VBINOINTERLEAVE = &H00080000

    
End Enum

Public Enum DDVPFLAGS
    /*
    * Perform automatic flipping.   Auto-flipping is performed between
    * the overlay surface that was attached to the video port using
    * IDirectDrawVideoPort::AttachSurface and the overlay surfaces that
    * are attached to the surface via the IDirectDrawSurface::AttachSurface
    * method.  The flip order is the order in which the overlay surfaces
    * were. attached.
    */
   DDVP_AUTOFLIP = &H00000001

   /*
    * Perform conversion using the ddpfOutputFormat information.
    */
   DDVP_CONVERT = &H00000002

   /*
    * Perform cropping using the specified rectangle.
    */
   DDVP_CROP = &H00000004

   /*
    * Indicates that interlaced fields should be interleaved in memory.
    */
   DDVP_INTERLEAVE = &H00000008

   /*
    * Indicates that the data should be mirrored left to right as it's
    * written into the frame buffer.
    */
   DDVP_MIRRORLEFTRIGHT = &H00000010

   /*
    * Indicates that the data should be mirrored top to bottom as it's
    * written into the frame buffer.
    */
   DDVP_MIRRORUPDOWN = &H00000020

   /*
    * Perform pre-scaling/zooming based on the pre-scale parameters.
    */
   DDVP_PRESCALE = &H00000040

   /*
    * Ignore input of even fields.
    */
   DDVP_SKIPEVENFIELDS = &H00000080

   /*
    * Ignore input of odd fields.
    */
   DDVP_SKIPODDFIELDS = &H00000100

   /*
    * Drive the graphics VSYNCs using the video port VYSNCs.
    */
   DDVP_SYNCMASTER = &H00000200

   /*
    * The ddpfVBIOutputFormatFormat member contains data that should be used
    * to convert the data within the vertical blanking interval.
    */
   DDVP_VBICONVERT = &H00000400

   /*
    * Indicates that data within the vertical blanking interval
    * should not be scaled.
    */
   DDVP_VBINOSCALE = &H00000800

   /*
    * Indicates that these bob/weave decisions should not be
    * overriden by other interfaces.
    */
   DDVP_OVERRIDEBOBWEAVE = &H00001000

   /*
    * Indicates that the video data should ignore the left and right
    * cropping coordinates when cropping the VBI data.
    */
   DDVP_IGNOREVBIXCROP = &H00002000

   /*
    * Indicates that interleaving can be disabled for data within the
    * vertical blanking interval.
    */
   DDVP_VBINOINTERLEAVE = &H00004000

   /*
    * Indicates that the video port should use the hardware
    * de-interlacing hardware.
    */
   DDVP_HARDWAREDEINTERLACE = &H00008000&
    
End Enum

Public Enum DDVPFORMATFLAGS
    /*
    * Return formats for the video data
    */
    DDVPFORMAT_VIDEO = &H00000001
    /*
    * Return formats for the VBI data
    */
    DDVPFORMAT_VBI = &H00000002
End Enum

Public Enum DDVPTARGETFLAGS
    /*
    * Surface should receive video data (and VBI data if a surface
    * is not explicitly attached for that purpose)
    */
    DDVPTARGET_VIDEO = &H00000001
    /*
    * Surface should receive VBI data
    */
    DDVPTARGET_VBI = &H00000002
End Enum

Public Enum DDVPWAITFLAGS
    /*
    * Waits until the beginning of the next VSYNC
    */
   DDVPWAIT_BEGIN = &H00000001

   /*
    * Waits until the end of the next/current VSYNC
    */
   DDVPWAIT_END = &H00000002

   /*
    * Waits until the beginning of the specified line
    */
   DDVPWAIT_LINE
End Enum

Public Enum DDVPFLIPFLAGS
    DDVPFLIP_VIDEO = &H00000001
    DDVPFLIP_VBI = &H00000002
End Enum

Public Enum DDVPSQFLAGS
    DDVPSQ_NOSIGNAL = &H00000001
    DDVPSQ_SIGNALOK = &H00000002
End Enum

Public Enum DDVPBFLAGS
    /*
    * The specified height/width refer to the size of the video port data
    * written into memory, after prescaling has occured.
    */
   DDVPB_VIDEOPORT = &H00000001

   /*
    * The specified height/width refer to the source size of the overlay.
    */
   DDVPB_OVERLAY = &H00000002

   /*
    * This is a query for the device to return which caps this device requires.
    */
   DDVPB_TYPE = &H00000004
End Enum

Public Enum DDVPBCAPSFLAGS
    DDVPBCAPS_SOURCE = &H00000001
    DDVPBCAPS_DESTINATION = &H00000002
End Enum

Public Enum DDVPCREATEFLAGS
    DDVPCREATE_VBIONLY = &H00000001
    DDVPCREATE_VIDEOONLY = &H00000002
End Enum

Public Enum DDVPSTATUSFLAGS
    DDVPSTATUS_VBIONLY = &H00000001
    DDVPSTATUS_VIDEOONLY = &H00000002
End Enum

'amaudio.h
#If WINDEVLIB_LITE = 0 Then
Public Function AMValidateAndFixWaveFormatEx(pwfx As WAVEFORMATEX, ByVal cb As Long) As Long
    If (cb < LenB(Of PCMWAVEFORMAT)) Then
        Return E_INVALIDARG
    End If
    If (pwfx.wFormatTag <> WAVE_FORMAT_PCM) Then
        If (cb < LenB(Of WAVEFORMATEX)) Then
            Return E_INVALIDARG
        End If
        If (cb < LenB(Of WAVEFORMATEX) + pwfx.cbSize) Then
            Return E_INVALIDARG
        End If
    End If
    If (pwfx.nAvgBytesPerSec > 10000000 Or pwfx.nAvgBytesPerSec = 0) Then pwfx.nAvgBytesPerSec = 176400
    
    If (pwfx.nChannels > 32) Then pwfx.nChannels = 1

    Return S_OK
End Function
#End If

'MpegType.h

[Description("Header only. bFormat is a variable C-style array.")]
Public Type AM_MPEGSTREAMTYPE
    dwStreamId As Long ' Stream id of stream to process
    dwReserved As Long ' 8-byte alignment
    mt As AM_MEDIA_TYPE ' Type for substream - pbFormat is NULL
    bFormat(0 To 0) As Byte ' Format data
End Type
[Description("Header only. Streams is a variable C-style array.")]
Public Type AM_MPEGSYSTEMTYPE
    dwBitRate As Long ' Bits per second
    cStreams As Long ' Number of streams
    Streams(0 To 63) As AM_MPEGSTREAMTYPE
End Type

Public Enum AMMpegAudioChannels
    AM_MPEG_AUDIO_DUAL_MERGE = 0
    AM_MPEG_AUDIO_DUAL_LEFT = 1
    AM_MPEG_AUDIO_DUAL_RIGHT = 2
End Enum

'VpTypes.h

Public Enum AMVP_SELECT_FORMAT_BY
    AMVP_DO_NOT_CARE = 0
    AMVP_BEST_BANDWIDTH = 1
    AMVP_INPUT_SAME_AS_OUTPUT = 2
End Enum

Public Enum AMVP_MODE
    AMVP_MODE_WEAVE = 0
    AMVP_MODE_BOBINTERLEAVED = 1
    AMVP_MODE_BOBNONINTERLEAVED = 2
    AMVP_MODE_SKIPEVEN = 3
    AMVP_MODE_SKIPODD = 4
End Enum

Public Type AMVPSIZE
    dwWidth As Long ' the width
    dwHeight As Long ' the height
End Type

Public Type AMVPDIMINFO
    dwFieldWidth As Long ' Field height of the data
    dwFieldHeight As Long ' Field width of the data
    dwVBIWidth As Long ' Width of the VBI data
    dwVBIHeight As Long ' Height of the VBI data
    rcValidRegion As RECT ' The vaild rectangle, used for cropping
End Type

Public Type AMVPDATAINFO
    dwSize As Long ' Size of the struct
    dwMicrosecondsPerField As Long ' Time taken by each field
    amvpDimInfo As AMVPDIMINFO ' Dimensional Information 
    dwPictAspectRatioX As Long ' X dimension of Picture Aspect Ratio
    dwPictAspectRatioY As Long ' Y dimension of Picture Aspect Ratio
    bEnableDoubleClock As BOOL ' Videoport should enable double clocking
    bEnableVACT As BOOL ' Videoport should use an external VACT signal
    bDataIsInterlaced As BOOL ' Indicates that the signal is interlaced
    lHalfLinesOdd As Long ' number of halflines in the odd field
    bFieldPolarityInverted As BOOL ' Device inverts the polarity by default
    dwNumLinesInVREF As Long ' Number of lines of data in VREF 
    lHalfLinesEven As Long ' number of halflines in the even field
    dwReserved1 As Long ' Reserved for future use
End Type

'mpconfig.h
Public Enum AM_ASPECT_RATIO_MODE
    AM_ARMODE_STRETCHED = 0 ' don't do any aspect ratio correction
    AM_ARMODE_LETTER_BOX = 1 ' letter box the video, paint background color in the excess region
    AM_ARMODE_CROP = 2 ' crop the video to the right aspect ratio
    AM_ARMODE_STRETCHED_AS_PRIMARY = 3 ' follow whatever the primary stream does (in terms of the mode as well as pict-aspect-ratio values)
End Enum

'dyngraph.idl

Public Enum AM_PIN_FLOW_CONTROL_BLOCK_FLAGS
    AM_PIN_FLOW_CONTROL_BLOCK = &H00000001 '  0 means unblock
End Enum

Public Enum AM_GRAPH_CONFIG_RECONNECT_FLAGS
    AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT = &H00000001
    AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS = &H00000002
    AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS = &H00000004
End Enum

Public Enum REM_FILTER_FLAGS
    REMFILTERF_LEAVECONNECTED = &H00000001
End Enum

Public Enum AM_FILTER_FLAGS
    AM_FILTER_FLAGS_REMOVABLE = &H00000001
End Enum

'axextend.idl 
Public Enum AMTunerSubChannel
    AMTUNER_SUBCHAN_NO_TUNE = -2 ' don't tune
    AMTUNER_SUBCHAN_DEFAULT = -1 ' use default sub chan
End Enum

Public Enum AMTunerSignalStrength
    AMTUNER_HASNOSIGNALSTRENGTH = -1 ' cannot indicate signal strength
    AMTUNER_NOSIGNAL = 0 ' no signal available
    AMTUNER_SIGNALPRESENT = 1 ' signal present
End Enum

Public Enum AMTunerModeType
    AMTUNER_MODE_DEFAULT = &H0000 ' default tuner mode
    AMTUNER_MODE_TV = &H0001 ' tv
    AMTUNER_MODE_FM_RADIO = &H0002 ' fm radio
    AMTUNER_MODE_AM_RADIO = &H0004 ' am radio
    AMTUNER_MODE_DSS = &H0008 ' dss
End Enum

Public Enum AMTunerEventType
    AMTUNER_EVENT_CHANGED = &H0001 ' status changed
End Enum

Public Enum AMPROPERTY_PIN
    AMPROPERTY_PIN_CATEGORY
    AMPROPERTY_PIN_MEDIUM
End Enum

Public Enum KsPropertyTypeSupport
    KSPROPERTY_SUPPORT_GET = 1
    KSPROPERTY_SUPPORT_SET = 2
End Enum

' typedef union _timecode {
' struct {
  ' WORD   wFrameRate;
  ' WORD   wFrameFract;
  ' DWORD  dwFrames;
  ' } DUMMYSTRUCTNAME;
' DWORDLONG  qw;
' } TIMECODE;
Public Type TIMECODE
    qw As LongLong 'Must use this one for alignment purposes
End Type

Public Type TIMECODE_SAMPLE
    qwTick As LongLong
    timecode As TIMECODE
    dwUser As Long
    dwFlags As Long
End Type

Public Enum _AMSTREAMSELECTINFOFLAGS
    AMSTREAMSELECTINFO_ENABLED = &H01 ' Enable - off for disable
    AMSTREAMSELECTINFO_EXCLUSIVE = &H02 ' Turns off the others in the group
                                        '  when enabling this one
End Enum

Public Enum _AMSTREAMSELECTENABLEFLAGS '(no non-underscore version defined)
    '   Currently valid values are :
    '   0 - disable all streams in the group containing this stream
    '   ..._ENABLE - enable only this stream with in the given group
    '                and disable all others
    '   ..._ENABLEALL - send out all streams
    AMSTREAMSELECTENABLE_ENABLE = &H01 ' Enable
    AMSTREAMSELECTENABLE_ENABLEALL = &H02 ' Enable all streams in the group
                                          '  containing this stream
End Enum

Public Enum _AMRESCTL_RESERVEFLAGS
    AMRESCTL_RESERVEFLAGS_RESERVE = &H00 ' Increment reserve count
    AMRESCTL_RESERVEFLAGS_UNRESERVE = &H01 ' Decrement reserve count
End Enum

Public Enum _AM_FILTER_MISC_FLAGS
    AM_FILTER_MISC_FLAGS_IS_RENDERER = &H00000001 ' Will deliver EC_COMPLETE
'                                                      at end of media */
    AM_FILTER_MISC_FLAGS_IS_SOURCE = &H00000002 '  Filter sources data */
End Enum

Public Enum DECIMATION_USAGE
    DECIMATION_LEGACY  ' decimate at ovly then video port then crop
    DECIMATION_USE_DECODER_ONLY  ' decimate image at the decoder only
    DECIMATION_USE_VIDEOPORT_ONLY   ' decimate at the video port only
    DECIMATION_USE_OVERLAY_ONLY   ' decimate at the overlay only
    DECIMATION_DEFAULT   ' decimate at decoder then ovly the vide port then crop 
End Enum

Public Enum _AM_PUSHSOURCE_FLAGS
    ' 
    '  The default assumption is that the data is from a live source,
    '  time stamped with the graph clock, and the source does not
    '  attempt to rate match the data it delivers.
    '  The following flags can be used to override this assumption.
    ' 
    '  capability flags
    AM_PUSHSOURCECAPS_INTERNAL_RM = &H00000001 ' source provides internal support for rate matching
    AM_PUSHSOURCECAPS_NOT_LIVE = &H00000002 ' don't treat source data as live
    AM_PUSHSOURCECAPS_PRIVATE_CLOCK = &H00000004 ' source data timestamped with clock not
    '  exposed to the graph
    '  request flags, set by user via SetPushSourceFlags method
    AM_PUSHSOURCEREQS_USE_STREAM_CLOCK = &H00010000 ' source was requested to timestamp
    '  using a clock that isn't the graph clock
    AM_PUSHSOURCEREQS_USE_CLOCK_CHAIN = &H00020000 ' source requests reference clock chaining
End Enum

Public Type DVINFO
    'for 1st 5/6 DIF seq.
    dwDVAAuxSrc As Long
    dwDVAAuxCtl As Long
    'for 2nd  5/6 DIF seq.
    dwDVAAuxSrc1 As Long
    dwDVAAuxCtl1 As Long
    'for video information
    dwDVVAuxSrc As Long
    dwDVVAuxCtl As Long
    dwDVReserved(0 To 1) As Long
End Type

Public Enum _DVENCODERRESOLUTION 'resolution
    DVENCODERRESOLUTION_720x480 = 2012
    DVENCODERRESOLUTION_360x240 = 2013
    DVENCODERRESOLUTION_180x120 = 2014
    DVENCODERRESOLUTION_88x60 = 2015
End Enum

Public Enum _DVENCODERVIDEOFORMAT 'PAL/ntsc
    DVENCODERVIDEOFORMAT_NTSC = 2000
    DVENCODERVIDEOFORMAT_PAL = 2001
End Enum

Public Enum _DVENCODERFORMAT ' dvsd/dvhd/dvsl
    DVENCODERFORMAT_DVSD = 2007
    DVENCODERFORMAT_DVHD = 2008
    DVENCODERFORMAT_DVSL = 2009
End Enum

Public Enum _DVDECODERRESOLUTION
    DVDECODERRESOLUTION_720x480 = 1000
    DVDECODERRESOLUTION_360x240 = 1001
    DVDECODERRESOLUTION_180x120 = 1002
    DVDECODERRESOLUTION_88x60 = 1003
End Enum

Public Enum _DVRESOLUTION
    DVRESOLUTION_FULL = 1000
    DVRESOLUTION_HALF = 1001
    DVRESOLUTION_QUARTER = 1002
    DVRESOLUTION_DC = 1003
End Enum

Public Enum _AM_AUDIO_RENDERER_STAT_PARAM
    AM_AUDREND_STAT_PARAM_BREAK_COUNT = 1 ' audio breaks
    AM_AUDREND_STAT_PARAM_SLAVE_MODE = 2 ' current clock mode, see AM_AUDREND_SLAVE_MODEs
    AM_AUDREND_STAT_PARAM_SILENCE_DUR = 3 ' silence inserted due to gaps (ms)
    AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR = 4 ' duration of the last buffer received
    AM_AUDREND_STAT_PARAM_DISCONTINUITIES = 5 ' discontinuities seen since running
    AM_AUDREND_STAT_PARAM_SLAVE_RATE = 6 ' what rate are we currently slaving at? S_FALSE if not slaving
    AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR = 7 ' for waveOut slaving - data dropped or added to stay in-sync
    '        dwParam1 - dropped duration(ms)
    '        dwParam2 - paused duration(ms)
    AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR = 8 ' highest & lowest clock differences seen
    '        dwParam1 - high err
    '        dwParam2 - low err
    AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR = 9 ' last high and low errs seen
    '        dwParam1 - last high err
    '        dwParam2 - last low err
    AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR = 10 ' error between primary/secondary clocks
    AM_AUDREND_STAT_PARAM_BUFFERFULLNESS = 11 ' percent audio buffer fullness
    AM_AUDREND_STAT_PARAM_JITTER = 12 ' input buffer jitter
End Enum

Public Enum _AM_INTF_SEARCH_FLAGS
    AM_INTF_SEARCH_INPUT_PIN = &H00000001 ' search input pins
    AM_INTF_SEARCH_OUTPUT_PIN = &H00000002 ' search output pins
    AM_INTF_SEARCH_FILTER = &H00000004 ' search filters
End Enum

Public Enum AMOVERLAYFX
    '  Normal (ie. top down, left to right) video
    AMOVERFX_NOFX = &H00000000
    '  Mirror the overlay across the vertical axis
    AMOVERFX_MIRRORLEFTRIGHT = &H00000002
    '  Mirror the overlay across the horizontal axis
    AMOVERFX_MIRRORUPDOWN = &H00000004
    '  Deinterlace the overlay, if possible
    AMOVERFX_DEINTERLACE = &H00000008
End Enum

Public Enum AMMpeg2StreamContentTypes
    MPEG2_PROGRAM_STREAM_MAP = &H00000000
    MPEG2_PROGRAM_ELEMENTARY_STREAM = &H00000001
    MPEG2_PROGRAM_DIRECTORY_PES_PACKET = &H00000002
    MPEG2_PROGRAM_PACK_HEADER = &H00000003
    MPEG2_PROGRAM_PES_STREAM = &H00000004
    MPEG2_PROGRAM_SYSTEM_HEADER = &H00000005
    SUBSTREAM_FILTER_VAL_NONE = &H10000000
End Enum

Public Type STREAM_ID_MAP
    stream_id As Long
    dwMediaSampleContent As AMMpeg2StreamContentTypes
    ulSubstreamFilterValue As Long
    iDataOffset As Long
End Type

Public Enum VIDEOENCODER_BITRATE_MODE
    ' 
    '  Bit rate used for encoding is constant
    ' 
    ConstantBitRate = 0
    ' 
    '  Bit rate used for encoding is variable with the specified bitrate used
    '  as a guaranteed average over a specified window.  The default window
    '  size is considered to be 5 minutes.
    ' 
    VariableBitRateAverage
    ' 
    '  Bit rate used for encoding is variable with the specified bitrate used
    '  as a peak rate over a specified window.  The default window size
    '  is considered to be 500ms (classically one GOP).
    ' 
    VariableBitRatePeak
End Enum

Public Enum AMDecoderCapQueryIndex
    AM_GETDECODERCAP_QUERY_VMR_SUPPORT = &H00000001
    AM_QUERY_DECODER_VMR_SUPPORT = &H00000001
    AM_QUERY_DECODER_DXVA_1_SUPPORT = &H00000002
    AM_QUERY_DECODER_DVD_SUPPORT = &H00000003
    AM_QUERY_DECODER_ATSC_SD_SUPPORT = &H00000004
    AM_QUERY_DECODER_ATSC_HD_SUPPORT = &H00000005
    AM_GETDECODERCAP_QUERY_VMR9_SUPPORT = &H00000006
    AM_GETDECODERCAP_QUERY_EVR_SUPPORT = &H00000007
End Enum
Public Enum AMDecoderCapQueryResult
    DECODER_CAP_NOTSUPPORTED = &H00000000
    DECODER_CAP_SUPPORTED = &H00000001
    VMR_NOTSUPPORTED = &H00000000
    VMR_SUPPORTED = &H00000001
End Enum



'amva.h

Public Const AMVA_TYPEINDEX_OUTPUTFRAME = &HFFFFFFFF

Public Enum AMQueryRenderStatusFlags
    AMVA_QUERYRENDERSTATUSF_READ = &H00000001
End Enum

Public Type AMVAUncompBufferInfo
    dwMinNumSurfaces As Long ' IN   min number of surfaces to be allocated
    dwMaxNumSurfaces As Long ' IN   max number of surfaces to be allocated
    ddUncompPixelFormat As DDPIXELFORMAT ' IN   pixel format of surfaces to be allocated
End Type

Public Type AMVAUncompDataInfo
    dwUncompWidth As Long ' [in]     width of uncompressed data
    dwUncompHeight As Long ' [in]     height of uncompressed data
    ddUncompPixelFormat As DDPIXELFORMAT ' [in]     pixel-format of uncompressed data
End Type

Public Type AMVAInternalMemInfo
    dwScratchMemAlloc As Long ' [out]    amount of scratch memory will the hal allocate for its private use
End Type

Public Type AMVACompBufferInfo
    dwNumCompBuffers As Long ' [out]    number of buffers reqd for compressed data
    dwWidthToCreate As Long ' [out]    Width of surface to create
    dwHeightToCreate As Long ' [out]    Height of surface to create
    dwBytesToAllocate As Long ' [out]    Total number of bytes used by each surface
    ddCompCaps As DDSCAPS2 ' [out]    caps to create surfaces to store compressed data
    ddPixelFormat As DDPIXELFORMAT ' [out]    fourcc to create surfaces to store compressed data
End Type

Public Type AMVABeginFrameInfo
    dwDestSurfaceIndex As Long ' IN  destination buffer in which to decoding this frame
    pInputData As LongPtr ' IN  pointer to misc data
    dwSizeInputData As Long ' IN  size of other misc data to begin frame
    pOutputData As LongPtr ' OUT pointer to data which the VGA is going to fill
    dwSizeOutputData As Long ' IN  size of data which the VGA is going to fill
End Type

Public Type AMVAEndFrameInfo
    dwSizeMiscData As Long ' [in]     size of other misc data to begin frame
    pMiscData As LongPtr ' [in]     pointer to misc data
End Type

Public Type AMVABUFFERINFO
    dwTypeIndex As Long ' [in]    Type of buffer
    dwBufferIndex As Long ' [in]    Buffer index
    dwDataOffset As Long ' [in]    offset of relevant data from the beginning of buffer
    dwDataSize As Long ' [in]    size of relevant data
End Type



'dvdmedia.h
Public Enum AM_PROPERTY_AC3
    AM_PROPERTY_AC3_ERROR_CONCEALMENT = 1
    AM_PROPERTY_AC3_ALTERNATE_AUDIO = 2
    AM_PROPERTY_AC3_DOWNMIX = 3
    AM_PROPERTY_AC3_BIT_STREAM_MODE = 4
    AM_PROPERTY_AC3_DIALOGUE_LEVEL = 5
    AM_PROPERTY_AC3_LANGUAGE_CODE = 6
    AM_PROPERTY_AC3_ROOM_TYPE = 7
End Enum

Public Type AM_AC3_ERROR_CONCEALMENT
    fRepeatPreviousBlock As BOOL
    fErrorInCurrentBlock As BOOL
End Type

Public Type AM_AC3_ALTERNATE_AUDIO
    fStereo As BOOL
    DualMode As Long
End Type


Public Enum AMAC3AltAudioFlags
    AM_AC3_ALTERNATE_AUDIO_1 = 1
    AM_AC3_ALTERNATE_AUDIO_2 = 2
    AM_AC3_ALTERNATE_AUDIO_BOTH = 3
End Enum

Public Type AM_AC3_DOWNMIX
    fDownMix As BOOL
    fDolbySurround As BOOL
End Type

Public Type AM_AC3_BIT_STREAM_MODE
    BitStreamMode As Long
End Type

Public Enum AMAC3Services
    AM_AC3_SERVICE_MAIN_AUDIO = 0
    AM_AC3_SERVICE_NO_DIALOG = 1
    AM_AC3_SERVICE_VISUALLY_IMPAIRED = 2
    AM_AC3_SERVICE_HEARING_IMPAIRED = 3
    AM_AC3_SERVICE_DIALOG_ONLY = 4
    AM_AC3_SERVICE_COMMENTARY = 5
    AM_AC3_SERVICE_EMERGENCY_FLASH = 6
    AM_AC3_SERVICE_VOICE_OVER = 7
End Enum

Public Type AM_AC3_DIALOGUE_LEVE
    DialogueLevel As Long
End Type

Public Type AM_AC3_ROOM_TYPE
    fLargeRoom As BOOL
End Type

Public Enum AM_PROPERTY_DVDSUBPIC
    AM_PROPERTY_DVDSUBPIC_PALETTE = 0
    AM_PROPERTY_DVDSUBPIC_HLI = 1
    AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = 2 ' TRUE for subpicture is displayed
End Enum

Public Type AM_DVD_YUV
    Reserved As Byte
    Y As Byte
    U As Byte
    V As Byte
End Type

Public Type AM_PROPERTY_SPPAL
    sppal(0 To 15) As AM_DVD_YUV
End Type

Public Type AM_COLCON
    ' UCHAR emph1col:4;
    ' UCHAR emph2col:4;
    ' UCHAR backcol:4;
    ' UCHAR patcol:4;
    ' UCHAR emph1con:4;
    ' UCHAR emph2con:4;
    ' UCHAR backcon:4;
    ' UCHAR patcon:4;
    emph As Byte
    backpatcol As Byte
    emphcon As Byte
    backpatcon As Byte
End Type

Public Type AM_PROPERTY_SPHLI
    HLISS As Integer '
    Reserved As Integer
    StartPTM As Long ' start presentation time in x/90000
    EndPTM As Long ' end PTM in x/90000
    StartX As Integer
    StartY As Integer
    StopX As Integer
    StopY As Integer
    ColCon As AM_COLCON ' color contrast description (4 bytes as given in HLI)
End Type

Public Const AM_UseNewCSSKey  = &H1
Public Const AM_ReverseBlockStart  = &H2
Public Const AM_ReverseBlockEnd  = &H4

Public Enum AM_PROPERTY_DVDCOPYPROT
    AM_PROPERTY_DVDCOPY_CHLG_KEY = &H01
    AM_PROPERTY_DVDCOPY_DVD_KEY1 = &H02
    AM_PROPERTY_DVDCOPY_DEC_KEY2 = &H03
    AM_PROPERTY_DVDCOPY_TITLE_KEY = &H04
    AM_PROPERTY_COPY_MACROVISION = &H05
    AM_PROPERTY_DVDCOPY_REGION = &H06
    AM_PROPERTY_DVDCOPY_SET_COPY_STATE = &H07
    AM_PROPERTY_COPY_ANALOG_COMPONENT = &H08 ' GetOnly property, return data is a BOOL
    AM_PROPERTY_COPY_DIGITAL_CP = &H09
    AM_PROPERTY_COPY_DVD_SRM = &H0a
    AM_PROPERTY_DVDCOPY_SUPPORTS_NEW_KEYCOUNT = &H0b ' read only, BOOL
    '  gap
    AM_PROPERTY_DVDCOPY_DISC_KEY = &H80
End Enum

Public Enum AM_DIGITAL_CP
    AM_DIGITAL_CP_OFF = 0
    AM_DIGITAL_CP_ON = 1
    AM_DIGITAL_CP_DVD_COMPLIANT = 2
End Enum

Public Type AM_DVDCOPY_CHLGKEY
    ChlgKey(0 To 9) As Byte
    Reserved(0 To 1) As Byte
End Type

Public Type AM_DVDCOPY_BUSKEY
    BusKey(0 To 4) As Byte
    Reserved(0 To 0) As Byte
End Type

Public Type AM_DVDCOPY_DISCKEY
    DiscKey(0 To 2047) As Byte
End Type

Public Type AM_DVDCOPY_TITLEKEY
    KeyFlags As Long
    Reserved1(0 To 1) As Long
    TitleKey(0 To 5) As Byte
    Reserved2(0 To 1) As Byte
End Type

Public Type AM_COPY_MACROVISION
    MACROVISIONLevel As AM_COPY_MACROVISION_LEVEL
End Type

Public Type AM_DVDCOPY_SET_COPY_STATE
    DVDCopyState As AM_DVDCOPYSTATE
End Type

Public Enum AM_DVDCOPYSTATE
    AM_DVDCOPYSTATE_INITIALIZE = 0
    AM_DVDCOPYSTATE_INITIALIZE_TITLE = 1 ' indicates we are starting a title
    '  key copy protection sequence
    AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = 2
    AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED = 3
    AM_DVDCOPYSTATE_DONE = 4
End Enum

Public Enum AM_COPY_MACROVISION_LEVEL
    AM_MACROVISION_DISABLED = 0
    AM_MACROVISION_LEVEL1 = 1
    AM_MACROVISION_LEVEL2 = 2
    AM_MACROVISION_LEVEL3 = 3
End Enum

Public Type DVD_REGION
    CopySystem As Byte
    RegionData As Byte
    SystemRegion As Byte
    ResetCount As Byte
End Type

Public Enum AMCGMSFlags
    AM_DVD_CGMS_RESERVED_MASK = &H00000078
    AM_DVD_CGMS_COPY_PROTECT_MASK = &H00000018
    AM_DVD_CGMS_COPY_PERMITTED = &H00000000
    AM_DVD_CGMS_COPY_ONCE = &H00000010
    AM_DVD_CGMS_NO_COPY = &H00000018
    AM_DVD_COPYRIGHT_MASK = &H00000040
    AM_DVD_NOT_COPYRIGHTED = &H00000000
    AM_DVD_COPYRIGHTED = &H00000040
    AM_DVD_SECTOR_PROTECT_MASK = &H00000020
    AM_DVD_SECTOR_NOT_PROTECTED = &H00000000
    AM_DVD_SECTOR_PROTECTED = &H00000020
End Enum

' Public Enum AM_MPEG2Level
'     AM_MPEG2Level_Low = 1
'     AM_MPEG2Level_Main = 2
'     AM_MPEG2Level_High1440 = 3
'     AM_MPEG2Level_High = 4
' End Enum

Public Enum AMVideoSampleFlags
    AM_VIDEO_FLAG_FIELD_MASK = &H0003    ' use this mask to check whether the sample is field1 or field2 or frame
    AM_VIDEO_FLAG_INTERLEAVED_FRAME = &H0000     ' the sample is a frame (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
    AM_VIDEO_FLAG_FIELD1 = &H0001    ' the sample is field1 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
    AM_VIDEO_FLAG_FIELD2 = &H0002   ' the sample is the field2 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
    AM_VIDEO_FLAG_FIELD1FIRST = &H0004    ' if set means display field1 first, else display field2 first.
'  this bit is irrelavant for 1FieldPerSample mode
    AM_VIDEO_FLAG_WEAVE = &H0008    ' if set use bob display mode else weave
    AM_VIDEO_FLAG_IPB_MASK = &H0030    ' use this mask to check whether the sample is I, P or B
    AM_VIDEO_FLAG_I_SAMPLE = &H0000    ' I Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
    AM_VIDEO_FLAG_P_SAMPLE = &H0010    ' P Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
    AM_VIDEO_FLAG_B_SAMPLE = &H0020    ' B Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
    AM_VIDEO_FLAG_REPEAT_FIELD = &H0040    ' if set means display the field which has been displayed first again after displaying
'  both fields first. This bit is irrelavant for 1FieldPerSample mode
End Enum

Public Type AM_DvdKaraokeData
    dwDownmix As Long ' bitwise OR of AM_DvdKaraoke_Downmix flags
    dwSpeakerAssignment As Long ' AM_DvdKaraoke_SpeakerAssignment
End Type

Public Enum AM_PROPERTY_DVDKARAOKE
    AM_PROPERTY_DVDKARAOKE_ENABLE = 0 ' BOOL
    AM_PROPERTY_DVDKARAOKE_DATA = 1
End Enum

Public Enum AM_PROPERTY_TS_RATE_CHANGE
    AM_RATE_SimpleRateChange = 1 ' rw, use AM_SimpleRateChange
    AM_RATE_ExactRateChange = 2 ' rw, use AM_ExactRateChange
    AM_RATE_MaxFullDataRate = 3 ' r,  use AM_MaxFullDataRate
    AM_RATE_Step = 4 ' w,  use AM_Step
    AM_RATE_UseRateVersion = 5 '  w, use WORD
    AM_RATE_QueryFullFrameRate = 6 '  r, use AM_QueryRate
    AM_RATE_QueryLastRateSegPTS = 7 '  r, use REFERENCE_TIME
    AM_RATE_CorrectTS = 8 ' w,  use LONG
    AM_RATE_ReverseMaxFullDataRate = 9 ' r,  use AM_MaxFullDataRate
    AM_RATE_ResetOnTimeDisc = 10 ' rw, use DWORD - indicates supports new 'timeline reset on time discontinuity' sample
    AM_RATE_QueryMapping = 11
End Enum

Public Enum AM_PROPERTY_DVD_RATE_CHANGE
    AM_RATE_ChangeRate = 1 ' w,  use AM_DVD_ChangeRate
    AM_RATE_FullDataRateMax = 2 ' r,  use AM_MaxFullDataRate
    AM_RATE_ReverseDecode = 3 ' r,  use LONG
    AM_RATE_DecoderPosition = 4 ' r,  use AM_DVD_DecoderPosition
    AM_RATE_DecoderVersion = 5 ' r,  use LONG
End Enum

Public Type AM_SimpleRateChange
    ' this is the simplest mechanism to set a time stamp rate change on
    ' a filter (simplest for the person setting the rate change, harder
    ' for the filter doing the rate change).
    StartTime As LongLong 'REFERENCE_TIME 'stream time at which to start this rate
    Rate As Long 'new rate * 10000 (decimal)
End Type

Public Type AM_QueryRate
   lMaxForwardFullFrame As Long     '  rate * 10000
   lMaxReverseFullFrame As Long     '  rate * 10000
End Type

Public Type AM_ExactRateChange
    OutputZeroTime As LongLong 'REFERENCE_TIME 'input TS that maps to zero output TS
    Rate As Long 'new rate * 10000 (decimal)
End Type

Public Type AM_DVD_ChangeRate
    StartInTime As LongLong 'REFERENCE_TIME ' stream time (input) at which to start decoding at this rate
    StartOutTime As LongLong 'REFERENCE_TIME ' reference time (output) at which to start showing at this rate
    Rate As Long ' new rate * 10000 (decimal)
End Type

Public Enum DVD_PLAY_DIRECTION
    DVD_DIR_FORWARD = 0
    DVD_DIR_BACKWARD = 1
End Enum


'vidcap.h/.idl

Public Type KSTOPOLOGY_CONNECTION
    FromNode As Long
    FromNodePin As Long
    ToNode As Long
    ToNodePin As Long
End Type

'CameraUIControl.h/.idl

Public Enum CameraUIControlMode
    CUICM_Browse = 0
    CUICM_Linear
End Enum

Public Enum CameraUIControlLinearSelectionMode
    CUICLSM_Single = 0
    CUICLSM_Multiple
End Enum

Public Enum CameraUIControlCaptureMode
    CUICCM_PhotoOrVideo = 0
    CUICCM_Photo
    CUICCM_Video
End Enum

Public Enum CameraUIControlPhotoFormat
    CUICPF_Jpeg = 0
    CUICPF_Png
    CUICPF_JpegXR
End Enum

Public Enum CameraUIControlVideoFormat
    CUICVF_Mp4 = 0
    CUICVF_Wmv
End Enum

Public Enum CameraUIControlViewType
    CUICVT_SingleItem = 0
    CUICVT_ItemList
End Enum

Public Function CLSID_CameraUIControl() As UUID
'{52d6f586-9f0f-4824-8fc8-e32ca04930c2}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H52d6f586, CInt(&H9f0f), CInt(&H4824), &H8f, &Hc8, &He3, &H2c, &Ha0, &H49, &H30, &Hc2)
 CLSID_CameraUIControl = iid
End Function
Public Function IID_ICameraUIControlEventCallback() As UUID
'{1BFA0C2C-FBCD-4776-BDA4-88BF974E74F4}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1BFA0C2C, CInt(&HFBCD), CInt(&H4776), &HBD, &HA4, &H88, &HBF, &H97, &H4E, &H74, &HF4)
 IID_ICameraUIControlEventCallback = iid
End Function
Public Function IID_IICameraUIControl() As UUID
'{B8733ADF-3D68-4b8f-BB08-E28A0BED0376}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB8733ADF, CInt(&H3D68), CInt(&H4b8f), &HBB, &H08, &HE2, &H8A, &H0B, &HED, &H03, &H76)
 IID_IICameraUIControl = iid
End Function

'il21dec.h

Public Enum AM_LINE21_CCLEVEL ' should we use TC1, TC2 in stead?
    AM_L21_CCLEVEL_TC2 = 0
End Enum
Public Enum AM_LINE21_CCSERVICE
    AM_L21_CCSERVICE_None = 0
    AM_L21_CCSERVICE_Caption1
    AM_L21_CCSERVICE_Caption2
    AM_L21_CCSERVICE_Text1
    AM_L21_CCSERVICE_Text2
    AM_L21_CCSERVICE_XDS
    AM_L21_CCSERVICE_DefChannel = 10
    AM_L21_CCSERVICE_Invalid
End Enum
Public Enum AM_LINE21_CCSTATE
    AM_L21_CCSTATE_Off = 0
    AM_L21_CCSTATE_On
End Enum
Public Enum AM_LINE21_CCSTYLE
    AM_L21_CCSTYLE_None = 0
    AM_L21_CCSTYLE_PopOn
    AM_L21_CCSTYLE_PaintOn
    AM_L21_CCSTYLE_RollUp
End Enum

Public Enum AM_LINE21_DRAWBGMODE
    AM_L21_DRAWBGMODE_Opaque
    AM_L21_DRAWBGMODE_Transparent
End Enum

'iwstdec.h
Public Type AM_WST_PAGE
    dwPageNr As Long
    dwSubPageNr As Long
    pucPageData As LongPtr 'BYTE    *
End Type
Public Enum AM_WST_LEVEL
    AM_WST_LEVEL_1_5 = 0
End Enum
Public Enum AM_WST_SERVICE
    AM_WST_SERVICE_None = 0
    AM_WST_SERVICE_Text
    AM_WST_SERVICE_IDS
    AM_WST_SERVICE_Invalid
End Enum
Public Enum AM_WST_STATE
    AM_WST_STATE_Off = 0
    AM_WST_STATE_On = 1
End Enum
Public Enum AM_WST_STYLE
    AM_WST_STYLE_None = 0
    AM_WST_STYLE_Invers = 1
End Enum
Public Enum AM_WST_DRAWBGMODE
    AM_WST_DRAWBGMODE_Opaque = 0
    AM_WST_DRAWBGMODE_Transparent = 1
End Enum

'dvdif.idl

Public Enum DVD_DOMAIN
    '  The DVD_DOMAIN is used to indicate the stat of a DVD player.
    DVD_DOMAIN_FirstPlay = 1 ' doing default initialization of a dvd disc
    DVD_DOMAIN_VideoManagerMenu = 2 ' displaying menus for whole disc
    DVD_DOMAIN_VideoTitleSetMenu = 3 ' displaying menus for current title set
    DVD_DOMAIN_Title = 4 ' displaying current title
    DVD_DOMAIN_Stop = 5 ' player is in stopped state
End Enum

Public Enum DVD_MENU_ID
    DVD_MENU_Title = 2 ' to choose a title from any VTS in a DVD-Video volume
    DVD_MENU_Root = 3 ' main menu for a specific VTS
    DVD_MENU_Subpicture = 4 ' to choose subpicture stream in a VTS
    DVD_MENU_Audio = 5 ' to choose audio stream in a VTS
    DVD_MENU_Angle = 6 ' to choose angle num in a VTS
    DVD_MENU_Chapter = 7 ' to choose a chapter in a VTS
    '  the Root menu always provides a means of getting to to Subpicture, Audio,
    '  Angle and Chapter menus if they exist.
End Enum

Public Enum DVD_DISC_SIDE
    DVD_SIDE_A = 1
    DVD_SIDE_B = 2
End Enum

Public Enum DVD_PREFERRED_DISPLAY_MODE
    '  DVD_PREFERRED_DISPLAY_MODE is used to indicate the user's
    '  preferred window aspect ratio and preferred method of converion of
    '  16*9 content to a 4*3 window aspect ratio.  Pan-scan and letterboxing are
    '  the two conversion methods.  This enum is used to indicate only a preference of
    '  conversion mechinism since some content can only be converted using one
    '  of these methods.  4*3 content is converted to a 16*9 window always by using
    '  "reverse" letterboxing where black bars are added to the right and left
    '  sides of the display instead of the top and bottom of the display as in the 16*9
    '  to 4*3 conversion useing letterboxing.
    DISPLAY_CONTENT_DEFAULT = 0 ' default to content
    DISPLAY_16x9 = 1 ' 16x9 display
    DISPLAY_4x3_PANSCAN_PREFERRED = 2 ' 4x3 display with pan-scan preferrence
    DISPLAY_4x3_LETTERBOX_PREFERRED = 3 ' 4x3 display with letterbox preferrence
End Enum

' typedef WORD DVD_REGISTER;
' typedef DVD_REGISTER    GPRMARRAY[16]; // DVD-Video 1.0 has 16 16-bit General Parameter Registers
' typedef DVD_REGISTER    SPRMARRAY[24]; // DVD-Video 1.0 has 24 16-bit System Parameter Registers

Public Type GPRMARRAY
    data(0 To 15) As Integer
End Type
Public Type SPRMARRAY
    data(0 To 23) As Integer
End Type

Public Type DVD_ATR
    ' Refer to the DVD-Video 1.0 spec to parse these structures.
    ulCAT As Long ' VMG_CAT if this is for a volume; or VTS_CAT 
    '      if this is for a Video Title Set (VTS)
    pbATRI(0 To 767) As Byte ' All stream attributes for menu and title from bytes
    '      256 to 1023 of VMGI or VTSI.
End Type

' typedef BYTE DVD_VideoATR[2];   // video stream attributes.
' typedef BYTE DVD_AudioATR[8];   // audio stream attributes.
' typedef BYTE DVD_SubpictureATR[6]; // subpicture stream attributes.
Public Type DVD_VideoATR
    data(0 To 1) As Byte
End Type
Public Type DVD_AudioATR
    data(0 To 7) As Byte
End Type
Public Type DVD_SubpictureATR
    data(0 To 5) As Byte
End Type

Public Enum DVD_FRAMERATE
    DVD_FPS_25 = 1 ' 25 frames per second
    DVD_FPS_30NonDrop = 3 ' exactly 30 frames per second
End Enum

Public Type DVD_TIMECODE
    ' ULONG Hours1    :4; // Hours
    ' ULONG Hours10  :4; // Tens of Hours 

    ' ULONG Minutes1  :4; // Minutes 
    ' ULONG Minutes10:4; // Tens of Minutes 

    ' ULONG Seconds1  :4; // Seconds 
    ' ULONG Seconds10:4; // Tens of Seconds 

    ' ULONG Frames1   :4; // Frames 
    ' ULONG Frames10 :2; // Tens of Frames 

    ' ULONG FrameRateCode: 2; // use DVD_FRAMERATE to indicate frames/sec and drop/non-drop
    Hours As Byte
    Minutes As Byte
    Seconds As Byte
    FramesAndRateCode As Byte
End Type

Public Enum DVD_NavCmdType
    DVD_NavCmdType_Pre = 1
    DVD_NavCmdType_Post = 2
    DVD_NavCmdType_Cell = 3
    DVD_NavCmdType_Button = 4
End Enum

Public Enum DVD_TIMECODE_FLAGS
    DVD_TC_FLAG_25fps = &H00000001 ' 25 frames per second
    DVD_TC_FLAG_30fps = &H00000002 ' 30 frames per second
    DVD_TC_FLAG_DropFrame = &H00000004 ' 29.97 instead of 30 fps
    DVD_TC_FLAG_Interpolated = &H00000008 ' timecode may be inaccurate
    '  remainder of bits are reserved and should not be read
End Enum

Public Type DVD_HMSF_TIMECODE
    bHours As Byte
    bMinutes As Byte
    bSeconds As Byte
    bFrames As Byte
End Type

Public Type DVD_PLAYBACK_LOCATION2
    ' TitleNum & ChapterNum or TitleNum & TimeCode are sufficient to save
    ' playback location for One_Sequential_PGC_Titles.
    TitleNum As Long ' title number for whole disc (TTN not VTS_TTN)
    ChapterNum As Long ' part-of-title number with title. 0xffffffff if not Once_Sequential_PGC_Title
    TimeCode As DVD_HMSF_TIMECODE ' use DVD_TIMECODE for current playback time.
    TimeCodeFlags As DVD_TIMECODE_FLAGS ' union of DVD_TIMECODE_EVENT_FLAGS
End Type

Public Type DVD_PLAYBACK_LOCATION
    ' TitleNum & ChapterNum or TitleNum & TimeCode are sufficient to save
    ' playback location for One_Sequential_PGC_Titles.
    TitleNum As Long ' title number for whole disc (TTN not VTS_TTN)
    ChapterNum As Long ' part-of-title number with title. 0xffffffff if not Once_Sequential_PGC_Title
    TimeCode As Long ' use DVD_TIMECODE for current playback time. 0xffffffff if not Once_Sequential_PGC_Title
End Type

Public Enum VALID_UOP_FLAG
    ' 
    '  Annex J User Functions ---
    ' 
    UOP_FLAG_Play_Title_Or_AtTime = &H00000001 ' Title_Or_Time_Play
    UOP_FLAG_Play_Chapter = &H00000002 ' Chapter_Search_Or_Play
    UOP_FLAG_Play_Title = &H00000004 ' Title_Play
    UOP_FLAG_Stop = &H00000008 ' Stop
    UOP_FLAG_ReturnFromSubMenu = &H00000010 ' GoUp
    UOP_FLAG_Play_Chapter_Or_AtTime = &H00000020 ' Time_Or_Chapter_Search
    UOP_FLAG_PlayPrev_Or_Replay_Chapter = &H00000040 ' Prev_Or_Top_PG_Search
    UOP_FLAG_PlayNext_Chapter = &H00000080 ' Next_PG_Search
    UOP_FLAG_Play_Forwards = &H00000100 ' Forward_Scan
    UOP_FLAG_Play_Backwards = &H00000200 ' Backward_Scan
    UOP_FLAG_ShowMenu_Title = &H00000400 ' Title_Menu_Call
    UOP_FLAG_ShowMenu_Root = &H00000800 ' Root_Menu_Call
    UOP_FLAG_ShowMenu_SubPic = &H00001000 ' SubPic_Menu_Call
    UOP_FLAG_ShowMenu_Audio = &H00002000 ' Audio_Menu_Call
    UOP_FLAG_ShowMenu_Angle = &H00004000 ' Angle_Menu_Call
    UOP_FLAG_ShowMenu_Chapter = &H00008000& ' Chapter_Menu_Call
    UOP_FLAG_Resume = &H00010000 ' Resume
    UOP_FLAG_Select_Or_Activate_Button = &H00020000 ' Button_Select_Or_Activate
    UOP_FLAG_Still_Off = &H00040000 ' Still_Off
    UOP_FLAG_Pause_On = &H00080000 ' Pause_On
    UOP_FLAG_Select_Audio_Stream = &H00100000 ' Audio_Stream_Change
    UOP_FLAG_Select_SubPic_Stream = &H00200000 ' SubPic_Stream_Change
    UOP_FLAG_Select_Angle = &H00400000 ' Angle_Change
    UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode = &H00800000 ' Karaoke_Audio_Pres_Mode_Change
    UOP_FLAG_Select_Video_Mode_Preference = &H01000000 ' Video_Pres_Mode_Change
End Enum

Public Enum DVD_CMD_FLAGS
    DVD_CMD_FLAG_None = &H00000000
    DVD_CMD_FLAG_Flush = &H00000001
    DVD_CMD_FLAG_SendEvents = &H00000002
    DVD_CMD_FLAG_Block = &H00000004 ' block end
    DVD_CMD_FLAG_StartWhenRendered = &H00000008 ' command "start" when the first frame is rendered
    DVD_CMD_FLAG_EndAfterRendered = &H00000010 ' command "ends" after the last frame is rendered
End Enum

Public Enum DVD_OPTION_FLAG
    DVD_ResetOnStop = 1 ' default TRUE
    DVD_NotifyParentalLevelChange = 2 ' default FALSE
    DVD_HMSF_TimeCodeEvents = 3 ' default FALSE (send DVD_CURRENT_TIME events)
    DVD_AudioDuringFFwdRew = 4 ' default FALSE (or by reg)
    DVD_EnableNonblockingAPIs = 5 ' default FALSE
    DVD_CacheSizeInMB = 6 ' default FALSE (or by reg)
    DVD_EnablePortableBookmarks = 7 ' default FALSE
    DVD_EnableExtendedCopyProtectErrors = 8 ' default FALSE
    DVD_NotifyPositionChange = 9 ' default FALSE
    DVD_IncreaseOutputControl = 10 ' default FALSE
    DVD_EnableStreaming = 11 ' default TRUE
    DVD_EnableESOutput = 12 ' default FALSE
    DVD_EnableTitleLength = 13 ' default FALSE, report title length in VideoAttributes
    DVD_DisableStillThrottle = 14 ' default FALSE, disable app throttling during still menus
    DVD_EnableLoggingEvents = 15 ' default FALSE
    DVD_MaxReadBurstInKB = 16
    DVD_ReadBurstPeriodInMS = 17
    DVD_RestartDisc = 18
    DVD_EnableCC = 19
End Enum

Public Enum DVD_RELATIVE_BUTTON
    DVD_Relative_Upper = 1
    DVD_Relative_Lower = 2
    DVD_Relative_Left = 3
    DVD_Relative_Right = 4
End Enum

Public Enum DVD_PARENTAL_LEVEL
    DVD_PARENTAL_LEVEL_8 = &H8000&
    DVD_PARENTAL_LEVEL_7 = &H4000
    DVD_PARENTAL_LEVEL_6 = &H2000
    DVD_PARENTAL_LEVEL_5 = &H1000
    DVD_PARENTAL_LEVEL_4 = &H0800
    DVD_PARENTAL_LEVEL_3 = &H0400
    DVD_PARENTAL_LEVEL_2 = &H0200
    DVD_PARENTAL_LEVEL_1 = &H0100
End Enum

Public Enum DVD_AUDIO_LANG_EXT
    DVD_AUD_EXT_NotSpecified = 0
    DVD_AUD_EXT_Captions = 1
    DVD_AUD_EXT_VisuallyImpaired = 2
    DVD_AUD_EXT_DirectorComments1 = 3
    DVD_AUD_EXT_DirectorComments2 = 4
End Enum

Public Enum DVD_SUBPICTURE_LANG_EXT
    DVD_SP_EXT_NotSpecified = 0
    DVD_SP_EXT_Caption_Normal = 1
    DVD_SP_EXT_Caption_Big = 2
    DVD_SP_EXT_Caption_Children = 3
    DVD_SP_EXT_CC_Normal = 5
    DVD_SP_EXT_CC_Big = 6
    DVD_SP_EXT_CC_Children = 7
    DVD_SP_EXT_Forced = 9
    DVD_SP_EXT_DirectorComments_Normal = 13
    DVD_SP_EXT_DirectorComments_Big = 14
    DVD_SP_EXT_DirectorComments_Children = 15
End Enum

Public Enum DVD_AUDIO_APPMODE
    DVD_AudioMode_None = 0 ' no special mode
    DVD_AudioMode_Karaoke = 1
    DVD_AudioMode_Surround = 2
    DVD_AudioMode_Other = 3
End Enum

Public Enum DVD_AUDIO_FORMAT
    DVD_AudioFormat_AC3 = 0
    DVD_AudioFormat_MPEG1 = 1
    DVD_AudioFormat_MPEG1_DRC = 2 ' MPEG1 with dynamic range control
    DVD_AudioFormat_MPEG2 = 3
    DVD_AudioFormat_MPEG2_DRC = 4 ' MPEG2 with dynamic range control
    DVD_AudioFormat_LPCM = 5
    DVD_AudioFormat_DTS = 6
    DVD_AudioFormat_SDDS = 7
    DVD_AudioFormat_Other = 8
End Enum

Public Enum DVD_KARAOKE_DOWNMIX
    DVD_Mix_0to0 = &H0001 ' unused - reserved for future use
    DVD_Mix_1to0 = &H0002 ' unused - reserved for future use
    DVD_Mix_2to0 = &H0004
    DVD_Mix_3to0 = &H0008
    DVD_Mix_4to0 = &H0010
    DVD_Mix_Lto0 = &H0020 ' mix auxillary L to channel 0 (left speaker)
    DVD_Mix_Rto0 = &H0040 ' mix auxillary R to channel 0 (left speaker)
    DVD_Mix_0to1 = &H0100 ' unused - reserved for future use
    DVD_Mix_1to1 = &H0200 ' unused - reserved for future use
    DVD_Mix_2to1 = &H0400
    DVD_Mix_3to1 = &H0800
    DVD_Mix_4to1 = &H1000
    DVD_Mix_Lto1 = &H2000 ' mix auxillary L to channel 1 (right speaker)
    DVD_Mix_Rto1 = &H4000 ' mix auxillary R to channel 1 (right speaker)
End Enum

Public Type DVD_AudioAttributes
    AppMode As DVD_AUDIO_APPMODE
    AppModeData As Byte
    AudioFormat As DVD_AUDIO_FORMAT ' Use GetKaraokeAttributes()
    Language As Long ' 0 if no language is present
    LanguageExtension As DVD_AUDIO_LANG_EXT ' (captions, if for children etc)
    fHasMultichannelInfo As BOOL ' multichannel attributes are present (Use GetMultiChannelAudioAttributes())
    dwFrequency As Long ' in hertz (48k, 96k)
    bQuantization As Byte ' resolution (16, 20, 24 bits etc), 0 is unknown
    bNumberOfChannels As Byte ' 5.1 AC3 has 6 channels
    dwReserved(0 To 1) As Long
End Type

Public Type DVD_MUA_MixingInfo
    ' surround sound mixing information applied when:
    ' AppMode = DVD_AudioMode_Surround
    ' AudioFormat = DVD_AudioFormat_LPCM,
    ' fHasMultichannelInfo=1 modes are all on
    fMixTo0 As BOOL
    fMixTo1 As BOOL
    fMix0InPhase As BOOL
    fMix1InPhase As BOOL
    dwSpeakerPosition As Long ' see ksmedia.h: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT, etc
End Type

Public Type DVD_MUA_Coeff
    log2_alpha As Double ' actual coeff = 2^alpha
    log2_beta As Double ' actual coeff = 2^beta
End Type

Public Type DVD_MultichannelAudioAttributes
    ' actual Data for each data stream
    Info(0 To 7) As DVD_MUA_MixingInfo
    Coeff(0 To 7) As DVD_MUA_Coeff
End Type

Public Enum DVD_KARAOKE_CONTENTS
    DVD_Karaoke_GuideVocal1 = &H0001
    DVD_Karaoke_GuideVocal2 = &H0002
    DVD_Karaoke_GuideMelody1 = &H0004
    DVD_Karaoke_GuideMelody2 = &H0008
    DVD_Karaoke_GuideMelodyA = &H0010
    DVD_Karaoke_GuideMelodyB = &H0020
    DVD_Karaoke_SoundEffectA = &H0040
    DVD_Karaoke_SoundEffectB = &H0080
End Enum

Public Enum DVD_KARAOKE_ASSIGNMENT
    DVD_Assignment_reserved0 = 0
    DVD_Assignment_reserved1 = 1
    DVD_Assignment_LR = 2 ' left right
    DVD_Assignment_LRM = 3 ' left right middle
    DVD_Assignment_LR1 = 4 ' left right audio1
    DVD_Assignment_LRM1 = 5 ' left right middle audio1
    DVD_Assignment_LR12 = 6 ' left right audio1 audio2
    DVD_Assignment_LRM12 = 7 ' left right middle audio1 audio2
End Enum

Public Type DVD_KaraokeAttributes
    bVersion As Byte
    fMasterOfCeremoniesInGuideVocal1 As BOOL
    fDuet As BOOL ' false = solo
    ChannelAssignment As DVD_KARAOKE_ASSIGNMENT
    wChannelContents(0 To 7) As Integer ' logical OR of DVD_KARAOKE_CONTENTS  
End Type

Public Enum DVD_VIDEO_COMPRESSION
    DVD_VideoCompression_Other = 0
    DVD_VideoCompression_MPEG1 = 1
    DVD_VideoCompression_MPEG2 = 2
End Enum

Public Type DVD_VideoAttributes
    fPanscanPermitted As BOOL ' if a 4x3 display, can be shown as PanScan
    fLetterboxPermitted As BOOL ' if a 4x3 display, can be shown as Letterbox
    ulAspectX As Long ' 4x3 or 16x9
    ulAspectY As Long
    ulFrameRate As Long ' 50hz or 60hz
    ulFrameHeight As Long ' 525 (60hz) or 625 (50hz)
    Compression As DVD_VIDEO_COMPRESSION ' MPEG1 or MPEG2
    fLine21Field1InGOP As BOOL ' true if there is user data in field 1 of GOP of video stream
    fLine21Field2InGOP As BOOL ' true if there is user data in field 1 of GOP of video stream
    ulSourceResolutionX As Long ' X source resolution (352,704, or 720)
    ulSourceResolutionY As Long ' Y source resolution (240,480, 288 or 576)
    fIsSourceLetterboxed As BOOL ' subpictures and highlights (e.g. subtitles or menu buttons) are only
    ' displayed in the active video area and cannot be displayed in the top/bottom 'black' bars
    fIsFilmMode As BOOL ' for 625/50hz systems, is film mode (true) or camera mode (false) 
End Type

Public Enum DVD_SUBPICTURE_TYPE
    DVD_SPType_NotSpecified = 0
    DVD_SPType_Language = 1
    DVD_SPType_Other = 2
End Enum

Public Enum DVD_SUBPICTURE_CODING
    DVD_SPCoding_RunLength = 0
    DVD_SPCoding_Extended = 1
    DVD_SPCoding_Other = 2
End Enum

Public Type DVD_SubpictureAttributes
    Type As DVD_SUBPICTURE_TYPE
    CodingMode As DVD_SUBPICTURE_CODING
    Language As Long
    LanguageExtension As DVD_SUBPICTURE_LANG_EXT
End Type

Public Enum DVD_TITLE_APPMODE
    DVD_AppMode_Not_Specified = 0 ' no special mode
    DVD_AppMode_Karaoke = 1
    DVD_AppMode_Other = 3
End Enum

Public Type DVD_TitleAttributes
    ' for Titles
    'union {
    'DVD_TITLE_APPMODE           AppMode;
    'DVD_HMSF_TIMECODE           TitleLength;
    '};
    AppNodeOrTitleLength As Long
    ' Attributes about the 'main' video of the menu or title
    VideoAttributes As DVD_VideoAttributes
    ulNumberOfAudioStreams As Long
    AudioAttributes(0 To 7) As DVD_AudioAttributes
    ' present if the multichannel bit is set in the corresponding stream's audio attributes
    MultichannelAudioAttributes(0 To 7) As DVD_MultichannelAudioAttributes
    ulNumberOfSubpictureStreams As Long
    SubpictureAttributes(0 To 31) As DVD_SubpictureAttributes
End Type

Public Type DVD_MenuAttributes
    ' for VMG only
    fCompatibleRegion(0 To 7) As BOOL ' indeces 0..7 correspond to regions 1..8
    ' Attributes about the main menu (VMGM or VTSM)
    VideoAttributes As DVD_VideoAttributes
    fAudioPresent As BOOL
    AudioAttributes As DVD_AudioAttributes
    fSubpicturePresent As BOOL
    SubpictureAttributes As DVD_SubpictureAttributes
End Type














Public Enum DVD_TextStringType
    '  disc structure (0x00..0x0f)
    DVD_Struct_Volume = &H01
    DVD_Struct_Title = &H02
    DVD_Struct_ParentalID = &H03
    DVD_Struct_PartOfTitle = &H04
    DVD_Struct_Cell = &H05
    '  stream (0x10..0x1f)
    DVD_Stream_Audio = &H10
    DVD_Stream_Subpicture = &H11
    DVD_Stream_Angle = &H12
    '  channel in stream (0x20..0x2f)
    DVD_Channel_Audio = &H20
    '  Application information
    '  General (0x30..0x37)
    DVD_General_Name = &H30
    DVD_General_Comments = &H31
    '  Title (0x38..0x3f)
    DVD_Title_Series = &H38
    DVD_Title_Movie = &H39
    DVD_Title_Video = &H3a
    DVD_Title_Album = &H3b
    DVD_Title_Song = &H3c
    DVD_Title_Other = &H3f
    '  Title (sub) (0x40..0x47)
    DVD_Title_Sub_Series = &H40
    DVD_Title_Sub_Movie = &H41
    DVD_Title_Sub_Video = &H42
    DVD_Title_Sub_Album = &H43
    DVD_Title_Sub_Song = &H44
    DVD_Title_Sub_Other = &H47
    '  Title (original) (0x48..0x4f)
    DVD_Title_Orig_Series = &H48
    DVD_Title_Orig_Movie = &H49
    DVD_Title_Orig_Video = &H4a
    DVD_Title_Orig_Album = &H4b
    DVD_Title_Orig_Song = &H4c
    DVD_Title_Orig_Other = &H4f
    '  Other info (0x50..0x57)
    DVD_Other_Scene = &H50
    DVD_Other_Cut = &H51
    DVD_Other_Take = &H52
    '  Language     0x58..0x5b
    '  Work         0x5c..0x6b
    '  Character    0x6c..0x8f
    '  Data         0x90..0x93
    '  Karaoke      0x94..0x9b
    '  Category     0x9c..0x9f
    '  Lyrics       0xa0..0xa3
    '  Document     0xa4..0xa7
    '  Others       0xa8..0xab
    '  Reserved     0xac..0xaf
    '  Admin        0xb0..0xb7
    '  more admin   0xb8..0xc0
    '  Reserved     0xd0..0xdf
    '  vendor       0xe0..0xef
    '  extension    0xf0..0xf7
    '  reserved     0xf8..0xff
End Enum

Public Enum DVD_TextCharSet
    DVD_CharSet_Unicode = 0
    DVD_CharSet_ISO646 = 1
    DVD_CharSet_JIS_Roman_Kanji = 2
    DVD_CharSet_ISO8859_1 = 3
    DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana = 4
End Enum

Public Const DVD_TITLE_MENU  = &H000
Public Const DVD_STREAM_DATA_CURRENT  = &H800
Public Const DVD_STREAM_DATA_VMGM  = &H400
Public Const DVD_STREAM_DATA_VTSM  = &H401
Public Const DVD_DEFAULT_AUDIO_STREAM  = &H0f

 
Public Type DVD_DECODER_CAPS
    dwSize As Long
    dwAudioCaps As DShowDVDAudioCaps
    dFwdMaxRateVideo As Double
    dFwdMaxRateAudio As Double
    dFwdMaxRateSP As Double
    dBwdMaxRateVideo As Double
    dBwdMaxRateAudio As Double
    dBwdMaxRateSP As Double
    dwRes1 As Long
    dwRes2 As Long
    dwRes3 As Long
    dwRes4 As Long
End Type

Public Enum DShowDVDAudioCaps
    DVD_AUDIO_CAPS_AC3 = &H00000001
    DVD_AUDIO_CAPS_MPEG2 = &H00000002
    DVD_AUDIO_CAPS_LPCM = &H00000004
    DVD_AUDIO_CAPS_DTS = &H00000008
    DVD_AUDIO_CAPS_SDDS = &H00000010
End Enum

Public Enum AM_DVD_GRAPH_FLAGS
    AM_DVD_HWDEC_PREFER = &H01 ' default
    AM_DVD_HWDEC_ONLY = &H02
    AM_DVD_SWDEC_PREFER = &H04
    AM_DVD_SWDEC_ONLY = &H08
    AM_DVD_NOVPE = &H100
    AM_DVD_DO_NOT_CLEAR = &H200 ' do not clear graph before building
    AM_DVD_VMR9_ONLY = &H0800 ' only use VMR9 (otherwise fail) for rendering
    AM_DVD_EVR_ONLY = &H1000 ' only use EVR (otherwise fail) for rendering
    AM_DVD_EVR_QOS = &H2000 ' Enabled EVR Dynamic QoS
    AM_DVD_ADAPT_GRAPH = &H4000 ' Adapt graph building to machine capbilities
    AM_DVD_MASK = &Hffff& ' only lower WORD is used/allowed
End Enum

Public Enum AM_DVD_STREAM_FLAGS
    AM_DVD_STREAM_VIDEO = &H01
    AM_DVD_STREAM_AUDIO = &H02
    AM_DVD_STREAM_SUBPIC = &H04
End Enum

Public Type AM_DVD_RENDERSTATUS
    hrVPEStatus As Long ' VPE mixing error code (0 => success)
    bDvdVolInvalid As BOOL ' Is specified DVD volume invalid?
    bDvdVolUnknown As BOOL ' Is DVD volume to be played not specified/not found?
    bNoLine21In As BOOL ' video decoder doesn't produce line21 (CC) data
    bNoLine21Out As BOOL ' can't show decoded line21 data as CC on video
    iNumStreams As Long ' number of DVD streams to render
    iNumStreamsFailed As Long ' number of streams failed to render
    dwFailedStreamsFlag As Long ' combination of flags to indicate failed streams
End Type

Public Enum _AM_OVERLAY_NOTIFY_FLAGS
    AM_OVERLAY_NOTIFY_VISIBLE_CHANGE = &H00000001
    AM_OVERLAY_NOTIFY_SOURCE_CHANGE = &H00000002
    AM_OVERLAY_NOTIFY_DEST_CHANGE = &H00000004
End Enum

Public Function DMOCATEGORY_AUDIO_DECODER() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H57f2db8b, &He6bb, &H4513, &H9d, &H43, &Hdc, &Hd2, &Ha6, &H59, &H31, &H25)
DMOCATEGORY_AUDIO_DECODER = iid
End Function
Public Function DMOCATEGORY_AUDIO_ENCODER() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33D9A761, &H90C8, &H11d0, &HBD, &H43, &H00, &HA0, &HC9, &H11, &HCE, &H86)
DMOCATEGORY_AUDIO_ENCODER = iid
End Function
Public Function DMOCATEGORY_VIDEO_DECODER() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4a69b442, &H28be, &H4991, &H96, &H9c, &Hb5, &H00, &Had, &Hf5, &Hd8, &Ha8)
DMOCATEGORY_VIDEO_DECODER = iid
End Function
Public Function DMOCATEGORY_VIDEO_ENCODER() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33D9A760, &H90C8, &H11d0, &HBD, &H43, &H00, &HA0, &HC9, &H11, &HCE, &H86)
DMOCATEGORY_VIDEO_ENCODER = iid
End Function
Public Function DMOCATEGORY_AUDIO_EFFECT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hf3602b3f, &H0592, &H48df, &Ha4, &Hcd, &H67, &H47, &H21, &He7, &Heb, &Heb)
DMOCATEGORY_AUDIO_EFFECT = iid
End Function
Public Function DMOCATEGORY_VIDEO_EFFECT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hd990ee14, &H776c, &H4723, &Hbe, &H46, &H3d, &Ha2, &Hf5, &H6f, &H10, &Hb9)
DMOCATEGORY_VIDEO_EFFECT = iid
End Function
Public Function DMOCATEGORY_AUDIO_CAPTURE_EFFECT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hf665aaba, &H3e09, &H4920, &Haa, &H5f, &H21, &H98, &H11, &H14, &H8f, &H09)
DMOCATEGORY_AUDIO_CAPTURE_EFFECT = iid
End Function
Public Function DMOCATEGORY_ACOUSTIC_ECHO_CANCEL() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HBF963D80, &HC559, &H11D0, &H8A, &H2B, &H00, &HA0, &HC9, &H25, &H5A, &HC1)
DMOCATEGORY_ACOUSTIC_ECHO_CANCEL = iid
End Function
Public Function DMOCATEGORY_AUDIO_NOISE_SUPPRESS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He07f903f, &H62fd, &H4e60, &H8c, &Hdd, &Hde, &Ha7, &H23, &H66, &H65, &Hb5)
DMOCATEGORY_AUDIO_NOISE_SUPPRESS = iid
End Function
Public Function DMOCATEGORY_AGC() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE88C9BA0, &HC557, &H11D0, &H8A, &H2B, &H00, &HA0, &HC9, &H25, &H5A, &HC1)
DMOCATEGORY_AGC = iid
End Function

Public Type DMO_PARTIAL_MEDIATYPE
    type As UUID
    subtype As UUID
End Type
Public Enum DMO_REGISTER_FLAGS
    DMO_REGISTERF_IS_KEYED = &H00000001
End Enum

Public Enum DMO_ENUM_FLAGS
    DMO_ENUMF_INCLUDE_KEYED = &H00000001
End Enum


[UseGetLastError(False)]
Public DeclareWide PtrSafe Function DMORegister Lib "msdmo.dll" (ByVal szName As String, clsidDMO As UUID, guidCategory As UUID, ByVal dwFlags As DMO_REGISTER_FLAGS, ByVal cInTypes As Long, pInTypes As DMO_PARTIAL_MEDIATYPE, ByVal cOutTypes As Long, pOutTypes As DMO_PARTIAL_MEDIATYPE) As Long
[UseGetLastError(False)]
Public DeclareWide PtrSafe Function DMOUnregister Lib "msdmo.dll" (clsidDMO As UUID, guidCategory As UUID) As Long
[UseGetLastError(False)]
Public DeclareWide PtrSafe Function DMOEnum Lib "msdmo.dll" (guidCategory As UUID, ByVal dwFlags As DMO_ENUM_FLAGS, ByVal cInTypes As Long, pInTypes As DMO_PARTIAL_MEDIATYPE, ByVal cOutTypes As Long, pOutTypes As DMO_PARTIAL_MEDIATYPE, ppEnum As IEnumDMO) As Long
[UseGetLastError(False)]
Public DeclareWide PtrSafe Function DMOGetTypes Lib "msdmo.dll" (clsidDMO As UUID, ByVal ulInputTypesRequested As Long, pulInputTypesSupplied As Long, pInputTypes As DMO_PARTIAL_MEDIATYPE, ByVal ulOutputTypesRequested As Long, pulOutputTypesSupplied As Long, pOutputTypes As DMO_PARTIAL_MEDIATYPE) As Long
[UseGetLastError(False)]
Public DeclareWide PtrSafe Function DMOGetName Lib "msdmo.dll" (clsidDMO As UUID, ByVal szName As String) As Long





Public Enum MixerOcxStatusFlags
    MIXER_STATE_MASK = &H00000003  ' use this mask with state status bits
    MIXER_STATE_UNCONNECTED = &H00000000  ' mixer is unconnected and stopped
    MIXER_STATE_CONNECTED_STOPPED = &H00000001  ' mixer is connected and stopped
    MIXER_STATE_CONNECTED_PAUSED = &H00000002  ' mixer is connected and paused
    MIXER_STATE_CONNECTED_PLAYING = &H00000003  ' mixer is connected and playing
End Enum
Public Enum MixerOcxDataFlags
    MIXER_DATA_ASPECT_RATIO = &H00000001  ' picture aspect ratio changed
    MIXER_DATA_NATIVE_SIZE = &H00000002  ' native size of video changed
    MIXER_DATA_PALETTE = &H00000004  ' palette of video changed
End Enum

Public Function IID_IMixerOCXNotify() As UUID
'{81A3BD31-DEE1-11d1-8508-00A0C91F9CA0}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H81A3BD31, CInt(&HDEE1), CInt(&H11d1), &H85, &H08, &H00, &HA0, &HC9, &H1F, &H9C, &HA0)
 IID_IMixerOCXNotify = iid
End Function
Public Function IID_IMixerOCX() As UUID
'{81A3BD32-DEE1-11d1-8508-00A0C91F9CA0}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H81A3BD32, CInt(&HDEE1), CInt(&H11d1), &H85, &H08, &H00, &HA0, &HC9, &H1F, &H9C, &HA0)
 IID_IMixerOCX = iid
End Function

#Region "GUIDs"
Public Function CLSID_DirectDrawProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H944d4c00, &Hdd52, &H11ce, &Hbf, &H0e, &H00, &Haa, &H00, &H55, &H59, &H5a)
CLSID_DirectDrawProperties = iid
End Function
Public Function CLSID_PerformanceProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H59ce6880, &Hacf8, &H11cf, &Hb5, &H6e, &H00, &H80, &Hc7, &Hc4, &Hb6, &H8a)
CLSID_PerformanceProperties = iid
End Function
Public Function CLSID_QualityProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H418afb70, &Hf8b8, &H11ce, &Haa, &Hc6, &H00, &H20, &Haf, &H0b, &H99, &Ha3)
CLSID_QualityProperties = iid
End Function
Public Function IID_IBaseVideoMixer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H61ded640, &He912, &H11ce, &Ha0, &H99, &H00, &Haa, &H00, &H47, &H9a, &H58)
IID_IBaseVideoMixer = iid
End Function
Public Function IID_IDirectDrawVideo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H36d39eb0, &Hdd75, &H11ce, &Hbf, &H0e, &H00, &Haa, &H00, &H55, &H59, &H5a)
IID_IDirectDrawVideo = iid
End Function
Public Function IID_IQualProp() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1bd0ecb0, &Hf8e2, &H11ce, &Haa, &Hc6, &H00, &H20, &Haf, &H0b, &H99, &Ha3)
IID_IQualProp = iid
End Function
Public Function CLSID_VPObject() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hce292861, &Hfc88, &H11d0, &H9e, &H69, &H0, &Hc0, &H4f, &Hd7, &Hc1, &H5b)
CLSID_VPObject = iid
End Function
Public Function IID_IVPObject() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hce292862, &Hfc88, &H11d0, &H9e, &H69, &H0, &Hc0, &H4f, &Hd7, &Hc1, &H5b)
IID_IVPObject = iid
End Function
Public Function IID_IVPControl() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H25df12c1, &H3de0, &H11d1, &H9e, &H69, &H0, &Hc0, &H4f, &Hd7, &Hc1, &H5b)
IID_IVPControl = iid
End Function
Public Function CLSID_VPVBIObject() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H814b9801, &H1c88, &H11d1, &Hba, &Hd9, &H0, &H60, &H97, &H44, &H11, &H1a)
CLSID_VPVBIObject = iid
End Function
Public Function IID_IVPVBIObject() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H814b9802, &H1c88, &H11d1, &Hba, &Hd9, &H0, &H60, &H97, &H44, &H11, &H1a)
IID_IVPVBIObject = iid
End Function
Public Function IID_IVPConfig() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hbc29a660, &H30e3, &H11d0, &H9e, &H69, &H0, &Hc0, &H4f, &Hd7, &Hc1, &H5b)
IID_IVPConfig = iid
End Function
Public Function IID_IVPNotify() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hc76794a1, &Hd6c5, &H11d0, &H9e, &H69, &H0, &Hc0, &H4f, &Hd7, &Hc1, &H5b)
IID_IVPNotify = iid
End Function
Public Function IID_IVPNotify2() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hebf47183, &H8764, &H11d1, &H9e, &H69, &H0, &Hc0, &H4f, &Hd7, &Hc1, &H5b)
IID_IVPNotify2 = iid
End Function
Public Function IID_IDDVideoPortContainer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6C142760, &HA733, &H11CE, &HA5, &H21, &H00, &H20, &HAF, &H0B, &HE5, &H60)
 IID_IDDVideoPortContainer = iid
End Function
Public Function IID_IDirectDrawVideoPort() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB36D93E0, &H2B43, &H11CF, &HA2, &HDE, &H00, &HAA, &H00, &HB9, &H33, &H56)
 IID_IDirectDrawVideoPort = iid
End Function
Public Function IID_IDirectDrawVideoPortNotify() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HA655FB94, &H0589, &H4E57, &HB3, &H33, &H56, &H7A, &H89, &H46, &H8C, &H88)
 IID_IDirectDrawVideoPortNotify = iid
End Function
Public Function DDVPTYPE_E_HREFH_VREFH() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H54F39980, &HDA60, &H11CF, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
 DDVPTYPE_E_HREFH_VREFH = iid
End Function
Public Function DDVPTYPE_E_HREFH_VREFL() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H92783220, &HDA60, &H11CF, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
 DDVPTYPE_E_HREFH_VREFL = iid
End Function
Public Function DDVPTYPE_E_HREFL_VREFH() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HA07A02E0, &HDA60, &H11CF, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
 DDVPTYPE_E_HREFL_VREFH = iid
End Function
Public Function DDVPTYPE_E_HREFL_VREFL() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE09C77E0, &HDA60, &H11CF, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
 DDVPTYPE_E_HREFL_VREFL = iid
End Function
Public Function DDVPTYPE_CCIR656() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFCA326A0, &HDA60, &H11CF, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
 DDVPTYPE_CCIR656 = iid
End Function
Public Function DDVPTYPE_BROOKTREE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1352A560, &HDA61, &H11CF, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
 DDVPTYPE_BROOKTREE = iid
End Function
Public Function DDVPTYPE_PHILIPS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H332CF160, &HDA61, &H11CF, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
 DDVPTYPE_PHILIPS = iid
End Function


Public Function GUID_TIME_REFERENCE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H93ad712b, &Hdaa0, &H4ffe, &Hbc, &H81, &Hb0, &Hce, &H50, &Hf, &Hcd, &Hd9)
GUID_TIME_REFERENCE = iid
End Function
Public Function GUID_TIME_MUSIC() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H574c49d, &H5b04, &H4b15, &Ha5, &H42, &Hae, &H28, &H20, &H30, &H11, &H7b)
GUID_TIME_MUSIC = iid
End Function
Public Function GUID_TIME_SAMPLES() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Ha8593d05, &Hc43, &H4984, &H9a, &H63, &H97, &Haf, &H9e, &H2, &Hc4, &Hc0)
GUID_TIME_SAMPLES = iid
End Function


Public Function LIBID_QuartzNetTypeLib() As UUID
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B1, &HAD4, &H11CE, &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
LIBID_QuartzNetTypeLib = iid
End Function

Public Function CLSID_MP3DecoderDMO() As UUID
'{BBEEA841-0A63-4F52-A7AB-A9B3A84ED38A}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HBBEEA841, CInt(&HA63), CInt(&H4F52), &HA7, &HAB, &HA9, &HB3, &HA8, &H4E, &HD3, &H8A)
 CLSID_MP3DecoderDMO = iid
End Function

Public Function CLSID_CaptureGraphBuilder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HBF87B6E0, CInt(&H8C27), CInt(&H11D0), &HB3, &HF0, &H0, &HAA, &H0, &H37, &H61, &HC5)
 CLSID_CaptureGraphBuilder = iid
End Function

Public Function CLSID_CaptureGraphBuilder2() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HBF87B6E1, CInt(&H8C27), CInt(&H11D0), &HB3, &HF0, &H0, &HAA, &H0, &H37, &H61, &HC5)
 CLSID_CaptureGraphBuilder2 = iid
End Function

Public Function CLSID_ProtoFilterGraph() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB0, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_ProtoFilterGraph = iid
End Function

Public Function CLSID_SystemClock() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB1, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_SystemClock = iid
End Function

Public Function CLSID_FilterMapper() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB2, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_FilterMapper = iid
End Function

Public Function CLSID_FilterGraph() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB3, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_FilterGraph = iid
End Function

Public Function CLSID_FilterGraphNoThread() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB8, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_FilterGraphNoThread = iid
End Function

Public Function CLSID_FilterGraphPrivateThread() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HA3ECBC41, CInt(&H581A), CInt(&H4476), &HB6, &H93, &HA6, &H33, &H40, &H46, &H2D, &H8B)
 CLSID_FilterGraphPrivateThread = iid
End Function

Public Function CLSID_MPEG1Doc() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE4BBD160, CInt(&H4269), CInt(&H11CE), &H83, &H8D, &H0, &HAA, &H0, &H55, &H59, &H5A)
 CLSID_MPEG1Doc = iid
End Function

Public Function CLSID_FileSource() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H701722E0, CInt(&H8AE3), CInt(&H11CE), &HA8, &H5C, &H0, &HAA, &H0, &H2F, &HEA, &HB5)
 CLSID_FileSource = iid
End Function

Public Function CLSID_MPEG1PacketPlayer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H26C25940, CInt(&H4CA9), CInt(&H11CE), &HA8, &H28, &H0, &HAA, &H0, &H2F, &HEA, &HB5)
 CLSID_MPEG1PacketPlayer = iid
End Function

Public Function CLSID_MPEG1Splitter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H336475D0, CInt(&H942A), CInt(&H11CE), &HA8, &H70, &H0, &HAA, &H0, &H2F, &HEA, &HB5)
 CLSID_MPEG1Splitter = iid
End Function

Public Function CLSID_CMpegVideoCodec() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFEB50740, CInt(&H7BEF), CInt(&H11CE), &H9B, &HD9, &H0, &H0, &HE2, &H2, &H59, &H9C)
 CLSID_CMpegVideoCodec = iid
End Function

Public Function CLSID_CMpegAudioCodec() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4A2286E0, CInt(&H7BEF), CInt(&H11CE), &H9B, &HD9, &H0, &H0, &HE2, &H2, &H59, &H9C)
 CLSID_CMpegAudioCodec = iid
End Function

Public Function CLSID_TextRender() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE30629D3, CInt(&H27E5), CInt(&H11CE), &H87, &H5D, &H0, &H60, &H8C, &HB7, &H80, &H66)
 CLSID_TextRender = iid
End Function

Public Function CLSID_InfTee() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HF8388A40, CInt(&HD5BB), CInt(&H11D0), &HBE, &H5A, &H0, &H80, &HC7, &H6, &H56, &H8E)
 CLSID_InfTee = iid
End Function
 
Public Function CLSID_AviReader() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1B544C21, CInt(&HFD0B), CInt(&H11CE), &H8C, &H63, &H0, &HAA, &H0, &H44, &HB5, &H1E)
 CLSID_AviReader = iid
End Function

Public Function CLSID_VfwCapture() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1B544C22, CInt(&HFD0B), CInt(&H11CE), &H8C, &H63, &H0, &HAA, &H0, &H44, &HB5, &H1E)
 CLSID_VfwCapture = iid
End Function

Public Function CLSID_CaptureProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1B544C22, CInt(&HFD0B), CInt(&H11CE), &H8C, &H63, &H0, &HAA, &H0, &H44, &HB5, &H1F)
 CLSID_CaptureProperties = iid
End Function

Public Function CLSID_FGControl() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB4, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_FGControl = iid
End Function

Public Function CLSID_MOVReader() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H44584800, CInt(&HF8EE), CInt(&H11CE), &HB2, &HD4, &H0, &HDD, &H1, &H10, &H1B, &H85)
 CLSID_MOVReader = iid
End Function

Public Function CLSID_QuickTimeParser() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD51BD5A0, CInt(&H7548), CInt(&H11CF), &HA5, &H20, &H0, &H80, &HC7, &H7E, &HF5, &H8A)
 CLSID_QuickTimeParser = iid
End Function

Public Function CLSID_QTDec() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFDFE9681, CInt(&H74A3), CInt(&H11D0), &HAF, &HA7, &H0, &HAA, &H0, &HB6, &H7A, &H42)
 CLSID_QTDec = iid
End Function

Public Function CLSID_AVIDoc() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD3588AB0, CInt(&H781), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_AVIDoc = iid
End Function

Public Function CLSID_VideoRenderer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H70E102B0, CInt(&H5556), CInt(&H11CE), &H97, &HC0, &H0, &HAA, &H0, &H55, &H59, &H5A)
 CLSID_VideoRenderer = iid
End Function
Public Function CLSID_EnhancedVideoRenderer() As UUID
'{fa10746c-9b63-4b6c-bc49-fc300ea5f256}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfa10746c, CInt(&H9b63), CInt(&H4b6c), &Hbc, &H49, &Hfc, &H30, &H0e, &Ha5, &Hf2, &H56)
 CLSID_EnhancedVideoRenderer = iid
End Function
Public Function CLSID_VideoMixingRenderer9() As UUID
'{51B4ABF3-748F-4E3B-A276-C828330E926A}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H51B4ABF3, CInt(&H748F), CInt(&H4E3B), &HA2, &H76, &HC8, &H28, &H33, &H0E, &H92, &H6A)
 CLSID_VideoMixingRenderer9 = iid
End Function
Public Function CLSID_FilgraphManager() As UUID
'{E436EBB3-524F-11CE-9F53-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB3, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H00, &H20, &HAF, &H0B, &HA7, &H70)
 CLSID_FilgraphManager = iid
End Function

Public Function CLSID_Colour() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1643E180, CInt(&H90F5), CInt(&H11CE), &H97, &HD5, &H0, &HAA, &H0, &H55, &H59, &H5A)
 CLSID_Colour = iid
End Function

Public Function CLSID_Dither() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1DA08500, CInt(&H9EDC), CInt(&H11CF), &HBC, &H10, &H0, &HAA, &H0, &HAC, &H74, &HF6)
 CLSID_Dither = iid
End Function

Public Function CLSID_ModexRenderer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7167665, CInt(&H5011), CInt(&H11CF), &HBF, &H33, &H0, &HAA, &H0, &H55, &H59, &H5A)
 CLSID_ModexRenderer = iid
End Function

Public Function CLSID_AudioRender() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE30629D1, CInt(&H27E5), CInt(&H11CE), &H87, &H5D, &H0, &H60, &H8C, &HB7, &H80, &H66)
 CLSID_AudioRender = iid
End Function

Public Function CLSID_AudioProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H5589FAF, CInt(&HC356), CInt(&H11CE), &HBF, &H1, &H0, &HAA, &H0, &H55, &H59, &H5A)
 CLSID_AudioProperties = iid
End Function

Public Function CLSID_DSoundRender() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H79376820, CInt(&H7D0), CInt(&H11CF), &HA2, &H4D, &H0, &H20, &HAF, &HD7, &H97, &H67)
 CLSID_DSoundRender = iid
End Function

Public Function CLSID_AudioRecord() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE30629D2, CInt(&H27E5), CInt(&H11CE), &H87, &H5D, &H0, &H60, &H8C, &HB7, &H80, &H66)
 CLSID_AudioRecord = iid
End Function

Public Function CLSID_AudioInputMixerProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H2CA8CA52, CInt(&H3C3F), CInt(&H11D2), &HB7, &H3D, &H0, &HC0, &H4F, &HB6, &HBD, &H3D)
 CLSID_AudioInputMixerProperties = iid
End Function

Public Function CLSID_AVIDec() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCF49D4E0, CInt(&H1115), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_AVIDec = iid
End Function

Public Function CLSID_AVIDraw() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HA888DF60, CInt(&H1E90), CInt(&H11CF), &HAC, &H98, &H0, &HAA, &H0, &H4C, &HF, &HA9)
 CLSID_AVIDraw = iid
End Function

Public Function CLSID_ACMWrapper() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6A08CF80, CInt(&HE18), CInt(&H11CF), &HA2, &H4D, &H0, &H20, &HAF, &HD7, &H97, &H67)
 CLSID_ACMWrapper = iid
End Function

Public Function CLSID_AsyncReader() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB5, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_AsyncReader = iid
End Function

Public Function CLSID_URLReader() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB6, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_URLReader = iid
End Function

Public Function CLSID_PersistMonikerPID() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE436EBB7, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
 CLSID_PersistMonikerPID = iid
End Function

Public Function CLSID_AVICo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD76E2820, CInt(&H1563), CInt(&H11CF), &HAC, &H98, &H0, &HAA, &H0, &H4C, &HF, &HA9)
 CLSID_AVICo = iid
End Function

Public Function CLSID_FileWriter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H8596E5F0, CInt(&HDA5), CInt(&H11D0), &HBD, &H21, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_FileWriter = iid
End Function

Public Function CLSID_AviDest() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE2510970, CInt(&HF137), CInt(&H11CE), &H8B, &H67, &H0, &HAA, &H0, &HA3, &HF1, &HA6)
 CLSID_AviDest = iid
End Function

Public Function CLSID_AviMuxProptyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HC647B5C0, CInt(&H157C), CInt(&H11D0), &HBD, &H23, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_AviMuxProptyPage = iid
End Function

Public Function CLSID_AviMuxProptyPage1() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HA9AE910, CInt(&H85C0), CInt(&H11D0), &HBD, &H42, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_AviMuxProptyPage1 = iid
End Function

Public Function CLSID_AVIMIDIRender() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7B65360, CInt(&HC445), CInt(&H11CE), &HAF, &HDE, &H0, &HAA, &H0, &H6C, &H14, &HF4)
 CLSID_AVIMIDIRender = iid
End Function

Public Function CLSID_WMAsfReader() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H187463A0, CInt(&H5BB7), CInt(&H11D3), &HAC, &HBE, &H0, &H80, &HC7, &H5E, &H24, &H6E)
 CLSID_WMAsfReader = iid
End Function

Public Function CLSID_WMAsfWriter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7C23220E, CInt(&H55BB), CInt(&H11D3), &H8B, &H16, &H0, &HC0, &H4F, &HB6, &HBD, &H3D)
 CLSID_WMAsfWriter = iid
End Function

Public Function CLSID_MPEG2Demultiplexer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HAFB6C280, CInt(&H2C41), CInt(&H11D3), &H8A, &H60, &H0, &H0, &HF8, &H1E, &HE, &H4A)
 CLSID_MPEG2Demultiplexer = iid
End Function

Public Function CLSID_MPEG2Demultiplexer_NoClock() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H687D3367, CInt(&H3644), CInt(&H467A), &HAD, &HFE, &H6C, &HD7, &HA8, &H5C, &H4A, &H2C)
 CLSID_MPEG2Demultiplexer_NoClock = iid
End Function

Public Function CLSID_MMSPLITTER() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3AE86B20, CInt(&H7BE8), CInt(&H11D1), &HAB, &HE6, &H0, &HA0, &HC9, &H5, &HF3, &H75)
 CLSID_MMSPLITTER = iid
End Function

Public Function CLSID_StreamBufferSink() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H2DB47AE5, CInt(&HCF39), CInt(&H43C2), &HB4, &HD6, &HC, &HD8, &HD9, &H9, &H46, &HF4)
 CLSID_StreamBufferSink = iid
End Function

Public Function CLSID_SBE2Sink() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE2448508, CInt(&H95DA), CInt(&H4205), &H9A, &H27, &H7E, &HC8, &H1E, &H72, &H3B, &H1A)
 CLSID_SBE2Sink = iid
End Function

Public Function CLSID_StreamBufferSource() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HC9F5FE02, CInt(&HF851), CInt(&H4EB5), &H99, &HEE, &HAD, &H60, &H2A, &HF1, &HE6, &H19)
 CLSID_StreamBufferSource = iid
End Function

Public Function CLSID_StreamBufferConfig() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFA8A68B2, CInt(&HC864), CInt(&H4BA2), &HAD, &H53, &HD3, &H87, &H6A, &H87, &H49, &H4B)
 CLSID_StreamBufferConfig = iid
End Function

Public Function CLSID_StreamBufferPropertyHandler() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE37A73F8, CInt(&HFB01), CInt(&H43DC), &H91, &H4E, &HAA, &HEE, &H76, &H9, &H5A, &HB9)
 CLSID_StreamBufferPropertyHandler = iid
End Function

Public Function CLSID_StreamBufferThumbnailHandler() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H713790EE, CInt(&H5EE1), CInt(&H45BA), &H80, &H70, &HA1, &H33, &H7D, &H27, &H62, &HFA)
 CLSID_StreamBufferThumbnailHandler = iid
End Function

Public Function CLSID_Mpeg2VideoStreamAnalyzer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6CFAD761, CInt(&H735D), CInt(&H4AA5), &H8A, &HFC, &HAF, &H91, &HA7, &HD6, &H1E, &HBA)
 CLSID_Mpeg2VideoStreamAnalyzer = iid
End Function

Public Function CLSID_StreamBufferRecordingAttributes() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCCAA63AC, CInt(&H1057), CInt(&H4778), &HAE, &H92, &H12, &H6, &HAB, &H9A, &HCE, &HE6)
 CLSID_StreamBufferRecordingAttributes = iid
End Function

Public Function CLSID_StreamBufferComposeRecording() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD682C4BA, CInt(&HA90A), CInt(&H42FE), &HB9, &HE1, &H3, &H10, &H98, &H49, &HC4, &H23)
 CLSID_StreamBufferComposeRecording = iid
End Function

Public Function CLSID_SBE2File() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H93A094D7, CInt(&H51E8), CInt(&H485B), &H90, &H4A, &H8D, &H6B, &H97, &HDC, &H6B, &H39)
 CLSID_SBE2File = iid
End Function

Public Function CLSID_DVVideoCodec() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB1B77C00, CInt(&HC3E4), CInt(&H11CF), &HAF, &H79, &H0, &HAA, &H0, &HB6, &H7A, &H42)
 CLSID_DVVideoCodec = iid
End Function

Public Function CLSID_DVVideoEnc() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H13AA3650, CInt(&HBB6F), CInt(&H11D0), &HAF, &HB9, &H0, &HAA, &H0, &HB6, &H7A, &H42)
 CLSID_DVVideoEnc = iid
End Function

Public Function CLSID_DVSplitter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4EB31670, CInt(&H9FC6), CInt(&H11CF), &HAF, &H6E, &H0, &HAA, &H0, &HB6, &H7A, &H42)
 CLSID_DVSplitter = iid
End Function

Public Function CLSID_DVMux() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H129D7E40, CInt(&HC10D), CInt(&H11D0), &HAF, &HB9, &H0, &HAA, &H0, &HB6, &H7A, &H42)
 CLSID_DVMux = iid
End Function

Public Function CLSID_SeekingPassThru() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H60AF76C, CInt(&H68DD), CInt(&H11D0), &H8F, &HC1, &H0, &HC0, &H4F, &HD9, &H18, &H9D)
 CLSID_SeekingPassThru = iid
End Function

Public Function CLSID_Line21Decoder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6E8D4A20, CInt(&H310C), CInt(&H11D0), &HB7, &H9A, &H0, &HAA, &H0, &H37, &H67, &HA7)
 CLSID_Line21Decoder = iid
End Function

Public Function CLSID_Line21Decoder2() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE4206432, CInt(&H1A1), CInt(&H4BEE), &HB3, &HE1, &H37, &H2, &HC8, &HED, &HC5, &H74)
 CLSID_Line21Decoder2 = iid
End Function

Public Function CLSID_CCAFilter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3D07A539, CInt(&H35CA), CInt(&H447C), &H9B, &H5, &H8D, &H85, &HCE, &H92, &H4F, &H9E)
 CLSID_CCAFilter = iid
End Function

Public Function CLSID_OverlayMixer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCD8743A1, CInt(&H3736), CInt(&H11D0), &H9E, &H69, &H0, &HC0, &H4F, &HD7, &HC1, &H5B)
 CLSID_OverlayMixer = iid
End Function

Public Function CLSID_VBISurfaces() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H814B9800, CInt(&H1C88), CInt(&H11D1), &HBA, &HD9, &H0, &H60, &H97, &H44, &H11, &H1A)
 CLSID_VBISurfaces = iid
End Function

Public Function CLSID_WSTDecoder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H70BC06E0, CInt(&H5666), CInt(&H11D3), &HA1, &H84, &H0, &H10, &H5A, &HEF, &H9F, &H33)
 CLSID_WSTDecoder = iid
End Function

Public Function CLSID_MjpegDec() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H301056D0, CInt(&H6DFF), CInt(&H11D2), &H9E, &HEB, &H0, &H60, &H8, &H3, &H9E, &H37)
 CLSID_MjpegDec = iid
End Function

Public Function CLSID_MJPGEnc() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB80AB0A0, CInt(&H7416), CInt(&H11D2), &H9E, &HEB, &H0, &H60, &H8, &H3, &H9E, &H37)
 CLSID_MJPGEnc = iid
End Function

Public Function CLSID_SystemDeviceEnum() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H62BE5D10, CInt(&H60EB), CInt(&H11D0), &HBD, &H3B, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_SystemDeviceEnum = iid
End Function

Public Function CLSID_CDeviceMoniker() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4315D437, CInt(&H5B8C), CInt(&H11D0), &HBD, &H3B, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_CDeviceMoniker = iid
End Function

Public Function CLSID_VideoInputDeviceCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H860BB310, CInt(&H5D01), CInt(&H11D0), &HBD, &H3B, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_VideoInputDeviceCategory = iid
End Function

Public Function CLSID_CVidCapClassManager() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H860BB310, CInt(&H5D01), CInt(&H11D0), &HBD, &H3B, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_CVidCapClassManager = iid
End Function

Public Function CLSID_LegacyAmFilterCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H83863F1, CInt(&H70DE), CInt(&H11D0), &HBD, &H40, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_LegacyAmFilterCategory = iid
End Function

Public Function CLSID_CQzFilterClassManager() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H83863F1, CInt(&H70DE), CInt(&H11D0), &HBD, &H40, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_CQzFilterClassManager = iid
End Function

Public Function CLSID_VideoCompressorCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33D9A760, CInt(&H90C8), CInt(&H11D0), &HBD, &H43, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_VideoCompressorCategory = iid
End Function

Public Function CLSID_CIcmCoClassManager() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33D9A760, CInt(&H90C8), CInt(&H11D0), &HBD, &H43, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_CIcmCoClassManager = iid
End Function

Public Function CLSID_AudioCompressorCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33D9A761, CInt(&H90C8), CInt(&H11D0), &HBD, &H43, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_AudioCompressorCategory = iid
End Function

Public Function CLSID_CAcmCoClassManager() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33D9A761, CInt(&H90C8), CInt(&H11D0), &HBD, &H43, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_CAcmCoClassManager = iid
End Function

Public Function CLSID_AudioInputDeviceCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33D9A762, CInt(&H90C8), CInt(&H11D0), &HBD, &H43, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_AudioInputDeviceCategory = iid
End Function

Public Function CLSID_CWaveinClassManager() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H33D9A762, CInt(&H90C8), CInt(&H11D0), &HBD, &H43, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_CWaveinClassManager = iid
End Function

Public Function CLSID_AudioRendererCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE0F158E1, CInt(&HCB04), CInt(&H11D0), &HBD, &H4E, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_AudioRendererCategory = iid
End Function

Public Function CLSID_CWaveOutClassManager() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE0F158E1, CInt(&HCB04), CInt(&H11D0), &HBD, &H4E, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_CWaveOutClassManager = iid
End Function

Public Function CLSID_MidiRendererCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4EFE2452, CInt(&H168A), CInt(&H11D1), &HBC, &H76, &H0, &HC0, &H4F, &HB9, &H45, &H3B)
 CLSID_MidiRendererCategory = iid
End Function

Public Function CLSID_CMidiOutClassManager() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4EFE2452, CInt(&H168A), CInt(&H11D1), &HBC, &H76, &H0, &HC0, &H4F, &HB9, &H45, &H3B)
 CLSID_CMidiOutClassManager = iid
End Function

Public Function CLSID_TransmitCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCC7BFB41, CInt(&HF175), CInt(&H11D1), &HA3, &H92, &H0, &HE0, &H29, &H1F, &H39, &H59)
 CLSID_TransmitCategory = iid
End Function

Public Function CLSID_DeviceControlCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCC7BFB46, CInt(&HF175), CInt(&H11D1), &HA3, &H92, &H0, &HE0, &H29, &H1F, &H39, &H59)
 CLSID_DeviceControlCategory = iid
End Function

Public Function CLSID_ActiveMovieCategories() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HDA4E3DA0, CInt(&HD07D), CInt(&H11D0), &HBD, &H50, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_ActiveMovieCategories = iid
End Function

Public Function CLSID_DVDHWDecodersCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H2721AE20, CInt(&H7E70), CInt(&H11D0), &HA5, &HD6, &H28, &HDB, &H4, &HC1, &H0, &H0)
 CLSID_DVDHWDecodersCategory = iid
End Function

Public Function CLSID_MediaEncoderCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7D22E920, CInt(&H5CA9), CInt(&H4787), &H8C, &H2B, &HA6, &H77, &H9B, &HD1, &H17, &H81)
 CLSID_MediaEncoderCategory = iid
End Function

Public Function CLSID_MediaMultiplexerCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H236C9559, CInt(&HADCE), CInt(&H4736), &HBF, &H72, &HBA, &HB3, &H4E, &H39, &H21, &H96)
 CLSID_MediaMultiplexerCategory = iid
End Function

Public Function CLSID_FilterMapper2() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCDA42200, CInt(&HBD88), CInt(&H11D0), &HBD, &H4E, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_FilterMapper2 = iid
End Function

Public Function CLSID_MemoryAllocator() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1E651CC0, CInt(&HB199), CInt(&H11D0), &H82, &H12, &H0, &HC0, &H4F, &HC3, &H2C, &H45)
 CLSID_MemoryAllocator = iid
End Function

Public Function CLSID_MediaPropertyBag() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCDBD8D00, CInt(&HC193), CInt(&H11D0), &HBD, &H4E, &H0, &HA0, &HC9, &H11, &HCE, &H86)
 CLSID_MediaPropertyBag = iid
End Function

Public Function CLSID_DvdGraphBuilder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFCC152B7, CInt(&HF372), CInt(&H11D0), &H8E, &H0, &H0, &HC0, &H4F, &HD7, &HC0, &H8B)
 CLSID_DvdGraphBuilder = iid
End Function

Public Function CLSID_DVDNavigator() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H9B8C4620, CInt(&H2C1A), CInt(&H11D0), &H84, &H93, &H0, &HA0, &H24, &H38, &HAD, &H48)
 CLSID_DVDNavigator = iid
End Function

Public Function CLSID_DVDState() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HF963C5CF, CInt(&HA659), CInt(&H4A93), &H96, &H38, &HCA, &HF3, &HCD, &H27, &H7D, &H13)
 CLSID_DVDState = iid
End Function

Public Function CLSID_SmartTee() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HCC58E280, CInt(&H8AA1), CInt(&H11D1), &HB3, &HF1, &H0, &HAA, &H0, &H37, &H61, &HC5)
 CLSID_SmartTee = iid
End Function

Public Function CLSID_DtvCcFilter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFB056BA0, CInt(&H2502), CInt(&H45B9), &H8E, &H86, &H2B, &H40, &HDE, &H84, &HAD, &H29)
 CLSID_DtvCcFilter = iid
End Function

Public Function CLSID_CaptionsFilter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H2F7EE4B6, CInt(&H6FF5), CInt(&H4EB4), &HB2, &H4A, &H2B, &HFC, &H41, &H11, &H71, &H71)
 CLSID_CaptionsFilter = iid
End Function

Public Function CLSID_SubtitlesFilter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H9F22CFEA, CInt(&HCE07), CInt(&H41AB), &H8B, &HA0, &HC7, &H36, &H4A, &HF9, &HA, &HF9)
 CLSID_SubtitlesFilter = iid
End Function

Public Function CLSID_DirectShowPluginControl() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H8670C736, CInt(&HF614), CInt(&H427B), &H8A, &HDA, &HBB, &HAD, &HC5, &H87, &H19, &H4B)
 CLSID_DirectShowPluginControl = iid
End Function

Public Function MSPID_PrimaryVideo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Ha35ff56a, &H9fda, &H11d0, &H8f, &Hdf, &H0, &Hc0, &H4f, &Hd9, &H18, &H9d)
MSPID_PrimaryVideo = iid
End Function
Public Function MSPID_PrimaryAudio() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Ha35ff56b, &H9fda, &H11d0, &H8f, &Hdf, &H0, &Hc0, &H4f, &Hd9, &H18, &H9d)
MSPID_PrimaryAudio = iid
End Function

Public Function FORMAT_None() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H0F6417D6, &Hc318, &H11d0, &Ha4, &H3f, &H00, &Ha0, &Hc9, &H22, &H31, &H96)
FORMAT_None = iid
End Function
Public Function FORMAT_VideoInfo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05589f80, &Hc356, &H11ce, &Hbf, &H01, &H00, &Haa, &H00, &H55, &H59, &H5a)
FORMAT_VideoInfo = iid
End Function
Public Function FORMAT_VideoInfo2() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hf72a76A0, &Heb0a, &H11d0, &Hac, &He4, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
FORMAT_VideoInfo2 = iid
End Function
Public Function FORMAT_WaveFormatEx() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05589f81, &Hc356, &H11ce, &Hbf, &H01, &H00, &Haa, &H00, &H55, &H59, &H5a)
FORMAT_WaveFormatEx = iid
End Function
Public Function FORMAT_MPEGVideo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05589f82, &Hc356, &H11ce, &Hbf, &H01, &H00, &Haa, &H00, &H55, &H59, &H5a)
FORMAT_MPEGVideo = iid
End Function
Public Function FORMAT_MPEGStreams() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05589f83, &Hc356, &H11ce, &Hbf, &H01, &H00, &Haa, &H00, &H55, &H59, &H5a)
FORMAT_MPEGStreams = iid
End Function
Public Function FORMAT_DvInfo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05589f84, &Hc356, &H11ce, &Hbf, &H01, &H00, &Haa, &H00, &H55, &H59, &H5a)
FORMAT_DvInfo = iid
End Function
Public Function FORMAT_525WSS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hc7ecf04d, &H4582, &H4869, &H9a, &Hbb, &Hbf, &Hb5, &H23, &Hb6, &H2e, &Hdf)
FORMAT_525WSS = iid
End Function


Public Function IID_IAMCollection() As UUID
'{56A868B9-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B9, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IAMCollection = iid
End Function
Public Function IID_IMediaControl() As UUID
'{56A868B1-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B1, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IMediaControl = iid
End Function
Public Function IID_IMediaEvent() As UUID
'{56A868B6-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B6, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IMediaEvent = iid
End Function
Public Function IID_IMediaEventEx() As UUID
'{56A868C0-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868C0, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IMediaEventEx = iid
End Function
Public Function IID_IMediaPosition() As UUID
'{56A868B2-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B2, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IMediaPosition = iid
End Function
Public Function IID_IBasicAudio() As UUID
'{56A868B3-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B3, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IBasicAudio = iid
End Function
Public Function IID_IVideoWindow() As UUID
'{56A868B4-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B4, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IVideoWindow = iid
End Function
Public Function IID_IBasicVideo() As UUID
'{56A868B5-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B5, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IBasicVideo = iid
End Function
Public Function IID_IBasicVideo2() As UUID
'{329BB360-F6EA-11D1-9038-00A0C9697298}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H329BB360, CInt(&HF6EA), CInt(&H11D1), &H90, &H38, &H0, &HA0, &HC9, &H69, &H72, &H98)
IID_IBasicVideo2 = iid
End Function
Public Function IID_IDeferredCommand() As UUID
'{56A868B8-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B8, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IDeferredCommand = iid
End Function
Public Function IID_IQueueCommand() As UUID
'{56A868B7-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868B7, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IQueueCommand = iid
End Function
Public Function IID_IFilterInfo() As UUID
'{E436EBB3-524F-11CE-9F53-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HE436EBB3, CInt(&H524F), CInt(&H11CE), &H9F, &H53, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IFilterInfo = iid
End Function
Public Function IID_IRegFilterInfo() As UUID
'{56A868BB-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868BB, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IRegFilterInfo = iid
End Function
Public Function IID_IMediaTypeInfo() As UUID
'{56A868BC-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868BC, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IMediaTypeInfo = iid
End Function
Public Function IID_IPinInfo() As UUID
'{56A868BD-0AD4-11CE-B03A-0020AF0BA770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868BD, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IPinInfo = iid
End Function
Public Function IID_IAMStats() As UUID
'{BC9BCF80-DCD2-11D2-ABF6-00A0C905F375}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HBC9BCF80, CInt(&HDCD2), CInt(&H11D2), &HAB, &HF6, &H0, &HA0, &HC9, &H5, &HF3, &H75)
IID_IAMStats = iid
End Function
Public Function IID_IEnumMediaTypes() As UUID
'{89c31040-846b-11ce-97d3-00aa0055595a}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H89C31040, CInt(&H846B), CInt(&H11CE), &H97, &HD3, &H0, &HAA, &H0, &H55, &H59, &H5A)
IID_IEnumMediaTypes = iid
End Function
Public Function IID_IPin() As UUID
'{56a86891-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A86891, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IPin = iid
End Function
Public Function IID_IEnumPins() As UUID
'{56a86892-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A86892, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IEnumPins = iid
End Function
Public Function IID_IReferenceClock() As UUID
'{56a86897-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A86897, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IReferenceClock = iid
End Function
Public Function IID_IMediaFilter() As UUID
'{56a86899-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A86899, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IMediaFilter = iid
End Function
Public Function IID_IBaseFilter() As UUID
'{56a86895-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A86895, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IBaseFilter = iid
End Function
Public Function IID_IEnumFilters() As UUID
'{56a86893-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A86893, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IEnumFilters = iid
End Function
Public Function IID_IFilterGraph() As UUID
'{56a8689f-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A8689F, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IFilterGraph = iid
End Function
Public Function IID_IFilterGraph2() As UUID
'{36b73882-c2c8-11cf-8b46-00805f6cef60}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H36B73882, CInt(&HC2C8), CInt(&H11CF), &H8B, &H46, &H0, &H80, &H5F, &H6C, &HEF, &H60)
 IID_IFilterGraph2 = iid
End Function
Public Function IID_IFilterGraph3() As UUID
'{aaf38154-b80b-422f-91e6-b66467509a07}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HAAF38154, CInt(&HB80B), CInt(&H422F), &H91, &HE6, &HB6, &H64, &H67, &H50, &H9A, &H7)
 IID_IFilterGraph3 = iid
End Function
Public Function IID_IFileSinkFilter() As UUID
'{a2104830-7c70-11cf-8bce-00aa00a3f1a6}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HA2104830, CInt(&H7C70), CInt(&H11CF), &H8B, &HCE, &H0, &HAA, &H0, &HA3, &HF1, &HA6)
IID_IFileSinkFilter = iid
End Function
Public Function IID_IAMCopyCaptureFileProgress() As UUID
'{670d1d20-a068-11d0-b3f0-00aa003761c5}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H670D1D20, CInt(&HA068), CInt(&H11D0), &HB3, &HF0, &H0, &HAA, &H0, &H37, &H61, &HC5)
IID_IAMCopyCaptureFileProgress = iid
End Function
Public Function IID_IGraphBuilder() As UUID
'{56a868a9-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56A868A9, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
IID_IGraphBuilder = iid
End Function
Public Function IID_ICaptureGraphBuilder() As UUID
'{bf87b6e0-8c27-11d0-b3f0-00aa003761c5}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HBF87B6E0, CInt(&H8C27), CInt(&H11D0), &HB3, &HF0, &H0, &HAA, &H0, &H37, &H61, &HC5)
IID_ICaptureGraphBuilder = iid
End Function
Public Function IID_ICaptureGraphBuilder2() As UUID
'{93E5A4E0-2D50-11d2-ABFA-00A0C9C6E38D}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H93E5A4E0, CInt(&H2D50), CInt(&H11D2), &HAB, &HFA, &H0, &HA0, &HC9, &HC6, &HE3, &H8D)
IID_ICaptureGraphBuilder2 = iid
End Function
Public Function IID_IAMChannelInfo() As UUID
'{FA2AA8F1-8B62-11D0-A520-000000000000}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HFA2AA8F1, CInt(&H8B62), CInt(&H11D0), &HA5, &H20, &H0, &H0, &H0, &H0, &H0, &H0)
IID_IAMChannelInfo = iid
End Function
Public Function IID_IAMNetworkStatus() As UUID
'{FA2AA8F3-8B62-11D0-A520-000000000000}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HFA2AA8F3, CInt(&H8B62), CInt(&H11D0), &HA5, &H20, &H0, &H0, &H0, &H0, &H0, &H0)
IID_IAMNetworkStatus = iid
End Function
Public Function IID_IAMNetShowExProps() As UUID
'{FA2AA8F5-8B62-11D0-A520-000000000000}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HFA2AA8F5, CInt(&H8B62), CInt(&H11D0), &HA5, &H20, &H0, &H0, &H0, &H0, &H0, &H0)
IID_IAMNetShowExProps = iid
End Function
Public Function IID_IAMExtendedErrorInfo() As UUID
'{FA2AA8F6-8B62-11D0-A520-000000000000}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HFA2AA8F6, CInt(&H8B62), CInt(&H11D0), &HA5, &H20, &H0, &H0, &H0, &H0, &H0, &H0)
IID_IAMExtendedErrorInfo = iid
End Function
Public Function IID_IAMNetShowPreroll() As UUID
'{AAE7E4E2-6388-11D1-8D93-006097C9A2B2}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HAAE7E4E2, CInt(&H6388), CInt(&H11D1), &H8D, &H93, &H0, &H60, &H97, &HC9, &HA2, &HB2)
IID_IAMNetShowPreroll = iid
End Function
Public Function IID_IAMMediaContent() As UUID
'{FA2AA8F4-8B62-11D0-A520-000000000000}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HFA2AA8F4, CInt(&H8B62), CInt(&H11D0), &HA5, &H20, &H0, &H0, &H0, &H0, &H0, &H0)
IID_IAMMediaContent = iid
End Function
Public Function IID_IAMExtendedSeeking() As UUID
'{FA2AA8F9-8B62-11D0-A520-000000000000}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HFA2AA8F9, CInt(&H8B62), CInt(&H11D0), &HA5, &H20, &H0, &H0, &H0, &H0, &H0, &H0)
IID_IAMExtendedSeeking = iid
End Function
Public Function IID_IAMMediaContent2() As UUID
'{CE8F78C1-74D9-11D2-B09D-00A0C9A81117}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HCE8F78C1, CInt(&H74D9), CInt(&H11D2), &HB0, &H9D, &H0, &HA0, &HC9, &HA8, &H11, &H17)
IID_IAMMediaContent2 = iid
End Function
Public Function IID_IAMNetShowConfig() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HFA2AA8F1, &H8B62, &H11D0, &HA5, &H20, &H00, &H00, &H00, &H00, &H00, &H00)
IID_IAMNetShowConfig = iid
End Function
Public Function IID_IDShowPlugin() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4746B7C8, &H700E, &H11D1, &HBE, &HCC, &H00, &HC0, &H4F, &HB6, &HE9, &H37)
IID_IDShowPlugin = iid
End Function
Public Function IID_IAMAnalogVideoDecoder() As UUID
'{C6E13350-30AC-11d0-A18C-00A0C9118956}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HC6E13350, CInt(&H30AC), CInt(&H11D0), &HA1, &H8C, &H0, &HA0, &HC9, &H11, &H89, &H56)
IID_IAMAnalogVideoDecoder = iid
End Function
Public Function IID_IAMAsyncReaderTimestampScaling() As UUID
'{cf7b26fc-9a00-485b-8147-3e789d5e8f67}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HCF7B26FC, CInt(&H9A00), CInt(&H485B), &H81, &H47, &H3E, &H78, &H9D, &H5E, &H8F, &H67)
IID_IAMAsyncReaderTimestampScaling = iid
End Function
Public Function IID_IAMAudioInputMixer() As UUID
'{54C39221-8380-11d0-B3F0-00AA003761C5}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H54C39221, CInt(&H8380), CInt(&H11D0), &HB3, &HF0, &H0, &HAA, &H0, &H37, &H61, &HC5)
IID_IAMAudioInputMixer = iid
End Function
Public Function IID_IAMBufferNegotiation() As UUID
'{56ED71A0-AF5F-11D0-B3F0-00AA003761C5}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56ED71A0, CInt(&HAF5F), CInt(&H11D0), &HB3, &HF0, &H0, &HAA, &H0, &H37, &H61, &HC5)
IID_IAMBufferNegotiation = iid
End Function
Public Function IID_IAMCameraControl() As UUID
'{C6E13370-30AC-11d0-A18C-00A0C9118956}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HC6E13370, CInt(&H30AC), CInt(&H11D0), &HA1, &H8C, &H0, &HA0, &HC9, &H11, &H89, &H56)
IID_IAMCameraControl = iid
End Function
Public Function IID_IAMCertifiedOutputProtection() As UUID
'{6feded3e-0ff1-4901-a2f1-43f7012c8515}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H6FEDED3E, CInt(&HFF1), CInt(&H4901), &HA2, &HF1, &H43, &HF7, &H1, &H2C, &H85, &H15)
IID_IAMCertifiedOutputProtection = iid
End Function
Public Function IID_IAMClockSlave() As UUID
'{9FD52741-176D-4b36-8F51-CA8F933223BE}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9FD52741, CInt(&H176D), CInt(&H4B36), &H8F, &H51, &HCA, &H8F, &H93, &H32, &H23, &HBE)
IID_IAMClockSlave = iid
End Function
Public Function IID_IAMCrossbar() As UUID
'{C6E13380-30AC-11d0-A18C-00A0C9118956}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HC6E13380, CInt(&H30AC), CInt(&H11D0), &HA1, &H8C, &H0, &HA0, &HC9, &H11, &H89, &H56)
IID_IAMCrossbar = iid
End Function
Public Function IID_IAMDecoderCaps() As UUID
'{c0dff467-d499-4986-972b-e1d9090fa941}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HC0DFF467, CInt(&HD499), CInt(&H4986), &H97, &H2B, &HE1, &HD9, &H9, &HF, &HA9, &H41)
IID_IAMDecoderCaps = iid
End Function
Public Function IID_IMediaSample() As UUID
'{56a8689a-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56A8689A, CInt(&HAD4), CInt(&H11CE), &HB0, &H3A, &H0, &H20, &HAF, &HB, &HA7, &H70)
 IID_IMediaSample = iid
End Function
Public Function IID_IMediaSample2() As UUID
'{36b73884-c2c8-11cf-8b46-00805f6cef60}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H36B73884, CInt(&HC2C8), CInt(&H11CF), &H8B, &H46, &H0, &H80, &H5F, &H6C, &HEF, &H60)
 IID_IMediaSample2 = iid
End Function
Public Function IID_ISampleGrabber() As UUID
'{6B652FFF-11FE-4fce-92AD-0266B5D7C78F}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6B652FFF, CInt(&H11FE), CInt(&H4FCE), &H92, &HAD, &H2, &H66, &HB5, &HD7, &HC7, &H8F)
 IID_ISampleGrabber = iid
End Function
Public Function IID_ISampleGrabberCB() As UUID
'{0579154a-2b53-4994-b0d0-e773148eff85}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H579154A, CInt(&H2B53), CInt(&H4994), &HB0, &HD0, &HE7, &H73, &H14, &H8E, &HFF, &H85)
 IID_ISampleGrabberCB = iid
End Function
Public Function IID_ICreateDevEnum() As UUID
'{29840822-5B84-11D0-BD3B-00A0C911CE86}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H29840822, CInt(&H5B84), CInt(&H11D0), &HBD, &H3B, &H00, &HA0, &HC9, &H11, &HCE, &H86)
 IID_ICreateDevEnum = iid
End Function
Public Function IID_IReferenceClockTimerControl() As UUID
'{ebec459c-2eca-4d42-a8af-30df557614b8}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hebec459c, CInt(&H2eca), CInt(&H4d42), &Ha8, &Haf, &H30, &Hdf, &H55, &H76, &H14, &Hb8)
 IID_IReferenceClockTimerControl = iid
End Function
Public Function IID_IReferenceClock2() As UUID
'{36b73885-c2c8-11cf-8b46-00805f6cef60}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H36b73885, CInt(&Hc2c8), CInt(&H11cf), &H8b, &H46, &H00, &H80, &H5f, &H6c, &Hef, &H60)
 IID_IReferenceClock2 = iid
End Function
Public Function IID_IMemAllocatorCallbackTemp() As UUID
'{379a0cf0-c1de-11d2-abf5-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H379a0cf0, CInt(&Hc1de), CInt(&H11d2), &Hab, &Hf5, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
 IID_IMemAllocatorCallbackTemp = iid
End Function
Public Function IID_IMemAllocatorNotifyCallbackTemp() As UUID
'{92980b30-c1de-11d2-abf5-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H92980b30, CInt(&Hc1de), CInt(&H11d2), &Hab, &Hf5, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
 IID_IMemAllocatorNotifyCallbackTemp = iid
End Function
Public Function IID_IMemInputPin() As UUID
'{56a8689d-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a8689d, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IMemInputPin = iid
End Function
Public Function IID_IAMovieSetup() As UUID
'{a3d8cec0-7e5a-11cf-bbc5-00805f6cef20}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Ha3d8cec0, CInt(&H7e5a), CInt(&H11cf), &Hbb, &Hc5, &H00, &H80, &H5f, &H6c, &Hef, &H20)
 IID_IAMovieSetup = iid
End Function
Public Function IID_IMediaSeeking() As UUID
'{36b73880-c2c8-11cf-8b46-00805f6cef60}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H36b73880, CInt(&Hc2c8), CInt(&H11cf), &H8b, &H46, &H00, &H80, &H5f, &H6c, &Hef, &H60)
 IID_IMediaSeeking = iid
End Function
Public Function IID_ICodecAPI() As UUID
'{901db4c7-31ce-41a2-85dc-8fa0bf41b8da}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H901db4c7, CInt(&H31ce), CInt(&H41a2), &H85, &Hdc, &H8f, &Ha0, &Hbf, &H41, &Hb8, &Hda)
 IID_ICodecAPI = iid
End Function
Public Function IID_IEnumRegFilters() As UUID
'{56a868a4-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868a4, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IEnumRegFilters = iid
End Function
Public Function IID_IFilterMapper() As UUID
'{56a868a3-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868a3, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IFilterMapper = iid
End Function
Public Function IID_IFilterMapper2() As UUID
'{b79bb0b0-33c1-11d1-abe1-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hb79bb0b0, CInt(&H33c1), CInt(&H11d1), &Hab, &He1, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
 IID_IFilterMapper2 = iid
End Function
Public Function IID_IFilterMapper3() As UUID
'{b79bb0b1-33c1-11d1-abe1-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hb79bb0b1, CInt(&H33c1), CInt(&H11d1), &Hab, &He1, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
 IID_IFilterMapper3 = iid
End Function
Public Function IID_IQualityControl() As UUID
'{56a868a5-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868a5, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IQualityControl = iid
End Function
Public Function IID_IOverlayNotify() As UUID
'{56a868a0-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868a0, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IOverlayNotify = iid
End Function
Public Function IID_IOverlayNotify2() As UUID
'{680EFA10-D535-11D1-87C8-00A0C9223196}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H680EFA10, CInt(&HD535), CInt(&H11D1), &H87, &HC8, &H00, &HA0, &HC9, &H22, &H31, &H96)
 IID_IOverlayNotify2 = iid
End Function
Public Function IID_IOverlay() As UUID
'{56a868a1-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868a1, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IOverlay = iid
End Function
Public Function IID_IMediaEventSink() As UUID
'{56a868a2-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868a2, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IMediaEventSink = iid
End Function
Public Function IID_IFileSourceFilter() As UUID
'{56a868a6-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868a6, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IFileSourceFilter = iid
End Function
Public Function IID_IFileSinkFilter2() As UUID
'{00855B90-CE1B-11d0-BD4F-00A0C911CE86}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H00855B90, CInt(&HCE1B), CInt(&H11d0), &HBD, &H4F, &H00, &HA0, &HC9, &H11, &HCE, &H86)
 IID_IFileSinkFilter2 = iid
End Function
Public Function IID_IStreamBuilder() As UUID
'{56a868bf-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868bf, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
 IID_IStreamBuilder = iid
End Function
Public Function IID_IAsyncReader() As UUID
'{56a868aa-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56a868aa, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
IID_IAsyncReader = iid
End Function
Public Function IID_IGraphVersion() As UUID
'{56a868ab-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56a868ab, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
IID_IGraphVersion = iid
End Function
Public Function IID_IResourceConsumer() As UUID
'{56a868ad-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56a868ad, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
IID_IResourceConsumer = iid
End Function
Public Function IID_IResourceManager() As UUID
'{56a868ac-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56a868ac, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
IID_IResourceManager = iid
End Function
Public Function IID_IDistributorNotify() As UUID
'{56a868af-0ad4-11ce-b03a-0020af0ba770}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H56a868af, CInt(&H0ad4), CInt(&H11ce), &Hb0, &H3a, &H00, &H20, &Haf, &H0b, &Ha7, &H70)
IID_IDistributorNotify = iid
End Function
Public Function IID_IAMStreamControl() As UUID
'{36b73881-c2c8-11cf-8b46-00805f6cef60}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H36b73881, CInt(&Hc2c8), CInt(&H11cf), &H8b, &H46, &H00, &H80, &H5f, &H6c, &Hef, &H60)
IID_IAMStreamControl = iid
End Function
Public Function IID_ISeekingPassThru() As UUID
'{36b73883-c2c8-11cf-8b46-00805f6cef60}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H36b73883, CInt(&Hc2c8), CInt(&H11cf), &H8b, &H46, &H00, &H80, &H5f, &H6c, &Hef, &H60)
IID_ISeekingPassThru = iid
End Function
Public Function IID_IAMStreamConfig() As UUID
'{C6E13340-30AC-11d0-A18C-00A0C9118956}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HC6E13340, CInt(&H30AC), CInt(&H11d0), &HA1, &H8C, &H00, &HA0, &HC9, &H11, &H89, &H56)
IID_IAMStreamConfig = iid
End Function
Public Function IID_IConfigInterleaving() As UUID
'{BEE3D220-157B-11d0-BD23-00A0C911CE86}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HBEE3D220, CInt(&H157B), CInt(&H11d0), &HBD, &H23, &H00, &HA0, &HC9, &H11, &HCE, &H86)
IID_IConfigInterleaving = iid
End Function
Public Function IID_IConfigAviMux() As UUID
'{5ACD6AA0-F482-11ce-8B67-00AA00A3F1A6}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H5ACD6AA0, CInt(&HF482), CInt(&H11ce), &H8B, &H67, &H00, &HAA, &H00, &HA3, &HF1, &HA6)
IID_IConfigAviMux = iid
End Function
Public Function IID_IAMVideoCompression() As UUID
'{C6E13343-30AC-11d0-A18C-00A0C9118956}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HC6E13343, CInt(&H30AC), CInt(&H11d0), &HA1, &H8C, &H00, &HA0, &HC9, &H11, &H89, &H56)
IID_IAMVideoCompression = iid
End Function
Public Function IID_IAMVfwCaptureDialogs() As UUID
'{D8D715A0-6E5E-11D0-B3F0-00AA003761C5}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HD8D715A0, CInt(&H6E5E), CInt(&H11D0), &HB3, &HF0, &H00, &HAA, &H00, &H37, &H61, &HC5)
IID_IAMVfwCaptureDialogs = iid
End Function
Public Function IID_IAMVfwCompressDialogs() As UUID
'{D8D715A3-6E5E-11D0-B3F0-00AA003761C5}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HD8D715A3, CInt(&H6E5E), CInt(&H11D0), &HB3, &HF0, &H00, &HAA, &H00, &H37, &H61, &HC5)
IID_IAMVfwCompressDialogs = iid
End Function
Public Function IID_IAMDroppedFrames() As UUID
'{C6E13344-30AC-11d0-A18C-00A0C9118956}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HC6E13344, CInt(&H30AC), CInt(&H11d0), &HA1, &H8C, &H00, &HA0, &HC9, &H11, &H89, &H56)
IID_IAMDroppedFrames = iid
End Function
Public Function IID_IAMVideoProcAmp() As UUID
'{C6E13360-30AC-11d0-A18C-00A0C9118956}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HC6E13360, CInt(&H30AC), CInt(&H11d0), &HA1, &H8C, &H00, &HA0, &HC9, &H11, &H89, &H56)
 IID_IAMVideoProcAmp = iid
End Function
Public Function IID_IAMVideoControl() As UUID
'{6a2e0670-28e4-11d0-a18c-00a0c9118956}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6a2e0670, CInt(&H28e4), CInt(&H11d0), &Ha1, &H8c, &H00, &Ha0, &Hc9, &H11, &H89, &H56)
 IID_IAMVideoControl = iid
End Function


Public Function IID_IKsTopologyInfo() As UUID
'{720D4AC0-7533-11D0-A5D6-28DB04C10000}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H720D4AC0, CInt(&H7533), CInt(&H11D0), &HA5, &HD6, &H28, &HDB, &H04, &HC1, &H00, &H00)
IID_IKsTopologyInfo = iid
End Function
Public Function IID_ISelector() As UUID
'{1ABDAECA-68B6-4F83-9371-B413907C7B9F}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H1ABDAECA, CInt(&H68B6), CInt(&H4F83), &H93, &H71, &HB4, &H13, &H90, &H7C, &H7B, &H9F)
IID_ISelector = iid
End Function
Public Function IID_ICameraControl() As UUID
'{2BA1785D-4D1B-44EF-85E8-C7F1D3F20184}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H2BA1785D, CInt(&H4D1B), CInt(&H44EF), &H85, &HE8, &HC7, &HF1, &HD3, &HF2, &H01, &H84)
IID_ICameraControl = iid
End Function
Public Function IID_IVideoProcAmp() As UUID
'{4050560E-42A7-413a-85C2-09269A2D0F44}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H4050560E, CInt(&H42A7), CInt(&H413a), &H85, &HC2, &H09, &H26, &H9A, &H2D, &H0F, &H44)
IID_IVideoProcAmp = iid
End Function
Public Function IID_IKsNodeControl() As UUID
'{11737C14-24A7-4bb5-81A0-0D003813B0C4}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H11737C14, CInt(&H24A7), CInt(&H4bb5), &H81, &HA0, &H0D, &H00, &H38, &H13, &HB0, &HC4)
IID_IKsNodeControl = iid
End Function





Public Function IID_IMediaParamInfo() As UUID
'{6d6cbb60-a223-44aa-842f-a2f06750be6d}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H6d6cbb60, CInt(&Ha223), CInt(&H44aa), &H84, &H2f, &Ha2, &Hf0, &H67, &H50, &Hbe, &H6d)
IID_IMediaParamInfo = iid
End Function
Public Function IID_IMediaParams() As UUID
'{6d6cbb61-a223-44aa-842f-a2f06750be6e}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H6d6cbb61, CInt(&Ha223), CInt(&H44aa), &H84, &H2f, &Ha2, &Hf0, &H67, &H50, &Hbe, &H6e)
IID_IMediaParams = iid
End Function


Public Function CLSID_AMMultiMediaStream() As UUID
'{49C47CE5-9BA4-11D0-8212-00C04FC32C45}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H49C47CE5, CInt(&H9BA4), CInt(&H11D0), &H82, &H12, &H00, &HC0, &H4F, &HC3, &H2C, &H45)
  CLSID_AMMultiMediaStream = iid
End Function


Public Function IID_IVPVBIConfig() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hec529b00, &H1a1f, &H11d1, &Hba, &Hd9, &H0, &H60, &H97, &H44, &H11, &H1a)
IID_IVPVBIConfig = iid
End Function
Public Function IID_IVPVBINotify() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hec529b01, &H1a1f, &H11d1, &Hba, &Hd9, &H0, &H60, &H97, &H44, &H11, &H1a)
IID_IVPVBINotify = iid
End Function
Public Function IID_IMixerPinConfig() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H593cdde1, &H759, &H11d1, &H9e, &H69, &H0, &Hc0, &H4f, &Hd7, &Hc1, &H5b)
IID_IMixerPinConfig = iid
End Function
Public Function IID_IMixerPinConfig2() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hebf47182, &H8764, &H11d1, &H9e, &H69, &H0, &Hc0, &H4f, &Hd7, &Hc1, &H5b)
IID_IMixerPinConfig2 = iid
End Function
Public Function CLSID_ModexProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H0618aa30, &H6bc4, &H11cf, &Hbf, &H36, &H00, &Haa, &H00, &H55, &H59, &H5a)
CLSID_ModexProperties = iid
End Function
Public Function IID_IFullScreenVideo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hdd1d7110, &H7836, &H11cf, &Hbf, &H47, &H00, &Haa, &H00, &H55, &H59, &H5a)
IID_IFullScreenVideo = iid
End Function
Public Function IID_IFullScreenVideoEx() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H53479470, &Hf1dd, &H11cf, &Hbc, &H42, &H00, &Haa, &H00, &Hac, &H74, &Hf6)
IID_IFullScreenVideoEx = iid
End Function
Public Function CLSID_DVDecPropertiesPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H101193c0, &Hbfe, &H11d0, &Haf, &H91, &H0, &Haa, &H0, &Hb6, &H7a, &H42)
CLSID_DVDecPropertiesPage = iid
End Function
Public Function CLSID_DVEncPropertiesPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4150f050, &Hbb6f, &H11d0, &Haf, &Hb9, &H0, &Haa, &H0, &Hb6, &H7a, &H42)
CLSID_DVEncPropertiesPage = iid
End Function
Public Function CLSID_DVMuxPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4db880e0, &Hc10d, &H11d0, &Haf, &Hb9, &H0, &Haa, &H0, &Hb6, &H7a, &H42)
CLSID_DVMuxPropertyPage = iid
End Function
Public Function IID_IAMDirectSound() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H546f4260, &Hd53e, &H11cf, &Hb3, &Hf0, &H0, &Haa, &H0, &H37, &H61, &Hc5)
IID_IAMDirectSound = iid
End Function
Public Function IID_IMpegAudioDecoder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hb45dd570, &H3c77, &H11d1, &Hab, &He1, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
IID_IMpegAudioDecoder = iid
End Function
Public Function IID_IAMLine21Decoder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6e8d4a21, &H310c, &H11d0, &Hb7, &H9a, &H0, &Haa, &H0, &H37, &H67, &Ha7)
IID_IAMLine21Decoder = iid
End Function
Public Function IID_IAMWstDecoder() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hc056de21, &H75c2, &H11d3, &Ha1, &H84, &H0, &H10, &H5a, &Hef, &H9f, &H33)
IID_IAMWstDecoder = iid
End Function
Public Function CLSID_WstDecoderPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4e27f80, &H91e4, &H11d3, &Ha1, &H84, &H0, &H10, &H5a, &Hef, &H9f, &H33)
CLSID_WstDecoderPropertyPage = iid
End Function
Public Function FORMAT_AnalogVideo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dde0, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
FORMAT_AnalogVideo = iid
End Function
Public Function MEDIATYPE_AnalogVideo() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dde1, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIATYPE_AnalogVideo = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_NTSC_M() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dde2, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_NTSC_M = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_PAL_B() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dde5, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_PAL_B = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_PAL_D() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dde6, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_PAL_D = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_PAL_G() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dde7, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_PAL_G = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_PAL_H() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dde8, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_PAL_H = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_PAL_I() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dde9, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_PAL_I = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_PAL_M() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddea, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_PAL_M = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_PAL_N() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddeb, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_PAL_N = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddec, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_SECAM_B() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddf0, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_SECAM_B = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_SECAM_D() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddf1, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_SECAM_D = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_SECAM_G() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddf2, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_SECAM_G = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_SECAM_H() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddf3, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_SECAM_H = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_SECAM_K() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddf4, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_SECAM_K = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_SECAM_K1() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddf5, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_SECAM_K1 = iid
End Function
Public Function MEDIASUBTYPE_AnalogVideo_SECAM_L() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482ddf6, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIASUBTYPE_AnalogVideo_SECAM_L = iid
End Function
Public Function MEDIATYPE_AnalogAudio() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H482dee1, &H7817, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
MEDIATYPE_AnalogAudio = iid
End Function
Public Function FORMAT_CAPTIONED_H264VIDEO() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Ha4efc024, &H873e, &H4da3, &H89, &H8b, &H47, &H4d, &Hdb, &Hd7, &H9f, &Hd0)
FORMAT_CAPTIONED_H264VIDEO = iid
End Function
Public Function FORMAT_CC_CONTAINER() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H50997a4a, &He508, &H4054, &Ha2, &Hb2, &H10, &Hff, &Ha, &Hc1, &Ha6, &H9a)
FORMAT_CC_CONTAINER = iid
End Function
Public Function CAPTION_FORMAT_ATSC() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3ed9cb31, &Hfd10, &H4ade, &Hbc, &Hcc, &Hfb, &H91, &H5, &Hd2, &Hf3, &Hef)
CAPTION_FORMAT_ATSC = iid
End Function
Public Function CAPTION_FORMAT_DVB() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H12230db4, &Hff2a, &H447e, &Hbb, &H88, &H68, &H41, &Hc4, &H16, &Hd0, &H68)
CAPTION_FORMAT_DVB = iid
End Function
Public Function CAPTION_FORMAT_DIRECTV() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He9ca1ce7, &H915e, &H47be, &H9b, &Hb9, &Hbf, &H1d, &H8a, &H13, &Ha5, &Hec)
CAPTION_FORMAT_DIRECTV = iid
End Function
Public Function CAPTION_FORMAT_ECHOSTAR() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hebb1a262, &H1158, &H4b99, &Hae, &H80, &H92, &Hac, &H77, &H69, &H52, &Hc4)
CAPTION_FORMAT_ECHOSTAR = iid
End Function
Public Function FORMAT_CAPTIONED_MPEG2VIDEO() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7ab2ada2, &H81b6, &H4f14, &Hb3, &Hc8, &Hd0, &Hc4, &H86, &H39, &H3b, &H67)
FORMAT_CAPTIONED_MPEG2VIDEO = iid
End Function
Public Function TIME_FORMAT_NONE() As UUID
TIME_FORMAT_NONE = UUID_NULL
End Function
Public Function TIME_FORMAT_FRAME() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7b785570, &H8c82, &H11cf, &Hbc, &Hc, &H0, &Haa, &H0, &Hac, &H74, &Hf6)
TIME_FORMAT_FRAME = iid
End Function
Public Function TIME_FORMAT_BYTE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7b785571, &H8c82, &H11cf, &Hbc, &Hc, &H0, &Haa, &H0, &Hac, &H74, &Hf6)
TIME_FORMAT_BYTE = iid
End Function
Public Function TIME_FORMAT_SAMPLE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7b785572, &H8c82, &H11cf, &Hbc, &Hc, &H0, &Haa, &H0, &Hac, &H74, &Hf6)
TIME_FORMAT_SAMPLE = iid
End Function
Public Function TIME_FORMAT_FIELD() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7b785573, &H8c82, &H11cf, &Hbc, &Hc, &H0, &Haa, &H0, &Hac, &H74, &Hf6)
TIME_FORMAT_FIELD = iid
End Function
Public Function TIME_FORMAT_MEDIA_TIME() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7b785574, &H8c82, &H11cf, &Hbc, &Hc, &H0, &Haa, &H0, &Hac, &H74, &Hf6)
TIME_FORMAT_MEDIA_TIME = iid
End Function
Public Function AMPROPSETID_Pin() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H9b00f101, &H1567, &H11d1, &Hb3, &Hf1, &H0, &Haa, &H0, &H37, &H61, &Hc5)
AMPROPSETID_Pin = iid
End Function
Public Function PIN_CATEGORY_CAPTURE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4281, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_CAPTURE = iid
End Function
Public Function PIN_CATEGORY_PREVIEW() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4282, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_PREVIEW = iid
End Function
Public Function PIN_CATEGORY_ANALOGVIDEOIN() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4283, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_ANALOGVIDEOIN = iid
End Function
Public Function PIN_CATEGORY_VBI() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4284, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_VBI = iid
End Function
Public Function PIN_CATEGORY_VIDEOPORT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4285, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_VIDEOPORT = iid
End Function
Public Function PIN_CATEGORY_NABTS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4286, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_NABTS = iid
End Function
Public Function PIN_CATEGORY_EDS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4287, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_EDS = iid
End Function
Public Function PIN_CATEGORY_TELETEXT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4288, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_TELETEXT = iid
End Function
Public Function PIN_CATEGORY_CC() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c4289, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_CC = iid
End Function
Public Function PIN_CATEGORY_STILL() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c428a, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_STILL = iid
End Function
Public Function PIN_CATEGORY_TIMECODE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c428b, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_TIMECODE = iid
End Function
Public Function PIN_CATEGORY_VIDEOPORT_VBI() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfb6c428c, &H0353, &H11d1, &H90, &H5f, &H00, &H00, &Hc0, &Hcc, &H16, &Hba)
PIN_CATEGORY_VIDEOPORT_VBI = iid
End Function
Public Function LOOK_UPSTREAM_ONLY() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hac798be0, &H98e3, &H11d1, &Hb3, &Hf1, &H0, &Haa, &H0, &H37, &H61, &Hc5)
LOOK_UPSTREAM_ONLY = iid
End Function
Public Function LOOK_DOWNSTREAM_ONLY() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hac798be1, &H98e3, &H11d1, &Hb3, &Hf1, &H0, &Haa, &H0, &H37, &H61, &Hc5)
LOOK_DOWNSTREAM_ONLY = iid
End Function
Public Function CLSID_TVTunerFilterPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H266eee41, &H6c63, &H11cf, &H8a, &H3, &H0, &Haa, &H0, &H6e, &Hcb, &H65)
CLSID_TVTunerFilterPropertyPage = iid
End Function
Public Function CLSID_CrossbarFilterPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H71f96461, &H78f3, &H11d0, &Ha1, &H8c, &H0, &Ha0, &Hc9, &H11, &H89, &H56)
CLSID_CrossbarFilterPropertyPage = iid
End Function
Public Function CLSID_TVAudioFilterPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H71f96463, &H78f3, &H11d0, &Ha1, &H8c, &H0, &Ha0, &Hc9, &H11, &H89, &H56)
CLSID_TVAudioFilterPropertyPage = iid
End Function
Public Function CLSID_VideoProcAmpPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H71f96464, &H78f3, &H11d0, &Ha1, &H8c, &H0, &Ha0, &Hc9, &H11, &H89, &H56)
CLSID_VideoProcAmpPropertyPage = iid
End Function
Public Function CLSID_CameraControlPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H71f96465, &H78f3, &H11d0, &Ha1, &H8c, &H0, &Ha0, &Hc9, &H11, &H89, &H56)
CLSID_CameraControlPropertyPage = iid
End Function
Public Function CLSID_AnalogVideoDecoderPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H71f96466, &H78f3, &H11d0, &Ha1, &H8c, &H0, &Ha0, &Hc9, &H11, &H89, &H56)
CLSID_AnalogVideoDecoderPropertyPage = iid
End Function
Public Function CLSID_VideoStreamConfigPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H71f96467, &H78f3, &H11d0, &Ha1, &H8c, &H0, &Ha0, &Hc9, &H11, &H89, &H56)
CLSID_VideoStreamConfigPropertyPage = iid
End Function
Public Function CLSID_AudioRendererAdvancedProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H37e92a92, &Hd9aa, &H11d2, &Hbf, &H84, &H8e, &Hf2, &Hb1, &H55, &H5a, &Hed)
CLSID_AudioRendererAdvancedProperties = iid
End Function
Public Function CLSID_AllocPresenter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H99d54f63, &H1a69, &H41ae, &Haa, &H4d, &Hc9, &H76, &Heb, &H3f, &H07, &H13)
CLSID_AllocPresenter = iid
End Function
Public Function CLSID_AllocPresenterDDXclMode() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4444ac9e, &H242e, &H471b, &Ha3, &Hc7, &H45, &Hdc, &Hd4, &H63, &H52, &Hbc)
CLSID_AllocPresenterDDXclMode = iid
End Function
Public Function CLSID_VideoPortManager() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6f26a6cd, &H967b, &H47fd, &H87, &H4a, &H7a, &Hed, &H2c, &H9d, &H25, &Ha2)
CLSID_VideoPortManager = iid
End Function
Public Function CLSID_MFVideoMixer9() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE474E05A, &HAB65, &H4f6a, &H82, &H7C, &H21, &H8B, &H1B, &HAA, &HF3, &H1F)
CLSID_MFVideoMixer9 = iid
End Function
Public Function CLSID_MFVideoPresenter9() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H98455561, &H5136, &H4d28, &Hab, &H8, &H4c, &Hee, &H40, &Hea, &H27, &H81)
CLSID_MFVideoPresenter9 = iid
End Function
Public Function CLSID_EVRTearlessWindowPresenter9() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Ha0a7a57b, &H59b2, &H4919, &Ha6, &H94, &Had, &Hd0, &Ha5, &H26, &Hc3, &H73)
CLSID_EVRTearlessWindowPresenter9 = iid
End Function
Public Function CLSID_EVRPlaybackPipelineOptimizer() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H62079164, &H233b, &H41f8, &Ha8, &H0f, &Hf0, &H17, &H05, &Hf5, &H14, &Ha8)
CLSID_EVRPlaybackPipelineOptimizer = iid
End Function
Public Function EVRConfig_ForceBob() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df01, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_ForceBob = iid
End Function
Public Function EVRConfig_AllowDropToBob() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df02, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_AllowDropToBob = iid
End Function
Public Function EVRConfig_ForceThrottle() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df03, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_ForceThrottle = iid
End Function
Public Function EVRConfig_AllowDropToThrottle() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df04, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_AllowDropToThrottle = iid
End Function
Public Function EVRConfig_ForceHalfInterlace() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df05, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_ForceHalfInterlace = iid
End Function
Public Function EVRConfig_AllowDropToHalfInterlace() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df06, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_AllowDropToHalfInterlace = iid
End Function
Public Function EVRConfig_ForceScaling() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df07, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_ForceScaling = iid
End Function
Public Function EVRConfig_AllowScaling() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df08, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_AllowScaling = iid
End Function
Public Function EVRConfig_ForceBatching() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df09, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_ForceBatching = iid
End Function
Public Function EVRConfig_AllowBatching() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He447df0a, &H10ca, &H4d17, &Hb1, &H7e, &H6a, &H84, &H0f, &H8a, &H3a, &H4c)
 EVRConfig_AllowBatching = iid
End Function
Public Function CLSID_NetworkProvider() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hb2f3a67c, &H29da, &H4c78, &H88, &H31, &H9, &H1e, &Hd5, &H9, &Ha4, &H75)
CLSID_NetworkProvider = iid
End Function
Public Function CLSID_ATSCNetworkProvider() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H0dad2fdd, &H5fd7, &H11d3, &H8f, &H50, &H00, &Hc0, &H4f, &H79, &H71, &He2)
CLSID_ATSCNetworkProvider = iid
End Function
Public Function CLSID_ATSCNetworkPropertyPage() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He3444d16, &H5ac4, &H4386, &H88, &Hdf, &H13, &Hfd, &H23, &H0e, &H1d, &Hda)
CLSID_ATSCNetworkPropertyPage = iid
End Function
Public Function CLSID_DVBSNetworkProvider() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hfa4b375a, &H45b4, &H4d45, &H84, &H40, &H26, &H39, &H57, &Hb1, &H16, &H23)
CLSID_DVBSNetworkProvider = iid
End Function
Public Function CLSID_DVBTNetworkProvider() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H216c62df, &H6d7f, &H4e9a, &H85, &H71, &H5, &Hf1, &H4e, &Hdb, &H76, &H6a)
CLSID_DVBTNetworkProvider = iid
End Function
Public Function CLSID_DVBCNetworkProvider() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hdc0c0fe7, &H485, &H4266, &Hb9, &H3f, &H68, &Hfb, &Hf8, &He, &Hd8, &H34)
CLSID_DVBCNetworkProvider = iid
End Function
Public Function DSATTRIB_UDCRTag() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HEB7836CA, &H14FF, &H4919, &Hbc, &He7, &H3a, &Hf1, &H23, &H19, &He5, &H0c)
DSATTRIB_UDCRTag = iid
End Function
Public Function DSATTRIB_PicSampleSeq() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H2f5bae02, &H7b8f, &H4f60, &H82, &Hd6, &He4, &Hea, &H2f, &H1f, &H4c, &H99)
DSATTRIB_PicSampleSeq = iid
End Function
Public Function DSATTRIB_OptionalVideoAttributes() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H5A5F08CA, &H55C2, &H4033, &H92, &HAB, &H55, &HDB, &H8F, &H78, &H12, &H26)
DSATTRIB_OptionalVideoAttributes = iid
End Function
Public Function DSATTRIB_CC_CONTAINER_INFO() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He7e050fb, &Hdd5d, &H40dd, &H99, &H15, &H35, &HDC, &HB8, &H1B, &HDC, &H8a)
DSATTRIB_CC_CONTAINER_INFO = iid
End Function
Public Function DSATTRIB_TRANSPORT_PROPERTIES() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hb622f612, &H47ad, &H4671, &Had, &H6c, &H5, &Ha9, &H8e, &H65, &Hde, &H3a)
DSATTRIB_TRANSPORT_PROPERTIES = iid
End Function
Public Function DSATTRIB_PBDATAG_ATTRIBUTE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He0b56679, &H12b9, &H43cc, &Hb7, &Hdf, &H57, &H8c, &Haa, &H5a, &H7b, &H63)
DSATTRIB_PBDATAG_ATTRIBUTE = iid
End Function
Public Function DSATTRIB_CAPTURE_STREAMTIME() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H0c1a5614, &H30cd, &H4f40, &Hbc, &Hbf, &Hd0, &H3e, &H52, &H30, &H62, &H07)
 DSATTRIB_CAPTURE_STREAMTIME = iid
End Function
Public Function DSATTRIB_DSHOW_STREAM_DESC() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H5fb5673b, &Ha2a, &H4565, &H82, &H7b, &H68, &H53, &Hfd, &H75, &He6, &H11)
DSATTRIB_DSHOW_STREAM_DESC = iid
End Function
Public Function DSATTRIB_SAMPLE_LIVE_STREAM_TIME() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H892cd111, &H72f3, &H411d, &H8b, &H91, &Ha9, &He9, &H12, &H3a, &Hc2, &H9a)
DSATTRIB_SAMPLE_LIVE_STREAM_TIME = iid
End Function
Public Function UUID_UdriTagTables() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He1b98d74, &H9778, &H4878, &Hb6, &H64, &Heb, &H20, &H20, &H36, &H4d, &H88)
 UUID_UdriTagTables = iid
End Function
Public Function UUID_WMDRMTagTables() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H5DCD1101, &H9263, &H45bb, &Ha4, &Hd5, &Hc4, &H15, &Hab, &H8c, &H58, &H9c)
 UUID_WMDRMTagTables = iid
End Function
Public Function CLSID_DShowTVEFilter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05500280, &HFAA5, &H4DF9, &H82, &H46, &HBF, &HC2, &H3A, &HC5, &HCE, &HA8)
CLSID_DShowTVEFilter = iid
End Function
Public Function CLSID_TVEFilterTuneProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05500281, &HFAA5, &H4DF9, &H82, &H46, &HBF, &HC2, &H3A, &HC5, &HCE, &HA8)
CLSID_TVEFilterTuneProperties = iid
End Function
Public Function CLSID_TVEFilterCCProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05500282, &HFAA5, &H4DF9, &H82, &H46, &HBF, &HC2, &H3A, &HC5, &HCE, &HA8)
CLSID_TVEFilterCCProperties = iid
End Function
Public Function CLSID_TVEFilterStatsProperties() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H05500283, &HFAA5, &H4DF9, &H82, &H46, &HBF, &HC2, &H3A, &HC5, &HCE, &HA8)
CLSID_TVEFilterStatsProperties = iid
End Function
Public Function CLSID_IVideoEncoderProxy() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hb43c4eec, &H8c32, &H4791, &H91, &H2, &H50, &H8a, &Hda, &H5e, &He8, &He7)
CLSID_IVideoEncoderProxy = iid
End Function
Public Function CLSID_ICodecAPIProxy() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7ff0997a, &H1999, &H4286, &Ha7, &H3c, &H62, &H2b, &H88, &H14, &He7, &Heb)
CLSID_ICodecAPIProxy = iid
End Function
Public Function CLSID_IVideoEncoderCodecAPIProxy() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hb05dabd9, &H56e5, &H4fdc, &Haf, &Ha4, &H8a, &H47, &He9, &H1f, &H1c, &H9c)
CLSID_IVideoEncoderCodecAPIProxy = iid
End Function
Public Function ENCAPIPARAM_BITRATE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H49cc4c43, &Hca83, &H4ad4, &Ha9, &Haf, &Hf3, &H69, &H6a, &Hf6, &H66, &Hdf)
ENCAPIPARAM_BITRATE = iid
End Function
Public Function ENCAPIPARAM_PEAK_BITRATE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H703f16a9, &H3d48, &H44a1, &Hb0, &H77, &H1, &H8d, &Hff, &H91, &H5d, &H19)
ENCAPIPARAM_PEAK_BITRATE = iid
End Function
Public Function ENCAPIPARAM_BITRATE_MODE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hee5fb25c, &Hc713, &H40d1, &H9d, &H58, &Hc0, &Hd7, &H24, &H1e, &H25, &Hf)
ENCAPIPARAM_BITRATE_MODE = iid
End Function
Public Function ENCAPIPARAM_SAP_MODE() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hc0171db, &Hfefc, &H4af7, &H99, &H91, &Ha5, &H65, &H7c, &H19, &H1c, &Hd1)
ENCAPIPARAM_SAP_MODE = iid
End Function
Public Function CODECAPI_CHANGELISTS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H62b12acf, &Hf6b0, &H47d9, &H94, &H56, &H96, &Hf2, &H2c, &H4e, &H0b, &H9d)
CODECAPI_CHANGELISTS = iid
End Function
Public Function CODECAPI_VIDEO_ENCODER() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7112e8e1, &H3d03, &H47ef, &H8e, &H60, &H03, &Hf1, &Hcf, &H53, &H73, &H01)
CODECAPI_VIDEO_ENCODER = iid
End Function
Public Function CODECAPI_AUDIO_ENCODER() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hb9d19a3e, &Hf897, &H429c, &Hbc, &H46, &H81, &H38, &Hb7, &H27, &H2b, &H2d)
CODECAPI_AUDIO_ENCODER = iid
End Function
Public Function CODECAPI_SETALLDEFAULTS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6c5e6a7c, &Hacf8, &H4f55, &Ha9, &H99, &H1a, &H62, &H81, &H09, &H05, &H1b)
CODECAPI_SETALLDEFAULTS = iid
End Function
Public Function CODECAPI_ALLSETTINGS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6a577e92, &H83e1, &H4113, &Had, &Hc2, &H4f, &Hce, &Hc3, &H2f, &H83, &Ha1)
CODECAPI_ALLSETTINGS = iid
End Function
Public Function CODECAPI_SUPPORTSEVENTS() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H0581af97, &H7693, &H4dbd, &H9d, &Hca, &H3f, &H9e, &Hbd, &H65, &H85, &Ha1)
CODECAPI_SUPPORTSEVENTS = iid
End Function
Public Function CODECAPI_CURRENTCHANGELIST() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1cb14e83, &H7d72, &H4657, &H83, &Hfd, &H47, &Ha2, &Hc5, &Hb9, &Hd1, &H3d)
CODECAPI_CURRENTCHANGELIST = iid
End Function
Public Function CLSID_SBE2MediaTypeProfile() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H1f26a602, &H2b5c, &H4b63, &Hb8, &He8, &H9e, &Ha5, &Hc1, &Ha7, &Hdc, &H2e)
CLSID_SBE2MediaTypeProfile = iid
End Function
Public Function CLSID_SBE2FileScan() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3e458037, &Hca6, &H41aa, &Ha5, &H94, &H2a, &Ha6, &Hc0, &H2d, &H70, &H9b)
CLSID_SBE2FileScan = iid
End Function
Public Function CODECAPI_AVDecMmcssClass() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &He0ad4828, &Hdf66, &H4893, &H9f, &H33, &H78, &H8a, &Ha4, &Hec, &H40, &H82)
CODECAPI_AVDecMmcssClass = iid
End Function
Public Function IID_IDirectDrawKernel() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H8D56C120, &H6A08, &H11D0, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
IID_IDirectDrawKernel = iid
End Function
Public Function IID_IDirectDrawSurfaceKernel() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H60755DA0, &H6A40, &H11D0, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
IID_IDirectDrawSurfaceKernel = iid
End Function


Public Function IID_IPinConnection() As UUID
'{4A9A62D3-27D4-403D-91E9-89F540E55534}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4A9A62D3, CInt(&H27D4), CInt(&H403D), &H91, &HE9, &H89, &HF5, &H40, &HE5, &H55, &H34)
 IID_IPinConnection = iid
End Function
Public Function IID_IPinFlowControl() As UUID
'{c56e9858-dbf3-4f6b-8119-384af2060deb}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hc56e9858, CInt(&Hdbf3), CInt(&H4f6b), &H81, &H19, &H38, &H4a, &Hf2, &H06, &H0d, &Heb)
 IID_IPinFlowControl = iid
End Function
Public Function IID_IGraphConfig() As UUID
'{03A1EB8E-32BF-4245-8502-114D08A9CB88}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H03A1EB8E, CInt(&H32BF), CInt(&H4245), &H85, &H02, &H11, &H4D, &H08, &HA9, &HCB, &H88)
 IID_IGraphConfig = iid
End Function
Public Function IID_IGraphConfigCallback() As UUID
'{ade0fd60-d19d-11d2-abf6-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hade0fd60, CInt(&Hd19d), CInt(&H11d2), &Hab, &Hf6, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
 IID_IGraphConfigCallback = iid
End Function
Public Function IID_IFilterChain() As UUID
'{DCFBDCF6-0DC2-45f5-9AB2-7C330EA09C29}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HDCFBDCF6, CInt(&H0DC2), CInt(&H45f5), &H9A, &HB2, &H7C, &H33, &H0E, &HA0, &H9C, &H29)
 IID_IFilterChain = iid
End Function
Public Function IID_IAMTuner() As UUID
'{211A8761-03AC-11d1-8D13-00AA00BD8339}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H211A8761, CInt(&H03AC), CInt(&H11d1), &H8D, &H13, &H00, &HAA, &H00, &HBD, &H83, &H39)
 IID_IAMTuner = iid
End Function
Public Function IID_IAMTunerNotification() As UUID
'{211A8760-03AC-11d1-8D13-00AA00BD8339}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H211A8760, CInt(&H03AC), CInt(&H11d1), &H8D, &H13, &H00, &HAA, &H00, &HBD, &H83, &H39)
 IID_IAMTunerNotification = iid
End Function
Public Function IID_IAMTVTuner() As UUID
'{211A8766-03AC-11d1-8D13-00AA00BD8339}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H211A8766, CInt(&H03AC), CInt(&H11d1), &H8D, &H13, &H00, &HAA, &H00, &HBD, &H83, &H39)
 IID_IAMTVTuner = iid
End Function
Public Function IID_IBPCSatelliteTuner() As UUID
'{211A8765-03AC-11d1-8D13-00AA00BD8339}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H211A8765, CInt(&H03AC), CInt(&H11d1), &H8D, &H13, &H00, &HAA, &H00, &HBD, &H83, &H39)
 IID_IBPCSatelliteTuner = iid
End Function
Public Function IID_IAMTVAudio() As UUID
'{83EC1C30-23D1-11d1-99E6-00A0C9560266}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H83EC1C30, CInt(&H23D1), CInt(&H11d1), &H99, &HE6, &H00, &HA0, &HC9, &H56, &H02, &H66)
 IID_IAMTVAudio = iid
End Function
Public Function IID_IAMTVAudioNotification() As UUID
'{83EC1C33-23D1-11d1-99E6-00A0C9560266}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H83EC1C33, CInt(&H23D1), CInt(&H11d1), &H99, &HE6, &H00, &HA0, &HC9, &H56, &H02, &H66)
 IID_IAMTVAudioNotification = iid
End Function
Public Function IID_IAMAnalogVideoEncoder() As UUID
'{C6E133B0-30AC-11d0-A18C-00A0C9118956}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HC6E133B0, CInt(&H30AC), CInt(&H11d0), &HA1, &H8C, &H00, &HA0, &HC9, &H11, &H89, &H56)
 IID_IAMAnalogVideoEncoder = iid
End Function
Public Function IID_IMediaPropertyBag() As UUID
'{6025A880-C0D5-11d0-BD4E-00A0C911CE86}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6025A880, CInt(&HC0D5), CInt(&H11d0), &HBD, &H4E, &H00, &HA0, &HC9, &H11, &HCE, &H86)
 IID_IMediaPropertyBag = iid
End Function
Public Function IID_IPersistMediaPropertyBag() As UUID
'{5738E040-B67F-11d0-BD4D-00A0C911CE86}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H5738E040, CInt(&HB67F), CInt(&H11d0), &HBD, &H4D, &H00, &HA0, &HC9, &H11, &HCE, &H86)
 IID_IPersistMediaPropertyBag = iid
End Function
Public Function IID_IAMPhysicalPinInfo() As UUID
'{F938C991-3029-11cf-8C44-00AA006B6814}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HF938C991, CInt(&H3029), CInt(&H11cf), &H8C, &H44, &H00, &HAA, &H00, &H6B, &H68, &H14)
 IID_IAMPhysicalPinInfo = iid
End Function
Public Function IID_IAMExtDevice() As UUID
'{B5730A90-1A2C-11cf-8C23-00AA006B6814}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HB5730A90, CInt(&H1A2C), CInt(&H11cf), &H8C, &H23, &H00, &HAA, &H00, &H6B, &H68, &H14)
IID_IAMExtDevice = iid
End Function
Public Function IID_IAMExtTransport() As UUID
'{A03CD5F0-3045-11cf-8C44-00AA006B6814}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HA03CD5F0, CInt(&H3045), CInt(&H11cf), &H8C, &H44, &H00, &HAA, &H00, &H6B, &H68, &H14)
IID_IAMExtTransport = iid
End Function
Public Function IID_IAMTimecodeReader() As UUID
'{9B496CE1-811B-11cf-8C77-00AA006B6814}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9B496CE1, CInt(&H811B), CInt(&H11cf), &H8C, &H77, &H00, &HAA, &H00, &H6B, &H68, &H14)
IID_IAMTimecodeReader = iid
End Function
Public Function IID_IAMTimecodeGenerator() As UUID
'{9B496CE0-811B-11cf-8C77-00AA006B6814}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9B496CE0, CInt(&H811B), CInt(&H11cf), &H8C, &H77, &H00, &HAA, &H00, &H6B, &H68, &H14)
IID_IAMTimecodeGenerator = iid
End Function
Public Function IID_IAMTimecodeDisplay() As UUID
'{9B496CE2-811B-11cf-8C77-00AA006B6814}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H9B496CE2, CInt(&H811B), CInt(&H11cf), &H8C, &H77, &H00, &HAA, &H00, &H6B, &H68, &H14)
IID_IAMTimecodeDisplay = iid
End Function
Public Function IID_IAMDevMemoryAllocator() As UUID
'{c6545bf0-e76b-11d0-bd52-00a0c911ce86}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hc6545bf0, CInt(&He76b), CInt(&H11d0), &Hbd, &H52, &H00, &Ha0, &Hc9, &H11, &Hce, &H86)
IID_IAMDevMemoryAllocator = iid
End Function
Public Function IID_IAMDevMemoryControl() As UUID
'{c6545bf1-e76b-11d0-bd52-00a0c911ce86}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hc6545bf1, CInt(&He76b), CInt(&H11d0), &Hbd, &H52, &H00, &Ha0, &Hc9, &H11, &Hce, &H86)
IID_IAMDevMemoryControl = iid
End Function
Public Function IID_IAMStreamSelect() As UUID
'{c1960960-17f5-11d1-abe1-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hc1960960, CInt(&H17f5), CInt(&H11d1), &Hab, &He1, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
IID_IAMStreamSelect = iid
End Function
Public Function IID_IAMResourceControl() As UUID
'{8389d2d0-77d7-11d1-abe6-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H8389d2d0, CInt(&H77d7), CInt(&H11d1), &Hab, &He6, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
IID_IAMResourceControl = iid
End Function
Public Function IID_IAMClockAdjust() As UUID
'{4d5466b0-a49c-11d1-abe8-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H4d5466b0, CInt(&Ha49c), CInt(&H11d1), &Hab, &He8, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
IID_IAMClockAdjust = iid
End Function
Public Function IID_IAMFilterMiscFlags() As UUID
'{2dd74950-a890-11d1-abe8-00a0c905f375}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H2dd74950, CInt(&Ha890), CInt(&H11d1), &Hab, &He8, &H00, &Ha0, &Hc9, &H05, &Hf3, &H75)
IID_IAMFilterMiscFlags = iid
End Function
Public Function IID_IDrawVideoImage() As UUID
'{48efb120-ab49-11d2-aed2-00a0c995e8d5}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H48efb120, CInt(&Hab49), CInt(&H11d2), &Hae, &Hd2, &H00, &Ha0, &Hc9, &H95, &He8, &Hd5)
IID_IDrawVideoImage = iid
End Function
Public Function IID_IDecimateVideoImage() As UUID
'{2e5ea3e0-e924-11d2-b6da-00a0c995e8df}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H2e5ea3e0, CInt(&He924), CInt(&H11d2), &Hb6, &Hda, &H00, &Ha0, &Hc9, &H95, &He8, &Hdf)
IID_IDecimateVideoImage = iid
End Function
Public Function IID_IAMVideoDecimationPropertie() As UUID
'{60d32930-13da-11d3-9ec6-c4fcaef5c7be}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H60d32930, CInt(&H13da), CInt(&H11d3), &H9e, &Hc6, &Hc4, &Hfc, &Hae, &Hf5, &Hc7, &Hbe)
IID_IAMVideoDecimationPropertie = iid
End Function
Public Function IID_IVideoFrameStep() As UUID
'{e46a9787-2b71-444d-a4b5-1fab7b708d6a}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &He46a9787, CInt(&H2b71), CInt(&H444d), &Ha4, &Hb5, &H1f, &Hab, &H7b, &H70, &H8d, &H6a)
IID_IVideoFrameStep = iid
End Function
Public Function IID_IAMPushSource() As UUID
'{F185FE76-E64E-11d2-B76E-00C04FB6BD3D}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HF185FE76, CInt(&HE64E), CInt(&H11d2), &HB7, &H6E, &H00, &HC0, &H4F, &HB6, &HBD, &H3D)
IID_IAMPushSource = iid
End Function
Public Function IID_IAMDeviceRemoval() As UUID
'{f90a6130-b658-11d2-ae49-0000f8754b99}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hf90a6130, CInt(&Hb658), CInt(&H11d2), &Hae, &H49, &H00, &H00, &Hf8, &H75, &H4b, &H99)
IID_IAMDeviceRemoval = iid
End Function
Public Function IID_IDVEnc() As UUID
'{d18e17a0-aacb-11d0-afb0-00aa00b67a42}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hd18e17a0, CInt(&Haacb), CInt(&H11d0), &Haf, &Hb0, &H00, &Haa, &H00, &Hb6, &H7a, &H42)
IID_IDVEnc = iid
End Function
Public Function IID_IIPDVDec() As UUID
'{b8e8bd60-0bfe-11d0-af91-00aa00b67a42}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &Hb8e8bd60, CInt(&H0bfe), CInt(&H11d0), &Haf, &H91, &H00, &Haa, &H00, &Hb6, &H7a, &H42)
IID_IIPDVDec = iid
End Function
Public Function IID_IDVRGB219() As UUID
'{58473A19-2BC8-4663-8012-25F81BABDDD1}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H58473A19, CInt(&H2BC8), CInt(&H4663), &H80, &H12, &H25, &HF8, &H1B, &HAB, &HDD, &HD1)
IID_IDVRGB219 = iid
End Function
Public Function IID_IDVSplitter() As UUID
'{92a3a302-da7c-4a1f-ba7e-1802bb5d2d02}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H92a3a302, CInt(&Hda7c), CInt(&H4a1f), &Hba, &H7e, &H18, &H02, &Hbb, &H5d, &H2d, &H02)
IID_IDVSplitter = iid
End Function
Public Function IID_IAMAudioRendererStats() As UUID
'{22320CB2-D41A-11d2-BF7C-D7CB9DF0BF93}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H22320CB2, CInt(&HD41A), CInt(&H11d2), &HBF, &H7C, &HD7, &HCB, &H9D, &HF0, &HBF, &H93)
IID_IAMAudioRendererStats = iid
End Function
Public Function IID_IAMLatency() As UUID
'{62EA93BA-EC62-11d2-B770-00C04FB6BD3D}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H62EA93BA, CInt(&HEC62), CInt(&H11d2), &HB7, &H70, &H00, &HC0, &H4F, &HB6, &HBD, &H3D)
IID_IAMLatency = iid
End Function
Public Function IID_IAMGraphStreams() As UUID
'{632105FA-072E-11d3-8AF9-00C04FB6BD3D}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H632105FA, CInt(&H072E), CInt(&H11d3), &H8A, &HF9, &H00, &HC0, &H4F, &HB6, &HBD, &H3D)
IID_IAMGraphStreams = iid
End Function
Public Function IID_IAMOverlayFX() As UUID
'{62fae250-7e65-4460-bfc9-6398b322073c}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H62fae250, CInt(&H7e65), CInt(&H4460), &Hbf, &Hc9, &H63, &H98, &Hb3, &H22, &H07, &H3c)
IID_IAMOverlayFX = iid
End Function
Public Function IID_IAMOpenProgress() As UUID
'{8E1C39A1-DE53-11cf-AA63-0080C744528D}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H8E1C39A1, CInt(&HDE53), CInt(&H11cf), &HAA, &H63, &H00, &H80, &HC7, &H44, &H52, &H8D)
IID_IAMOpenProgress = iid
End Function
Public Function IID_IRegisterServiceProvider() As UUID
'{7B3A2F01-0751-48DD-B556-004785171C54}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H7B3A2F01, CInt(&H0751), CInt(&H48DD), &HB5, &H56, &H00, &H47, &H85, &H17, &H1C, &H54)
IID_IRegisterServiceProvider = iid
End Function
Public Function IID_IAMFilterGraphCallback() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H56a868fd, &H0ad4, &H11ce, &Hb0, &Ha3, &H0, &H20, &Haf, &H0b, &Ha7, &H70)
IID_IAMFilterGraphCallback = iid
End Function
Public Function IID_IAMPluginControl() As UUID
'{0e26a181-f40c-4635-8786-976284b52981}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H0e26a181, CInt(&Hf40c), CInt(&H4635), &H87, &H86, &H97, &H62, &H84, &Hb5, &H29, &H81)
 IID_IAMPluginControl = iid
End Function
Public Function IID_IVideoEncoder() As UUID
'{02997C3B-8E1B-460e-9270-545E0DE9563E}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H02997C3B, CInt(&H8E1B), CInt(&H460e), &H92, &H70, &H54, &H5E, &H0D, &HE9, &H56, &H3E)
 IID_IVideoEncoder = iid
End Function
Public Function IID_IEncoderAPI() As UUID
'{70423839-6ACC-4b23-B079-21DBF08156A5}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H70423839, CInt(&H6ACC), CInt(&H4b23), &HB0, &H79, &H21, &HDB, &HF0, &H81, &H56, &HA5)
 IID_IEncoderAPI = iid
End Function
Public Function IID_IAMGraphBuilderCallback() As UUID
'{4995f511-9ddb-4f12-bd3b-f04611807b79}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4995f511, CInt(&H9ddb), CInt(&H4f12), &Hbd, &H3b, &Hf0, &H46, &H11, &H80, &H7b, &H79)
 IID_IAMGraphBuilderCallback = iid
End Function
Public Function IID_IAMParse() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hc47a3420, &H005c, &H11d2, &H90, &H38, &H00, &Ha0, &Hc9, &H69, &H72, &H98)
IID_IAMParse = iid
End Function
Public Function IID_IAMVideoAcceleratorNotify() As UUID
'{256A6A21-FBAD-11d1-82BF-00A0C9696C8F}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H256A6A21, CInt(&HFBAD), CInt(&H11d1), &H82, &HBF, &H00, &HA0, &HC9, &H69, &H6C, &H8F)
IID_IAMVideoAcceleratorNotify = iid
End Function
Public Function IID_IAMVideoAccelerator() As UUID
'{256A6A22-FBAD-11d1-82BF-00A0C9696C8F}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H256A6A22, CInt(&HFBAD), CInt(&H11d1), &H82, &HBF, &H00, &HA0, &HC9, &H69, &H6C, &H8F)
IID_IAMVideoAccelerator = iid
End Function

Public Function CLSID_DMOWrapperFilter() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H94297043, &Hbd82, &H4dfd, &Hb0, &Hde, &H81, &H77, &H73, &H9c, &H6d, &H20)
CLSID_DMOWrapperFilter = iid
End Function
Public Function CLSID_DMOFilterCategory() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hbcd5796c, &Hbd52, &H4d30, &Hab, &H76, &H70, &Hf9, &H75, &Hb8, &H91, &H99)
CLSID_DMOFilterCategory = iid
End Function
Public Function IID_IDMOWrapperFilter() As UUID
'{52d6f586-9f0f-4824-8fc8-e32ca04930c2}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H52d6f586, CInt(&H9f0f), CInt(&H4824), &H8f, &Hc8, &He3, &H2c, &Ha0, &H49, &H30, &Hc2)
 IID_IDMOWrapperFilter = iid
End Function

Public Function IID_IDvdControl() As UUID
'{A70EFE61-E2A3-11d0-A9BE-00AA0061BE93}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HA70EFE61, CInt(&HE2A3), CInt(&H11d0), &HA9, &HBE, &H00, &HAA, &H00, &H61, &HBE, &H93)
IID_IDvdControl = iid
End Function
Public Function IID_IDvdInfo() As UUID
'{A70EFE60-E2A3-11d0-A9BE-00AA0061BE93}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HA70EFE60, CInt(&HE2A3), CInt(&H11d0), &HA9, &HBE, &H00, &HAA, &H00, &H61, &HBE, &H93)
IID_IDvdInfo = iid
End Function
Public Function IID_IDvdCmd() As UUID
'{5a4a97e4-94ee-4a55-9751-74b5643aa27d}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H5a4a97e4, CInt(&H94ee), CInt(&H4a55), &H97, &H51, &H74, &Hb5, &H64, &H3a, &Ha2, &H7d)
IID_IDvdCmd = iid
End Function
Public Function IID_IDvdState() As UUID
'{86303d6d-1c4a-4087-ab42-f711167048ef}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H86303d6d, CInt(&H1c4a), CInt(&H4087), &Hab, &H42, &Hf7, &H11, &H16, &H70, &H48, &Hef)
IID_IDvdState = iid
End Function
Public Function IID_IDvdControl2() As UUID
'{33BC7430-EEC0-11D2-8201-00A0C9D74842}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H33BC7430, CInt(&HEEC0), CInt(&H11D2), &H82, &H01, &H00, &HA0, &HC9, &HD7, &H48, &H42)
IID_IDvdControl2 = iid
End Function
Public Function IID_IDvdInfo2() As UUID
'{34151510-EEC0-11D2-8201-00A0C9D74842}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H34151510, CInt(&HEEC0), CInt(&H11D2), &H82, &H01, &H00, &HA0, &HC9, &HD7, &H48, &H42)
IID_IDvdInfo2 = iid
End Function
Public Function IID_IDvdGraphBuilder() As UUID
'{FCC152B6-F372-11d0-8E00-00C04FD7C08B}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &HFCC152B6, CInt(&HF372), CInt(&H11d0), &H8E, &H00, &H00, &HC0, &H4F, &HD7, &HC0, &H8B)
IID_IDvdGraphBuilder = iid
End Function
Public Function IID_IDDrawExclModeVideo() As UUID
'{153ACC21-D83B-11d1-82BF-00A0C9696C8F}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H153ACC21, CInt(&HD83B), CInt(&H11d1), &H82, &HBF, &H00, &HA0, &HC9, &H69, &H6C, &H8F)
IID_IDDrawExclModeVideo = iid
End Function
Public Function IID_IDDrawExclModeVideoCallback() As UUID
'{913c24a0-20ab-11d2-9038-00a0c9697298}
Static iid As UUID
 If (iid.Data1 = 0&) Then Call DEFINE_UUID(iid, &H913c24a0, CInt(&H20ab), CInt(&H11d2), &H90, &H38, &H00, &Ha0, &Hc9, &H69, &H72, &H98)
IID_IDDrawExclModeVideoCallback = iid
End Function
#End Region

#Region "EDCodes"
'edevdefs.h/xprtdefs.h
Public Const ED_BASE = &H1000

Public Enum DShowDevPorts
    DEV_PORT_SIM = 1
    DEV_PORT_COM1 = 2  ' standard serial ports
    DEV_PORT_COM2 = 3
    DEV_PORT_COM3 = 4
    DEV_PORT_COM4 = 5
    DEV_PORT_DIAQ = 6  ' Diaquest driver
    DEV_PORT_ARTI = 7  ' ARTI driver
    DEV_PORT_1394 = 8  ' IEEE 1394 Serial Bus
    DEV_PORT_USB = 9  ' Universal Serial Bus
    DEV_PORT_MIN = DEV_PORT_SIM
    DEV_PORT_MAX = DEV_PORT_USB
End Enum

Public Enum AMExtDevCaps
    ED_DEVCAP_CAN_RECORD = ED_BASE + 1
    ED_DEVCAP_CAN_RECORD_STROBE = ED_BASE + 2  ' for multitrack devices:
'  switches currently recording tracks off
'  and selected non-recording tracks into record
    ED_DEVCAP_HAS_AUDIO = ED_BASE + 3
    ED_DEVCAP_HAS_VIDEO = ED_BASE + 4
    ED_DEVCAP_USES_FILES = ED_BASE + 5
    ED_DEVCAP_CAN_SAVE = ED_BASE + 6
    ED_DEVCAP_DEVICE_TYPE = ED_BASE + 7  ' returns one of the following:
    ED_DEVTYPE_VCR = ED_BASE + 8
    ED_DEVTYPE_LASERDISK = ED_BASE + 9
    ED_DEVTYPE_ATR = ED_BASE + 10
    ED_DEVTYPE_DDR = ED_BASE + 11
    ED_DEVTYPE_ROUTER = ED_BASE + 12
    ED_DEVTYPE_KEYER = ED_BASE + 13
    ED_DEVTYPE_MIXER_VIDEO = ED_BASE + 14
    ED_DEVTYPE_DVE = ED_BASE + 15
    ED_DEVTYPE_WIPEGEN = ED_BASE + 16
    ED_DEVTYPE_MIXER_AUDIO = ED_BASE + 17
    ED_DEVTYPE_CG = ED_BASE + 18
    ED_DEVTYPE_TBC = ED_BASE + 19
    ED_DEVTYPE_TCG = ED_BASE + 20
    ED_DEVTYPE_GPI = ED_BASE + 21
    ED_DEVTYPE_JOYSTICK = ED_BASE + 22
    ED_DEVTYPE_KEYBOARD = ED_BASE + 23
    ED_DEVTYPE_CAMERA = ED_BASE + 900
    ED_DEVTYPE_TUNER = ED_BASE + 901
    ED_DEVTYPE_DVHS = ED_BASE + 902  ' Digital VHS
    ED_DEVTYPE_UNKNOWN = ED_BASE + 903  ' Driver cannot determine the device type
    ED_DEVTYPE_CAMERA_STORAGE = ED_BASE + 1034  ' Storage for digital still images, short video files, etc.
    ED_DEVTYPE_DTV = ED_BASE + 1035  ' DTV with serial bus interface
    ED_DEVTYPE_PC_VIRTUAL = ED_BASE + 1036  ' Emulated device (virtual) on a PC
'  returns mfr-specific ID from external device.
    ED_DEVCAP_EXTERNAL_DEVICE_ID = ED_BASE + 24
    ED_DEVCAP_TIMECODE_READ = ED_BASE + 25
    ED_DEVCAP_TIMECODE_WRITE = ED_BASE + 26
'     used for seekable non-timecode enabled devices
    ED_DEVCAP_CTLTRK_READ = ED_BASE + 27
'     used for seekable non-timecode enabled devices
    ED_DEVCAP_INDEX_READ = ED_BASE + 28
'  returns device preroll time in current time format
    ED_DEVCAP_PREROLL = ED_BASE + 29
'  returns device postroll time in current time format
    ED_DEVCAP_POSTROLL = ED_BASE + 30
'  returns indication of device's synchronization accuracy.
    ED_DEVCAP_SYNC_ACCURACY = ED_BASE + 31  ' returns one of the following:
    ED_SYNCACC_PRECISE = ED_BASE + 32
    ED_SYNCACC_FRAME = ED_BASE + 33
    ED_SYNCACC_ROUGH = ED_BASE + 34
'  returns device's normal framerate.
    ED_DEVCAP_NORMAL_RATE = ED_BASE + 35  ' returns one of the following:
    ED_RATE_24 = ED_BASE + 36
    ED_RATE_25 = ED_BASE + 37
    ED_RATE_2997 = ED_BASE + 38
    ED_RATE_30 = ED_BASE + 39
    ED_DEVCAP_CAN_PREVIEW = ED_BASE + 40
    ED_DEVCAP_CAN_MONITOR_SOURCES = ED_BASE + 41
'  indicates implementation allows testing of methods/parameters by
'  setting the hi bit of a parm that makes sense - see individual methods
'  for details.
    ED_DEVCAP_CAN_TEST = ED_BASE + 42
'  indicates device accepts video as an input.
    ED_DEVCAP_VIDEO_INPUTS = ED_BASE + 43
'  indicates device accepts audio as an input.
    ED_DEVCAP_AUDIO_INPUTS = ED_BASE + 44
    ED_DEVCAP_NEEDS_CALIBRATING = ED_BASE + 45
    ED_DEVCAP_SEEK_TYPE = ED_BASE + 46  ' returns one of the following:
    ED_SEEK_PERFECT = ED_BASE + 47  ' indicates device can execute seek
'  within 1 video frames without signal
'     break (like a DDR)
    ED_SEEK_FAST = ED_BASE + 48  ' indicates device can move pretty quick
'   with short break in signal
    ED_SEEK_SLOW = ED_BASE + 49  ' seeks like a tape transport
End Enum
Public Enum AMDevExtPowerModes
    ED_POWER_ON = ED_BASE + 50
    ED_POWER_OFF = ED_BASE + 51
    ED_POWER_STANDBY = ED_BASE + 52
    ED_POWER_DEVICE_DEPENDENT = ED_BASE + 1033  ' Power is on with limited functions
End Enum
Public Enum AMDevExtCalibrate
    ED_ACTIVE = ED_BASE + 53
    ED_INACTIVE = ED_BASE + 54
    ED_ALL = ED_BASE + 55
    ED_TEST = ED_BASE + 56
End Enum
Public Enum AMDevExtTransportCaps
    ED_TRANSCAP_CAN_EJECT = ED_BASE + 100
    ED_TRANSCAP_CAN_BUMP_PLAY = ED_BASE + 101  ' variable speed for synchronizing
    ED_TRANSCAP_CAN_PLAY_BACKWARDS = ED_BASE + 102  ' servo locked for use during an edit
    ED_TRANSCAP_CAN_SET_EE = ED_BASE + 103  ' show device's input on its output
    ED_TRANSCAP_CAN_SET_PB = ED_BASE + 104  ' show media playback on device's output
    ED_TRANSCAP_CAN_DELAY_VIDEO_IN = ED_BASE + 105  ' transport can do delayed-in video edits
    ED_TRANSCAP_CAN_DELAY_VIDEO_OUT = ED_BASE + 106  ' transport can do delayed-out video edits
    ED_TRANSCAP_CAN_DELAY_AUDIO_IN = ED_BASE + 107  ' transport can do delayed-in audio edits
    ED_TRANSCAP_CAN_DELAY_AUDIO_OUT = ED_BASE + 108  ' transport can do delayed-out audio edits
    ED_TRANSCAP_FWD_VARIABLE_MAX = ED_BASE + 109  ' max forward speed (multiple of play speed)
'   in pdblValue
    ED_TRANSCAP_FWD_VARIABLE_MIN = ED_BASE + 800  ' min forward speed (multiple of play speed)
'   in pdblValue
    ED_TRANSCAP_REV_VARIABLE_MAX = ED_BASE + 110  ' max reverse speed (multiple of play speed) in
'   pdblValue
    ED_TRANSCAP_REV_VARIABLE_MIN = ED_BASE + 801  ' min reverse speed (multiple of play speed)
'   in pdblValue
    ED_TRANSCAP_FWD_SHUTTLE_MAX = ED_BASE + 802  ' max forward speed in Shuttle mode (multiple
'   of play speed) in pdblValue
    ED_TRANSCAP_FWD_SHUTTLE_MIN = ED_BASE + 803  ' min forward speed in Shuttle mode (multiple
'   of play speed) in pdblValue
    ED_TRANSCAP_REV_SHUTTLE_MAX = ED_BASE + 804  ' max reverse speed in Shuttle mode (multiple
'   of play speed) in pdblValue
    ED_TRANSCAP_REV_SHUTTLE_MIN = ED_BASE + 805  ' min reverse speed in Shuttle mode (multiple
'   of play speed) in pdblValue
    ED_TRANSCAP_NUM_AUDIO_TRACKS = ED_BASE + 111  ' returns number of audio tracks
    ED_TRANSCAP_LTC_TRACK = ED_BASE + 112  ' returns track number of LTC timecode track.
'   ED_ALL means no dedicated timecode track
    ED_TRANSCAP_NEEDS_TBC = ED_BASE + 113  ' device's output not stable
    ED_TRANSCAP_NEEDS_CUEING = ED_BASE + 114  ' device must be cued prior to performing edit
    ED_TRANSCAP_CAN_INSERT = ED_BASE + 115
    ED_TRANSCAP_CAN_ASSEMBLE = ED_BASE + 116
    ED_TRANSCAP_FIELD_STEP = ED_BASE + 117  ' device responds to Frame Advance command by
'   advancing one field
    ED_TRANSCAP_CLOCK_INC_RATE = ED_BASE + 118  ' VISCA command - keep for compatibility
    ED_TRANSCAP_CAN_DETECT_LENGTH = ED_BASE + 119
    ED_TRANSCAP_CAN_FREEZE = ED_BASE + 120
    ED_TRANSCAP_HAS_TUNER = ED_BASE + 121
    ED_TRANSCAP_HAS_TIMER = ED_BASE + 122
    ED_TRANSCAP_HAS_CLOCK = ED_BASE + 123
    ED_TRANSCAP_MULTIPLE_EDITS = ED_BASE + 806  ' OATRUE means device/filter can support
'   multiple edit events
    ED_TRANSCAP_IS_MASTER = ED_BASE + 807  ' OATRUE means device is the master clock
'   for synchronizing (this sets timecode-to-
'   reference clock offset for editing)
    ED_TRANSCAP_HAS_DT = ED_BASE + 814  ' OATRUE means device has Dynamic Tracking
End Enum
Public Enum AMDevExtTransportMediaStates
    ED_MEDIA_SPIN_UP = ED_BASE + 130
    ED_MEDIA_SPIN_DOWN = ED_BASE + 131
    ED_MEDIA_UNLOAD = ED_BASE + 132
End Enum
Public Enum AMDevExtTransportMediaModes
    ED_MODE_PLAY = ED_BASE + 200  ' Forward playback at normal speed
    ED_MODE_STOP = ED_BASE + 201
    ED_MODE_FREEZE = ED_BASE + 202  ' Forward pause
    ED_MODE_THAW = ED_BASE + 203
    ED_MODE_FF = ED_BASE + 204  ' Fast forward
    ED_MODE_REW = ED_BASE + 205  ' Fast rewind
    ED_MODE_RECORD = ED_BASE + 206
    ED_MODE_RECORD_STROBE = ED_BASE + 207
    ED_MODE_RECORD_FREEZE = ED_BASE + 808  ' Pause recording
    ED_MODE_STEP = ED_BASE + 208  ' same as "jog"
    ED_MODE_STEP_FWD = ED_BASE + 208  ' same as ED_MODE_STEP - next frame
    ED_MODE_STEP_REV = ED_BASE + 809  ' Previous frame
    ED_MODE_SHUTTLE = ED_BASE + 209
    ED_MODE_EDIT_CUE = ED_BASE + 210
    ED_MODE_VAR_SPEED = ED_BASE + 211
    ED_MODE_PERFORM = ED_BASE + 212  ' returned status only
    ED_MODE_LINK_ON = ED_BASE + 280
    ED_MODE_LINK_OFF = ED_BASE + 281
    ED_MODE_NOTIFY_ENABLE = ED_BASE + 810
    ED_MODE_NOTIFY_DISABLE = ED_BASE + 811
    ED_MODE_SHOT_SEARCH = ED_BASE + 812
    ED_MODE_PLAY_SLOW_FWD_6 = ED_BASE + 1001  ' Slow forward
    ED_MODE_PLAY_SLOW_FWD_5 = ED_BASE + 1002
    ED_MODE_PLAY_SLOW_FWD_4 = ED_BASE + 1003
    ED_MODE_PLAY_SLOW_FWD_3 = ED_BASE + 1004
    ED_MODE_PLAY_SLOW_FWD_2 = ED_BASE + 1005
    ED_MODE_PLAY_SLOW_FWD_1 = ED_BASE + 1006
    ED_MODE_PLAY_FAST_FWD_1 = ED_BASE + 1007  ' Fast forward
    ED_MODE_PLAY_FAST_FWD_2 = ED_BASE + 1008
    ED_MODE_PLAY_FAST_FWD_3 = ED_BASE + 1009
    ED_MODE_PLAY_FAST_FWD_4 = ED_BASE + 1010
    ED_MODE_PLAY_FAST_FWD_5 = ED_BASE + 1011
    ED_MODE_PLAY_FAST_FWD_6 = ED_BASE + 1012
    ED_MODE_PLAY_SLOW_REV_6 = ED_BASE + 1013  ' Slow reverse
    ED_MODE_PLAY_SLOW_REV_5 = ED_BASE + 1014
    ED_MODE_PLAY_SLOW_REV_4 = ED_BASE + 1015
    ED_MODE_PLAY_SLOW_REV_3 = ED_BASE + 1016
    ED_MODE_PLAY_SLOW_REV_2 = ED_BASE + 1017
    ED_MODE_PLAY_SLOW_REV_1 = ED_BASE + 1018
    ED_MODE_PLAY_FAST_REV_1 = ED_BASE + 1019  ' Fast reverse
    ED_MODE_PLAY_FAST_REV_2 = ED_BASE + 1020
    ED_MODE_PLAY_FAST_REV_3 = ED_BASE + 1021
    ED_MODE_PLAY_FAST_REV_4 = ED_BASE + 1022
    ED_MODE_PLAY_FAST_REV_5 = ED_BASE + 1023
    ED_MODE_PLAY_FAST_REV_6 = ED_BASE + 1024
    ED_MODE_REVERSE = ED_MODE_REV_PLAY  ' Same as Reverse playback
    ED_MODE_REVERSE_FREEZE = ED_BASE + 1025  ' Pause at reverse playback
    ED_MODE_PLAY_SLOW_FWD_X = ED_BASE + 1026  ' Possible response for a trick play
    ED_MODE_PLAY_FAST_FWD_X = ED_BASE + 1027  ' Possible response for a trick play
    ED_MODE_PLAY_SLOW_REV_X = ED_BASE + 1028  ' Possible response for a trick play
    ED_MODE_PLAY_FAST_REV_X = ED_BASE + 1029  ' Possible response for a trick play
    ED_MODE_STOP_START = ED_BASE + 1030  ' Indicate stopping at the begin of a tape
    ED_MODE_STOP_END = ED_BASE + 1031  ' Indicate stopping at the end of a tape
    ED_MODE_STOP_EMERGENCY = ED_BASE + 1032  ' Indicate stopping due to an emergency
End Enum
Public Enum AMTimegenModeParamsAndValues
    ED_TCG_TIMECODE_TYPE = ED_BASE + 400  ' can be one of the following:
    ED_TCG_SMPTE_LTC = ED_BASE + 401
    ED_TCG_SMPTE_VITC = ED_BASE + 402
    ED_TCG_MIDI_QF = ED_BASE + 403
    ED_TCG_MIDI_FULL = ED_BASE + 404
    ED_TCG_FRAMERATE = ED_BASE + 405  ' can be one of the following:
    ED_FORMAT_SMPTE_30 = ED_BASE + 406
    ED_FORMAT_SMPTE_30DROP = ED_BASE + 407
    ED_FORMAT_SMPTE_25 = ED_BASE + 408
    ED_FORMAT_SMPTE_24 = ED_BASE + 409
    ED_TCG_SYNC_SOURCE = ED_BASE + 410  ' can be one of the following:
    ED_TCG_VIDEO = ED_BASE + 411
    ED_TCG_READER = ED_BASE + 412
    ED_TCG_FREE = ED_BASE + 413
    ED_TCG_REFERENCE_SOURCE = ED_BASE + 414  ' can have one these values:
'     ED_TCG_FREE || ED_TCG_READER
'     (for regen/jamsync)
End Enum
Public Enum AMTimecodeReaderModeParamsAndValues
    ED_TCR_SOURCE = ED_BASE + 416  ' can be one of the following:
'  ED_TCG (already defined)
    ED_TCR_LTC = ED_BASE + 417
    ED_TCR_VITC = ED_BASE + 418
    ED_TCR_CT = ED_BASE + 419  ' Control Track
    ED_TCR_FTC = ED_BASE + 420  ' File TimeCode - for file-based devices
'   that wish they were transports
'  ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
'   section of this file).
    ED_TCR_LAST_VALUE = ED_BASE + 421  ' for notification mode -
'   successive calls to GetTimecode
'   return the last read value
End Enum
Public Enum AMTimecodeDispModeParamsAndValues
    ED_TCD_SOURCE = ED_BASE + 422  ' can be one of the following:
    ED_TCR = ED_BASE + 423
    ED_TCG = ED_BASE + 424
    ED_TCD_SIZE = ED_BASE + 425  ' can be one of the following:
    ED_SMALL = ED_BASE + 426
    ED_MED = ED_BASE + 427
    ED_LARGE = ED_BASE + 428
    ED_TCD_POSITION = ED_BASE + 429  ' can be one of the following:
    ED_TOP = &H0001
    ED_MIDDLE = &H0002
    ED_BOTTOM = &H0004  ' or'd  with
    ED_LEFT = &H0100
    ED_CENTER = &H0200
    ED_RIGHT = &H0400
    ED_TCD_INTENSITY = ED_BASE + 436  ' can be one of the following:
    ED_HIGH = ED_BASE + 437
    ED_LOW = ED_BASE + 438
    ED_TCD_TRANSPARENCY = ED_BASE + 439  ' 0-4, 0 is opaque
    ED_TCD_INVERT = ED_BASE + 440  ' OATRUE=black on white
'  OAFALSE=white on black
End Enum
Public Enum AmExtTransportStatusParamsAndValues
    ED_MODE = ED_BASE + 500  ' see ED_MODE_xxx values above
    ED_ERROR = ED_BASE + 501
    ED_LOCAL = ED_BASE + 502
    ED_RECORD_INHIBIT = ED_BASE + 503
    ED_SERVO_LOCK = ED_BASE + 504
    ED_MEDIA_PRESENT = ED_BASE + 505
    ED_MEDIA_LENGTH = ED_BASE + 506
    ED_MEDIA_SIZE = ED_BASE + 507
    ED_MEDIA_TRACK_COUNT = ED_BASE + 508
    ED_MEDIA_TRACK_LENGTH = ED_BASE + 509
    ED_MEDIA_SIDE = ED_BASE + 510
    ED_MEDIA_TYPE = ED_BASE + 511  ' can be one of the following:
    ED_MEDIA_VHS = ED_BASE + 512
    ED_MEDIA_SVHS = ED_BASE + 513
    ED_MEDIA_HI8 = ED_BASE + 514
    ED_MEDIA_UMATIC = ED_BASE + 515
    ED_MEDIA_DVC = ED_BASE + 516
    ED_MEDIA_1_INCH = ED_BASE + 517
    ED_MEDIA_D1 = ED_BASE + 518
    ED_MEDIA_D2 = ED_BASE + 519
    ED_MEDIA_D3 = ED_BASE + 520
    ED_MEDIA_D5 = ED_BASE + 521
    ED_MEDIA_DBETA = ED_BASE + 522
    ED_MEDIA_BETA = ED_BASE + 523
    ED_MEDIA_8MM = ED_BASE + 524
    ED_MEDIA_DDR = ED_BASE + 525
    ED_MEDIA_SX = ED_BASE + 813
    ED_MEDIA_OTHER = ED_BASE + 526
    ED_MEDIA_CLV = ED_BASE + 527
    ED_MEDIA_CAV = ED_BASE + 528
    ED_MEDIA_POSITION = ED_BASE + 529
    ED_MEDIA_NEO = ED_BASE + 531  ' Mini digital tape for MPEG2TS signal
    ED_MEDIA_MICROMV = ED_MEDIA_NEO
    ED_LINK_MODE = ED_BASE + 530  ' OATRUE if transport controls
                                    '  are linked to graph's RUN,
                                    '  STOP, and PAUSE methods
    ED_MEDIA_VHSC = ED_BASE + 925  ' New media type
    ED_MEDIA_UNKNOWN = ED_BASE + 926  ' Unknown media
    ED_MEDIA_NOT_PRESENT = ED_BASE + 927
End Enum
Public Enum AmExtTransportBasicParamsAndValues
    ED_TRANSBASIC_TIME_FORMAT = ED_BASE + 540  ' can be one of the following:
    ED_FORMAT_MILLISECONDS = ED_BASE + 541
    ED_FORMAT_FRAMES = ED_BASE + 542
    ED_FORMAT_REFERENCE_TIME = ED_BASE + 543
    ED_FORMAT_HMSF = ED_BASE + 547
    ED_FORMAT_TMSF = ED_BASE + 548
    ED_TRANSBASIC_TIME_REFERENCE = ED_BASE + 549  ' can be one of the following:
    ED_TIMEREF_TIMECODE = ED_BASE + 550
    ED_TIMEREF_CONTROL_TRACK = ED_BASE + 551
    ED_TIMEREF_INDEX = ED_BASE + 552
    ED_TRANSBASIC_SUPERIMPOSE = ED_BASE + 553  ' enable/disable onscreen display
    ED_TRANSBASIC_END_STOP_ACTION = ED_BASE + 554  ' can be one of: ED_MODE_STOP |
'     ED_MODE_REWIND | ED_MODE_FREEZE
    ED_TRANSBASIC_RECORD_FORMAT = ED_BASE + 555  ' can be one of the following:
    ED_RECORD_FORMAT_SP = ED_BASE + 556
    ED_RECORD_FORMAT_LP = ED_BASE + 557
    ED_RECORD_FORMAT_EP = ED_BASE + 558
    ED_TRANSBASIC_STEP_COUNT = ED_BASE + 559
    ED_TRANSBASIC_STEP_UNIT = ED_BASE + 560  ' can be one of the following:
    ED_STEP_FIELD = ED_BASE + 561
    ED_STEP_FRAME = ED_BASE + 562
    ED_STEP_3_2 = ED_BASE + 563
    ED_TRANSBASIC_PREROLL = ED_BASE + 564
    ED_TRANSBASIC_RECPREROLL = ED_BASE + 565
    ED_TRANSBASIC_POSTROLL = ED_BASE + 566
    ED_TRANSBASIC_EDIT_DELAY = ED_BASE + 567
    ED_TRANSBASIC_PLAYTC_DELAY = ED_BASE + 568
    ED_TRANSBASIC_RECTC_DELAY = ED_BASE + 569
    ED_TRANSBASIC_EDIT_FIELD = ED_BASE + 570
    ED_TRANSBASIC_FRAME_SERVO = ED_BASE + 571
    ED_TRANSBASIC_CF_SERVO = ED_BASE + 572
    ED_TRANSBASIC_SERVO_REF = ED_BASE + 573  ' can be one of the following:
    ED_REF_EXTERNAL = ED_BASE + 574
    ED_REF_INPUT = ED_BASE + 575
    ED_REF_INTERNAL = ED_BASE + 576
    ED_REF_AUTO = ED_BASE + 577
    ED_TRANSBASIC_WARN_GL = ED_BASE + 578
    ED_TRANSBASIC_SET_TRACKING = ED_BASE + 579  ' can be one of the following:
    ED_TRACKING_PLUS = ED_BASE + 580
    ED_TRACKING_MINUS = ED_BASE + 581
    ED_TRACKING_RESET = ED_BASE + 582
    ED_TRANSBASIC_SET_FREEZE_TIMEOUT = ED_BASE + 583
    ED_TRANSBASIC_VOLUME_NAME = ED_BASE + 584
    ED_TRANSBASIC_BALLISTIC_1 = ED_BASE + 585  ' space for proprietary data
    ED_TRANSBASIC_BALLISTIC_2 = ED_BASE + 586
    ED_TRANSBASIC_BALLISTIC_3 = ED_BASE + 587
    ED_TRANSBASIC_BALLISTIC_4 = ED_BASE + 588
    ED_TRANSBASIC_BALLISTIC_5 = ED_BASE + 589
    ED_TRANSBASIC_BALLISTIC_6 = ED_BASE + 590
    ED_TRANSBASIC_BALLISTIC_7 = ED_BASE + 591
    ED_TRANSBASIC_BALLISTIC_8 = ED_BASE + 592
    ED_TRANSBASIC_BALLISTIC_9 = ED_BASE + 593
    ED_TRANSBASIC_BALLISTIC_10 = ED_BASE + 594
    ED_TRANSBASIC_BALLISTIC_11 = ED_BASE + 595
    ED_TRANSBASIC_BALLISTIC_12 = ED_BASE + 596
    ED_TRANSBASIC_BALLISTIC_13 = ED_BASE + 597
    ED_TRANSBASIC_BALLISTIC_14 = ED_BASE + 598
    ED_TRANSBASIC_BALLISTIC_15 = ED_BASE + 599
    ED_TRANSBASIC_BALLISTIC_16 = ED_BASE + 600
    ED_TRANSBASIC_BALLISTIC_17 = ED_BASE + 601
    ED_TRANSBASIC_BALLISTIC_18 = ED_BASE + 602
    ED_TRANSBASIC_BALLISTIC_19 = ED_BASE + 603
    ED_TRANSBASIC_BALLISTIC_20 = ED_BASE + 604
'  consumer VCR items
    ED_TRANSBASIC_SETCLOCK = ED_BASE + 605
    ED_TRANSBASIC_SET_COUNTER_FORMAT = ED_BASE + 606  ' uses time format flags
    ED_TRANSBASIC_SET_COUNTER_VALUE = ED_BASE + 607
    ED_TRANSBASIC_SETTUNER_CH_UP = ED_BASE + 608
    ED_TRANSBASIC_SETTUNER_CH_DN = ED_BASE + 609
    ED_TRANSBASIC_SETTUNER_SK_UP = ED_BASE + 610
    ED_TRANSBASIC_SETTUNER_SK_DN = ED_BASE + 611
    ED_TRANSBASIC_SETTUNER_CH = ED_BASE + 612
    ED_TRANSBASIC_SETTUNER_NUM = ED_BASE + 613
    ED_TRANSBASIC_SETTIMER_EVENT = ED_BASE + 614
    ED_TRANSBASIC_SETTIMER_STARTDAY = ED_BASE + 615
    ED_TRANSBASIC_SETTIMER_STARTTIME = ED_BASE + 616
    ED_TRANSBASIC_SETTIMER_STOPDAY = ED_BASE + 617
    ED_TRANSBASIC_SETTIMER_STOPTIME = ED_BASE + 618
    ED_RAW_EXT_DEV_CMD = ED_BASE + 920
    ED_TRANSBASIC_INPUT_SIGNAL = ED_BASE + 940
    ED_TRANSBASIC_OUTPUT_SIGNAL = ED_BASE + 941
    ED_TRANSBASIC_SIGNAL_525_60_SD = ED_BASE + 942
    ED_TRANSBASIC_SIGNAL_525_60_SDL = ED_BASE + 943
    ED_TRANSBASIC_SIGNAL_625_50_SD = ED_BASE + 944
    ED_TRANSBASIC_SIGNAL_625_50_SDL = ED_BASE + 945
    ED_TRANSBASIC_SIGNAL_625_60_HD = ED_BASE + 947
    ED_TRANSBASIC_SIGNAL_625_50_HD = ED_BASE + 948
    ED_TRANSBASIC_SIGNAL_MPEG2TS = ED_BASE + 946
    ED_TRANSBASIC_SIGNAL_2500_60_MPEG = ED_BASE + 980
    ED_TRANSBASIC_SIGNAL_1250_60_MPEG = ED_BASE + 981
    ED_TRANSBASIC_SIGNAL_0625_60_MPEG = ED_BASE + 982
    ED_TRANSBASIC_SIGNAL_2500_50_MPEG = ED_BASE + 985
    ED_TRANSBASIC_SIGNAL_1250_50_MPEG = ED_BASE + 986
    ED_TRANSBASIC_SIGNAL_0625_50_MPEG = ED_BASE + 987
    ED_TRANSBASIC_SIGNAL_UNKNOWN = ED_BASE + 990
    ED_TRANSBASIC_SIGNAL_525_60_DV25 = ED_BASE + 991
    ED_TRANSBASIC_SIGNAL_625_50_DV25 = ED_BASE + 992
    ED_TRANSBASIC_SIGNAL_525_60_DV50 = ED_BASE + 993
    ED_TRANSBASIC_SIGNAL_625_50_DV50 = ED_BASE + 994
    ED_TRANSBASIC_SIGNAL_HD_60_DVH1 = ED_BASE + 995  ' DVCPRO 100: 1080i or 720p
    ED_TRANSBASIC_SIGNAL_HD_50_DVH1 = ED_BASE + 996  ' DVCPRO 100: 1080i only
End Enum
Public Enum AmExtTransportVideoParamsAndValues
    ED_TRANSVIDEO_SET_OUTPUT = ED_BASE + 630  ' can be one of the following:
    ED_E2E = ED_BASE + 631
    ED_PLAYBACK = ED_BASE + 632
    ED_OFF = ED_BASE + 633
    ED_TRANSVIDEO_SET_SOURCE = ED_BASE + 634
End Enum
Public Enum AmExtTransportAudioParamsAndValues
    ED_TRANSAUDIO_ENABLE_OUTPUT = ED_BASE + 640  ' can be the following:
    ED_AUDIO_ALL = &H10000000  '    or any of the following OR'd together
    ED_AUDIO_1 = &H0000001
    ED_AUDIO_2 = &H0000002
    ED_AUDIO_3 = &H0000004
    ED_AUDIO_4 = &H0000008
    ED_AUDIO_5 = &H0000010
    ED_AUDIO_6 = &H0000020
    ED_AUDIO_7 = &H0000040
    ED_AUDIO_8 = &H0000080
    ED_AUDIO_9 = &H0000100
    ED_AUDIO_10 = &H0000200
    ED_AUDIO_11 = &H0000400
    ED_AUDIO_12 = &H0000800
    ED_AUDIO_13 = &H0001000
    ED_AUDIO_14 = &H0002000
    ED_AUDIO_15 = &H0004000
    ED_AUDIO_16 = &H0008000&
    ED_AUDIO_17 = &H0010000
    ED_AUDIO_18 = &H0020000
    ED_AUDIO_19 = &H0040000
    ED_AUDIO_20 = &H0080000
    ED_AUDIO_21 = &H0100000
    ED_AUDIO_22 = &H0200000
    ED_AUDIO_23 = &H0400000
    ED_AUDIO_24 = &H0800000
    ED_VIDEO = &H2000000    ' for Edit props below
    ED_TRANSAUDIO_ENABLE_RECORD = ED_BASE + 642
    ED_TRANSAUDIO_ENABLE_SELSYNC = ED_BASE + 643
    ED_TRANSAUDIO_SET_SOURCE = ED_BASE + 644
    ED_TRANSAUDIO_SET_MONITOR = ED_BASE + 645
End Enum
Public Enum AmExtEditParamsAndValues
    ED_INVALID = ED_BASE + 652
    ED_EXECUTING = ED_BASE + 653
    ED_REGISTER = ED_BASE + 654
    ED_DELETE = ED_BASE + 655
'  Edit property set parameters and values
    ED_EDIT_HEVENT = ED_BASE + 656  ' event handle to signal event
'  completion
    ED_EDIT_TEST = ED_BASE + 657  ' returns OAFALSE if filter thinks
'   edit can be done, OATRUE if not
    ED_EDIT_IMMEDIATE = ED_BASE + 658  ' OATRUE means start put the
'  device into edit mode (editing
'  "on the fly") immediately upon
'   execution of Mode(ED_MODE_EDIT_CUE)
    ED_EDIT_MODE = ED_BASE + 659
'  can be one of the following values:
    ED_EDIT_MODE_ASSEMBLE = ED_BASE + 660
    ED_EDIT_MODE_INSERT = ED_BASE + 661
    ED_EDIT_MODE_CRASH_RECORD = ED_BASE + 662
    ED_EDIT_MODE_BOOKMARK_TIME = ED_BASE + 663  ' these two are for
    ED_EDIT_MODE_BOOKMARK_CHAPTER = ED_BASE + 664  ' laserdisks
    ED_EDIT_MASTER = ED_BASE + 666  ' OATRUE causes device
'   not to synchronize
    ED_EDIT_TRACK = ED_BASE + 667
'  can be one of the following possible OR'd values:
'     ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)
    ED_EDIT_SRC_INPOINT = ED_BASE + 668  ' in current time format
    ED_EDIT_SRC_OUTPOINT = ED_BASE + 669  ' in current time format
    ED_EDIT_REC_INPOINT = ED_BASE + 670  ' in current time format
    ED_EDIT_REC_OUTPOINT = ED_BASE + 671  ' in current time format
    ED_EDIT_REHEARSE_MODE = ED_BASE + 672
'  can be one of the following possible values:
    ED_EDIT_BVB = ED_BASE + 673  ' means rehearse the edit with
'   "black-video-black"
    ED_EDIT_VBV = ED_BASE + 674
    ED_EDIT_VVV = ED_BASE + 675
    ED_EDIT_PERFORM = ED_BASE + 676  ' means perform the edit with no
'   rehearsal.
'  Set this property to OATRUE to kill the edit if in progress
    ED_EDIT_ABORT = ED_BASE + 677
'  how long to wait for edit to complete
    ED_EDIT_TIMEOUT = ED_BASE + 678  ' in current time format
'  This property causes the device to seek to a point specified by
'  ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
    ED_EDIT_SEEK = ED_BASE + 679  ' OATRUE means do it now.
    ED_EDIT_SEEK_MODE = ED_BASE + 680
' possible values:
    ED_EDIT_SEEK_EDIT_IN = ED_BASE + 681  ' seek to edit's inpoint
    ED_EDIT_SEEK_EDIT_OUT = ED_BASE + 682  ' seek to edit's outpoint
    ED_EDIT_SEEK_PREROLL = ED_BASE + 683  ' seek to edit's
'   inpoint-preroll
    ED_EDIT_SEEK_PREROLL_CT = ED_BASE + 684  ' seek to preroll point
'  using control track (used for tapes with
'  discontinuoustimecode before edit point: seek
'  to inpoint using timecode, then backup to
'  preroll point using control track)
    ED_EDIT_SEEK_BOOKMARK = ED_BASE + 685  ' seek to bookmark (just like
'   timecode search)
'  This property is used for multiple-VCR systems where each machine must
'  cue to a different location relative to the graph's reference clock.  The
'  basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
'  that tells the VCR what offset to maintain between it's timecode (converted
'  to reference clock units) and the reference clock.
    ED_EDIT_OFFSET = ED_BASE + 686  ' in current time format
    ED_EDIT_PREREAD = ED_BASE + 815  ' OATRUE means device supports
'   pre-read (recorder can also be
'   player
End Enum

Public Const ED_ERR_DEVICE_NOT_READY    = ED_BASE + 700
Public Const ED_CAPABILITY_UNKNOWN          = ED_BASE + 910
'  Device Control command that can result in pending state.
Public Const ED_CONTROL_HEVENT_GET  = ED_BASE + 928  ' To get a sychronous event handle
Public Const ED_CONTROL_HEVENT_RELEASE  = ED_BASE + 929  ' To release sychronous event handle must match what it got
Public Const ED_DEV_REMOVED_HEVENT_GET  = ED_BASE + 960  ' To be a notify event and will be signal if device is removed.
Public Const ED_DEV_REMOVED_HEVENT_RELEASE  = ED_BASE + 961  ' Release this event handle

Public Enum AmExtTransportState
    ED_NOTIFY_HEVENT_GET = ED_BASE + 930  ' To get a sychronous event handle
    ED_NOTIFY_HEVENT_RELEASE = ED_BASE + 931  ' To release sychronous event handle must match what it got
    ED_MODE_CHANGE_NOTIFY = ED_BASE + 932  ' This is asynchronous operation, wait for event.
    ED_MODE_PLAY_FASTEST_FWD = ED_BASE + 933
    ED_MODE_PLAY_SLOWEST_FWD = ED_BASE + 934
    ED_MODE_PLAY_FASTEST_REV = ED_BASE + 935
    ED_MODE_PLAY_SLOWEST_REV = ED_BASE + 936
    ED_MODE_WIND = ED_BASE + 937
    ED_MODE_REW_FASTEST = ED_BASE + 938  ' High speed rewind
    ED_MODE_REV_PLAY = ED_BASE + 939  ' x1 speed reverse play
End Enum
Public Enum AmExtTimecodeDevcap
    ED_DEVCAP_TIMECODE_SEEK = ED_BASE + 950
    ED_DEVCAP_ATN_READ = ED_BASE + 951
    ED_DEVCAP_ATN_SEEK = ED_BASE + 952
    ED_DEVCAP_ATN_WRITE = ED_BASE + 953
    ED_DEVCAP_RTC_READ = ED_BASE + 954
    ED_DEVCAP_RTC_SEEK = ED_BASE + 955
    ED_DEVCAP_RTC_WRITE = ED_BASE + 956
'  Basic parameter
    ED_TIMEREF_ATN = ED_BASE + 958
End Enum

Public Function MSTapeDeviceGUID() As UUID
'{8C0F6AF2-0EDB-44c1-8AEB-59040BD830ED}
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H8C0F6AF2, CInt(&H0EDB), CInt(&H44c1), &H8A, &HEB, &H59, &H04, &H0B, &HD8, &H30, &HED)
 MSTapeDeviceGUID = iid
End Function

#End Region


End Module

#End If