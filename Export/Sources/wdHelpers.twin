'*****************************************************************************************
'This file is a part of WinDevLib - Windows Development Library for twinBASIC
'https://github.com/fafalone/WinDevLib
'Code ported by Jon Johnson. 
'"Windows" is a trademark of the Microsoft Corporation.
'Certain Description attributes (c) Microsoft, taken from SDK headers and official docs.
'Licensed under Creative Commons CC0 1.0 Universal
'*****************************************************************************************

'WinDevLib - wdHelpers :: Custom Helper Functions

Module wdHelpers
#If Win64 Then
[Description("Returns the higher two bytes of a Long variable.")]
Public Function HIWORD CDecl Naked(ByVal Value As LongLong) As Integer
    Emit(&H48, &HC1, &HE9, &H10)   'shr       rcx,16
    Emit(&H0f, &Hb7, &Hc1)         'movzx     eax, cx
    Emit(&hc3)                     'ret       0
End Function
[Description("Returns the lower two bytes of a Long variable.")]
Public Function LOWORD CDecl Naked(ByVal Value As LongLong) As Integer
    Emit(&H0f, &Hb7, &hc1)         'movzx     eax, cx
    Emit(&hc3)                     'ret       0
End Function
#Else
[Description("Returns the lower two bytes of a Long variable.")]
[IgnoreWarnings(TB0018)]
Public Function LOWORD(ByVal Value As Long) As Integer
If Value And &H8000& Then
    Return Value Or &HFFFF0000
Else
    Return Value And &HFFFF&
End If
End Function
[Description("Returns the higher two bytes of a Long variable.")]
[IgnoreWarnings(TB0018)]
Public Function HIWORD(ByVal Value As Long) As Integer
Return (Value And &HFFFF0000) \ &H10000
End Function
#End If
' [Description("Returns the lower two bytes of a LongLong variable.")]
' Public Function LOWORD(ByVal Value As LongLong) As Integer
' Dim DWord As Long = CULngToLng(Value)
' If DWord And &H8000& Then
'     Return DWord Or &HFFFF0000
' Else
'     Return DWord And &HFFFF&
' End If
' End Function
' [Description("Returns the higher two bytes of a the lower Long of a LongLong variable.")]
' Public Function HIWORD(ByVal Value As LongLong) As Integer
' Dim DWord As Long = CULngToLng(Value)
' Return (DWord And &HFFFF0000) \ &H10000
' End Function
#If WINDEVLIB_LITE = 0 Then
    #Region "Helpers"

    'Standard helper functions:
    
    [IgnoreWarnings(TB0025)]
    [DebugOnly]
    Public Sub UNREFERENCED_PARAMETER(Of T)(arg As T)
    
    End Sub
    
    
    Public Const HIGH_SURROGATE_START  = &Hd800
    Public Const HIGH_SURROGATE_END  = &Hdbff
    Public Const LOW_SURROGATE_START  = &Hdc00
    Public Const LOW_SURROGATE_END  = &Hdfff

    Public Function min(ByVal x As Long, ByVal y As Long) As Long: Return If(x < y, x, y): End Function
    Public Function max(ByVal x As Long, ByVal y As Long) As Long: Return If(x > y, x, y): End Function
    [IgnoreWarnings(TB0018)]
    Public Function PALETTERGB(ByVal r As Long, ByVal g As Long, ByVal b As Long) As Long
        Return ((&H02000000) Or RGB(r, g, b))
    End Function
    Public Function PALETTEINDEX(ByVal i As Long) As Long
        Return ((&H01000000) Or i)
    End Function
    Public Function GetRValue(ByVal rgb As Long) As Long: Return RGB_R(rgb): End Function
    Public Function GetGValue(ByVal rgb As Long) As Long: Return RGB_G(rgb): End Function
    Public Function GetBValue(ByVal rgb As Long) As Long: Return RGB_B(rgb): End Function

    Public Function GDI_WIDTHBYTES(ByVal bits As Long) As Long
        Return ((((bits) + 31) And (Not 31)) \ 8)
    End Function
    Public Function GDI_DIBWIDTHBYTES(bi As BITMAPINFOHEADER) As Long
        Return GDI_WIDTHBYTES(bi.biWidth * bi.biBitCount)
    End Function
    Public Function GDI__DIBSIZE(bi As BITMAPINFOHEADER) As Long
        Return (GDI_DIBWIDTHBYTES(bi) * bi.biHeight)
    End Function
    Public Function GDI_DIBSIZE(bi As BITMAPINFOHEADER) As Long
        Return If(bi.biHeight < 0, (-1) * (GDI__DIBSIZE(bi)), GDI__DIBSIZE(bi))
    End Function
       
    Public Function EIRESID(ByVal x As Long) As Long: Return (-1 * x): End Function
    
    Public Sub InitializeObjectAttributes(p As OBJECT_ATTRIBUTES, ByVal n As LongPtr, ByVal a As ObjectAttributeValues, ByVal r As LongPtr, ByVal s As LongPtr)
        With p
            .Length = LenB(Of OBJECT_ATTRIBUTES)
            .RootDirectory = r
            .Attributes = a
            .ObjectName = n
            .SecurityDescriptor = s
            .SecurityQualityOfService = 0
        End With
    End Sub
    
    Public Const PROP_CONTRACT_DELEGATE = "ContractDelegate"
    Public Sub SetContractDelegateWindow(ByVal hwndSource As LongPtr, Optional ByVal hwndDelegate As LongPtr = 0)
        If hwndDelegate Then
            SetPropW(hwndSource, StrPtr(PROP_CONTRACT_DELEGATE), hwndDelegate)
        Else
            RemovePropW(hwndSource, StrPtr(PROP_CONTRACT_DELEGATE))
        End If
    End Sub

    Public Function HasOverlappedIoCompleted(lpOverlapped As OVERLAPPED) As Boolean
        Return lpOverlapped.Internal <> STATUS_PENDING
    End Function
    

    Public Function CREDUIP_IS_USER_PASSWORD_ERROR(_Status As Long) As Boolean
            Return _
            ((_Status) = STATUS_SMB_GUEST_LOGON_BLOCKED) Or _
            ((_Status) = HRESULT_FROM_NT(STATUS_SMB_GUEST_LOGON_BLOCKED)) Or _
            ((_Status) = ERROR_SMB_GUEST_LOGON_BLOCKED) Or _
            ((_Status) = __HRESULT_FROM_WIN32(ERROR_SMB_GUEST_LOGON_BLOCKED)) Or _
            ((_Status) = ERROR_LOGON_FAILURE) Or _
            ((_Status) = __HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE)) Or _
            ((_Status) = STATUS_LOGON_FAILURE) Or _
            ((_Status) = HRESULT_FROM_NT(STATUS_LOGON_FAILURE)) Or _
            ((_Status) = ERROR_ACCESS_DENIED) Or _
            ((_Status) = __HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)) Or _
            ((_Status) = STATUS_ACCESS_DENIED) Or _
            ((_Status) = HRESULT_FROM_NT(STATUS_ACCESS_DENIED)) Or _
            ((_Status) = ERROR_INVALID_PASSWORD) Or _
            ((_Status) = __HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD)) Or _
            ((_Status) = STATUS_WRONG_PASSWORD) Or _
            ((_Status) = HRESULT_FROM_NT(STATUS_WRONG_PASSWORD)) Or _
            ((_Status) = STATUS_NO_SUCH_USER) Or _
            ((_Status) = HRESULT_FROM_NT(STATUS_NO_SUCH_USER)) Or _
            ((_Status) = ERROR_NO_SUCH_USER) Or _
            ((_Status) = __HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) Or _
            ((_Status) = ERROR_NO_SUCH_LOGON_SESSION) Or _
            ((_Status) = __HRESULT_FROM_WIN32(ERROR_NO_SUCH_LOGON_SESSION)) Or _
            ((_Status) = STATUS_NO_SUCH_LOGON_SESSION) Or _
            ((_Status) = HRESULT_FROM_NT(STATUS_NO_SUCH_LOGON_SESSION)) Or _
            ((_Status) = SEC_E_NO_CREDENTIALS) Or _
            ((_Status) = SEC_E_LOGON_DENIED) Or _
            ((_Status) = SEC_E_NO_CONTEXT) Or _
            ((_Status) = STATUS_NO_SECURITY_CONTEXT)
    End Function
    Public Function CREDUIP_IS_DOWNGRADE_ERROR(ByVal _Status As Long) As Boolean
        Return _
        ((_Status) = ERROR_DOWNGRADE_DETECTED) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_DOWNGRADE_DETECTED)) Or _
        ((_Status) = STATUS_DOWNGRADE_DETECTED) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_DOWNGRADE_DETECTED)) Or _
        ((_Status) = SEC_E_DOWNGRADE_DETECTED)
    End Function
    Public Function CREDUIP_IS_EXPIRED_ERROR(ByVal _Status As Long) As Boolean
        Return _
        ((_Status) = ERROR_PASSWORD_EXPIRED) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_PASSWORD_EXPIRED)) Or _
        ((_Status) = STATUS_PASSWORD_EXPIRED) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_PASSWORD_EXPIRED)) Or _
        ((_Status) = ERROR_PASSWORD_MUST_CHANGE) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_PASSWORD_MUST_CHANGE)) Or _
        ((_Status) = STATUS_PASSWORD_MUST_CHANGE) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_PASSWORD_MUST_CHANGE)) Or _
        ((_Status) = NERR_PasswordExpired) Or _
        ((_Status) = __HRESULT_FROM_WIN32(NERR_PasswordExpired))
    End Function
    Public Function CREDUI_IS_AUTHENTICATION_ERROR(ByVal _Status As Long) As Boolean
        Return _
        CREDUIP_IS_USER_PASSWORD_ERROR(_Status) Or _
        CREDUIP_IS_DOWNGRADE_ERROR(_Status) Or _
        CREDUIP_IS_EXPIRED_ERROR(_Status)
    End Function
    Public Function CREDUI_NO_PROMPT_AUTHENTICATION_ERROR(ByVal _Status As Long) As Boolean
        Return _    
        ((_Status) = ERROR_AUTHENTICATION_FIREWALL_FAILED) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_AUTHENTICATION_FIREWALL_FAILED)) Or _
        ((_Status) = STATUS_AUTHENTICATION_FIREWALL_FAILED) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_AUTHENTICATION_FIREWALL_FAILED)) Or _
        ((_Status) = ERROR_ACCOUNT_DISABLED) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_ACCOUNT_DISABLED)) Or _
        ((_Status) = STATUS_ACCOUNT_DISABLED) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_ACCOUNT_DISABLED)) Or _
        ((_Status) = ERROR_ACCOUNT_RESTRICTION) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_ACCOUNT_RESTRICTION)) Or _
        ((_Status) = STATUS_ACCOUNT_RESTRICTION) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_ACCOUNT_RESTRICTION)) Or _
        ((_Status) = ERROR_ACCOUNT_LOCKED_OUT) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_ACCOUNT_LOCKED_OUT)) Or _
        ((_Status) = STATUS_ACCOUNT_LOCKED_OUT) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_ACCOUNT_LOCKED_OUT)) Or _
        ((_Status) = ERROR_ACCOUNT_EXPIRED) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_ACCOUNT_EXPIRED)) Or _
        ((_Status) = STATUS_ACCOUNT_EXPIRED) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_ACCOUNT_EXPIRED)) Or _
        ((_Status) = ERROR_LOGON_TYPE_NOT_GRANTED) Or _
        ((_Status) = __HRESULT_FROM_WIN32(ERROR_LOGON_TYPE_NOT_GRANTED)) Or _
        ((_Status) = STATUS_LOGON_TYPE_NOT_GRANTED) Or _
        ((_Status) = HRESULT_FROM_NT(STATUS_LOGON_TYPE_NOT_GRANTED))
    End Function

    Public Sub CredAppendLogonTypeToFlags(Flags As Long, LogonType As Long)
    Flags = Flags Or (LogonType << 12)
    End Sub
    Public Function CredGetLogonTypeFromFlags(ByVal Flags As Long) As Long
     Return (Flags And CRED_LOGON_TYPES_MASK) >> 12
    End Function
    Public Function CredRemoveLogonTypeFromFlags(ByVal Flags As Long) As Long
        Return (Flags And Not CRED_LOGON_TYPES_MASK)
    End Function

    [IgnoreWarnings(TB0025)]
    Public Sub FreeIDListArray(ppidls() As LongPtr, cItems As Long)
        Dim i As Long
        For i = 0 To UBound(ppidls)
            CoTaskMemFree ppidls(i)
        Next i
    End Sub
    [IgnoreWarnings(TB0025)]
    Public Sub FreeIDListArrayFull(ppidls() As LongPtr, cItems As Long)
        Dim i As Long
        For i = 0 To UBound(ppidls)
            CoTaskMemFree ppidls(i)
        Next i
    End Sub
    [IgnoreWarnings(TB0025)]
    Public Sub FreeIDListArrayChild(ppidls() As LongPtr, cItems As Long)
        Dim i As Long
        For i = 0 To UBound(ppidls)
            CoTaskMemFree ppidls(i)
        Next i
    End Sub
    Public Function SHCreateLibrary(riid As UUID, ppv As IUnknown) As Long
        Return CoCreateInstance(CLSID_ShellLibrary, Nothing, CLSCTX_INPROC_SERVER, riid, ppv)
    End Function
    Public Function SHLoadLibraryFromItem(ByVal psiLibrary As IShellItem, ByVal grfMode As STGM, riid As UUID, ppv As IUnknown) As Long
        Set ppv = Nothing
        Dim plib As IShellLibrary
        Set plib = New ShellLibrary
        If plib IsNot Nothing Then
            On Error Resume Next
            plib.LoadLibraryFromItem(psiLibrary, grfMode)
            On Error GoTo 0
            If Err.LastHresult = S_OK Then
                Dim pUnk As IUnknownUnrestricted
                Set pUnk = plib
                On Error Resume Next
                Dim hr As Long = pUnk.QueryInterface(riid, ppv)
                On Error GoTo 0
                Return hr
            End If
        End If
        Return Err.LastHresult
    End Function
    Public Function SHLoadLibraryFromKnownFolder(kfidLibrary As UUID, ByVal grfMode As STGM, riid As UUID, ppv As IUnknown) As Long
        Set ppv = Nothing
        Dim plib As IShellLibrary
        Set plib = New ShellLibrary
        Dim hr As Long
        If plib IsNot Nothing Then
            On Error Resume Next
            plib.LoadLibraryFromKnownFolder(kfidLibrary, grfMode)
            hr = Err.LastHresult
            If hr = S_OK Then
                Dim pUnk As IUnknownUnrestricted
                Set pUnk = plib
                hr = pUnk.QueryInterface(riid, ppv)
            End If
            On Error GoTo 0
        End If
        Return hr
    End Function

    Public Function SHLoadLibraryFromParsingName(ByVal pszParsingName As String, ByVal grfMode As STGM, riid As UUID, ppv As IUnknown) As Long
        Set ppv = Nothing
        Dim psiLibrary As IShellItem
        Dim s As String = "abddef"
        Debug.Print IsValidLocaleName(StrPtr(s))
        Dim hr As Long = SHCreateItemFromParsingName(StrPtr(pszParsingName), Nothing, IID_IShellItem, psiLibrary)
        If SUCCEEDED(hr) Then
            hr = SHLoadLibraryFromItem(psiLibrary, grfMode, riid, ppv)
            Set psiLibrary = Nothing
        End If
        Return hr
    End Function
    Public Function SHAddFolderPathToLibrary(ByVal plib As IShellLibrary, ByVal pszFolderPath As String) As Long
        Dim psiFolder As IShellItem
        Dim hr As Long = SHCreateItemFromParsingName(StrPtr(pszFolderPath), Nothing, IID_IShellItem, psiFolder)
        If SUCCEEDED(hr) Then
            On Error Resume Next
            plib.AddFolder psiFolder
            hr = Err.LastHresult
             On Error GoTo 0
       End If
        Return hr
    End Function
    Public Function SHRemoveFolderPathFromLibrary(ByVal plib As IShellLibrary, ByVal pszFolderPath As String) As Long
        Dim pidlFolder As LongPtr = SHSimpleIDListFromPath(pszFolderPath)
        Dim hr As Long = CLng(IIf(pidlFolder, S_OK, E_INVALIDARG))
        If SUCCEEDED(hr) Then
            Dim psiFolder As IShellItem
            hr = SHCreateItemFromIDList(pidlFolder, IID_IShellItem, psiFolder)
            If SUCCEEDED(hr) Then
                On Error Resume Next
                plib.RemoveFolder(psiFolder)
                hr = Err.LastHresult
                On Error GoTo 0
            End If
        End If
        Return hr
    End Function
    Public Function SHSaveLibraryInFolderPath(ByVal plib As IShellLibrary, ByVal pszFolderPath As String, ByVal pszLibraryName As String, ByVal lsf As LIBRARYSAVEFLAGS, ppszSavedToPath As LongPtr) As Long
        ppszSavedToPath = 0
        Dim psiFolder As IShellItem
        Dim hr As Long = SHCreateItemFromParsingName(StrPtr(pszFolderPath), Nothing, IID_IShellItem, psiFolder)
        If SUCCEEDED(hr) Then
            Dim psiSavedTo As IShellItem
            On Error Resume Next
            hr = plib.Save(psiFolder, StrPtr(pszLibraryName), lsf, psiSavedTo)
            If SUCCEEDED(hr) Then
                hr = psiSavedTo.GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING, ppszSavedToPath)
            End If
            On Error GoTo 0
        End If
        Return hr
    End Function
    Public Function SHResolveFolderPathInLibrary(ByVal plib As IShellLibrary, ByVal pszFolderPath As String, ByVal dwTimeout As Long, ppszResolvedPath As LongPtr) As Long
        On Error Resume Next
        ppszResolvedPath = 0
        Dim pidlFolder As LongPtr = SHSimpleIDListFromPath(pszFolderPath)
        Dim hr As Long = If(pidlFolder, S_OK, E_INVALIDARG)
        If (SUCCEEDED(hr)) Then
            Dim psiFolder As IShellItem
            hr = SHCreateItemFromIDList(pidlFolder, IID_IShellItem, psiFolder)
            If (SUCCEEDED(hr)) Then
                Dim psiResolved As IShellItem
                hr = plib.ResolveFolder(psiFolder, dwTimeout, IID_IShellItem, psiResolved)
                If (SUCCEEDED(hr)) Then
                    hr = psiResolved.GetDisplayName(SIGDN_DESKTOPABSOLUTEPARSING, ppszResolvedPath)
                    Set psiResolved = Nothing
                End If
                Set psiFolder = Nothing
            End If
            CoTaskMemFree pidlFolder
        End If
        Return hr
    End Function


    Public Function KERB_IS_MS_PRINCIPAL(ByVal x As Long) As Boolean: Return ((x <= KRB_NT_MS_PRINCIPAL) Or (x >= KRB_NT_ENTERPRISE_PRINCIPAL)): End Function

    Public Function WHashValOfLHashVal(ByVal lhashval As Long) As Integer
        Return CUIntToInt(&H0000FFFF& And lhashval)
    End Function
    Public Function IsHashValCompatible(ByVal lhashval1 As Long, ByVal lhashval2 As Long) As Boolean
        Return ((&H00ff0000 And (lhashval1)) = (&H00ff0000 And (lhashval2)))
    End Function
    Public Function V_ISBYREF(x As Variant) As Boolean
        If (VarTypeEx(x) And VT_BYREF) Then Return True
    End Function
    Public Function V_ISARRAY(x As Variant) As Boolean
        If (VarTypeEx(x) And VT_ARRAY) Then Return True
    End Function
    Public Function V_ISVECTOR(x As Variant) As Boolean
        If (VarTypeEx(x) And VT_VECTOR) Then Return True
    End Function


    Public Function IsPenEvent(ByVal dw As LongPtr) As Boolean
        Return (((dw) And SIGNATURE_MASK) = MI_WP_SIGNATURE)
    End Function


    ' #define TOUCH_COORD_TO_PIXEL(l)         ((l) / 100)

    Public Function TOUCH_COORD_TO_PIXEL(ByVal l As Long) As Long
        Return l \ 100
    End Function
    ' #define GID_ROTATE_ANGLE_TO_ARGUMENT(_arg_)     ((USHORT)((((_arg_) + 2.0 * 3.14159265) / (4.0 * 3.14159265)) * 65535.0))
    Public Function GID_ROTATE_ANGLE_TO_ARGUMENT(ByVal arg As Double) As Integer
        Return CUIntToInt(CLng(((((arg) + 2.0 * 3.14159265) / (4.0 * 3.14159265)) * 65535.0)))
    End Function
    ' #define GID_ROTATE_ANGLE_FROM_ARGUMENT(_arg_)   ((((double)(_arg_) / 65535.0) * 4.0 * 3.14159265) - 2.0 * 3.14159265)
    Public Function GID_ROTATE_ANGLE_FROM_ARGUMENT(ByVal arg As Integer) As Double
        Return ((((arg) / 65535.0) * 4.0 * 3.14159265) - 2.0 * 3.14159265)
    End Function

    Public Function IS_HIGH_SURROGATE(ByVal wch As Integer) As Boolean
        Return (((wch) >= HIGH_SURROGATE_START) And ((wch) <= HIGH_SURROGATE_END))
    End Function
    Public Function IS_LOW_SURROGATE(ByVal wch As Integer) As Boolean
        Return (((wch) >= LOW_SURROGATE_START) And ((wch) <= LOW_SURROGATE_END))
    End Function
    Public Function IS_SURROGATE_PAIR(ByVal hs As Integer, ByVal ls As Integer) As Boolean
        Return (IS_HIGH_SURROGATE(hs) And IS_LOW_SURROGATE(ls))
    End Function

    Public Function ICMP6_ISTYPEINFORMATIONAL(ByVal Type As Long) As Long
        Return (((Type) And ICMP6_INFOMSG_MASK) <> 0)
    End Function
    Public Function ICMP6_ISTYPEERROR(ByVal Type As Long) As Long
        Return (Not ICMP6_ISTYPEINFORMATIONAL(Type))
    End Function
    Public Function ICMP4_ISTYPEERROR(ByVal Type As ICMP4_TYPE) As Long
        Return ((Type = ICMP4_DST_UNREACH) Or (Type = ICMP4_SOURCE_QUENCH) Or (Type = ICMP4_REDIRECT) Or (Type = ICMP4_PARAM_PROB) Or (Type = ICMP4_TIME_EXCEEDED))
    End Function
    
    Public Function STAGING_FLAG(ByVal Effective As Long) As Long
        Return ((Effective And &HF) << 8)
    End Function
    
    [Description("WARNING: May be invalid. Use WTSGetActiveConsoleSessionId instead.")]
    Public Function INTERNAL_TS_ACTIVE_CONSOLE_ID() As Long
        CopyMemory INTERNAL_TS_ACTIVE_CONSOLE_ID, ByVal &H7ffe02d8, 4
    End Function

    Public Enum CtlBufferPassMethod
        METHOD_BUFFERED = 0
        METHOD_IN_DIRECT = 1
        METHOD_OUT_DIRECT = 2
        METHOD_NEITHER = 3
        METHOD_DIRECT_TO_HARDWARE = METHOD_IN_DIRECT
        METHOD_DIRECT_FROM_HARDWARE = METHOD_OUT_DIRECT
    End Enum
    Public Enum DEVICE_FILE_ACCESS
        FILE_ANY_ACCESS = 0
        FILE_SPECIAL_ACCESS = (FILE_ANY_ACCESS)
        FILE_READ_ACCESS = (&H0001)  ' file & pipe
        FILE_WRITE_ACCESS = (&H0002)  ' file & pipe
    End Enum

    'Not needed in tB, but for compatbility with converted projects.
    Public Function FARPROC(ByVal pfn As LongPtr) As LongPtr
        Return pfn
    End Function

    [Description("Indicates whether an NTSTATUS value represents a successful operation (>= 0)")]
    Public Function NT_SUCCESS(ByVal Status As Long) As Boolean
        Return Status >= STATUS_SUCCESS
    End Function
    
    Public Function LSA_SUCCESS(ByVal Error As Long) As Boolean
        Return (Error >= 0)
    End Function

    Public Function MAKEINTRESOURCEA(ByVal dwVal As Long) As LongPtr
       Return &HFFFF& And dwVal
    End Function
    Public Function MAKEINTRESOURCEW(ByVal dwVal As Long) As LongPtr
       Return &HFFFF& And dwVal
    End Function
    Public Function MAKEINTRESOURCE(ByVal dwVal As Long) As LongPtr
       Return &HFFFF& And dwVal
    End Function
    Public Function IS_INTRESOURCE(ByVal r As LongPtr) As Boolean
        Return ((r >> 16) = 0)
    End Function

    Public Sub POINTSTOPOINT(pt As POINT, pts As POINTS)
        pt.x = pts.x: pt.y = pts.y
    End Sub
    Public Function POINTTOPOINTS(pt As POINT) As Long
            Return MAKELONG(CInt(pt.x), CInt(pt.y))
    End Function

    Public Function MAKEWPARAM(wLow As Long, wHigh As Long) As LongPtr
        Return MAKELONG(wLow, wHigh)
    End Function
    Public Function MAKELRESULT(wLow As Long, wHigh As Long) As LongPtr
        Return MAKELONG(wLow, wHigh)
    End Function
    Public Function MAKELPARAM(wLow As Long, wHigh As Long) As LongPtr
        Return MAKELONG(wLow, wHigh)
    End Function
    Public Function MAKELONG(wLow As Long, wHigh As Long) As Long
        Return LOWORD(wLow) Or (&H10000 * LOWORD(wHigh))
    End Function
    Public Function MAKEDWORD(ByVal LoWord As Integer, ByVal HiWord As Integer) As Long
        Return (CLng(HiWord) * &H10000) Or (LoWord And &HFFFF&)
    End Function
    [Description("Converted a state image index to a mask suitable to use as an item state for Common Controls.")]
    Public Function INDEXTOSTATEIMAGEMASK(ByVal Index As Long) As Long
    #If TWINBASIC Then
    Return (Index << 12)
    #Else
    INDEXTOSTATEIMAGEMASK = Index * (2 ^ 12)    
    #End If
    End Function
    [Description("Extracts the state image index from a full item state variable.")]
    Public Function STATEIMAGEMASKTOINDEX(ByVal ImgState As Long) As Long
    #If TWINBASIC Then
    Return (ImgState >> 12)
    #Else
    STATEIMAGEMASKTOINDEX = ImgState / (2 ^ 12)    
    #End If
    End Function
    [Description("Converted an overlay image index to a mask suitable to use as an item state for Common Controls.")]
    Public Function INDEXTOOVERLAYMASK(ByVal Index As Long) As Long
        #If TWINBASIC Then
        Return (Index << 8)
        #Else
        INDEXTOOVERLAYMASK = Index * (2 ^ 8) 
        #End If
    End Function
    [Description("Extracts the overlay image index from a full item state variable.")]
    Public Function OVERLAYMASKTOINDEX(ByVal Index As Long) As Long
        #If TWINBASIC Then
        Return (Index >> 8)
        #Else
        INDEXTOOVERLAYMASK = Index / (2 ^ 8) 
        #End If
    End Function

    [Description("Returns the lower byte of an Integer variable.")]
    [IgnoreWarnings(TB0018)]
    Public Function LOBYTE(ByVal Word As Integer) As Byte
        Return Word And &HFF
    End Function
    [Description("Returns the higher byte of an Integer variable.")]
    [IgnoreWarnings(TB0018)]
    Public Function HIBYTE(ByVal Word As Integer) As Byte
        Return (Word And &HFF00&) \ &H100
    End Function
    [IgnoreWarnings(TB0018)]
    Public Function MAKEWORD(ByVal LoByte As Byte, ByVal HiByte As Byte) As Integer
    If (HiByte And &H80) <> 0 Then
        Return ((HiByte * &H100&) Or LoByte) Or &HFFFF0000
    Else
        Return (HiByte * &H100) Or LoByte
    End If
    End Function
    Public Function ISLBUTTON(ByVal x As Long) As Boolean
        Return (NSTCECT_LBUTTON = ((x) And NSTCECT_BUTTON))
    End Function
    Public Function ISMBUTTON(ByVal x As Long) As Boolean
        Return (NSTCECT_MBUTTON = ((x) And NSTCECT_BUTTON))
    End Function
    Public Function ISRBUTTON(ByVal x As Long) As Boolean
        Return (NSTCECT_RBUTTON = ((x) And NSTCECT_BUTTON))
    End Function
    Public Function ISDBLCLICK(ByVal x As Long) As Boolean
        Return (NSTCECT_DBLCLICK = ((x) And NSTCECT_DBLCLICK))
    End Function

    Public Function GET_APPCOMMAND_LPARAM(ByVal lParam As LongPtr) As Integer
        Return CInt(HIWORD(CLng(lParam))) And Not FAPPCOMMAND_MASK
    End Function
    Public Function GET_DEVICE_LPARAM(ByVal lParam As LongPtr) As Integer
        Return CUIntToInt(HIWORD(CLng(lParam))) And FAPPCOMMAND_MASK
    End Function
    Public Function GET_MOUSEORKEY_LPARAM(ByVal lParam As LongPtr) As Integer
        Return CUIntToInt(HIWORD(CLng(lParam))) And FAPPCOMMAND_MASK
    End Function

    Public Function GET_FLAGS_LPARAM(ByVal lParam As LongPtr) As Integer
        Return LOWORD(CLng(lParam))
    End Function

    Public Function GET_KEYSTATE_WPARAM(ByVal wParam As LongPtr) As Integer
        Return LOWORD(CLng(wParam))
    End Function
    Public Function GET_KEYSTATE_LPARAM(ByVal lParam As LongPtr) As Integer
        Return GET_FLAGS_LPARAM(lParam)
    End Function

    [ConstantFoldable]
    Public Function MAKE_HRESULT(sev As Long, fac As HRESULT_Facility, code As Long) As Long
        Return (sev << 31) Or (fac << 16) Or code
    End Function
    [ConstantFoldable]
    Public Function MAKE_SCODE(sev As Long, fac As HRESULT_Facility, code As Long) As Long
        Return (sev << 31) Or (fac << 16) Or code
    End Function
    Public Function HRESULT_SEVERITY(ByVal hr As Long) As Long
        Return (((hr) << 31) And 1)
    End Function
    Public Function SCODE_SEVERITY(ByVal sc As Long) As Long
        Return (((sc) << 31) And 1)
    End Function

    [ConstantFoldable]
    Public Function HRESULT_FROM_NT(ByVal x As Long) As Long
        Return (x Or FACILITY_NT_BIT)
    End Function

    [ConstantFoldable]
    Public Function HRESULT_FROM_WIN32(x As Long) As Long
     '__HRESULT_FROM_WIN32(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)))
        Return CLng(IIf(x <= 0, x, (((x) And &H0000FFFF&) Or (FACILITY_WIN32 << 16) Or &H80000000)))
    End Function
    [ConstantFoldable]
    Public Function __HRESULT_FROM_WIN32(x As Long) As Long
     '__HRESULT_FROM_WIN32(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)))
        Return CLng(IIf(x <= 0, x, (((x) And &H0000FFFF&) Or (FACILITY_WIN32 << 16) Or &H80000000)))
    End Function

    Private Type SignedWords
        LoWord As Integer
        HiWord As Integer
    End Type
    Public Function GET_WHEEL_DELTA_WPARAM(ByVal wParam As LongPtr) As Integer
        Return CType(Of SignedWords)(VarPtr(wParam)).HiWord
    End Function

    Public Function GET_NCHITTEST_WPARAM(ByVal wParam As LongPtr) As Integer
        Return LOWORD(CLng(wParam))
    End Function
    Public Function GET_XBUTTON_WPARAM(ByVal wParam As LongPtr) As Integer
        Return HIWORD(CLng(wParam))
    End Function

    Public Function Get_X_lParam(ByVal lParam As LongPtr) As Long
    Get_X_lParam = CLng(lParam) And &H7FFF&
    If CLng(lParam) And &H8000& Then Get_X_lParam = Get_X_lParam Or &HFFFF8000
    End Function

    Public Function Get_Y_lParam(ByVal lParam As LongPtr) As Long
    Get_Y_lParam = (CLng(lParam) And &H7FFF0000) \ &H10000
    If CLng(lParam) And &H80000000 Then Get_Y_lParam = Get_Y_lParam Or &HFFFF8000
    End Function

    Public Function Make_XY_lParam(ByVal X As Long, ByVal Y As Long) As LongPtr
    Make_XY_lParam = (CLng(LOWORD(Y)) * &H10000) Or (LOWORD(X) And &HFFFF&)
    End Function

    Public Function GET_SC_WPARAM(ByVal wParam As LongPtr) As Long
        Return (CLng(wParam) And &HFFF0&)
    End Function
    
    [IgnoreWarnings(TB0025)]
    Public Function GET_WM_COMMAND_ID(ByVal wp As LongPtr, ByVal lp As LongPtr) As Long
        Return LOWORD(CLng(wp))
    End Function
    [IgnoreWarnings(TB0025)]
    Public Function GET_WM_COMMAND_CMD(ByVal wp As LongPtr, ByVal lp As LongPtr) As Long
        Return HIWORD(CLng(wp))
    End Function

    Public Function GET_RAWINPUT_CODE_WPARAM(ByVal wParam As LongPtr) As Long
        Return CLng(wParam And &HFF)
    End Function
    [IgnoreWarnings(TB0018)]
    Public Function MAKEIPRANGE(ByVal Low As Byte, ByVal High As Byte) As Integer
    If (High And &H80) <> 0 Then
        Return ((High * &H100&) Or Low) Or &HFFFF0000
    Else
        Return (High * &H100) Or Low
    End If
    End Function

    [Description("Creates a Long representing an IPv4 address from 4 subfields.")]
    Public Function MAKEIPADDRESS(ByVal b1 As Long, ByVal b2 As Long, ByVal b3 As Long, ByVal b4 As Long) As Long
        Return ((b1 << 24) + (b2 << 16) + (b3 << 8) + b4)
    End Function

    /*
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
    ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
    ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
    */
    [ConstantFoldable]
    Public Function MAKEFOURCC(ByVal ch0 As Long, ByVal ch1 As Long, ByVal ch2 As Long, ByVal ch3 As Long) As Long
        Return ((ch0) Or ((ch1) << 8) Or ((ch2) << 16) Or ((ch3) << 24))
    End Function

    Public Function MAKEROP4(fore As Long, back As Long) As Long
        Return ((((back) << 8) And &HFF000000) Or (fore))
    End Function

    Public Function HandleToULong(ByVal h As LongPtr) As Long
        #If Win64 Then
            CopyMemory HandleToULong, h, 4
        #Else
            Return h
        #End If
    End Function
    
    #If WINDEVLIB_NOMATH = 0 Then
    Public Function Log10f(ByVal Value As Single) As Single
        Return CSng((Log(Value) / Log(10!)))
    End Function
    Public Function Log10(ByVal Value As Double) As Double
        Return (Log(Value) / Log(10#))
    End Function
    Public Function Asin(ByVal Arg As Double) As Double
        Return Atn(Arg / Sqr(-Arg * Arg + 1))
    End Function
    Public Function Asinf(ByVal Arg As Single) As Single
        Return CSng(Atn(Arg / Sqr(-Arg * Arg + 1)))
    End Function
    Public Function Acos(ByVal Arg As Double) As Double
        Return Atn(Arg / Sqr(-Arg * Arg + 1))
    End Function
    Public Function Acosf(ByVal Arg As Single) As Single
        Return CSng(Atn(Arg / Sqr(-Arg * Arg + 1)))
    End Function
    Public Function Atan(ByVal Arg As Double) As Double
        Return Atn(Arg)
    End Function
    Public Function Atanf(ByVal Arg As Single) As Single
        Return CSng(Atn(Arg))
    End Function
    Public Function Sec(ByVal Arg As Double) As Double
        Return 1 / Cos(Arg)
    End Function
    Public Function Secf(ByVal Arg As Single) As Single
        Return CSng(1 / Cos(Arg))
    End Function
    Public Function Asec(ByVal Arg As Double) As Double
        Return Atn(Arg / Sqr(Arg * Arg - 1)) + CDbl(Sgn(CDbl(Arg - 1))) * (2 * Atn(1))
    End Function
    Public Function Asecf(ByVal Arg As Single) As Single
        Return CSng(Atn(Arg / Sqr(Arg * Arg - 1)) + CDbl(Sgn(CDbl(Arg - 1))) * (2 * Atn(1)))
    End Function
    Public Function Cosec(ByVal Arg As Double) As Double
        Return 1 / Sin(Arg)
    End Function
    Public Function Cosecf(ByVal Arg As Single) As Single
        Return CSng(1 / Sin(Arg))
    End Function
    Public Function Acosec(ByVal Arg As Double) As Double
        Return Atn(Arg / Sqr(Arg * Arg - 1)) + (CDbl(Sgn(Arg)) - 1) * (2 * Atn(1))
    End Function
    Public Function Acosecf(ByVal Arg As Single) As Single
        Return CSng(Atn(Arg / Sqr(Arg * Arg - 1)) + (CSng(Sgn(Arg)) - 1) * (2 * Atn(1)))
    End Function
    Public Function Acotan(ByVal Arg As Double) As Double
        Return Atn(Arg) + 2 * Atn(1)
    End Function
    Public Function Acotanf(ByVal Arg As Single) As Single
        Return CSng(Atn(Arg) + 2 * Atn(1))
    End Function
    Public Function Sinh(ByVal Arg As Double) As Double
        Return (Exp(Arg) - Exp(-Arg)) / 2
    End Function
    Public Function Sinhf(ByVal Arg As Single) As Single
        Return CSng((Exp(Arg) - Exp(-Arg)) / 2)
    End Function
    Public Function Cosh(ByVal Arg As Double) As Double
        Return (Exp(Arg) + Exp(-Arg)) / 2
    End Function
    Public Function Coshf(ByVal Arg As Single) As Single
        Return CSng((Exp(Arg) + Exp(-Arg)) / 2)
    End Function
    Public Function Tanh(ByVal Arg As Double) As Double
        Return (Exp(Arg) - Exp(-Arg)) / (Exp(Arg) + Exp(-Arg))
    End Function
    Public Function Tanhf(ByVal Arg As Single) As Single
        Return CSng((Exp(Arg) - Exp(-Arg)) / (Exp(Arg) + Exp(-Arg)))
    End Function
    Public Function Sech(ByVal Arg As Double) As Double
        Return 2 / (Exp(Arg) + Exp(-Arg))
    End Function
    Public Function Sechf(ByVal Arg As Single) As Single
        Return CSng(2 / (Exp(Arg) + Exp(-Arg)))
    End Function
    Public Function Cosech(ByVal Arg As Double) As Double
        Return 2 / (Exp(Arg) - Exp(-Arg))
    End Function
    Public Function Cosechf(ByVal Arg As Single) As Single
        Return CSng(2 / (Exp(Arg) - Exp(-Arg)))
    End Function
    Public Function Cotanh(ByVal Arg As Double) As Double
        Return (Exp(Arg) + Exp(-Arg)) / (Exp(Arg) - Exp(-Arg))
    End Function
    Public Function Cotanhf(ByVal Arg As Single) As Single
        Return CSng((Exp(Arg) + Exp(-Arg)) / (Exp(Arg) - Exp(-Arg)))
    End Function
    Public Function Asinh(ByVal Arg As Double) As Double
        Return Log(Arg + Sqr(Arg * Arg + 1))
    End Function
    Public Function Asinhf(ByVal Arg As Single) As Single
        Return CSng(Log(Arg + Sqr(Arg * Arg + 1)))
    End Function
    Public Function Acosh(ByVal Arg As Double) As Double
        Return Log(Arg + Sqr(Arg * Arg - 1))
    End Function
    Public Function Acoshf(ByVal Arg As Single) As Single
        Return CSng(Log(Arg + Sqr(Arg * Arg - 1)))
    End Function
    Public Function Atanh(ByVal Arg As Double) As Double
        Return Log((1 + Arg) / (1 - Arg)) / 2
    End Function
    Public Function Atanhf(ByVal Arg As Single) As Single
        Return CSng(Log((1 + Arg) / (1 - Arg)) / 2)
    End Function
    Public Function Asech(ByVal Arg As Double) As Double
    Return Log((Sqr(-Arg * Arg + 1) + 1) / Arg)
    End Function
    Public Function Asechf(ByVal Arg As Single) As Single
        Return CSng(Log((Sqr(-Arg * Arg + 1) + 1) / Arg))
    End Function
    Public Function Acosech(ByVal Arg As Double) As Double
        Return Log(CDbl((Sgn(Arg)) * Sqr(Arg * Arg + 1) + 1) / Arg)
    End Function
    Public Function Acosechf(ByVal Arg As Single) As Single
        Return CSng(Log((CDbl(Sgn(Arg)) * Sqr(Arg * Arg + 1) + 1) / Arg))
    End Function
    Public Function Acotanh(ByVal Arg As Double) As Double
        Return Log((Arg + 1) / (Arg - 1)) / 2
    End Function
    Public Function Acotanhf(ByVal Arg As Single) As Single
        Return CSng(Log((Arg + 1) / (Arg - 1)) / 2)
    End Function
    Public Function Pow(ByVal Base As Double, ByVal Power As Double) As Double
        Return Base ^ Power
    End Function
    Public Function Powf(ByVal Base As Single, ByVal Power As Single) As Single
        Return CSng(Base ^ Power)
    End Function
    #End If
        
        
        
    [Description("Implementation of AtlPixelToHiMetric")]
    Public Sub AtlPixelToHiMetric(lpSizeInPix As SIZE, lpSizeInHiMetric As SIZE, Optional hwndForDC As LongPtr = 0)
        Dim nPixelsPerInchX As Long
        Dim nPixelsPerInchY As Long
 
        Dim hDC As LongPtr = GetDC(hwndForDC)
        nPixelsPerInchX = GetDeviceCaps(hDC, LOGPIXELSX)
        nPixelsPerInchY = GetDeviceCaps(hDC, LOGPIXELSY)
        ReleaseDC(hwndForDC, hDC)
        lpSizeInHiMetric.cx = MAP_PIX_TO_LOGHIM(lpSizeInPix.cx, nPixelsPerInchX)
        lpSizeInHiMetric.cy = MAP_PIX_TO_LOGHIM(lpSizeInPix.cy, nPixelsPerInchY)
    End Sub
    [Description("Implementation of AtlHiMetricToPixel")]
    Public Sub AtlHiMetricToPixel(lpSizeInHiMetric As SIZE, lpSizeInPix As SIZE, Optional hwndForDC As LongPtr = 0)
        Dim nPixelsPerInchX As Long
        Dim nPixelsPerInchY As Long

        Dim hDC As LongPtr = GetDC(hwndForDC)
        nPixelsPerInchX = GetDeviceCaps(hDC, LOGPIXELSX)
        nPixelsPerInchY = GetDeviceCaps(hDC, LOGPIXELSY)
        ReleaseDC(hwndForDC, hDC)
        lpSizeInPix.cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric.cx, nPixelsPerInchX)
        lpSizeInPix.cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric.cy, nPixelsPerInchY)
    End Sub
    Private Function MAP_PIX_TO_LOGHIM(x As Long, ppli As Long) As Long
        Return MulDiv(HIMETRIC_PER_INCH, x, ppli)
    End Function
    Private Function MAP_LOGHIM_TO_PIX(x As Long, ppli As Long) As Long
        Return MulDiv(ppli, x, HIMETRIC_PER_INCH)
    End Function

    'CUSTOM:
    [Description("Implementation of AtlPixelToHiMetric")]
    Public Sub PixelToHiMetric(lpSizeInPix As SIZE, lpSizeInHiMetric As SIZE, Optional hwndForDC As LongPtr = 0)
        Dim nPixelsPerInchX As Long
        Dim nPixelsPerInchY As Long

        Dim hDC As LongPtr = GetDC(hwndForDC)
        nPixelsPerInchX = GetDeviceCaps(hDC, LOGPIXELSX)
        nPixelsPerInchY = GetDeviceCaps(hDC, LOGPIXELSY)
        ReleaseDC(hwndForDC, hDC)
        lpSizeInHiMetric.cx = MAP_PIX_TO_LOGHIM(lpSizeInPix.cx, nPixelsPerInchX)
        lpSizeInHiMetric.cy = MAP_PIX_TO_LOGHIM(lpSizeInPix.cy, nPixelsPerInchY)
    End Sub
    [Description("Implementation of AtlHiMetricToPixel")]
    Public Sub HiMetricToPixel(lpSizeInHiMetric As SIZE, lpSizeInPix As SIZE, Optional hwndForDC As LongPtr = 0)
        Dim nPixelsPerInchX As Long
        Dim nPixelsPerInchY As Long

        Dim hDC As LongPtr = GetDC(hwndForDC)
        nPixelsPerInchX = GetDeviceCaps(hDC, LOGPIXELSX)
        nPixelsPerInchY = GetDeviceCaps(hDC, LOGPIXELSY)
        ReleaseDC(hwndForDC, hDC)
        lpSizeInPix.cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric.cx, nPixelsPerInchX)
        lpSizeInPix.cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric.cy, nPixelsPerInchY)
    End Sub
    [Description("Converts a POINT, POINTL, or {x.y} to LongLong for use with methods requiring a ByVal POINT")]
    Public Function PointToLongLong(pt As POINT) As LongLong
        Dim ll As LongLong
        CopyMemory ll, pt, 8
        Return ll
    End Function
    [Description("Converts a POINT, POINTL, POINTS, or {x.y} to LongLong for use with methods requiring a ByVal POINT")]
    Public Function PointToLongLong(ByVal ptx As Long, ByVal pty As Long) As LongLong
        Dim pt As POINT
        pt.x = ptx: pt.y = pty
        Dim ll As LongLong
        CopyMemory ll, pt, 8
        Return ll
    End Function
    [Description("Converts a POINT, POINTL, POINTS, or {x.y} to LongLong for use with methods requiring a ByVal POINT")]
    Public Function PointToLongLong(ByVal ptx As Integer, ByVal pty As Integer) As LongLong
        Dim pt As POINT
        pt.x = ptx: pt.y = pty
        Dim ll As LongLong
        CopyMemory ll, pt, 8
        Return ll
    End Function
    [Description("Converts a POINTF or {x.y} to LongLong for use with methods requiring a ByVal POINT")]
    Public Function PointFToLongLong(pt As POINTF) As LongLong
        Dim ll As LongLong
        CopyMemory ll, pt, 8
        Return ll
    End Function
    [Description("Converts a POINTF or {x.y} to LongLong for use with methods requiring a ByVal POINT")]
    Public Function PointFToLongLong(ptx As Single, pty As Single) As LongLong
        Dim pt As POINTF
        pt.x = ptx: pt.y = pty
        Dim ll As LongLong
        CopyMemory ll, pt, 8
        Return ll
    End Function
    [Description("Converts a POINTS to Long for use with methods requiring a ByVal POINTS")]
    Public Function PointSToLong(pt As POINTS) As Long
        Dim ll As Long
        CopyMemory ll, pt, 4
        Return ll
    End Function
    [Description("Converts a SIZE, or {cx,cy} to LongLong for use with methods requiring a ByVal SIZE")]
    Public Function SizeToLongLong(ByVal cx As Long, ByVal cy As Long) As LongLong
        Dim z As SIZE
        z.cx = cx: z.cy = cy
        Dim ll As LongLong
        CopyMemory ll, z, 8
        Return ll
    End Function
    [Description("Converts a SIZE, or {cx,cy} to LongLong for use with methods requiring a ByVal SIZE")]
    Public Function SizeToLongLong(z As SIZE) As LongLong
       Dim ll As LongLong
       CopyMemory ll, z, 8
       Return ll
    End Function
    [Description("Converts a UUID (GUID) to 4 Longs to prepare for passing it to API/COM methods expecting it ByVal.")]
    Public Sub UUIDtoLong(pGuid As UUID, pl1 As Long, pl2 As Long, pl3 As Long, pl4 As Long)
        Dim t(3) As Long
        CopyMemory t(0), pGuid, LenB(Of UUID)
        pl1 = t(0)
        pl2 = t(1)
        pl3 = t(2)
        pl4 = t(3)
    End Sub
    [Description("Converts a UUID (GUID) to 4 Longs to prepare for passing it to API/COM methods expecting it ByVal.")]
    Public Sub UUIDtoLong(pGuid As UUID, pls() As Long)
        ReDim pls(3)
        CopyMemory pls(0), pGuid, LenB(Of UUID)
    End Sub

    [Description("A 32 and 64bit compatible implementation of the classic helper function.")]
    Public Function SwapVtableEntry(pObj As LongPtr, EntryNumber As Integer, ByVal lpFN As LongPtr) As LongPtr

        Dim lOldAddr As LongPtr
        Dim lpVtableHead As LongPtr
        Dim lpfnAddr As LongPtr
        Dim lOldProtect As MemProtectFlags
    

        CopyMemory lpVtableHead, ByVal pObj, LenB(Of LongPtr)
        lpfnAddr = lpVtableHead + (EntryNumber - 1) * LenB(Of LongPtr)
        CopyMemory lOldAddr, ByVal lpfnAddr, LenB(Of LongPtr)

        Call VirtualProtect(lpfnAddr, LenB(Of LongPtr), PAGE_EXECUTE_READWRITE, lOldProtect)
        CopyMemory ByVal lpfnAddr, lpFN, LenB(Of LongPtr)
        Call VirtualProtect(lpfnAddr, LenB(Of LongPtr), lOldProtect, lOldProtect)

        SwapVtableEntry = lOldAddr
    
    End Function

    [ConstantFoldable]
    Public Function UtfToANSI(sIn As String) As String
        Return CStr(StrConv(sIn, vbFromUnicode))
    End Function

    [ConstantFoldable]
    Public Function CTL_CODE(ByVal DeviceType As DEVICE_TYPE, ByVal lFunction As Long, [TypeHint(CtlBufferPassMethod)] ByVal Method As Long, [TypeHint(DEVICE_FILE_ACCESS, FileAccessRights)] ByVal Access As Long) As Long
       CTL_CODE = ((DeviceType) << 16&) Or ((Access) << 14&) Or ((lFunction) << 2) Or (Method)
    End Function

    [Description("A 32 and 64bit compatible implementation of the classic helper function.")]
    Public Function LPWSTRtoStr(lPtr As LongPtr, Optional ByVal fFree As Boolean = True) As String
    SysReAllocStringW VarPtr(LPWSTRtoStr), lPtr
    If fFree Then
        Call CoTaskMemFree(lPtr)
        lPtr = 0
    End If

    End Function
    [Description("Retrieves a tB-style String from a VT_LPWSTR Variant. Returns False if not VT_LPWSTR or PropVariantToStringAlloc returns a nullptr.")]
    Public Function VariantLPWSTRtoSTR(pVar As Variant, pOut As String) As Boolean
        Dim vt As Integer
        If VarPtr(pVar) <> 0 Then
            CopyMemory vt, ByVal VarPtr(pVar), 2
            If (vt = VT_LPWSTR) Then
                Dim lp As LongPtr
                PropVariantToStringAlloc pVar, lp
                If lp Then
                    pOut = LPWSTRtoStr(lp, True)
                    Return True
                End If
            End If
        End If
    End Function

    [Description("Returns an HRESULT error description given it's number, e.g. 5 returns Access denied. Leave lpSource off for standard system messages.")]
    Public Function GetSystemErrorString(lErrNum As Long, Optional ByVal lpSource As LongPtr = 0) As String
        Dim sError As String, ret As Long
        sError = Space$(MAX_PATH)
        ret = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS, ByVal lpSource, lErrNum, 0&, sError, Len(sError), 0)
        If ret > 0 Then Return Left$(sError, ret)
    End Function
    [Description("Returns an NTSTATUS error description given it's number, e.g. &HC0000005 returns Access denied.")]
    Public Function GetNtErrorString(lErrNum As Long) As String
        Dim sError As String, ret As Long
        Dim lpSource As LongPtr = LoadLibrary("ntdll.dll")
        sError = Space$(MAX_PATH)
        ret = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS Or FORMAT_MESSAGE_FROM_HMODULE, ByVal lpSource, lErrNum, 0&, sError, Len(sError), 0)
        If ret > 0 Then Return Left$(sError, ret)
    End Function

    [Description("Ensures a block of memory is zeroed where compiler optimizations may prevent that with ZeroMemory")]
    Public Sub SecureZeroMemory(ByVal pv As LongPtr, cb As LongPtr)
        If pv = 0 Then Exit Sub
        If cb = 0 Then Exit Sub
        Dim i As LongPtr
        For i = 0 To cb - 1
            CopyMemory ByVal pv + i, 0, 1
        Next
    End Sub

    [Description("Returns the true VarType without filtering VT_BYREF etc")]
    Public Function VarTypeEx(pvar As Variant) As VARENUM
        If VarPtr(pvar) = 0 Then Return 0
        CopyMemory VarTypeEx, ByVal VarPtr(pvar), 2
        ' Return CType(Of VARENUM)(CType(Of PROPVARIANT)(VarPtr(pvar)).vt)
    End Function

    [Description("Sets a Variant to the specified type without any alteration to the data. vtOnlyIf raises an error if the original type is other than specified.  " & vbCrLf & "⚠️ WARNING: Many data formats are incompatible, use VariantChangeType absent specific need....")]
    Public Function VariantSetType(pvar As Variant, [TypeHint(VARENUM)] ByVal vt As Integer, [TypeHint(VARENUM)] Optional ByVal vtOnlyIf As Integer = -1) As Boolean
        If VarPtr(pvar) = 0 Then Return False
        If vtOnlyIf <> -1 Then
            If VarTypeEx(pvar) <> vtOnlyIf Then
                Return False
            End If
        End If
        CopyMemory pvar, vt, 2
        Return True
    End Function
    [Description("Performs an unsigned add on a LongPtr (Long or LongLong)")]
    Public Function PointerAdd(ByVal Start As LongPtr, ByVal Incr As LongPtr) As LongPtr
        #If Win64 Then
        Return ((Start Xor &H8000000000000000) + Incr) Xor &H8000000000000000
        #Else
        Return ((Start Xor &H80000000) + Incr) Xor &H80000000
        #End If
    End Function
    [Description("Performs an unsigned subtraction on a LongPtr (Long or LongLong)")]
    Public Function PointerSubtract(ByVal Start As LongPtr, ByVal Incr As LongPtr) As LongPtr
        #If Win64 Then
        Return ((Start Xor &H8000000000000000) - Incr) Xor &H8000000000000000
        #Else
        Return ((Start Xor &H80000000) - Incr) Xor &H80000000
        #End If
    End Function

    'The following 5 function taken from Krool's excellent VBCCR project and modified to use tB features:
    [IgnoreWarnings(TB0018)]
    [Description("Created an unsigned Integer from a Long.")]
    Public Function CUIntToInt(ByVal Value As Long) As Integer
    Const OFFSET_2 As Long = 65536
    Const MAXINT_2 As Integer = 32767
    If Value < 0 Or Value >= OFFSET_2 Then Err.Raise 6
    If Value <= MAXINT_2 Then
        Return Value
    Else
        Return Value - OFFSET_2
    End If
    End Function
    [Description("Converts an Integer to a Long as if it were an unsigned Integer.")]
    Public Function CIntToUInt(ByVal Value As Integer) As Long
    Const OFFSET_2 As Long = 65536
    If Value < 0 Then
        Return Value + OFFSET_2
    Else
        Return Value
    End If
    End Function

    [Description("Created an unsigned Long from a LongLong.")]
    Public Function CULngToLng(ByVal Value As LongLong) As Long
    Const OFFSET_4 As LongLong = 4294967296^
    Const MAXINT_4 As Long = 2147483647
    If Value < 0 Or Value >= OFFSET_4 Then Err.Raise 6
    If Value <= MAXINT_4 Then
        Return CLng(Value)
    Else
        Return CLng(CLngLng(Value) - OFFSET_4)
    End If
    End Function
    [IgnoreWarnings(TB0018)]
    [Description("Created an unsigned Long from a Double.")]
    Public Function CULngToLng(ByVal Value As Double) As Long
    Const OFFSET_4 As Double = 4294967296#
    Const MAXINT_4 As Long = 2147483647
    If Value < 0 Or Value >= OFFSET_4 Then Err.Raise 6
    If Value <= MAXINT_4 Then
        CULngToLng = Value
    Else
        CULngToLng = Value - OFFSET_4
    End If
    End Function

    [Description("Converts a Long to LongLong as if it were an unsigned Long.")]
    Public Function CLngToULng(ByVal Value As Long) As LongLong
    Const OFFSET_4 As LongLong = 4294967296
    If Value < 0 Then
        Return Value + OFFSET_4
    Else
        Return Value
    End If
    End Function
    [Description("Converts a Long to Double as if it were an unsigned Long.")]
    Public Sub CLngToULng(ByVal Value As Long, pULng As Double)
    Const OFFSET_4 As Double = 4294967296#
    If Value < 0 Then
        pULng = Value + OFFSET_4
    Else
        pULng = Value
    End If
    End Sub

    Public Function UnsignedAdd(ByVal Start As Integer, ByVal Incr As Integer) As Integer
    Return ((Start Xor &H8000) + Incr) Xor &H8000
    End Function
    Public Function UnsignedAdd(ByVal Start As Long, ByVal Incr As Long) As Long
    Return ((Start Xor &H80000000) + Incr) Xor &H80000000
    End Function
    Public Function UnsignedAdd(ByVal Start As LongLong, ByVal Incr As LongLong) As LongLong
    Return ((Start Xor &H8000000000000000) + Incr) Xor &H8000000000000000
    End Function
    #End Region
    
    #Region "Intrinsics"
    'Low level intrinsics
    Public Function __readfsdword CDecl Naked(ByVal offset As Long) As Long
        #If Win64 Then
        Emit(&H64, &H8B, &H01)          'mov eax, fs:[rcx]     ; 
        Emit(&Hc3)                      'ret
        #Else
        Emit(&H8B, &H44, &H24, &H04)    'mov eax, [esp+4]
        Emit(&H64, &H8B, &H00)          'mov eax, fs:[eax]
        Emit(&Hc3)                      'ret
        #End If
    End Function
    
    
    #End Region
#End If
End Module
