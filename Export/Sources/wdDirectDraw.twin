'*****************************************************************************************
'This file is a part of WinDevLib - Windows Development Library for twinBASIC
'https://github.com/fafalone/WinDevLib
'Code ported by Jon Johnson. 
'"Windows" is a trademark of the Microsoft Corporation.
'Certain Description attributes (c) Microsoft, taken from SDK headers and official docs.
'Licensed under Creative Commons CC0 1.0 Universal
'*****************************************************************************************

'WinDevLib - DirectDraw

' ddraw.h

' DirectDraw is still used by legacy media components; the DirectShow interfaces ironically
'   offer far more than their replacement Media Foundation APIs in terms of codec support.

#If WDL_NO_DIRECTX = 0 Then

[InterfaceId("6C14DB80-A733-11CE-A521-0020AF0BE560")]
[OleAutomation(False)]
[Description("IDirectDraw Interface")]
Interface IDirectDraw Extends stdole.IUnknown
    Sub Compact()
    Sub CreateClipper(ByVal dwFlags As Long, lplpDDClipper As IDirectDrawClipper, ByVal pUnkOuter As IUnknown)
    Sub CreatePalette(ByVal dwFlags As DDPCAPSFLAGS, lpDDColorTable As PALETTEENTRY, lplpDDPalette As IDirectDrawPalette, ByVal pUnkOuter As IUnknown)
    Sub CreateSurface(ByRef lpDDSurfaceDesc As DDSURFACEDESC, lplpDDSurface As IDirectDrawSurface, ByVal pUnkOuter As IUnknown)
    Sub DuplicateSurface(ByVal lpDDSurface As IDirectDrawSurface, lplpDupDDSurface As IDirectDrawSurface)
	' #If WDL_NO_DELEGATES Then
    Sub EnumDisplayModes(ByVal dwFlags As DDEDMFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC, ByVal lpContext As LongPtr, ByVal lpEnumModesCallback As LongPtr)
    Sub EnumSurfaces(ByVal dwFlags As DDENUMSURFACESFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC, ByVal lpContext As LongPtr, ByVal lpEnumSurfacesCallback As LongPtr)
	' #Else
    ' Sub EnumDisplayModes(ByVal dwFlags As DDEDMFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC, ByVal lpContext As LongPtr, ByVal lpEnumModesCallback As DDENUMMODESCALLBACK)
    ' Sub EnumSurfaces(ByVal dwFlags As DDENUMSURFACESFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC, ByVal lpContext As LongPtr, ByVal lpEnumSurfacesCallback As DDENUMSURFACESCALLBACK)
    ' #End If
    Sub FlipToGDISurface()
    Sub GetCaps(ByRef lpDDDriverCaps As DDCAPS, ByRef lpDDHELCaps As DDCAPS)
    Sub GetDisplayMode(ByRef lpDDSurfaceDesc As DDSURFACEDESC)
    Sub GetFourCCCodes(ByRef lpNumCodes As Long, ByRef lpCodes As Long)
    Sub GetGDISurface(ByRef ppGDISurface As IDirectDrawSurface)
    Sub GetMonitorFrequency(ByRef lpdwFrequency As Long)
    Sub GetScanLine(ByRef lpdwScanLine As Long)
    Sub GetVerticalBlankStatus(ByRef lpbIsInVB As BOOL)
    Sub Initialize(ByRef lpGUID As GUID)
    Sub RestoreDisplayMode()
    Sub SetCooperativeLevel(ByVal hWnd As LongPtr, ByVal dwFlags As DDSCLFLAGS)
    Sub SetDisplayMode(ByVal dwWidth As Long, ByVal dwHeight As Long, ByVal dwBPP As Long)
    Sub WaitForVerticalBlank(ByVal dwFlags As DDWAITVBFLAGS, ByVal hEvent As LongPtr)
End Interface

[InterfaceId("B3A6F3E0-2B43-11CF-A2DE-00AA00B93356")]
[OleAutomation(False)]
[Description("IDirectDraw2 Interface")]
Interface IDirectDraw2 Extends stdole.IUnknown
    Sub Compact()
    Sub CreateClipper(ByVal dwFlags As Long, lplpDDClipper As IDirectDrawClipper, ByVal pUnkOuter As IUnknown)
    Sub CreatePalette(ByVal dwFlags As DDPCAPSFLAGS, lpDDColorTable As PALETTEENTRY, lplpDDPalette As IDirectDrawPalette, ByVal pUnkOuter As IUnknown)
    Sub CreateSurface(ByRef lpDDSurfaceDesc As DDSURFACEDESC, lplpDDSurface As IDirectDrawSurface, ByVal pUnkOuter As IUnknown)
    Sub DuplicateSurface(ByVal lpDDSurface As IDirectDrawSurface, lplpDupDDSurface As IDirectDrawSurface)
    ' #If WDL_NO_DELEGATES Then
    Sub EnumDisplayModes(ByVal dwFlags As DDEDMFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC, ByVal lpContext As LongPtr, ByVal lpEnumModesCallback As LongPtr)
    Sub EnumSurfaces(ByVal dwFlags As DDENUMSURFACESFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC, ByVal lpContext As LongPtr, ByVal lpEnumSurfacesCallback As LongPtr)
    ' #Else
    ' Sub EnumDisplayModes(ByVal dwFlags As DDEDMFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC, ByVal lpContext As LongPtr, ByVal lpEnumModesCallback As DDENUMMODESCALLBACK)
    ' Sub EnumSurfaces(ByVal dwFlags As DDENUMSURFACESFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC, ByVal lpContext As LongPtr, ByVal lpEnumSurfacesCallback As DDENUMSURFACESCALLBACK)
    ' #End If
    Sub FlipToGDISurface()
    Sub GetCaps(ByRef lpDDDriverCaps As DDCAPS, ByRef lpDDHELCaps As DDCAPS)
    Sub GetDisplayMode(ByRef lpDDSurfaceDesc As DDSURFACEDESC)
    Sub GetFourCCCodes(ByRef lpNumCodes As Long, ByRef lpCodes As Long)
    Sub GetGDISurface(ByRef ppGDISurface As IDirectDrawSurface)
    Sub GetMonitorFrequency(ByRef lpdwFrequency As Long)
    Sub GetScanLine(ByRef lpdwScanLine As Long)
    Sub GetVerticalBlankStatus(ByRef lpbIsInVB As BOOL)
    Sub Initialize(ByRef lpGUID As GUID)
    Sub RestoreDisplayMode()
    Sub SetCooperativeLevel(ByVal hWnd As LongPtr, ByVal dwFlags As DDSCLFLAGS)
    Sub SetDisplayMode(ByVal dwWidth As Long, ByVal dwHeight As Long, ByVal dwBPP As Long, ByVal dwRefreshRate As Long, ByVal dwFlags As DDSDMFLAGS)
	Sub WaitForVerticalBlank(ByVal dwFlags As Long, ByVal hEvent As LongPtr)
	Sub GetAvailableVidMem(ByRef lpDDSCaps As DDSCAPS, ByRef lpdwTotal As Long, ByRef lpdwFree As Long)
End Interface

[InterfaceId("9C59509A-39BD-11D1-8C4A-00C04FD930C5")]
[OleAutomation(False)]
[Description("IDirectDraw4 Interface")]
Interface IDirectDraw4 Extends stdole.IUnknown
    Sub Compact()
    Sub CreateClipper(ByVal dwFlags As Long, lplpDDClipper As IDirectDrawClipper, ByVal pUnkOuter As IUnknown)
    Sub CreatePalette(ByVal dwFlags As DDPCAPSFLAGS, lpDDColorTable As PALETTEENTRY, lplpDDPalette As IDirectDrawPalette, ByVal pUnkOuter As IUnknown)
    Sub CreateSurface(ByRef lpDDSurfaceDesc As DDSURFACEDESC2, lplpDDSurface As IDirectDrawSurface4, ByVal pUnkOuter As IUnknown)
    Sub DuplicateSurface(ByVal lpDDSurface As IDirectDrawSurface4, lplpDupDDSurface As IDirectDrawSurface4)
    ' #If WDL_NO_DELEGATES Then
    Sub EnumDisplayModes(ByVal dwFlags As DDEDMFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC2, ByVal lpContext As LongPtr, ByVal lpEnumModesCallback As LongPtr)
    Sub EnumSurfaces(ByVal dwFlags As DDENUMSURFACESFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC2, ByVal lpContext As LongPtr, ByVal lpEnumSurfacesCallback As LongPtr)
    ' #Else
    ' Sub EnumDisplayModes(ByVal dwFlags As DDEDMFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC2, ByVal lpContext As LongPtr, ByVal lpEnumModesCallback As DDENUMMODESCALLBACK2)
    ' Sub EnumSurfaces(ByVal dwFlags As DDENUMSURFACESFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC2, ByVal lpContext As LongPtr, ByVal lpEnumSurfacesCallback As DDENUMSURFACESCALLBACK2)
    ' #End If
    Sub FlipToGDISurface()
    Sub GetCaps(ByRef lpDDDriverCaps As DDCAPS, ByRef lpDDHELCaps As DDCAPS)
    Sub GetDisplayMode(ByRef lpDDSurfaceDesc As DDSURFACEDESC2)
    Sub GetFourCCCodes(ByRef lpNumCodes As Long, ByRef lpCodes As Long)
    Sub GetGDISurface(ByRef ppGDISurface As IDirectDrawSurface4)
    Sub GetMonitorFrequency(ByRef lpdwFrequency As Long)
    Sub GetScanLine(ByRef lpdwScanLine As Long)
    Sub GetVerticalBlankStatus(ByRef lpbIsInVB As BOOL)
    Sub Initialize(ByRef lpGUID As GUID)
    Sub RestoreDisplayMode()
    Sub SetCooperativeLevel(ByVal hWnd As LongPtr, ByVal dwFlags As DDSCLFLAGS)
    Sub SetDisplayMode(ByVal dwWidth As Long, ByVal dwHeight As Long, ByVal dwBPP As Long, ByVal dwRefreshRate As Long, ByVal dwFlags As DDSDMFLAGS)
    Sub WaitForVerticalBlank(ByVal dwFlags As Long, ByVal hEvent As LongPtr)
    Sub GetAvailableVidMem(ByRef lpDDSCaps As DDSCAPS2, ByRef lpdwTotal As Long, ByRef lpdwFree As Long)
    Sub GetSurfaceFromDC(ByVal hDC As LongPtr, lplpDDSurface4 As IDirectDrawSurface4)
    Sub RestoreAllSurfaces()
    Sub TestCooperativeLevel()
    Sub GetDeviceIdentifier(pIdentifier As DDDEVICEIDENTIFIER, ByVal dwFlags As DDDEVICEIDFLAGS)
End Interface

[InterfaceId("15E65EC0-3B9C-11D2-B92F-00609797EA5B")]
[OleAutomation(False)]
[Description("IDirectDraw7 Interface")]
Interface IDirectDraw7 Extends stdole.IUnknown
    Sub Compact()
    Sub CreateClipper(ByVal dwFlags As Long, lplpDDClipper As IDirectDrawClipper, ByVal pUnkOuter As IUnknown)
    Sub CreatePalette(ByVal dwFlags As DDPCAPSFLAGS, lpDDColorTable As PALETTEENTRY, lplpDDPalette As IDirectDrawPalette, ByVal pUnkOuter As IUnknown)
    Sub CreateSurface(ByRef lpDDSurfaceDesc As DDSURFACEDESC2, lplpDDSurface As IDirectDrawSurface7, ByVal pUnkOuter As IUnknown)
    Sub DuplicateSurface(ByVal lpDDSurface As IDirectDrawSurface7, lplpDupDDSurface As IDirectDrawSurface7)
    ' #If WDL_NO_DELEGATES Then
    Sub EnumDisplayModes(ByVal dwFlags As DDEDMFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC2, ByVal lpContext As LongPtr, ByVal lpEnumModesCallback As LongPtr)
    Sub EnumSurfaces(ByVal dwFlags As DDENUMSURFACESFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC2, ByVal lpContext As LongPtr, ByVal lpEnumSurfacesCallback As LongPtr)
    ' #Else
    ' Sub EnumDisplayModes(ByVal dwFlags As DDEDMFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC2, ByVal lpContext As LongPtr, ByVal lpEnumModesCallback As DDENUMMODESCALLBACK2)
    ' Sub EnumSurfaces(ByVal dwFlags As DDENUMSURFACESFLAGS, ByRef lpDDSurfaceDesc As DDSURFACEDESC2, ByVal lpContext As LongPtr, ByVal lpEnumSurfacesCallback As DDENUMSURFACESCALLBACK7)
    ' #End If
    Sub FlipToGDISurface()
    Sub GetCaps(ByRef lpDDDriverCaps As DDCAPS, ByRef lpDDHELCaps As DDCAPS)
    Sub GetDisplayMode(ByRef lpDDSurfaceDesc As DDSURFACEDESC2)
    Sub GetFourCCCodes(ByRef lpNumCodes As Long, ByRef lpCodes As Long)
    Sub GetGDISurface(ByRef ppGDISurface As IDirectDrawSurface7)
    Sub GetMonitorFrequency(ByRef lpdwFrequency As Long)
    Sub GetScanLine(ByRef lpdwScanLine As Long)
    Sub GetVerticalBlankStatus(ByRef lpbIsInVB As BOOL)
    Sub Initialize(ByRef lpGUID As GUID)
    Sub RestoreDisplayMode()
    Sub SetCooperativeLevel(ByVal hWnd As LongPtr, ByVal dwFlags As DDSCLFLAGS)
    Sub SetDisplayMode(ByVal dwWidth As Long, ByVal dwHeight As Long, ByVal dwBPP As Long, ByVal dwRefreshRate As Long, ByVal dwFlags As DDSDMFLAGS)
    Sub WaitForVerticalBlank(ByVal dwFlags As Long, ByVal hEvent As LongPtr)
    Sub GetAvailableVidMem(ByRef lpDDSCaps As DDSCAPS2, ByRef lpdwTotal As Long, ByRef lpdwFree As Long)
    Sub GetSurfaceFromDC(ByVal hDC As LongPtr, lplpDDSurface4 As IDirectDrawSurface7)
    Sub RestoreAllSurfaces()
    Sub TestCooperativeLevel()
    Sub GetDeviceIdentifier(pIdentifier As DDDEVICEIDENTIFIER2, ByVal dwFlags As DDDEVICEIDFLAGS)
    Sub StartModeTest(lpModesToTest As SIZE, ByVal dwNumEntries As Long, ByVal dwFlags As DDSMTFLAGS)
    Sub EvaluateMode(ByVal dwFlags As DDEMFLAGS, pSecondsUntilTimeout As Long)
End Interface

[InterfaceId("6C14DB84-A733-11CE-A521-0020AF0BE560")]
[OleAutomation(False)]
Interface IDirectDrawPalette Extends stdole.IUnknown
    ' IDirectDrawPalette methods
    Sub GetCaps(ByRef lpdwCaps As DDPCAPSFLAGS)
    Sub GetEntries(ByVal dwFlags As Long, ByVal dwBase As Long, ByVal dwNumEntries As Long, ByRef lpEntries As PALETTEENTRY)
    Sub Initialize(ByVal pDD As IDirectDraw, ByVal dwFlags As Long, ByVal lpColorTable As LongPtr)
    Sub SetEntries(ByVal dwFlags As Long, ByVal dwBase As Long, ByVal dwCount As Long, ByRef lpEntries As PALETTEENTRY)
End Interface

[InterfaceId("6C14DB85-A733-11CE-A521-0020AF0BE560")]
[OleAutomation(False)]
Interface IDirectDrawClipper Extends stdole.IUnknown
    ' IDirectDrawClipper methods
    Sub GetClipList(ByRef lpRect As RECT, ByRef lpClipList As RGNDATA, ByRef lpdwSize As Long)
    Sub GetHWnd(ByRef lphWnd As LongPtr)
    Sub Initialize(ByVal pDD As IDirectDraw, ByVal dwFlags As Long)
    Sub IsClipListChanged(ByRef lpbChanged As BOOL)
    Sub SetClipList(ByRef lpClipList As RGNDATA, ByVal dwFlags As Long)
    Sub SetHWnd(ByVal dwFlags As Long, ByVal hWnd As LongPtr)
End Interface

[InterfaceId("6C14DB81-A733-11CE-A521-0020AF0BE560")]
[OleAutomation(False)]
Interface IDirectDrawSurface Extends IUnknown
    Sub AddAttachedSurface(ByVal lpDDSurface As IDirectDrawSurface)
    Sub AddOverlayDirtyRect(ByRef lpRect As RECT)
    Sub Blt(ByRef lpDestRect As RECT, ByVal lpDDSrcSurface As IDirectDrawSurface, ByRef lpSrcRect As RECT, ByVal dwFlags As DDBLTFLAGS, ByRef lpBltFx As DDBLTFX)
    Sub BltBatch(ByRef lpBltBatch As DDBLTBATCH, ByVal dwCount As Long, ByVal dwFlags As Long)
    Sub BltFast(ByVal dwX As Long, ByVal dwY As Long, ByVal lpDDSrcSurface As IDirectDrawSurface, ByRef lpSrcRect As RECT, ByVal dwFlags As Long)
    Sub DeleteAttachedSurface(ByVal dwFlags As Long, ByVal lpDDSurface As IDirectDrawSurface)
	' #If WDL_NO_DELEGATES Then
    Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
	' #Else
    ' Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK)
    ' Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK)
    ' #End If
    Sub Flip(ByVal lpDDSurfaceTargetOverride As IDirectDrawSurface, ByVal dwFlags As DDFLIPFLAGS)
    Sub GetAttachedSurface(ByRef lpCaps As DDSCAPS, ByRef lpDDAttachedSurface As IDirectDrawSurface)
    Sub GetBltStatus(ByVal dwFlags As DDGBSFLAGS)
    Sub GetCaps(ByRef lpCaps As DDSCAPS)
    Sub GetClipper(ByRef lpClipper As IDirectDrawClipper)
    Sub GetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub GetDC(ByRef lpHDC As LongPtr)
    Sub GetFlipStatus(ByVal dwFlags As DDGFSFLAGS)
    Sub GetOverlayPosition(ByRef lpX As Long, ByRef lpY As Long)
    Sub GetPalette(ByRef lpPalette As IDirectDrawPalette)
    Sub GetPixelFormat(ByRef lpPixelFormat As DDPIXELFORMAT)
    Sub GetSurfaceDesc(ByRef lpSurfaceDesc As DDSURFACEDESC)
    Sub Initialize(ByVal lpDD As IDirectDraw, ByRef lpSurfaceDesc As DDSURFACEDESC)
    Sub IsLost()
    Sub Lock(ByRef lpDestRect As RECT, ByRef lpSurfaceDesc As DDSURFACEDESC, ByVal dwFlags As DDLOCKFLAGS, ByVal hEvent As LongPtr)
    Sub ReleaseDC(ByVal hDC As LongPtr)
    Sub Restore()
    Sub SetClipper(ByVal lpClipper As IDirectDrawClipper)
    Sub SetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub SetOverlayPosition(ByVal lX As Long, ByVal lY As Long)
    Sub SetPalette(ByVal lpPalette As IDirectDrawPalette)
    Sub Unlock(lpRect As Any)
    Sub UpdateOverlay(ByRef lpSrcRect As RECT, ByVal lpDDDestSurface As IDirectDrawSurface, ByRef lpDestRect As RECT, ByVal dwFlags As DDOVERFLAGS, ByRef lpOverlayFx As DDOVERLAYFX)
    Sub UpdateOverlayDisplay(ByVal dwFlags As Long)
    Sub UpdateOverlayZOrder(ByVal dwFlags As DDOVERZFLAGS, ByVal lpDDSReference As IDirectDrawSurface)
End Interface

[InterfaceId("57805885-6EEC-11CF-9441-A82303C10E27")]
[OleAutomation(False)]
Interface IDirectDrawSurface2 Extends IUnknown
    Sub AddAttachedSurface(ByVal lpDDSurface As IDirectDrawSurface2)
    Sub AddOverlayDirtyRect(ByRef lpRect As RECT)
    Sub Blt(ByRef lpDestRect As RECT, ByVal lpDDSrcSurface As IDirectDrawSurface2, ByRef lpSrcRect As RECT, ByVal dwFlags As DDBLTFLAGS, ByRef lpBltFx As DDBLTFX)
    Sub BltBatch(ByRef lpBltBatch As DDBLTBATCH, ByVal dwCount As Long, ByVal dwFlags As Long)
    Sub BltFast(ByVal dwX As Long, ByVal dwY As Long, ByVal lpDDSrcSurface As IDirectDrawSurface2, ByRef lpSrcRect As RECT, ByVal dwFlags As Long)
    Sub DeleteAttachedSurface(ByVal dwFlags As Long, ByVal lpDDSurface As IDirectDrawSurface2)
    ' #If WDL_NO_DELEGATES Then
    Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    ' #Else
    ' Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK)
    ' Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK)
    ' #End If
    Sub Flip(ByVal lpDDSurfaceTargetOverride As IDirectDrawSurface2, ByVal dwFlags As DDFLIPFLAGS)
    Sub GetAttachedSurface(ByRef lpCaps As DDSCAPS, ByRef lpDDAttachedSurface As IDirectDrawSurface2)
    Sub GetBltStatus(ByVal dwFlags As DDGBSFLAGS)
    Sub GetCaps(ByRef lpCaps As DDSCAPS)
    Sub GetClipper(ByRef lpClipper As IDirectDrawClipper)
    Sub GetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub GetDC(ByRef lpHDC As LongPtr)
    Sub GetFlipStatus(ByVal dwFlags As DDGFSFLAGS)
    Sub GetOverlayPosition(ByRef lpX As Long, ByRef lpY As Long)
    Sub GetPalette(ByRef lpPalette As IDirectDrawPalette)
    Sub GetPixelFormat(ByRef lpPixelFormat As DDPIXELFORMAT)
    Sub GetSurfaceDesc(ByRef lpSurfaceDesc As DDSURFACEDESC)
    Sub Initialize(ByVal lpDD As IDirectDraw, ByRef lpSurfaceDesc As DDSURFACEDESC)
    Sub IsLost()
    Sub Lock(ByRef lpDestRect As RECT, ByRef lpSurfaceDesc As DDSURFACEDESC, ByVal dwFlags As DDLOCKFLAGS, ByVal hEvent As LongPtr)
    Sub ReleaseDC(ByVal hDC As LongPtr)
    Sub Restore()
    Sub SetClipper(ByVal lpClipper As IDirectDrawClipper)
    Sub SetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub SetOverlayPosition(ByVal lX As Long, ByVal lY As Long)
    Sub SetPalette(ByVal lpPalette As IDirectDrawPalette)
    Sub Unlock(lpRect As Any)
    Sub UpdateOverlay(ByRef lpSrcRect As RECT, ByVal lpDDDestSurface As IDirectDrawSurface2, ByRef lpDestRect As RECT, ByVal dwFlags As DDOVERFLAGS, ByRef lpOverlayFx As DDOVERLAYFX)
    Sub UpdateOverlayDisplay(ByVal dwFlags As Long)
    Sub UpdateOverlayZOrder(ByVal dwFlags As DDOVERZFLAGS, ByVal lpDDSReference As IDirectDrawSurface2)
    Sub GetDDInterface(ppv As Any)
    Sub PageLock(ByVal dwFlags As Long)
    Sub PageUnlock(ByVal dwFlags As Long)
End Interface

[InterfaceId("DA044E00-69B2-11D0-A1D5-00AA00B8DFBB")]
[OleAutomation(False)]
Interface IDirectDrawSurface3 Extends IUnknown
    Sub AddAttachedSurface(ByVal lpDDSurface As IDirectDrawSurface3)
    Sub AddOverlayDirtyRect(ByRef lpRect As RECT)
    Sub Blt(ByRef lpDestRect As RECT, ByVal lpDDSrcSurface As IDirectDrawSurface3, ByRef lpSrcRect As RECT, ByVal dwFlags As DDBLTFLAGS, ByRef lpBltFx As DDBLTFX)
    Sub BltBatch(ByRef lpBltBatch As DDBLTBATCH, ByVal dwCount As Long, ByVal dwFlags As Long)
    Sub BltFast(ByVal dwX As Long, ByVal dwY As Long, ByVal lpDDSrcSurface As IDirectDrawSurface3, ByRef lpSrcRect As RECT, ByVal dwFlags As Long)
    Sub DeleteAttachedSurface(ByVal dwFlags As Long, ByVal lpDDSurface As IDirectDrawSurface3)
    ' #If WDL_NO_DELEGATES Then
    Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    ' #Else
    ' Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK)
    ' Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK)
    ' #End If
    Sub Flip(ByVal lpDDSurfaceTargetOverride As IDirectDrawSurface3, ByVal dwFlags As DDFLIPFLAGS)
    Sub GetAttachedSurface(ByRef lpCaps As DDSCAPS, ByRef lpDDAttachedSurface As IDirectDrawSurface3)
    Sub GetBltStatus(ByVal dwFlags As DDGBSFLAGS)
    Sub GetCaps(ByRef lpCaps As DDSCAPS)
    Sub GetClipper(ByRef lpClipper As IDirectDrawClipper)
    Sub GetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub GetDC(ByRef lpHDC As LongPtr)
    Sub GetFlipStatus(ByVal dwFlags As DDGFSFLAGS)
    Sub GetOverlayPosition(ByRef lpX As Long, ByRef lpY As Long)
    Sub GetPalette(ByRef lpPalette As IDirectDrawPalette)
    Sub GetPixelFormat(ByRef lpPixelFormat As DDPIXELFORMAT)
    Sub GetSurfaceDesc(ByRef lpSurfaceDesc As DDSURFACEDESC)
    Sub Initialize(ByVal lpDD As IDirectDraw, ByRef lpSurfaceDesc As DDSURFACEDESC)
    Sub IsLost()
    Sub Lock(ByRef lpDestRect As RECT, ByRef lpSurfaceDesc As DDSURFACEDESC, ByVal dwFlags As DDLOCKFLAGS, ByVal hEvent As LongPtr)
    Sub ReleaseDC(ByVal hDC As LongPtr)
    Sub Restore()
    Sub SetClipper(ByVal lpClipper As IDirectDrawClipper)
    Sub SetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub SetOverlayPosition(ByVal lX As Long, ByVal lY As Long)
    Sub SetPalette(ByVal lpPalette As IDirectDrawPalette)
    Sub Unlock(lpRect As Any)
    Sub UpdateOverlay(ByRef lpSrcRect As RECT, ByVal lpDDDestSurface As IDirectDrawSurface3, ByRef lpDestRect As RECT, ByVal dwFlags As DDOVERFLAGS, ByRef lpOverlayFx As DDOVERLAYFX)
    Sub UpdateOverlayDisplay(ByVal dwFlags As Long)
    Sub UpdateOverlayZOrder(ByVal dwFlags As DDOVERZFLAGS, ByVal lpDDSReference As IDirectDrawSurface3)
    Sub GetDDInterface(ppv As Any)
    Sub PageLock(ByVal dwFlags As Long)
    Sub PageUnlock(ByVal dwFlags As Long)
    Sub SetSurfaceDesc(pDesc As DDSURFACEDESC, ByVal dwFlags As Long)
End Interface

[InterfaceId("0B2B8630-AD35-11D0-8EA6-00609797EA5B")]
[OleAutomation(False)]
Interface IDirectDrawSurface4 Extends IUnknown
    Sub AddAttachedSurface(ByVal lpDDSurface As IDirectDrawSurface4)
    Sub AddOverlayDirtyRect(ByRef lpRect As RECT)
    Sub Blt(ByRef lpDestRect As RECT, ByVal lpDDSrcSurface As IDirectDrawSurface4, ByRef lpSrcRect As RECT, ByVal dwFlags As DDBLTFLAGS, ByRef lpBltFx As DDBLTFX)
    Sub BltBatch(ByRef lpBltBatch As DDBLTBATCH, ByVal dwCount As Long, ByVal dwFlags As Long)
    Sub BltFast(ByVal dwX As Long, ByVal dwY As Long, ByVal lpDDSrcSurface As IDirectDrawSurface4, ByRef lpSrcRect As RECT, ByVal dwFlags As Long)
    Sub DeleteAttachedSurface(ByVal dwFlags As Long, ByVal lpDDSurface As IDirectDrawSurface4)
    ' #If WDL_NO_DELEGATES Then
    Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    ' #Else
    ' Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK2)
    ' Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK2)
    ' #End If
    Sub Flip(ByVal lpDDSurfaceTargetOverride As IDirectDrawSurface4, ByVal dwFlags As DDFLIPFLAGS)
    Sub GetAttachedSurface(ByRef lpCaps As DDSCAPS, ByRef lpDDAttachedSurface As IDirectDrawSurface4)
    Sub GetBltStatus(ByVal dwFlags As DDGBSFLAGS)
    Sub GetCaps(ByRef lpCaps As DDSCAPS2)
    Sub GetClipper(ByRef lpClipper As IDirectDrawClipper)
    Sub GetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub GetDC(ByRef lpHDC As LongPtr)
    Sub GetFlipStatus(ByVal dwFlags As DDGFSFLAGS)
    Sub GetOverlayPosition(ByRef lpX As Long, ByRef lpY As Long)
    Sub GetPalette(ByRef lpPalette As IDirectDrawPalette)
    Sub GetPixelFormat(ByRef lpPixelFormat As DDPIXELFORMAT)
    Sub GetSurfaceDesc(ByRef lpSurfaceDesc As DDSURFACEDESC2)
    Sub Initialize(ByVal lpDD As IDirectDraw, ByRef lpSurfaceDesc As DDSURFACEDESC2)
    Sub IsLost()
    Sub Lock(ByRef lpDestRect As RECT, ByRef lpSurfaceDesc As DDSURFACEDESC2, ByVal dwFlags As DDLOCKFLAGS, ByVal hEvent As LongPtr)
    Sub ReleaseDC(ByVal hDC As LongPtr)
    Sub Restore()
    Sub SetClipper(ByVal lpClipper As IDirectDrawClipper)
    Sub SetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub SetOverlayPosition(ByVal lX As Long, ByVal lY As Long)
    Sub SetPalette(ByVal lpPalette As IDirectDrawPalette)
    Sub Unlock(lpRect As RECT)
    Sub UpdateOverlay(ByRef lpSrcRect As RECT, ByVal lpDDDestSurface As IDirectDrawSurface4, ByRef lpDestRect As RECT, ByVal dwFlags As DDOVERFLAGS, ByRef lpOverlayFx As DDOVERLAYFX)
    Sub UpdateOverlayDisplay(ByVal dwFlags As Long)
    Sub UpdateOverlayZOrder(ByVal dwFlags As DDOVERZFLAGS, ByVal lpDDSReference As IDirectDrawSurface4)
    Sub GetDDInterface(ppv As Any)
    Sub PageLock(ByVal dwFlags As Long)
    Sub PageUnlock(ByVal dwFlags As Long)
    Sub SetSurfaceDesc(pDesc As DDSURFACEDESC2, ByVal dwFlags As Long)
    Sub SetPrivateData(pGuid As UUID, pvData As Any, ByVal cbData As Long, ByVal dwFlags As DDSPDFLAGS)
	Sub GetPrivateData(pGuid As UUID, pvData As Any, pcbData As Long)
    Sub GetUniquenessValue(pdwValue As Long)
    Sub ChangeUniquenessValue()
End Interface

[InterfaceId("06675A80-3B9B-11D2-B92F-00609797EA5B")]
[OleAutomation(False)]
Interface IDirectDrawSurface7 Extends IUnknown
    Sub AddAttachedSurface(ByVal lpDDSurface As IDirectDrawSurface7)
    Sub AddOverlayDirtyRect(ByRef lpRect As RECT)
    Sub Blt(ByRef lpDestRect As RECT, ByVal lpDDSrcSurface As IDirectDrawSurface7, ByRef lpSrcRect As RECT, ByVal dwFlags As DDBLTFLAGS, ByRef lpBltFx As DDBLTFX)
    Sub BltBatch(ByRef lpBltBatch As DDBLTBATCH, ByVal dwCount As Long, ByVal dwFlags As Long)
    Sub BltFast(ByVal dwX As Long, ByVal dwY As Long, ByVal lpDDSrcSurface As IDirectDrawSurface7, ByRef lpSrcRect As RECT, ByVal dwFlags As Long)
    Sub DeleteAttachedSurface(ByVal dwFlags As Long, ByVal lpDDSurface As IDirectDrawSurface7)
    ' #If WDL_NO_DELEGATES Then
    Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As LongPtr)
    ' #Else
    ' Sub EnumAttachedSurfaces(ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK7)
    ' Sub EnumOverlayZOrders(ByVal dwFlags As DDENUMOVERLAYZFLAGS, ByVal lpContext As LongPtr, ByVal lpEnumCallback As DDENUMSURFACESCALLBACK7)
    ' #End If
    Sub Flip(ByVal lpDDSurfaceTargetOverride As IDirectDrawSurface7, ByVal dwFlags As DDFLIPFLAGS)
    Sub GetAttachedSurface(ByRef lpCaps As DDSCAPS, ByRef lpDDAttachedSurface As IDirectDrawSurface7)
    Sub GetBltStatus(ByVal dwFlags As DDGBSFLAGS)
    Sub GetCaps(ByRef lpCaps As DDSCAPS2)
    Sub GetClipper(ByRef lpClipper As IDirectDrawClipper)
    Sub GetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub GetDC(ByRef lpHDC As LongPtr)
    Sub GetFlipStatus(ByVal dwFlags As DDGFSFLAGS)
    Sub GetOverlayPosition(ByRef lpX As Long, ByRef lpY As Long)
    Sub GetPalette(ByRef lpPalette As IDirectDrawPalette)
    Sub GetPixelFormat(ByRef lpPixelFormat As DDPIXELFORMAT)
    Sub GetSurfaceDesc(ByRef lpSurfaceDesc As DDSURFACEDESC2)
    Sub Initialize(ByVal lpDD As IDirectDraw, ByRef lpSurfaceDesc As DDSURFACEDESC2)
    Sub IsLost()
    Sub Lock(ByRef lpDestRect As RECT, ByRef lpSurfaceDesc As DDSURFACEDESC2, ByVal dwFlags As DDLOCKFLAGS, ByVal hEvent As LongPtr)
    Sub ReleaseDC(ByVal hDC As LongPtr)
    Sub Restore()
    Sub SetClipper(ByVal lpClipper As IDirectDrawClipper)
    Sub SetColorKey(ByVal dwFlags As DDCKEYFLAGS, ByRef lpColorKey As DDCOLORKEY)
    Sub SetOverlayPosition(ByVal lX As Long, ByVal lY As Long)
    Sub SetPalette(ByVal lpPalette As IDirectDrawPalette)
    Sub Unlock(lpRect As RECT)
    Sub UpdateOverlay(ByRef lpSrcRect As RECT, ByVal lpDDDestSurface As IDirectDrawSurface7, ByRef lpDestRect As RECT, ByVal dwFlags As DDOVERFLAGS, ByRef lpOverlayFx As DDOVERLAYFX)
    Sub UpdateOverlayDisplay(ByVal dwFlags As Long)
    Sub UpdateOverlayZOrder(ByVal dwFlags As DDOVERZFLAGS, ByVal lpDDSReference As IDirectDrawSurface7)
    Sub GetDDInterface(ppv As Any)
    Sub PageLock(ByVal dwFlags As Long)
    Sub PageUnlock(ByVal dwFlags As Long)
    Sub SetSurfaceDesc(pDesc As DDSURFACEDESC2, ByVal dwFlags As Long)
    Sub SetPrivateData(pGuid As UUID, pvData As Any, ByVal cbData As Long, ByVal dwFlags As DDSPDFLAGS)
    Sub GetPrivateData(pGuid As UUID, pvData As Any, pcbData As Long)
    Sub GetUniquenessValue(pdwValue As Long)
    Sub ChangeUniquenessValue()
    Sub SetPriority(ByVal dwPriority As Long)
    Sub GetPriority(pdwPriority As Long)
    Sub SetLOD(ByVal dwValue As Long)
    Sub GetLOD(pdwValue As Long)
End Interface

[InterfaceId("4B9F0EE0-0D7E-11D0-9B06-00A0C903A3B8")]
[OleAutomation(False)]
Interface IDirectDrawColorControl Extends stdole.IUnknown 
    Sub GetColorControls(ByRef lpColorControl As DDCOLORCONTROL)
    Sub SetColorControls(ByRef lpColorControl As DDCOLORCONTROL)
End Interface

[InterfaceId("69C11C3E-B46B-11D1-AD7A-00C04FC29B4E")]
[OleAutomation(False)]
Interface IDirectDrawGammaControl Extends stdole.IUnknown
    Sub GetGammaRamp(ByVal dwFlags As Long, ByRef lpRampData As DDGAMMARAMP)
    Sub SetGammaRamp(ByVal dwFlags As Long, ByRef lpRampData As DDGAMMARAMP)
End Interface


'ddstream.idl

[InterfaceId("F4104FCE-9A70-11d0-8FDE-00C04FD9189D")]
Interface IDirectDrawMediaStream Extends IMediaStream
    Sub GetFormat(ByRef pDDSDCurrent As DDSURFACEDESC, ByRef ppDirectDrawPalette As IDirectDrawPalette, ByRef pDDSDDesired As DDSURFACEDESC, ByRef pdwFlags As DDSD_FLAGS)
    Sub SetFormat(ByRef pDDSurfaceDesc As DDSURFACEDESC, ByVal pDirectDrawPalette As IDirectDrawPalette)
    Sub GetDirectDraw(ByRef ppDirectDraw As IDirectDraw)
    Sub SetDirectDraw(ByVal pDirectDraw As IDirectDraw)
    Sub CreateSample(ByVal pSurface As IDirectDrawSurface, ByRef pRect As RECT, ByVal dwFlags As DDSFF_CS_FLAGS, ByRef ppSample As IDirectDrawStreamSample)
    Sub GetTimePerFrame(ByRef pFrameTime As LongLong /* STREAM_TIME */)
End Interface

[InterfaceId("F4104FCF-9A70-11d0-8FDE-00C04FD9189D")]
Interface IDirectDrawStreamSample Extends IStreamSample
    Sub GetSurface(ByRef ppDirectDrawSurface As IDirectDrawSurface, ByRef pRect As RECT)
    Sub SetRect(ByRef pRect As RECT)
End Interface





Module wdDirectDraw

Public Const DIRECTDRAW_VERSION = &H700

Public Const FOURCC_DXT1  = &H31545844 ' (MAKEFOURCC('D','X','T','1'))
Public Const FOURCC_DXT2  = &H32545844 ' (MAKEFOURCC('D','X','T','2'))
Public Const FOURCC_DXT3  = &H33545844 ' (MAKEFOURCC('D','X','T','3'))
Public Const FOURCC_DXT4  = &H34545844 ' (MAKEFOURCC('D','X','T','4'))
    
Public Function CLSID_DirectDraw() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD7B70EE0, &H4340, &H11CF, &HB0, &H63, &H00, &H20, &HAF, &HC2, &HCD, &H35)
	CLSID_DirectDraw = iid
End Function
Public Function CLSID_DirectDraw7() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H3c305196, &H50db, &H11d3, &H9c, &Hfe, &H00, &Hc0, &H4f, &Hd9, &H30, &Hc5)
	CLSID_DirectDraw7 = iid
End Function
Public Function CLSID_DirectDrawClipper() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H593817A0, &H7DB3, &H11CF, &HA2, &HDE, &H00, &HAA, &H00, &Hb9, &H33, &H56)
	CLSID_DirectDrawClipper = iid
End Function
Public Function IID_IDirectDraw() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6C14DB80, &HA733, &H11CE, &HA5, &H21, &H00, &H20, &HAF, &H0B, &HE5, &H60)
	IID_IDirectDraw = iid
End Function
Public Function IID_IDirectDraw2() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB3A6F3E0, &H2B43, &H11CF, &HA2, &HDE, &H00, &HAA, &H00, &HB9, &H33, &H56)
	IID_IDirectDraw2 = iid
End Function
Public Function IID_IDirectDraw4() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H9c59509a, &H39bd, &H11d1, &H8c, &H4a, &H00, &Hc0, &H4f, &Hd9, &H30, &Hc5)
	IID_IDirectDraw4 = iid
End Function
Public Function IID_IDirectDraw7() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H15e65ec0, &H3b9c, &H11d2, &Hb9, &H2f, &H00, &H60, &H97, &H97, &Hea, &H5b)
	IID_IDirectDraw7 = iid
End Function
Public Function IID_IDirectDrawSurface() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6C14DB81, &HA733, &H11CE, &HA5, &H21, &H00, &H20, &HAF, &H0B, &HE5, &H60)
	IID_IDirectDrawSurface = iid
End Function
Public Function IID_IDirectDrawSurface2() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H57805885, &H6eec, &H11cf, &H94, &H41, &Ha8, &H23, &H03, &Hc1, &H0e, &H27)
	IID_IDirectDrawSurface2 = iid
End Function
Public Function IID_IDirectDrawSurface3() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HDA044E00, &H69B2, &H11D0, &HA1, &HD5, &H00, &HAA, &H00, &HB8, &HDF, &HBB)
	IID_IDirectDrawSurface3 = iid
End Function
Public Function IID_IDirectDrawSurface4() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H0B2B8630, &HAD35, &H11D0, &H8E, &HA6, &H00, &H60, &H97, &H97, &HEA, &H5B)
	IID_IDirectDrawSurface4 = iid
End Function
Public Function IID_IDirectDrawSurface7() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H06675a80, &H3b9b, &H11d2, &Hb9, &H2f, &H00, &H60, &H97, &H97, &Hea, &H5b)
	IID_IDirectDrawSurface7 = iid
End Function
Public Function IID_IDirectDrawPalette() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6C14DB84, &HA733, &H11CE, &HA5, &H21, &H00, &H20, &HAF, &H0B, &HE5, &H60)
	IID_IDirectDrawPalette = iid
End Function
Public Function IID_IDirectDrawClipper() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H6C14DB85, &HA733, &H11CE, &HA5, &H21, &H00, &H20, &HAF, &H0B, &HE5, &H60)
	IID_IDirectDrawClipper = iid
End Function
Public Function IID_IDirectDrawColorControl() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H4B9F0EE0, &H0D7E, &H11D0, &H9B, &H06, &H00, &HA0, &HC9, &H03, &HA3, &HB8)
	IID_IDirectDrawColorControl = iid
End Function
Public Function IID_IDirectDrawGammaControl() As UUID
Static iid As UUID
	If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H69C11C3E, &HB46B, &H11D1, &HAD, &H7A, &H00, &HC0, &H4F, &HC2, &H9B, &H4E)
	IID_IDirectDrawGammaControl = iid
End Function

Public Delegate Function DDENUMCALLBACKA (guidDevice As UUID, ByVal lpName As LongPtr, ByVal lpDescription As LongPtr, ByVal context As LongPtr) As BOOL
Public Delegate Function DDENUMCALLBACKW (guidDevice As UUID, ByVal lpName As LongPtr, ByVal lpDescription As LongPtr, ByVal context As LongPtr) As BOOL
Public Delegate Function DDENUMCALLBACK (guidDevice As UUID, ByVal lpName As LongPtr, ByVal lpDescription As LongPtr, ByVal context As LongPtr) As BOOL
Public Delegate Function DDENUMCALLBACKEXA (guidDevice As UUID, ByVal lpName As LongPtr, ByVal lpDescription As LongPtr, ByVal context As LongPtr, ByVal hMonitor As LongPtr) As BOOL
Public Delegate Function DDENUMCALLBACKEXW (guidDevice As UUID, ByVal lpName As LongPtr, ByVal lpDescription As LongPtr, ByVal context As LongPtr, ByVal hMonitor As LongPtr) As BOOL
Public Delegate Function DDENUMCALLBACKEX (guidDevice As UUID, ByVal lpName As LongPtr, ByVal lpDescription As LongPtr, ByVal context As LongPtr, ByVal hMonitor As LongPtr) As BOOL

' #If WDL_NO_DELEGATES
[UseGetLastError(False)]
Public Declare PtrSafe Function DirectDrawEnumerateA Lib "ddraw.dll" (ByVal lpCallback As LongPtr, ByVal lpContext As LongPtr) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function DirectDrawEnumerateW Lib "ddraw.dll" (ByVal lpCallback As LongPtr, ByVal lpContext As LongPtr) As Long
[UseGetLastError(False)]
Public DeclareWide PtrSafe Function DirectDrawEnumerate Lib "ddraw.dll" Alias "DirectDrawEnumerateW" (ByVal lpCallback As LongPtr, ByVal lpContext As LongPtr) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function DirectDrawEnumerateExA Lib "ddraw.dll" (ByVal lpCallback As LongPtr, ByVal lpContext As LongPtr, ByVal dwFlags As DDrawEnumFlags) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function DirectDrawEnumerateExW Lib "ddraw.dll" (ByVal lpCallback As LongPtr, ByVal lpContext As LongPtr, ByVal dwFlags As DDrawEnumFlags) As Long
[UseGetLastError(False)]
Public DeclareWide PtrSafe Function DirectDrawEnumerateEx Lib "ddraw.dll" Alias "DirectDrawEnumerateExW" (ByVal lpCallback As LongPtr, ByVal lpContext As LongPtr, ByVal dwFlags As DDrawEnumFlags) As Long
' #Else
' [UseGetLastError(False)]
' Public Declare PtrSafe Function DirectDrawEnumerateA Lib "ddraw.dll" (ByVal lpCallback As DDENUMCALLBACKA, ByVal lpContext As LongPtr) As Long
' [UseGetLastError(False)]
' Public Declare PtrSafe Function DirectDrawEnumerateW Lib "ddraw.dll" (ByVal lpCallback As DDENUMCALLBACKW, ByVal lpContext As LongPtr) As Long
' [UseGetLastError(False)]
' Public DeclareWide PtrSafe Function DirectDrawEnumerate Lib "ddraw.dll" Alias "DirectDrawEnumerateW" (ByVal lpCallback As DDENUMCALLBACK, ByVal lpContext As LongPtr) As Long
' #End If

[UseGetLastError(False)]
Public Declare PtrSafe Function DirectDrawCreate Lib "ddraw.dll" (lpGUID As UUID, lplpDD As IDirectDraw, ByVal pUnkOuter As IUnknown) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function DirectDrawCreateEx Lib "ddraw.dll" (lpGUID As UUID, lplpDD As IDirectDraw, iid As UUID, ByVal pUnkOuter As IUnknown) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function DirectDrawCreateClipper Lib "ddraw.dll" (ByVal dwFlags As DDrawCreateFlags, llplpDDClipper As IDirectDrawClipper, ByVal pUnkOuter As IUnknown) As Long




Public Enum DDrawEnumFlags
    /*
    * This flag causes enumeration of any GDI display devices which are part of
    * the Windows Desktop
    */
    DDENUM_ATTACHEDSECONDARYDEVICES = &H00000001
    /*
    * This flag causes enumeration of any GDI display devices which are not
    * part of the Windows Desktop
    */
    DDENUM_DETACHEDSECONDARYDEVICES = &H00000002
    /*
    * This flag causes enumeration of non-display devices
    */
    DDENUM_NONDISPLAYDEVICES = &H00000004
End Enum

Public Const REGSTR_KEY_DDHW_DESCRIPTION  = "Description"
Public Const REGSTR_KEY_DDHW_DRIVERNAME  = "DriverName"
Public Const REGSTR_PATH_DDHW  = "Hardware\DirectDrawDrivers"

Public Enum DDrawCreateFlags
	DDCREATE_HARDWAREONLY = &H00000001
	DDCREATE_EMULATIONONLY = &H00000002
End Enum


Public Delegate Function DDENUMMODESCALLBACK (dds As DDSURFACEDESC, ByVal lpConext As LongPtr) As Long
Public Delegate Function DDENUMMODESCALLBACK2 (dds As DDSURFACEDESC2, ByVal lpConext As LongPtr) As Long
Public Delegate Function DDENUMSURFACESCALLBACK (ByVal pSurface As IDirectDrawSurface, dds As DDSURFACEDESC, ByVal lpConext As LongPtr) As Long
Public Delegate Function DDENUMSURFACESCALLBACK2 (ByVal pSurface As IDirectDrawSurface4, dds As DDSURFACEDESC2, ByVal lpConext As LongPtr) As Long
Public Delegate Function DDENUMSURFACESCALLBACK7 (ByVal pSurface As IDirectDrawSurface7, dds As DDSURFACEDESC2, ByVal lpConext As LongPtr) As Long

Public Type DDARGB
	blue As Byte
	green As Byte
	red As Byte
	alpha As Byte
End Type

#If WDL_DX7VB_DD Then
Public Type DDCOLORKEY
	low As Long                                          
	high As Long                                         
End Type 
Public Type DDBLTFX
	lSize As Long                                        
	lDDFX As CONST_DDBLTFXFLAGS                  
	lROP As Long                                         
	lDDROP As Long                                       
	lRotationAngle As Long                               
	lZBufferOpCode As Long                               
	lZBufferLow As Long                                  
	lZBufferHigh As Long                                 
	lZBufferBaseDest As Long                             
	lZDestConstBitDepth As Long                          
	lZDestConst As LongPtr                                   
	lZSrcConstBitDepth As Long                          
	lZSrcConst As LongPtr                                   
	lAlphaEdgeBlendBitDepth As Long                      
	lAlphaEdgeBlend As Long                              
	lReserved As Long                                    
	lAlphaDestConstBitDepth As Long                      
	lAlphaDestConst As LongPtr                              
	lAlphaSrcConstBitDepth As Long                       
	lAlphaSrcConst As LongPtr                               
	lFill As LongPtr                                        
	ddckDestColorKey_low As Long                         
	ddckDestColorKey_high As Long                        
	ddckSrcColorKey_low As Long                          
	ddckSrcColorKey_high As Long                         
End Type 
Public Type DDSCAPS2
	lCaps As CONST_DDSURFACECAPSFLAGS            
	lCaps2 As CONST_DDSURFACECAPS2FLAGS          
	lCaps3 As Long                                       
	lCaps4 As Long                                       
End Type
Public Type DDCAPS
	lSize As Long                                        
	lCaps As CONST_DDCAPS1FLAGS                  
	lCaps2 As CONST_DDCAPS2FLAGS                 
	lCKeyCaps As CONST_DDCKEYCAPSFLAGS           
	lFXCaps As CONST_DDFXCAPSFLAGS               
	lFXAlphaCaps As Long                                 
	lPalCaps As CONST_DDPCAPSFLAGS               
	lSVCaps As CONST_DDSTEREOCAPSFLAGS           
	lAlphaBltConstBitDepths As Long                      
	lAlphaBltPixelBitDepths As Long                      
	lAlphaBltSurfaceBitDepths As Long                    
	lAlphaOverlayConstBitDepths As Long                  
	lAlphaOverlayPixelBitDepths As Long                  
	lAlphaOverlaySurfaceBitDepths As Long                
	lZBufferBitDepths As Long                            
	lVidMemTotal As Long                                 
	lVidMemFree As Long                                  
	lMaxVisibleOverlays As Long                          
	lCurrVisibleOverlays As Long                         
	lNumFourCCCodes As Long                              
	lAlignBoundarySrc As Long                            
	lAlignSizeSrc As Long                                
	lAlignBoundaryDest As Long                           
	lAlignSizeDest As Long                               
	lAlignStrideAlign As Long                            
	lRops(0 To 7) As Long                                
	lReservedCaps As Long                                
	lMinOverlayStretch As Long                           
	lMaxOverlayStretch As Long                           
	lMinLiveVideoStretch As Long                         
	lMaxLiveVideoStretch As Long                         
	lMinHwCodecStretch As Long                           
	lMaxHwCodecStretch As Long                           
	lReserved1 As Long                                   
	lReserved2 As Long                                   
	lReserved3 As Long                                   
	lSVBCaps As CONST_DDCAPS1FLAGS               
	lSVBCKeyCaps As CONST_DDCKEYCAPSFLAGS        
	lSVBFXCaps As CONST_DDFXCAPSFLAGS            
	lSVBRops(0 To 7) As Long                             
	lVSBCaps As CONST_DDCAPS1FLAGS               
	lVSBCKeyCaps As CONST_DDCKEYCAPSFLAGS        
	lVSBFXCaps As CONST_DDFXCAPSFLAGS            
	lVSRops(0 To 7) As Long                              
	lSSBCaps As CONST_DDCAPS1FLAGS               
	lSSBCKeyCaps As CONST_DDCKEYCAPSFLAGS        
	lSSBFXCaps As CONST_DDFXCAPSFLAGS            
	lSSBRops(0 To 7) As Long                             
	lMaxVideoPorts As Long                               
	lCurrVideoPorts As Long                              
	lSVBCaps2 As CONST_DDCAPS2FLAGS              
	lNLVBCaps As CONST_DDCAPS1FLAGS              
	lNLVBCaps2 As CONST_DDCAPS2FLAGS             
	lNLVBCKeyCaps As CONST_DDCKEYCAPSFLAGS       
	lNLVBFXCaps As CONST_DDFXCAPSFLAGS           
	lNLVBRops(0 To 7) As Long                            
	ddsCaps As DDSCAPS2                          
End Type                                                 

#Else
Public Type DDCOLORKEY
    dwColorSpaceLowValue As Long ' low boundary of color space that is to
    ' be treated as Color Key, inclusive
    dwColorSpaceHighValue As Long ' high boundary of color space that is
    ' to be treated as Color Key, inclusive
End Type
Public Type DDBLTFX
    dwSize As Long ' size of structure
    dwDDFX As DDBLTFXFLAGS ' FX operations
    dwROP As Long ' Win32 raster operations
    dwDDROP As Long ' Raster operations new for DirectDraw
    dwRotationAngle As Long ' Rotation angle for blt
    dwZBufferOpCode As Long ' ZBuffer compares
    dwZBufferLow As Long ' Low limit of Z buffer
    dwZBufferHigh As Long ' High limit of Z buffer
    dwZBufferBaseDest As Long ' Destination base value
    dwZDestConstBitDepth As Long ' Bit depth used to specify Z constant for destination
    'union
    '{
    '    DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
    '    LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest
    '} DUMMYUNIONNAMEN(1);
    dwZDestConst_lpDDSZBufferDest As LongPtr
    dwZSrcConstBitDepth As Long ' Bit depth used to specify Z constant for source
    'union
    '{
    '    DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
    '    LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src
    '} DUMMYUNIONNAMEN(2);
    dwZSrcConst_lpDDSZBufferSrc As LongPtr
    dwAlphaEdgeBlendBitDepth As Long ' Bit depth used to specify constant for alpha edge blend
    dwAlphaEdgeBlend As Long ' Alpha for edge blending
    dwReserved As Long
    dwAlphaDestConstBitDepth As Long ' Bit depth used to specify alpha constant for destination
    'union
    '{
    '    DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
    '    LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel
    '} DUMMYUNIONNAMEN(3);
    dwAlphaDestConst_lpDDSAlphaDest As LongPtr
    dwAlphaSrcConstBitDepth As Long ' Bit depth used to specify alpha constant for source
    'union
    '{
    '    DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
    '    LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel
    '} DUMMYUNIONNAMEN(4);
    dwAlphaSrcConst_lpDDSAlphaSrc As LongPtr
    'union
    '{
    '    DWORD   dwFillColor;                    // color in RGB or Palettized
    '    DWORD   dwFillDepth;                    // depth value for z-buffer
    '    DWORD   dwFillPixel;                    // pixel value for RGBA or RGBZ
    '    LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern
    '} DUMMYUNIONNAMEN(5);
    dwFillOrDDSPattern As LongPtr
    ddckDestColorkey As DDCOLORKEY ' DestColorkey override
    ddckSrcColorkey As DDCOLORKEY ' SrcColorkey override
End Type
Public Type DDSCAPS2
    dwCaps As DDSURFACECAPSFLAGS ' capabilities of surface wanted
    dwCaps2 As DDSURFACECAPS2FLAGS
    dwCaps3 As DDSURFACECAPS3FLAGS
    ' union
    ' {
        ' DWORD       dwCaps4;
        ' DWORD       dwVolumeDepth;
    ' } DUMMYUNIONNAMEN(1);
    dwCaps4OrVolumeDepth As Long
End Type
Public Type DDCAPS
    dwSize As Long ' size of the DDDRIVERCAPS structure
    dwCaps As DDCAPS1FLAGS ' driver specific capabilities
    dwCaps2 As DDCAPS2FLAGS ' more driver specific capabilites
    dwCKeyCaps As DDCKEYCAPSFLAGS ' color key capabilities of the surface
    dwFXCaps As DDFXCAPSFLAGS ' driver specific stretching and effects capabilites
    dwFXAlphaCaps As DDFXALPHACAPSFLAGS ' alpha driver specific capabilities
    dwPalCaps As DDPCAPSFLAGS ' palette capabilities
    dwSVCaps As DDSTEREOCAPSFLAGS ' stereo vision capabilities
    dwAlphaBltConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaBltPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaBltSurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlayConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaOverlayPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlaySurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwZBufferBitDepths As Long ' DDBD_8,16,24,32
    dwVidMemTotal As Long ' total amount of video memory
    dwVidMemFree As Long ' amount of free video memory
    dwMaxVisibleOverlays As Long ' maximum number of visible overlays
    dwCurrVisibleOverlays As Long ' current number of visible overlays
    dwNumFourCCCodes As Long ' number of four cc codes
    dwAlignBoundarySrc As Long ' source rectangle alignment
    dwAlignSizeSrc As Long ' source rectangle byte size
    dwAlignBoundaryDest As Long ' dest rectangle alignment
    dwAlignSizeDest As Long ' dest rectangle byte size
    dwAlignStrideAlign As Long ' stride alignment
    dwRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported
    ddsOldCaps As DDSCAPS ' Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
    dwMinOverlayStretch As Long ' minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxOverlayStretch As Long ' maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinLiveVideoStretch As Long ' minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxLiveVideoStretch As Long ' maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinHwCodecStretch As Long ' minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxHwCodecStretch As Long ' maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwReserved1 As Long ' reserved
    dwReserved2 As Long ' reserved
    dwReserved3 As Long ' reserved
    dwSVBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->Vmem blts
    dwSVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->Vmem blts
    dwSVBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->Vmem blts
    dwSVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->Vmem blts
    dwVSBCaps As DDCAPS1FLAGS ' driver specific capabilities for Vmem->System blts
    dwVSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for Vmem->System blts
    dwVSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for Vmem->System blts
    dwVSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for Vmem->System blts
    dwSSBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->System blts
    dwSSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->System blts
    dwSSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->System blts
    dwSSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->System blts
    dwMaxVideoPorts As Long ' maximum number of usable video ports
    dwCurrVideoPorts As Long ' current number of video ports used
    dwSVBCaps2 As DDCAPS2FLAGS ' more driver specific capabilities for System->Vmem blts
    dwNLVBCaps As DDCAPS1FLAGS ' driver specific capabilities for non-local->local vidmem blts
    dwNLVBCaps2 As DDCAPS2FLAGS ' more driver specific capabilities non-local->local vidmem blts
    dwNLVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for non-local->local vidmem blts
    dwNLVBFXCaps As DDFXCAPSFLAGS  ' driver FX capabilities for non-local->local blts
    dwNLVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for non-local->local blts
    ' Members added for DX6 release
    ddsCaps As DDSCAPS2 ' Surface Caps
End Type



#End If

Public Type DDSCAPS
    dwCaps As DDSURFACECAPSFLAGS ' capabilities of surface wanted
End Type

Public Type DDOSCAPS
    dwCaps As Long ' capabilities of surface wanted
End Type

Public Type DDSCAPSEX
    dwCaps2 As DDSURFACECAPS2FLAGS
    dwCaps3 As DDSURFACECAPS3FLAGS
    ' union
    ' {
        ' DWORD       dwCaps4;
        ' DWORD       dwVolumeDepth;
    ' } DUMMYUNIONNAMEN(1);
    dwCaps4OrVolumeDepth As Long
End Type

Public Const DD_ROP_SPACE  = (256 / 32)        ' space required to store ROP array

Public Type DDCAPS_DX1 'no dxvb
    dwSize As Long ' size of the DDDRIVERCAPS structure
    dwCaps As DDCAPS1FLAGS ' driver specific capabilities
    dwCaps2 As DDCAPS2FLAGS ' more driver specific capabilites
    dwCKeyCaps As DDCKEYCAPSFLAGS ' color key capabilities of the surface
    dwFXCaps As DDFXCAPSFLAGS ' driver specific stretching and effects capabilites
    dwFXAlphaCaps As DDFXALPHACAPSFLAGS ' alpha driver specific capabilities
    dwPalCaps As DDPCAPSFLAGS ' palette capabilities
    dwSVCaps As DDSTEREOCAPSFLAGS ' stereo vision capabilities
    dwAlphaBltConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaBltPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaBltSurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlayConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaOverlayPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlaySurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwZBufferBitDepths As Long ' DDBD_8,16,24,32
    dwVidMemTotal As Long ' total amount of video memory
    dwVidMemFree As Long ' amount of free video memory
    dwMaxVisibleOverlays As Long ' maximum number of visible overlays
    dwCurrVisibleOverlays As Long ' current number of visible overlays
    dwNumFourCCCodes As Long ' number of four cc codes
    dwAlignBoundarySrc As Long ' source rectangle alignment
    dwAlignSizeSrc As Long ' source rectangle byte size
    dwAlignBoundaryDest As Long ' dest rectangle alignment
    dwAlignSizeDest As Long ' dest rectangle byte size
    dwAlignStrideAlign As Long ' stride alignment
    dwRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported
    ddsCaps As DDSCAPS ' DDSCAPS structure has all the general capabilities
    dwMinOverlayStretch As Long ' minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxOverlayStretch As Long ' maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinLiveVideoStretch As Long ' OBSOLETE! This field remains for compatability reasons only
    dwMaxLiveVideoStretch As Long ' OBSOLETE! This field remains for compatability reasons only
    dwMinHwCodecStretch As Long ' OBSOLETE! This field remains for compatability reasons only
    dwMaxHwCodecStretch As Long ' OBSOLETE! This field remains for compatability reasons only
    dwReserved1 As Long ' reserved
    dwReserved2 As Long ' reserved
    dwReserved3 As Long ' reserved
End Type
Public Type DDCAPS_DX3
    dwSize As Long ' size of the DDDRIVERCAPS structure
    dwCaps As DDCAPS1FLAGS ' driver specific capabilities
    dwCaps2 As DDCAPS2FLAGS ' more driver specific capabilites
    dwCKeyCaps As DDCKEYCAPSFLAGS ' color key capabilities of the surface
    dwFXCaps As DDFXCAPSFLAGS ' driver specific stretching and effects capabilites
    dwFXAlphaCaps As DDFXALPHACAPSFLAGS ' alpha driver specific capabilities
    dwPalCaps As DDPCAPSFLAGS ' palette capabilities
    dwSVCaps As DDSTEREOCAPSFLAGS ' stereo vision capabilities
    dwAlphaBltConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaBltPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaBltSurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlayConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaOverlayPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlaySurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwZBufferBitDepths As Long ' DDBD_8,16,24,32
    dwVidMemTotal As Long ' total amount of video memory
    dwVidMemFree As Long ' amount of free video memory
    dwMaxVisibleOverlays As Long ' maximum number of visible overlays
    dwCurrVisibleOverlays As Long ' current number of visible overlays
    dwNumFourCCCodes As Long ' number of four cc codes
    dwAlignBoundarySrc As Long ' source rectangle alignment
    dwAlignSizeSrc As Long ' source rectangle byte size
    dwAlignBoundaryDest As Long ' dest rectangle alignment
    dwAlignSizeDest As Long ' dest rectangle byte size
    dwAlignStrideAlign As Long ' stride alignment
    dwRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported
    ddsCaps As DDSCAPS ' DDSCAPS structure has all the general capabilities
    dwMinOverlayStretch As Long ' minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxOverlayStretch As Long ' maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinLiveVideoStretch As Long ' minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxLiveVideoStretch As Long ' maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinHwCodecStretch As Long ' minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxHwCodecStretch As Long ' maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwReserved1 As Long ' reserved
    dwReserved2 As Long ' reserved
    dwReserved3 As Long ' reserved
    dwSVBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->Vmem blts
    dwSVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->Vmem blts
    dwSVBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->Vmem blts
    dwSVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->Vmem blts
    dwVSBCaps As DDCAPS1FLAGS ' driver specific capabilities for Vmem->System blts
    dwVSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for Vmem->System blts
    dwVSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for Vmem->System blts
    dwVSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for Vmem->System blts
    dwSSBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->System blts
    dwSSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->System blts
    dwSSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->System blts
    dwSSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->System blts
    dwReserved4 As Long ' reserved
    dwReserved5 As Long ' reserved
    dwReserved6 As Long ' reserved
End Type
Public Type DDCAPS_DX5
    dwSize As Long ' size of the DDDRIVERCAPS structure
    dwCaps As DDCAPS1FLAGS ' driver specific capabilities
    dwCaps2 As DDCAPS2FLAGS ' more driver specific capabilites
    dwCKeyCaps As DDCKEYCAPSFLAGS ' color key capabilities of the surface
    dwFXCaps As DDFXCAPSFLAGS ' driver specific stretching and effects capabilites
    dwFXAlphaCaps As DDFXALPHACAPSFLAGS ' alpha driver specific capabilities
    dwPalCaps As DDPCAPSFLAGS ' palette capabilities
    dwSVCaps As DDSTEREOCAPSFLAGS ' stereo vision capabilities
    dwAlphaBltConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaBltPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaBltSurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlayConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaOverlayPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlaySurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwZBufferBitDepths As Long ' DDBD_8,16,24,32
    dwVidMemTotal As Long ' total amount of video memory
    dwVidMemFree As Long ' amount of free video memory
    dwMaxVisibleOverlays As Long ' maximum number of visible overlays
    dwCurrVisibleOverlays As Long ' current number of visible overlays
    dwNumFourCCCodes As Long ' number of four cc codes
    dwAlignBoundarySrc As Long ' source rectangle alignment
    dwAlignSizeSrc As Long ' source rectangle byte size
    dwAlignBoundaryDest As Long ' dest rectangle alignment
    dwAlignSizeDest As Long ' dest rectangle byte size
    dwAlignStrideAlign As Long ' stride alignment
    dwRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported
    ddsCaps As DDSCAPS ' DDSCAPS structure has all the general capabilities
    dwMinOverlayStretch As Long ' minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxOverlayStretch As Long ' maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinLiveVideoStretch As Long ' minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxLiveVideoStretch As Long ' maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinHwCodecStretch As Long ' minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxHwCodecStretch As Long ' maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwReserved1 As Long ' reserved
    dwReserved2 As Long ' reserved
    dwReserved3 As Long ' reserved
    dwSVBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->Vmem blts
    dwSVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->Vmem blts
    dwSVBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->Vmem blts
    dwSVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->Vmem blts
    dwVSBCaps As DDCAPS1FLAGS ' driver specific capabilities for Vmem->System blts
    dwVSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for Vmem->System blts
    dwVSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for Vmem->System blts
    dwVSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for Vmem->System blts
    dwSSBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->System blts
    dwSSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->System blts
    dwSSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->System blts
    dwSSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->System blts
    ' Members added for DX5:
    dwMaxVideoPorts As Long ' maximum number of usable video ports
    dwCurrVideoPorts As Long ' current number of video ports used
    dwSVBCaps2 As DDCAPS2FLAGS ' more driver specific capabilities for System->Vmem blts
    dwNLVBCaps As DDCAPS1FLAGS ' driver specific capabilities for non-local->local vidmem blts
    dwNLVBCaps2 As DDCAPS2FLAGS ' more driver specific capabilities non-local->local vidmem blts
    dwNLVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for non-local->local vidmem blts
    dwNLVBFXCaps As DDFXCAPSFLAGS  ' driver FX capabilities for non-local->local blts
    dwNLVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for non-local->local blts
End Type
Public Type DDCAPS_DX6
    dwSize As Long ' size of the DDDRIVERCAPS structure
    dwCaps As DDCAPS1FLAGS ' driver specific capabilities
    dwCaps2 As DDCAPS2FLAGS ' more driver specific capabilites
    dwCKeyCaps As DDCKEYCAPSFLAGS ' color key capabilities of the surface
    dwFXCaps As DDFXCAPSFLAGS ' driver specific stretching and effects capabilites
    dwFXAlphaCaps As DDFXALPHACAPSFLAGS ' alpha driver specific capabilities
    dwPalCaps As DDPCAPSFLAGS ' palette capabilities
    dwSVCaps As DDSTEREOCAPSFLAGS ' stereo vision capabilities
    dwAlphaBltConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaBltPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaBltSurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlayConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaOverlayPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlaySurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwZBufferBitDepths As Long ' DDBD_8,16,24,32
    dwVidMemTotal As Long ' total amount of video memory
    dwVidMemFree As Long ' amount of free video memory
    dwMaxVisibleOverlays As Long ' maximum number of visible overlays
    dwCurrVisibleOverlays As Long ' current number of visible overlays
    dwNumFourCCCodes As Long ' number of four cc codes
    dwAlignBoundarySrc As Long ' source rectangle alignment
    dwAlignSizeSrc As Long ' source rectangle byte size
    dwAlignBoundaryDest As Long ' dest rectangle alignment
    dwAlignSizeDest As Long ' dest rectangle byte size
    dwAlignStrideAlign As Long ' stride alignment
    dwRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported
    ddsOldCaps As DDSCAPS ' Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
    dwMinOverlayStretch As Long ' minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxOverlayStretch As Long ' maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinLiveVideoStretch As Long ' minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxLiveVideoStretch As Long ' maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinHwCodecStretch As Long ' minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxHwCodecStretch As Long ' maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwReserved1 As Long ' reserved
    dwReserved2 As Long ' reserved
    dwReserved3 As Long ' reserved
    dwSVBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->Vmem blts
    dwSVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->Vmem blts
    dwSVBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->Vmem blts
    dwSVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->Vmem blts
    dwVSBCaps As DDCAPS1FLAGS ' driver specific capabilities for Vmem->System blts
    dwVSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for Vmem->System blts
    dwVSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for Vmem->System blts
    dwVSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for Vmem->System blts
    dwSSBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->System blts
    dwSSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->System blts
    dwSSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->System blts
    dwSSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->System blts
    dwMaxVideoPorts As Long ' maximum number of usable video ports
    dwCurrVideoPorts As Long ' current number of video ports used
    dwSVBCaps2 As DDCAPS2FLAGS ' more driver specific capabilities for System->Vmem blts
    dwNLVBCaps As DDCAPS1FLAGS ' driver specific capabilities for non-local->local vidmem blts
    dwNLVBCaps2 As DDCAPS2FLAGS ' more driver specific capabilities non-local->local vidmem blts
    dwNLVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for non-local->local vidmem blts
    dwNLVBFXCaps As DDFXCAPSFLAGS  ' driver FX capabilities for non-local->local blts
    dwNLVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for non-local->local blts
    ' Members added for DX6 release
    ddsCaps As DDSCAPS2 ' Surface Caps
End Type
Public Type DDCAPS_DX7
    dwSize As Long ' size of the DDDRIVERCAPS structure
    dwCaps As DDCAPS1FLAGS ' driver specific capabilities
    dwCaps2 As DDCAPS2FLAGS ' more driver specific capabilites
    dwCKeyCaps As DDCKEYCAPSFLAGS ' color key capabilities of the surface
    dwFXCaps As DDFXCAPSFLAGS ' driver specific stretching and effects capabilites
    dwFXAlphaCaps As DDFXALPHACAPSFLAGS ' alpha driver specific capabilities
    dwPalCaps As DDPCAPSFLAGS ' palette capabilities
    dwSVCaps As DDSTEREOCAPSFLAGS ' stereo vision capabilities
    dwAlphaBltConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaBltPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaBltSurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlayConstBitDepths As Long ' DDBD_2,4,8
    dwAlphaOverlayPixelBitDepths As Long ' DDBD_1,2,4,8
    dwAlphaOverlaySurfaceBitDepths As Long ' DDBD_1,2,4,8
    dwZBufferBitDepths As Long ' DDBD_8,16,24,32
    dwVidMemTotal As Long ' total amount of video memory
    dwVidMemFree As Long ' amount of free video memory
    dwMaxVisibleOverlays As Long ' maximum number of visible overlays
    dwCurrVisibleOverlays As Long ' current number of visible overlays
    dwNumFourCCCodes As Long ' number of four cc codes
    dwAlignBoundarySrc As Long ' source rectangle alignment
    dwAlignSizeSrc As Long ' source rectangle byte size
    dwAlignBoundaryDest As Long ' dest rectangle alignment
    dwAlignSizeDest As Long ' dest rectangle byte size
    dwAlignStrideAlign As Long ' stride alignment
    dwRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported
    ddsOldCaps As DDSCAPS ' Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
    dwMinOverlayStretch As Long ' minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxOverlayStretch As Long ' maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinLiveVideoStretch As Long ' minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxLiveVideoStretch As Long ' maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMinHwCodecStretch As Long ' minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwMaxHwCodecStretch As Long ' maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    dwReserved1 As Long ' reserved
    dwReserved2 As Long ' reserved
    dwReserved3 As Long ' reserved
    dwSVBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->Vmem blts
    dwSVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->Vmem blts
    dwSVBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->Vmem blts
    dwSVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->Vmem blts
    dwVSBCaps As DDCAPS1FLAGS ' driver specific capabilities for Vmem->System blts
    dwVSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for Vmem->System blts
    dwVSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for Vmem->System blts
    dwVSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for Vmem->System blts
    dwSSBCaps As DDCAPS1FLAGS ' driver specific capabilities for System->System blts
    dwSSBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for System->System blts
    dwSSBFXCaps As DDFXCAPSFLAGS ' driver FX capabilities for System->System blts
    dwSSBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for System->System blts
    dwMaxVideoPorts As Long ' maximum number of usable video ports
    dwCurrVideoPorts As Long ' current number of video ports used
    dwSVBCaps2 As DDCAPS2FLAGS ' more driver specific capabilities for System->Vmem blts
    dwNLVBCaps As DDCAPS1FLAGS ' driver specific capabilities for non-local->local vidmem blts
    dwNLVBCaps2 As DDCAPS2FLAGS ' more driver specific capabilities non-local->local vidmem blts
    dwNLVBCKeyCaps As DDCKEYCAPSFLAGS ' driver color key capabilities for non-local->local vidmem blts
    dwNLVBFXCaps As DDFXCAPSFLAGS  ' driver FX capabilities for non-local->local blts
    dwNLVBRops(0 To (DD_ROP_SPACE - 1)) As Long ' ROPS supported for non-local->local blts
    ' Members added for DX6 release
    ddsCaps As DDSCAPS2 ' Surface Caps
End Type

Public Type DDPIXELFORMAT
   dwSize As Long ' size of structure
   dwFlags As DDPIXELFORMATFLAGS ' pixel format flags
   dwFourCC As Long ' (FOURCC code)
   'union
   '{
   '    DWORD   dwRGBBitCount;          // how many bits per pixel
   '    DWORD   dwYUVBitCount;          // how many bits per pixel
   '    DWORD   dwZBufferBitDepth;      // how many total bits/pixel in z buffer (including any stencil bits)
   '    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels
   '    DWORD   dwLuminanceBitCount;    // how many bits per pixel
   '    DWORD   dwBumpBitCount;         // how many bits per "buxel", total
   '    DWORD   dwPrivateFormatBitCount;// Bits per pixel of private driver formats. Only valid in texture
   '                                    // format list and if DDPF_D3DFORMAT is set
   '} DUMMYUNIONNAMEN(1);
   BitCount As Long
   'union
   '{
   '    DWORD   dwRBitMask;             // mask for red bit
   '    DWORD   dwYBitMask;             // mask for Y bits
   '    DWORD   dwStencilBitDepth;      // how many stencil bits (note: dwZBufferBitDepth-dwStencilBitDepth is total Z-only bits)
   '    DWORD   dwLuminanceBitMask;     // mask for luminance bits
   '    DWORD   dwBumpDuBitMask;        // mask for bump map U delta bits
   '    DWORD   dwOperations;           // DDPF_D3DFORMAT Operations
   '} DUMMYUNIONNAMEN(2);
   RYSLUOpsBits As Long
   'union
   '{
   '    DWORD   dwGBitMask;             // mask for green bits
   '    DWORD   dwUBitMask;             // mask for U bits
   '    DWORD   dwZBitMask;             // mask for Z bits
   '    DWORD   dwBumpDvBitMask;        // mask for bump map V delta bits
   '    struct
   '    {
   '        WORD    wFlipMSTypes;       // Multisample methods supported via flip for this D3DFORMAT
   '        WORD    wBltMSTypes;        // Multisample methods supported via blt for this D3DFORMAT
   '    } MultiSampleCaps;
   '} DUMMYUNIONNAMEN(3);
   GUZVBits As Long
   'union
   '{
   '    DWORD   dwBBitMask;             // mask for blue bits
   '    DWORD   dwVBitMask;             // mask for V bits
   '    DWORD   dwStencilBitMask;       // mask for stencil bits
   '    DWORD   dwBumpLuminanceBitMask; // mask for luminance in bump map
   '} DUMMYUNIONNAMEN(4);
   BVSBBits As Long
   'union
   '{
   '    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
   '    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
   '    DWORD   dwLuminanceAlphaBitMask;// mask for alpha channel
   '    DWORD   dwRGBZBitMask;          // mask for Z channel
   '    DWORD   dwYUVZBitMask;          // mask for Z channel
   '} DUMMYUNIONNAMEN(5);
   AlphaOrZ As Long
End Type

Public Type DDOVERLAYFX
    dwSize As Long ' size of structure
    dwAlphaEdgeBlendBitDepth As Long ' Bit depth used to specify constant for alpha edge blend
    dwAlphaEdgeBlend As Long ' Constant to use as alpha for edge blend
    dwReserved As Long
    dwAlphaDestConstBitDepth As Long ' Bit depth used to specify alpha constant for destination
    'union
    '{
    '    DWORD   dwAlphaDestConst;               // Constant to use as alpha channel for dest
    '    LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as alpha channel for dest
    '} DUMMYUNIONNAMEN(1);
    AlphaDest As LongPtr
    dwAlphaSrcConstBitDepth As Long ' Bit depth used to specify alpha constant for source
    'union
    '{
    '    DWORD   dwAlphaSrcConst;                // Constant to use as alpha channel for src
    '    LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as alpha channel for src
    '} DUMMYUNIONNAMEN(2);
    AlphaSrc As LongPtr
    dckDestColorkey As DDCOLORKEY ' DestColorkey override
    dckSrcColorkey As DDCOLORKEY ' DestColorkey override
    dwDDFX As DDOVERFXFLAGS ' Overlay FX
    dwFlags As Long ' flags
End Type

Public Type DDBLTBATCH
    lprDest As LongPtr 'LPRECT
    lpDDSSrc As IDirectDrawSurface
    lprSrc As LongPtr 'LPRECT
    dwFlags As Long
    lpDDBltFx As LongPtr 'LPDDBLTFX
End Type

Public Type DDGAMMARAMP
    red(0 To 255) As Integer
    green(0 To 255) As Integer
    blue(0 To 255) As Integer
End Type

Public Const MAX_DDDEVICEID_STRING = 512

Public Type DDDEVICEIDENTIFIER
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    szDriver(0 To (MAX_DDDEVICEID_STRING - 1)) As Byte
    szDescription(0 To (MAX_DDDEVICEID_STRING - 1)) As Byte
    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
    '#ifdef _WIN32
    liDriverVersion As LARGE_INTEGER ' Defined for applications and other 32 bit components
    '#else
    '    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    '    DWORD   dwDriverVersionHighPart;
    '#endif
    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    dwVendorId As Long
    dwDeviceId As Long
    dwSubSysId As Long
    dwRevision As Long
    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    guidDeviceIdentifier As UUID
End Type
Public Type DDDEVICEIDENTIFIER2
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    szDriver(0 To (MAX_DDDEVICEID_STRING - 1)) As Byte
    szDescription(0 To (MAX_DDDEVICEID_STRING - 1)) As Byte
    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
    '#ifdef _WIN32
    liDriverVersion As LARGE_INTEGER ' Defined for applications and other 32 bit components
    '#else
    '    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    '    DWORD   dwDriverVersionHighPart;
    '#endif
    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    dwVendorId As Long
    dwDeviceId As Long
    dwSubSysId As Long
    dwRevision As Long
    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    guidDeviceIdentifier As UUID
    /*
     * This element is used to determine the Windows Hardware Quality Lab (WHQL)
     * certification level for this driver/device pair.
     */
    dwWHQLLevel As Long
End Type
Public Enum DDDEVICEIDFLAGS
	DDGDI_DEFAULT = 0
	DDGDI_GETHOSTIDENTIFIER = 1
End Enum

Public Delegate Function CLIPPERCALLBACK (ByVal lpDDClipper As IDirectDrawClipper, ByVal hWnd As LongPtr, ByVal code As Long, ByVal lpContext As LongPtr) As Long
 
Public Type DDSURFACEDESC
    dwSize As Long ' size of the DDSURFACEDESC structure
    dwFlags As DDSD_FLAGS ' determines what fields are valid
    dwHeight As Long ' height of surface to be created
    dwWidth As Long ' width of input surface
    'union
    '{
    '    LONG            lPitch;                 // distance to start of next line (return value only)
    '    DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    '} DUMMYUNIONNAMEN(1);
    'DWORD               dwBackBufferCount;      // number of back buffers requested
    'union
    '{
    '    DWORD           dwMipMapCount;          // number of mip-map levels requested
    '    DWORD           dwZBufferBitDepth;      // depth of Z buffer requested
    '    DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
    '} DUMMYUNIONNAMEN(2);
    PitchOrLinearSize As Long
    dwBackBufferCount As Long
    MipmapzDeptchOrRefreshRate As Long
    dwAlphaBitDepth As Long ' depth of alpha buffer requested
    dwReserved As Long ' reserved
    lpSurface As LongPtr ' pointer to the associated surface memory
    ddckCKDestOverlay As DDCOLORKEY ' color key for destination overlay use
    ddckCKDestBlt As DDCOLORKEY ' color key for destination blt use
    ddckCKSrcOverlay As DDCOLORKEY ' color key for source overlay use
    ddckCKSrcBlt As DDCOLORKEY ' color key for source blt use
    ddpfPixelFormat As DDPIXELFORMAT ' pixel format description of the surface
    ddsCaps As DDSCAPS ' direct draw surface capabilities
End Type

Public Type DDSURFACEDESC2
    dwSize As Long ' size of the DDSURFACEDESC structure
    dwFlags As DDSD_FLAGS ' determines what fields are valid
    dwHeight As Long ' height of surface to be created
    dwWidth As Long ' width of input surface
    'union
    '{
    '    LONG            lPitch;                 // distance to start of next line (return value only)
    '    DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    '} DUMMYUNIONNAMEN(1);
    lPitchOrLinearSize As Long
    'union
    '{
    '    DWORD           dwBackBufferCount;      // number of back buffers requested
    '    DWORD           dwDepth;                // the depth if this is a volume texture
    '} DUMMYUNIONNAMEN(5);
    dwBackBufferCountOrDepth As Long
    'union
    '{
    '    DWORD           dwMipMapCount;          // number of mip-map levels requestde
    '                                            // dwZBufferBitDepth removed, use ddpfPixelFormat one instead
    '    DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
    '    DWORD           dwSrcVBHandle;          // The source used in VB::Optimize
    '} DUMMYUNIONNAMEN(2);
    dwMipMapCountRefreshRateOrSrcVBHandle As Long
    dwAlphaBitDepth As Long ' depth of alpha buffer requested
    dwReserved As Long ' reserved
    lpSurface As LongPtr ' pointer to the associated surface memory
    'union
    '{
    '    DDCOLORKEY      ddckCKDestOverlay;      // color key for destination overlay use
    '    DWORD           dwEmptyFaceColor;       // Physical color for empty cubemap faces
    '} DUMMYUNIONNAMEN(3);
    ddckCKDestOverlayOrEmptyFaceColor As DDCOLORKEY
    ddckCKDestBlt As DDCOLORKEY ' color key for destination blt use
    ddckCKSrcOverlay As DDCOLORKEY ' color key for source overlay use
    ddckCKSrcBlt As DDCOLORKEY ' color key for source blt use
    'union
    '{
    '    DDPIXELFORMAT   ddpfPixelFormat;        // pixel format description of the surface
    '    DWORD           dwFVF;                  // vertex format description of vertex buffers
    '} DUMMYUNIONNAMEN(4);
    ddpfPixelFormatOrFVF As DDPIXELFORMAT
    ddsCaps As DDSCAPS2 ' direct draw surface capabilities
    dwTextureStage As Long ' stage in multitexture cascade
End Type

Public Enum DDSD_FLAGS
    DDSD_CAPS = &H00000001 ' default
'      * dwHeight field is valid.
'      */
    DDSD_HEIGHT = &H00000002
'       * dwWidth field is valid.
'       */
    DDSD_WIDTH = &H00000004
'        * lPitch is valid.
'        */
    DDSD_PITCH = &H00000008
'         * dwBackBufferCount is valid.
'         */
    DDSD_BACKBUFFERCOUNT = &H00000020
'          * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
'          */
    DDSD_ZBUFFERBITDEPTH = &H00000040
'           * dwAlphaBitDepth is valid.
'           */
    DDSD_ALPHABITDEPTH = &H00000080
'            * lpSurface is valid.
'            */
    DDSD_LPSURFACE = &H00000800
'             * ddpfPixelFormat is valid.
'             */
    DDSD_PIXELFORMAT = &H00001000
'              * ddckCKDestOverlay is valid.
'              */
    DDSD_CKDESTOVERLAY = &H00002000
'               * ddckCKDestBlt is valid.
'               */
    DDSD_CKDESTBLT = &H00004000
'                * ddckCKSrcOverlay is valid.
'                */
    DDSD_CKSRCOVERLAY = &H00008000&
'                 * ddckCKSrcBlt is valid.
'                 */
    DDSD_CKSRCBLT = &H00010000
'                  * dwMipMapCount is valid.
'                  */
    DDSD_MIPMAPCOUNT = &H00020000
'                   * dwRefreshRate is valid
'                   */
    DDSD_REFRESHRATE = &H00040000
'                    * dwLinearSize is valid
'                    */
    DDSD_LINEARSIZE = &H00080000
'                     * dwTextureStage is valid
'                     */
    DDSD_TEXTURESTAGE = &H00100000
'                      * dwFVF is valid
'                      */
    DDSD_FVF = &H00200000
'                       * dwSrcVBHandle is valid
'                       */
    DDSD_SRCVBHANDLE = &H00400000
'                        * dwDepth is valid
'                        */
    DDSD_DEPTH = &H00800000
'                         * All input fields are valid.
'                         */
    DDSD_ALL = &H00fff9ee
End Enum

Public Type DDOPTSURFACEDESC
    dwSize As Long ' size of the DDOPTSURFACEDESC structure
    dwFlags As DDOSDFLAGS ' determines what fields are valid
    ddSCaps As DDSCAPS2 ' Common caps like: Memory type
    ddOSCaps As DDOSCAPS ' Common caps like: Memory type
    guid As UUID ' Compression technique GUID
    dwCompressionRatio As Long ' Compression ratio
End Type
Public Enum DDOSDFLAGS
    DDOSD_GUID = &H00000001
    DDOSD_COMPRESSION_RATIO = &H00000002
    DDOSD_SCAPS = &H00000004
    DDOSD_OSCAPS = &H00000008
    DDOSD_ALL = &H0000000f
End Enum
Public Enum DDOSDCAPSFLAGS
    DDOSDCAPS_OPTCOMPRESSED = &H00000001
    DDOSDCAPS_OPTREORDERED = &H00000002
    DDOSDCAPS_MONOLITHICMIPMAP = &H00000004
    DDOSDCAPS_VALIDSCAPS = &H30004800
    DDOSDCAPS_VALIDOSCAPS = &H00000007
End Enum

Public Type DDCOLORCONTROL
    dwSize As Long
    dwFlags As DDCOLORFLAGS
    lBrightness As Long
    lContrast As Long
    lHue As Long
    lSaturation As Long
    lSharpness As Long
    lGamma As Long
    lColorEnable As Long
    dwReserved1 As Long
End Type
Public Enum DDCOLORFLAGS
    DDCOLOR_BRIGHTNESS = &H00000001
    DDCOLOR_CONTRAST = &H00000002
    DDCOLOR_HUE = &H00000004
    DDCOLOR_SATURATION = &H00000008
    DDCOLOR_SHARPNESS = &H00000010
    DDCOLOR_GAMMA = &H00000020
    DDCOLOR_COLORENABLE = &H00000040
End Enum











#If WDL_DX7VB_DD Then
Public ENum CONST_DDBLTFXFLAGS
#Else
Public Enum DDBLTFXFLAGS
#End If
    /*
    * If stretching, use arithmetic stretching along the Y axis for this blt.
    */
   DDBLTFX_ARITHSTRETCHY = &H00000001

   /*
    * Do this blt mirroring the surface left to right.  Spin the
    * surface around its y-axis.
    */
   DDBLTFX_MIRRORLEFTRIGHT = &H00000002

   /*
    * Do this blt mirroring the surface up and down.  Spin the surface
    * around its x-axis.
    */
   DDBLTFX_MIRRORUPDOWN = &H00000004

   /*
    * Schedule this blt to avoid tearing.
    */
   DDBLTFX_NOTEARING = &H00000008

   /*
    * Do this blt rotating the surface one hundred and eighty degrees.
    */
   DDBLTFX_ROTATE180 = &H00000010

   /*
    * Do this blt rotating the surface two hundred and seventy degrees.
    */
   DDBLTFX_ROTATE270 = &H00000020

   /*
    * Do this blt rotating the surface ninety degrees.
    */
   DDBLTFX_ROTATE90 = &H00000040

   /*
    * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
    * specified to limit the bits copied from the source surface.
    */
   DDBLTFX_ZBUFFERRANGE = &H00000080

   /*
    * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
    * before comparing it with the desting z values.
    */
   DDBLTFX_ZBUFFERBASEDEST = &H00000100
       
    
End Enum

#If WDL_DX7VB_DD Then
Public Enum CONST_DDSURFACECAPSFLAGS
#Else
Public Enum DDSURFACECAPSFLAGS
#End If
    DDSCAPS_RESERVED1 = &H00000001
    DDSCAPS_ALPHA = &H00000002
    DDSCAPS_BACKBUFFER = &H00000004
    DDSCAPS_COMPLEX = &H00000008
    DDSCAPS_FLIP = &H00000010
    DDSCAPS_FRONTBUFFER = &H00000020
    DDSCAPS_OFFSCREENPLAIN = &H00000040
    DDSCAPS_OVERLAY = &H00000080
    DDSCAPS_PALETTE = &H00000100
    DDSCAPS_PRIMARYSURFACE = &H00000200
    DDSCAPS_RESERVED3 = &H00000400
    DDSCAPS_PRIMARYSURFACELEFT = &H00000000
    DDSCAPS_SYSTEMMEMORY = &H00000800
    DDSCAPS_TEXTURE = &H00001000
    DDSCAPS_3DDEVICE = &H00002000
    DDSCAPS_VIDEOMEMORY = &H00004000
    DDSCAPS_VISIBLE = &H00008000&
    DDSCAPS_WRITEONLY = &H00010000
    DDSCAPS_ZBUFFER = &H00020000
    DDSCAPS_OWNDC = &H00040000
    DDSCAPS_LIVEVIDEO = &H00080000
    DDSCAPS_HWCODEC = &H00100000
    DDSCAPS_MODEX = &H00200000
    DDSCAPS_MIPMAP = &H00400000
    DDSCAPS_RESERVED2 = &H00800000
    DDSCAPS_ALLOCONLOAD = &H04000000
    DDSCAPS_VIDEOPORT = &H08000000
    DDSCAPS_LOCALVIDMEM = &H10000000
    DDSCAPS_NONLOCALVIDMEM = &H20000000
    DDSCAPS_STANDARDVGAMODE = &H40000000
    DDSCAPS_OPTIMIZED = &H80000000
End Enum
#If WDL_DX7VB_DD Then
Public Enum CONST_DDSURFACECAPS2FLAGS
#Else
Public Enum DDSURFACECAPS2FLAGS
#End If
    DDSCAPS2_RESERVED4 = &H00000002
    DDSCAPS2_HARDWAREDEINTERLACE = &H00000000
    DDSCAPS2_HINTDYNAMIC = &H00000004
    DDSCAPS2_HINTSTATIC = &H00000008
    DDSCAPS2_TEXTUREMANAGE = &H00000010
    DDSCAPS2_RESERVED1 = &H00000020
    DDSCAPS2_RESERVED2 = &H00000040
    DDSCAPS2_OPAQUE = &H00000080
    DDSCAPS2_HINTANTIALIASING = &H00000100
    DDSCAPS2_CUBEMAP = &H00000200
    DDSCAPS2_CUBEMAP_POSITIVEX = &H00000400
    DDSCAPS2_CUBEMAP_NEGATIVEX = &H00000800
    DDSCAPS2_CUBEMAP_POSITIVEY = &H00001000
    DDSCAPS2_CUBEMAP_NEGATIVEY = &H00002000
    DDSCAPS2_CUBEMAP_POSITIVEZ = &H00004000
    DDSCAPS2_CUBEMAP_NEGATIVEZ = &H00008000&
    DDSCAPS2_CUBEMAP_ALLFACES = (DDSCAPS2_CUBEMAP_POSITIVEX Or DDSCAPS2_CUBEMAP_NEGATIVEX Or DDSCAPS2_CUBEMAP_POSITIVEY Or DDSCAPS2_CUBEMAP_NEGATIVEY Or DDSCAPS2_CUBEMAP_POSITIVEZ Or DDSCAPS2_CUBEMAP_NEGATIVEZ)
    DDSCAPS2_MIPMAPSUBLEVEL = &H00010000
    DDSCAPS2_D3DTEXTUREMANAGE = &H00020000
    DDSCAPS2_DONOTPERSIST = &H00040000
    DDSCAPS2_STEREOSURFACELEFT = &H00080000
    DDSCAPS2_VOLUME = &H00200000
    DDSCAPS2_NOTUSERLOCKABLE = &H00400000
    DDSCAPS2_POINTS = &H00800000
    DDSCAPS2_RTPATCHES = &H01000000
    DDSCAPS2_NPATCHES = &H02000000
    DDSCAPS2_RESERVED3 = &H04000000
    DDSCAPS2_DISCARDBACKBUFFER = &H10000000
    DDSCAPS2_ENABLEALPHACHANNEL = &H20000000
    DDSCAPS2_EXTENDEDFORMATPRIMARY = &H40000000
    DDSCAPS2_ADDITIONALPRIMARY = &H80000000
End Enum
#If WDL_DX7VB_DD Then
Public Enum CONST_DDSURFACECAPS3FLAGS
#Else
Public Enum DDSURFACECAPS3FLAGS
#End If
    DDSCAPS3_MULTISAMPLE_MASK = &H0000001F
    DDSCAPS3_MULTISAMPLE_QUALITY_MASK = &H000000E0
    DDSCAPS3_MULTISAMPLE_QUALITY_SHIFT = 5
    DDSCAPS3_RESERVED1 = &H00000100
    DDSCAPS3_RESERVED2 = &H00000200
    DDSCAPS3_LIGHTWEIGHTMIPMAP = &H00000400
    DDSCAPS3_AUTOGENMIPMAP = &H00000800
    DDSCAPS3_DMAP = &H00001000
    DDSCAPS3_CREATESHAREDRESOURCE = &H00002000
    DDSCAPS3_READONLYRESOURCE = &H00004000
    DDSCAPS3_OPENSHAREDRESOURCE = &H00008000&
End Enum

Public Enum DDCAPS1FLAGS
    /*
    * Display hardware has 3D acceleration.
    */
   DDCAPS_3D = &H00000001

   /*
    * Indicates that DirectDraw will support only dest rectangles that are aligned
    * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
    * READ ONLY.
    */
   DDCAPS_ALIGNBOUNDARYDEST = &H00000002

   /*
    * Indicates that DirectDraw will support only source rectangles  whose sizes in
    * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
    */
   DDCAPS_ALIGNSIZEDEST = &H00000004
   /*
    * Indicates that DirectDraw will support only source rectangles that are aligned
    * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
    * READ ONLY.
    */
   DDCAPS_ALIGNBOUNDARYSRC = &H00000008

   /*
    * Indicates that DirectDraw will support only source rectangles  whose sizes in
    * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
    */
   DDCAPS_ALIGNSIZESRC = &H00000010

   /*
    * Indicates that DirectDraw will create video memory surfaces that have a stride
    * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
    */
   DDCAPS_ALIGNSTRIDE = &H00000020

   /*
    * Display hardware is capable of blt operations.
    */
   DDCAPS_BLT = &H00000040

   /*
    * Display hardware is capable of asynchronous blt operations.
    */
   DDCAPS_BLTQUEUE = &H00000080

   /*
    * Display hardware is capable of color space conversions during the blt operation.
    */
   DDCAPS_BLTFOURCC = &H00000100

   /*
    * Display hardware is capable of stretching during blt operations.
    */
   DDCAPS_BLTSTRETCH = &H00000200

   /*
    * Display hardware is shared with GDI.
    */
   DDCAPS_GDI = &H00000400

   /*
    * Display hardware can overlay.
    */
   DDCAPS_OVERLAY = &H00000800

   /*
    * Set if display hardware supports overlays but can not clip them.
    */
   DDCAPS_OVERLAYCANTCLIP = &H00001000

   /*
    * Indicates that overlay hardware is capable of color space conversions during
    * the overlay operation.
    */
   DDCAPS_OVERLAYFOURCC = &H00002000

   /*
    * Indicates that stretching can be done by the overlay hardware.
    */
   DDCAPS_OVERLAYSTRETCH = &H00004000

   /*
    * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
    * other than the primary surface.
    */
   DDCAPS_PALETTE = &H00008000&

   /*
    * Indicates that palette changes can be syncd with the veritcal refresh.
    */
   DDCAPS_PALETTEVSYNC = &H00010000

   /*
    * Display hardware can return the current scan line.
    */
   DDCAPS_READSCANLINE = &H00020000


   /*
    * This flag used to bo DDCAPS_STEREOVIEW, which is now obsolete
    */
   DDCAPS_RESERVED1 = &H00040000

   /*
    * Display hardware is capable of generating a vertical blank interrupt.
    */
   DDCAPS_VBI = &H00080000

   /*
    * Supports the use of z buffers with blt operations.
    */
   DDCAPS_ZBLTS = &H00100000

   /*
    * Supports Z Ordering of overlays.
    */
   DDCAPS_ZOVERLAYS = &H00200000

   /*
    * Supports color key
    */
   DDCAPS_COLORKEY = &H00400000

   /*
    * Supports alpha surfaces
    */
   DDCAPS_ALPHA = &H00800000

   /*
    * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
    */
   DDCAPS_COLORKEYHWASSIST = &H01000000

   /*
    * no hardware support at all
    */
   DDCAPS_NOHARDWARE = &H02000000

   /*
    * Display hardware is capable of color fill with bltter
    */
   DDCAPS_BLTCOLORFILL = &H04000000

   /*
    * Display hardware is bank switched, and potentially very slow at
    * random access to VRAM.
    */
   DDCAPS_BANKSWITCHED = &H08000000

   /*
    * Display hardware is capable of depth filling Z-buffers with bltter
    */
   DDCAPS_BLTDEPTHFILL = &H10000000

   /*
    * Display hardware is capable of clipping while bltting.
    */
   DDCAPS_CANCLIP = &H20000000

   /*
    * Display hardware is capable of clipping while stretch bltting.
    */
   DDCAPS_CANCLIPSTRETCHED = &H40000000

   /*
    * Display hardware is capable of bltting to or from system memory
    */
   DDCAPS_CANBLTSYSMEM = &H80000000
    
End Enum
Public Enum DDCAPS2FLAGS
    /*
    * Display hardware is certified
    */
   DDCAPS2_CERTIFIED = &H00000001

   /*
    * Driver cannot interleave 2D operations (lock and blt) to surfaces with
    * Direct3D rendering operations between calls to BeginScene() and EndScene()
    */
   DDCAPS2_NO2DDURING3DSCENE = &H00000002

   /*
    * Display hardware contains a video port
    */
   DDCAPS2_VIDEOPORT = &H00000004

   /*
    * The overlay can be automatically flipped according to the video port
    * VSYNCs, providing automatic doubled buffered display of video port
    * data using an overlay
    */
   DDCAPS2_AUTOFLIPOVERLAY = &H00000008

   /*
    * Overlay can display each field of interlaced data individually while
    * it is interleaved in memory without causing jittery artifacts.
    */
   DDCAPS2_CANBOBINTERLEAVED = &H00000010

   /*
    * Overlay can display each field of interlaced data individually while
    * it is not interleaved in memory without causing jittery artifacts.
    */
   DDCAPS2_CANBOBNONINTERLEAVED = &H00000020

   /*
    * The overlay surface contains color controls (brightness, sharpness, etc.)
    */
   DDCAPS2_COLORCONTROLOVERLAY = &H00000040

   /*
    * The primary surface contains color controls (gamma, etc.)
    */
   DDCAPS2_COLORCONTROLPRIMARY = &H00000080

   /*
    * RGBZ -> RGB supported for 16:16 RGB:Z
    */
   DDCAPS2_CANDROPZ16BIT = &H00000100

   /*
    * Driver supports non-local video memory.
    */
   DDCAPS2_NONLOCALVIDMEM = &H00000200

   /*
    * Dirver supports non-local video memory but has different capabilities for
    * non-local video memory surfaces. If this bit is set then so must
    * DDCAPS2_NONLOCALVIDMEM.
    */
   DDCAPS2_NONLOCALVIDMEMCAPS = &H00000400

   /*
    * Driver neither requires nor prefers surfaces to be pagelocked when performing
    * blts involving system memory surfaces
    */
   DDCAPS2_NOPAGELOCKREQUIRED = &H00000800

   /*
    * Driver can create surfaces which are wider than the primary surface
    */
   DDCAPS2_WIDESURFACES = &H00001000

   /*
    * Driver supports bob without using a video port by handling the
    * DDFLIP_ODD and DDFLIP_EVEN flags specified in Flip.
    */
   DDCAPS2_CANFLIPODDEVEN = &H00002000

   /*
    * Driver supports bob using hardware
    */
   DDCAPS2_CANBOBHARDWARE = &H00004000

   /*
    * Driver supports bltting any FOURCC surface to another surface of the same FOURCC
    */
   DDCAPS2_COPYFOURCC = &H00008000&


   /*
    * Driver supports loadable gamma ramps for the primary surface
    */
   DDCAPS2_PRIMARYGAMMA = &H00020000

   /*
    * Driver can render in windowed mode.
    */
   DDCAPS2_CANRENDERWINDOWED = &H00080000

   /*
    * A calibrator is available to adjust the gamma ramp according to the
    * physical display properties so that the result will be identical on
    * all calibrated systems.
    */
   DDCAPS2_CANCALIBRATEGAMMA = &H00100000

   /*
    * Indicates that the driver will respond to DDFLIP_INTERVALn flags
    */
   DDCAPS2_FLIPINTERVAL = &H00200000

   /*
    * Indicates that the driver will respond to DDFLIP_NOVSYNC
    */
   DDCAPS2_FLIPNOVSYNC = &H00400000

   /*
    * Driver supports management of video memory, if this flag is ON,
    * driver manages the texture if requested with DDSCAPS2_TEXTUREMANAGE on
    * DirectX manages the texture if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
    */
   DDCAPS2_CANMANAGETEXTURE = &H00800000

   /*
    * The Direct3D texture manager uses this cap to decide whether to put managed
    * surfaces in non-local video memory. If the cap is set, the texture manager will
    * put managed surfaces in non-local vidmem. Drivers that cannot texture from
    * local vidmem SHOULD NOT set this cap.
    */
   DDCAPS2_TEXMANINNONLOCALVIDMEM = &H01000000

   /*
    * Indicates that the driver supports DX7 type of stereo in at least one mode (which may
    * not necessarily be the current mode). Applications should use IDirectDraw7 (or higher)
    * ::EnumDisplayModes and check the DDSURFACEDESC.ddsCaps.dwCaps2 field for the presence of
    * DDSCAPS2_STEREOSURFACELEFT to check if a particular mode supports stereo. The application
    * can also use IDirectDraw7(or higher)::GetDisplayMode to check the current mode.
    */
   DDCAPS2_STEREO = &H02000000

   /*
    * This caps bit is intended for internal DirectDraw use.
    * -It is only valid if DDCAPS2_NONLOCALVIDMEMCAPS is set.
    * -If this bit is set, then DDCAPS_CANBLTSYSMEM MUST be set by the driver (and
    *  all the assoicated system memory blt caps must be correct).
    * -It implies that the system->video blt caps in DDCAPS also apply to system to
    *  nonlocal blts. I.e. the dwSVBCaps, dwSVBCKeyCaps, dwSVBFXCaps and dwSVBRops
    *  members of DDCAPS (DDCORECAPS) are filled in correctly.
    * -Any blt from system to nonlocal memory that matches these caps bits will
    *  be passed to the driver.
    *
    * NOTE: This is intended to enable the driver itself to do efficient reordering
    * of textures. This is NOT meant to imply that hardware can write into AGP memory.
    * This operation is not currently supported.
    */
   DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL = &H04000000

   /*
    * was DDCAPS2_PUREHAL
    */
   DDCAPS2_RESERVED1 = &H08000000

   /*
    * Driver supports management of video memory, if this flag is ON,
    * driver manages the resource if requested with DDSCAPS2_TEXTUREMANAGE on
    * DirectX manages the resource if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
    */
   DDCAPS2_CANMANAGERESOURCE = &H10000000

   /*
    * Driver supports dynamic textures. This will allow the application to set
    * D3DUSAGE_DYNAMIC (DDSCAPS2_HINTDYNAMIC for drivers) at texture create time.
    * Video memory dynamic textures WILL be lockable by applications. It is
    * expected that these locks will be very efficient (which implies that the
    * driver should always maintain a linear copy, a pointer to which can be
    * quickly handed out to the application).
    */
   DDCAPS2_DYNAMICTEXTURES = &H20000000

   /*
    * Driver supports auto-generation of mipmaps.
    */
   DDCAPS2_CANAUTOGENMIPMAP = &H40000000

   /* D3D9Ex only -- */
'    #If !defined(D3D_DISABLE_9EX)

   /*
    * Driver supports sharing of cross process resouces
    */
   DDCAPS2_CANSHARERESOURCE = &H80000000
    
End Enum
Public Enum DDFXALPHACAPSFLAGS
    /*
    * Supports alpha blending around the edge of a source color keyed surface.
    * For Blt.
    */
   DDFXALPHACAPS_BLTALPHAEDGEBLEND = &H00000001

   /*
    * Supports alpha information in the pixel format.  The bit depth of alpha
    * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
    * more opaque as the alpha value increases.  (0 is transparent.)
    * For Blt.
    */
   DDFXALPHACAPS_BLTALPHAPIXELS = &H00000002

   /*
    * Supports alpha information in the pixel format.  The bit depth of alpha
    * information in the pixel format can be 1,2,4, or 8.  The alpha value
    * becomes more transparent as the alpha value increases.  (0 is opaque.)
    * This flag can only be set if DDCAPS_ALPHA is set.
    * For Blt.
    */
   DDFXALPHACAPS_BLTALPHAPIXELSNEG = &H00000004

   /*
    * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
    * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
    * (0 is transparent.)
    * For Blt.
    */
   DDFXALPHACAPS_BLTALPHASURFACES = &H00000008

   /*
    * The depth of the alpha channel data can range can be 1,2,4, or 8.
    * The NEG suffix indicates that this alpha channel becomes more transparent
    * as the alpha value increases. (0 is opaque.)  This flag can only be set if
    * DDCAPS_ALPHA is set.
    * For Blt.
    */
   DDFXALPHACAPS_BLTALPHASURFACESNEG = &H00000010

   /*
    * Supports alpha blending around the edge of a source color keyed surface.
    * For Overlays.
    */
   DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND = &H00000020

   /*
    * Supports alpha information in the pixel format.  The bit depth of alpha
    * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
    * more opaque as the alpha value increases.  (0 is transparent.)
    * For Overlays.
    */
   DDFXALPHACAPS_OVERLAYALPHAPIXELS = &H00000040

   /*
    * Supports alpha information in the pixel format.  The bit depth of alpha
    * information in the pixel format can be 1,2,4, or 8.  The alpha value
    * becomes more transparent as the alpha value increases.  (0 is opaque.)
    * This flag can only be set if DDCAPS_ALPHA is set.
    * For Overlays.
    */
   DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG = &H00000080

   /*
    * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
    * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
    * (0 is transparent.)
    * For Overlays.
    */
   DDFXALPHACAPS_OVERLAYALPHASURFACES = &H00000100

   /*
    * The depth of the alpha channel data can range can be 1,2,4, or 8.
    * The NEG suffix indicates that this alpha channel becomes more transparent
    * as the alpha value increases. (0 is opaque.)  This flag can only be set if
    * DDCAPS_ALPHA is set.
    * For Overlays.
    */
   DDFXALPHACAPS_OVERLAYALPHASURFACESNEG = &H00000200
End Enum
Public Enum DDFXCAPSFLAGS
    /*
    * Uses arithmetic operations to stretch and shrink surfaces during blt
    * rather than pixel doubling techniques.  Along the Y axis.
    */
   DDFXCAPS_BLTARITHSTRETCHY = &H00000020

   /*
    * Uses arithmetic operations to stretch during blt
    * rather than pixel doubling techniques.  Along the Y axis. Only
    * works for x1, x2, etc.
    */
   DDFXCAPS_BLTARITHSTRETCHYN = &H00000010

   /*
    * Supports mirroring left to right in blt.
    */
   DDFXCAPS_BLTMIRRORLEFTRIGHT = &H00000040

   /*
    * Supports mirroring top to bottom in blt.
    */
   DDFXCAPS_BLTMIRRORUPDOWN = &H00000080

   /*
    * Supports arbitrary rotation for blts.
    */
   DDFXCAPS_BLTROTATION = &H00000100

   /*
    * Supports 90 degree rotations for blts.
    */
   DDFXCAPS_BLTROTATION90 = &H00000200

   /*
    * DirectDraw supports arbitrary shrinking of a surface along the
    * x axis (horizontal direction) for blts.
    */
   DDFXCAPS_BLTSHRINKX = &H00000400

   /*
    * DirectDraw supports integer shrinking (1x,2x,) of a surface
    * along the x axis (horizontal direction) for blts.
    */
   DDFXCAPS_BLTSHRINKXN = &H00000800

   /*
    * DirectDraw supports arbitrary shrinking of a surface along the
    * y axis (horizontal direction) for blts.
    */
   DDFXCAPS_BLTSHRINKY = &H00001000

   /*
    * DirectDraw supports integer shrinking (1x,2x,) of a surface
    * along the y axis (vertical direction) for blts.
    */
   DDFXCAPS_BLTSHRINKYN = &H00002000

   /*
    * DirectDraw supports arbitrary stretching of a surface along the
    * x axis (horizontal direction) for blts.
    */
   DDFXCAPS_BLTSTRETCHX = &H00004000

   /*
    * DirectDraw supports integer stretching (1x,2x,) of a surface
    * along the x axis (horizontal direction) for blts.
    */
   DDFXCAPS_BLTSTRETCHXN = &H00008000&

   /*
    * DirectDraw supports arbitrary stretching of a surface along the
    * y axis (horizontal direction) for blts.
    */
   DDFXCAPS_BLTSTRETCHY = &H00010000

   /*
    * DirectDraw supports integer stretching (1x,2x,) of a surface
    * along the y axis (vertical direction) for blts.
    */
   DDFXCAPS_BLTSTRETCHYN = &H00020000

   /*
    * Uses arithmetic operations to stretch and shrink surfaces during
    * overlay rather than pixel doubling techniques.  Along the Y axis
    * for overlays.
    */
   DDFXCAPS_OVERLAYARITHSTRETCHY = &H00040000

   /*
    * Uses arithmetic operations to stretch surfaces during
    * overlay rather than pixel doubling techniques.  Along the Y axis
    * for overlays. Only works for x1, x2, etc.
    */
   DDFXCAPS_OVERLAYARITHSTRETCHYN = &H00000008

   /*
    * DirectDraw supports arbitrary shrinking of a surface along the
    * x axis (horizontal direction) for overlays.
    */
   DDFXCAPS_OVERLAYSHRINKX = &H00080000

   /*
    * DirectDraw supports integer shrinking (1x,2x,) of a surface
    * along the x axis (horizontal direction) for overlays.
    */
   DDFXCAPS_OVERLAYSHRINKXN = &H00100000

   /*
    * DirectDraw supports arbitrary shrinking of a surface along the
    * y axis (horizontal direction) for overlays.
    */
   DDFXCAPS_OVERLAYSHRINKY = &H00200000

   /*
    * DirectDraw supports integer shrinking (1x,2x,) of a surface
    * along the y axis (vertical direction) for overlays.
    */
   DDFXCAPS_OVERLAYSHRINKYN = &H00400000

   /*
    * DirectDraw supports arbitrary stretching of a surface along the
    * x axis (horizontal direction) for overlays.
    */
   DDFXCAPS_OVERLAYSTRETCHX = &H00800000

   /*
    * DirectDraw supports integer stretching (1x,2x,) of a surface
    * along the x axis (horizontal direction) for overlays.
    */
   DDFXCAPS_OVERLAYSTRETCHXN = &H01000000

   /*
    * DirectDraw supports arbitrary stretching of a surface along the
    * y axis (horizontal direction) for overlays.
    */
   DDFXCAPS_OVERLAYSTRETCHY = &H02000000

   /*
    * DirectDraw supports integer stretching (1x,2x,) of a surface
    * along the y axis (vertical direction) for overlays.
    */
   DDFXCAPS_OVERLAYSTRETCHYN = &H04000000

   /*
    * DirectDraw supports mirroring of overlays across the vertical axis
    */
   DDFXCAPS_OVERLAYMIRRORLEFTRIGHT = &H08000000

   /*
    * DirectDraw supports mirroring of overlays across the horizontal axis
    */
   DDFXCAPS_OVERLAYMIRRORUPDOWN = &H10000000

   /*
    * DirectDraw supports deinterlacing of overlay surfaces
    */
   DDFXCAPS_OVERLAYDEINTERLACE = &H20000000

   /*
    * Driver can do alpha blending for blits.
    */
   DDFXCAPS_BLTALPHA = &H00000001


   /*
    * Driver can do surface-reconstruction filtering for warped blits.
    */
   DDFXCAPS_BLTFILTER = DDFXCAPS_BLTARITHSTRETCHY

   /*
    * Driver can do alpha blending for overlays.
    */
   DDFXCAPS_OVERLAYALPHA = &H00000004


   /*
    * Driver can do surface-reconstruction filtering for warped overlays.
    */
   DDFXCAPS_OVERLAYFILTER = DDFXCAPS_OVERLAYARITHSTRETCHY
    
End Enum
Public Enum DDSTEREOCAPSFLAGS
    /*
    * This flag used to be DDSVCAPS_ENIGMA, which is now obsolete
    */

   DDSVCAPS_RESERVED1 = &H00000001

   /*
    * This flag used to be DDSVCAPS_FLICKER, which is now obsolete
    */
   DDSVCAPS_RESERVED2 = &H00000002

   /*
    * This flag used to be DDSVCAPS_REDBLUE, which is now obsolete
    */
   DDSVCAPS_RESERVED3 = &H00000004

   /*
    * This flag used to be DDSVCAPS_SPLIT, which is now obsolete
    */
   DDSVCAPS_RESERVED4 = &H00000008

   /*
    * The stereo view is accomplished with switching technology
    */

   DDSVCAPS_STEREOSEQUENTIAL = &H00000010
   DDSVCAPS_ENIGMA = 1
   DDSVCAPS_FLICKER = 2
   DDSVCAPS_REDBLUE = 4
   DDSVCAPS_SPLIT = 8
End Enum
Public Enum DDPCAPSFLAGS
    /*
    * Index is 4 bits.  There are sixteen color entries in the palette table.
    */
   DDPCAPS_4BIT = &H00000001

   /*
    * Index is onto a 8 bit color index.  This field is only valid with the
    * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
    * surface is in 8bpp. Each color entry is one byte long and is an index
    * into destination surface's 8bpp palette.
    */
   DDPCAPS_8BITENTRIES = &H00000002

   /*
    * Index is 8 bits.  There are 256 color entries in the palette table.
    */
   DDPCAPS_8BIT = &H00000004

   /*
    * Indicates that this DIRECTDRAWPALETTE should use the palette color array
    * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
    * object.
    * This flag is obsolete. DirectDraw always initializes the color array from
    * the lpDDColorArray parameter. The definition remains for source-level
    * compatibility.
    */
   DDPCAPS_INITIALIZE = &H00000000

   /*
    * This palette is the one attached to the primary surface.  Changing this
    * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
    * and supported.
    */
   DDPCAPS_PRIMARYSURFACE = &H00000010

   /*
    * This palette is the one attached to the primary surface left.  Changing
    * this table has immediate effect on the display for the left eye unless
    * DDPSETPAL_VSYNC is specified and supported.
    */
   DDPCAPS_PRIMARYSURFACELEFT = &H00000020

   /*
    * This palette can have all 256 entries defined
    */
   DDPCAPS_ALLOW256 = &H00000040

   /*
    * This palette can have modifications to it synced with the monitors
    * refresh rate.
    */
   DDPCAPS_VSYNC = &H00000080

   /*
    * Index is 1 bit.  There are two color entries in the palette table.
    */
   DDPCAPS_1BIT = &H00000100

   /*
    * Index is 2 bit.  There are four color entries in the palette table.
    */
   DDPCAPS_2BIT = &H00000200

   /*
    * The peFlags member of PALETTEENTRY denotes an 8 bit alpha value
    */
   DDPCAPS_ALPHA = &H00000400
    
End Enum
Public Enum DDSPDFLAGS 'no dxvb
    /*
    * The passed pointer is an IUnknown ptr. The cbData argument to SetPrivateData
    * must be set to sizeof(IUnknown*). DirectDraw will call AddRef through this
    * pointer and Release when the private data is destroyed. This includes when
    * the surface or palette is destroyed before such priovate data is destroyed.
    */
   DDSPD_IUNKNOWNPOINTER = &H00000001

   /*
    * Private data is only valid for the current state of the object,
    * as determined by the uniqueness value.
    */
   DDSPD_VOLATILE = &H00000002
End Enum
Public Enum DDBITDEPTHFLAGS
    /*
    * 1 bit per pixel.
    */
   DDBD_1 = &H00004000

   /*
    * 2 bits per pixel.
    */
   DDBD_2 = &H00002000

   /*
    * 4 bits per pixel.
    */
   DDBD_4 = &H00001000

   /*
    * 8 bits per pixel.
    */
   DDBD_8 = &H00000800

   /*
    * 16 bits per pixel.
    */
   DDBD_16 = &H00000400

   /*
    * 24 bits per pixel.
    */
   DDBD_24 = &H00000200

   /*
    * 32 bits per pixel.
    */
   DDBD_32 = &H00000100
End Enum
Public Enum DDCKEYFLAGS
    /*
    * Set if the structure contains a color space.  Not set if the structure
    * contains a single color key.
    */
   DDCKEY_COLORSPACE = &H00000001

   /*
    * Set if the structure specifies a color key or color space which is to be
    * used as a destination color key for blt operations.
    */
   DDCKEY_DESTBLT = &H00000002

   /*
    * Set if the structure specifies a color key or color space which is to be
    * used as a destination color key for overlay operations.
    */
   DDCKEY_DESTOVERLAY = &H00000004

   /*
    * Set if the structure specifies a color key or color space which is to be
    * used as a source color key for blt operations.
    */
   DDCKEY_SRCBLT = &H00000008

   /*
    * Set if the structure specifies a color key or color space which is to be
    * used as a source color key for overlay operations.
    */
   DDCKEY_SRCOVERLAY = &H00000010
End Enum
Public Enum DDCKEYCAPSFLAGS
    /*
    * Supports transparent blting using a color key to identify the replaceable
    * bits of the destination surface for RGB colors.
    */
   DDCKEYCAPS_DESTBLT = &H00000001

   /*
    * Supports transparent blting using a color space to identify the replaceable
    * bits of the destination surface for RGB colors.
    */
   DDCKEYCAPS_DESTBLTCLRSPACE = &H00000002

   /*
    * Supports transparent blting using a color space to identify the replaceable
    * bits of the destination surface for YUV colors.
    */
   DDCKEYCAPS_DESTBLTCLRSPACEYUV = &H00000004

   /*
    * Supports transparent blting using a color key to identify the replaceable
    * bits of the destination surface for YUV colors.
    */
   DDCKEYCAPS_DESTBLTYUV = &H00000008

   /*
    * Supports overlaying using colorkeying of the replaceable bits of the surface
    * being overlayed for RGB colors.
    */
   DDCKEYCAPS_DESTOVERLAY = &H00000010

   /*
    * Supports a color space as the color key for the destination for RGB colors.
    */
   DDCKEYCAPS_DESTOVERLAYCLRSPACE = &H00000020

   /*
    * Supports a color space as the color key for the destination for YUV colors.
    */
   DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV = &H00000040

   /*
    * Supports only one active destination color key value for visible overlay
    * surfaces.
    */
   DDCKEYCAPS_DESTOVERLAYONEACTIVE = &H00000080

   /*
    * Supports overlaying using colorkeying of the replaceable bits of the
    * surface being overlayed for YUV colors.
    */
   DDCKEYCAPS_DESTOVERLAYYUV = &H00000100

   /*
    * Supports transparent blting using the color key for the source with
    * this surface for RGB colors.
    */
   DDCKEYCAPS_SRCBLT = &H00000200

   /*
    * Supports transparent blting using a color space for the source with
    * this surface for RGB colors.
    */
   DDCKEYCAPS_SRCBLTCLRSPACE = &H00000400

   /*
    * Supports transparent blting using a color space for the source with
    * this surface for YUV colors.
    */
   DDCKEYCAPS_SRCBLTCLRSPACEYUV = &H00000800

   /*
    * Supports transparent blting using the color key for the source with
    * this surface for YUV colors.
    */
   DDCKEYCAPS_SRCBLTYUV = &H00001000

   /*
    * Supports overlays using the color key for the source with this
    * overlay surface for RGB colors.
    */
   DDCKEYCAPS_SRCOVERLAY = &H00002000

   /*
    * Supports overlays using a color space as the source color key for
    * the overlay surface for RGB colors.
    */
   DDCKEYCAPS_SRCOVERLAYCLRSPACE = &H00004000

   /*
    * Supports overlays using a color space as the source color key for
    * the overlay surface for YUV colors.
    */
   DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV = &H00008000&

   /*
    * Supports only one active source color key value for visible
    * overlay surfaces.
    */
   DDCKEYCAPS_SRCOVERLAYONEACTIVE = &H00010000

   /*
    * Supports overlays using the color key for the source with this
    * overlay surface for YUV colors.
    */
   DDCKEYCAPS_SRCOVERLAYYUV = &H00020000

   /*
    * there are no bandwidth trade-offs for using colorkey with an overlay
    */
   DDCKEYCAPS_NOCOSTOVERLAY = &H00040000
End Enum

Public Enum DDPIXELFORMATFLAGS
    /*
    * The surface has alpha channel information in the pixel format.
    */
   DDPF_ALPHAPIXELS = &H00000001

   /*
    * The pixel format contains alpha only information
    */
   DDPF_ALPHA = &H00000002

   /*
    * The FourCC code is valid.
    */
   DDPF_FOURCC = &H00000004

   /*
    * The surface is 4-bit color indexed.
    */
   DDPF_PALETTEINDEXED4 = &H00000008

   /*
    * The surface is indexed into a palette which stores indices
    * into the destination surface's 8-bit palette.
    */
   DDPF_PALETTEINDEXEDTO8 = &H00000010

   /*
    * The surface is 8-bit color indexed.
    */
   DDPF_PALETTEINDEXED8 = &H00000020

   /*
    * The RGB data in the pixel format structure is valid.
    */
   DDPF_RGB = &H00000040

   /*
    * The surface will accept pixel data in the format specified
    * and compress it during the write.
    */
   DDPF_COMPRESSED = &H00000080

   /*
    * The surface will accept RGB data and translate it during
    * the write to YUV data.  The format of the data to be written
    * will be contained in the pixel format structure.  The DDPF_RGB
    * flag will be set.
    */
   DDPF_RGBTOYUV = &H00000100

   /*
    * pixel format is YUV - YUV data in pixel format struct is valid
    */
   DDPF_YUV = &H00000200

   /*
    * pixel format is a z buffer only surface
    */
   DDPF_ZBUFFER = &H00000400

   /*
    * The surface is 1-bit color indexed.
    */
   DDPF_PALETTEINDEXED1 = &H00000800

   /*
    * The surface is 2-bit color indexed.
    */
   DDPF_PALETTEINDEXED2 = &H00001000

   /*
    * The surface contains Z information in the pixels
    */
   DDPF_ZPIXELS = &H00002000

   /*
    * The surface contains stencil information along with Z
    */
   DDPF_STENCILBUFFER = &H00004000

   /*
    * Premultiplied alpha format -- the color components have been
    * premultiplied by the alpha component.
    */
   DDPF_ALPHAPREMULT = &H00008000&


   /*
    * Luminance data in the pixel format is valid.
    * Use this flag for luminance-only or luminance+alpha surfaces,
    * the bit depth is then ddpf.dwLuminanceBitCount.
    */
   DDPF_LUMINANCE = &H00020000

   /*
    * Luminance data in the pixel format is valid.
    * Use this flag when hanging luminance off bumpmap surfaces,
    * the bit mask for the luminance portion of the pixel is then
    * ddpf.dwBumpLuminanceBitMask
    */
   DDPF_BUMPLUMINANCE = &H00040000

   /*
    * Bump map dUdV data in the pixel format is valid.
    */
   DDPF_BUMPDUDV = &H00080000
End Enum
Public Enum DDENUMSURFACESFLAGS
    /*
    * Enumerate all of the surfaces that meet the search criterion.
    */
   DDENUMSURFACES_ALL = &H00000001

   /*
    * A search hit is a surface that matches the surface description.
    */
   DDENUMSURFACES_MATCH = &H00000002

   /*
    * A search hit is a surface that does not match the surface description.
    */
   DDENUMSURFACES_NOMATCH = &H00000004

   /*
    * Enumerate the first surface that can be created which meets the search criterion.
    */
   DDENUMSURFACES_CANBECREATED = &H00000008

   /*
    * Enumerate the surfaces that already exist that meet the search criterion.
    */
   DDENUMSURFACES_DOESEXIST = &H00000010
    
End Enum
Public Enum DDSDMFLAGS
	DDSDM_DEFAULT = 0
    /*
    * The desired mode is a standard VGA mode
    */
	DDSDM_STANDARDVGAMODE = 1
End Enum
Public Enum DDEDMFLAGS
	DDEDM_DEFAULT = 0
	DDEDM_REFRESHRATES = 1
	DDEDM_STANDARDVGAMODES = 2
End Enum
Public Enum DDSCLFLAGS
    /*
    * Exclusive mode owner will be responsible for the entire primary surface.
    * GDI can be ignored. used with DD
    */
   DDSCL_FULLSCREEN = &H00000001

   /*
    * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
    */
   DDSCL_ALLOWREBOOT = &H00000002

   /*
    * prevents DDRAW from modifying the application window.
    * prevents DDRAW from minimize/restore the application window on activation.
    */
   DDSCL_NOWINDOWCHANGES = &H00000004

   /*
    * app wants to work as a regular Windows application
    */
   DDSCL_NORMAL = &H00000008

   /*
    * app wants exclusive access
    */
   DDSCL_EXCLUSIVE = &H00000010


   /*
    * app can deal with non-windows display modes
    */
   DDSCL_ALLOWMODEX = &H00000040

   /*
    * this window will receive the focus messages
    */
   DDSCL_SETFOCUSWINDOW = &H00000080

   /*
    * this window is associated with the DDRAW object and will
    * cover the screen in fullscreen mode
    */
   DDSCL_SETDEVICEWINDOW = &H00000100

   /*
    * app wants DDRAW to create a window to be associated with the
    * DDRAW object
    */
   DDSCL_CREATEDEVICEWINDOW = &H00000200

   /*
    * App explicitly asks DDRAW/D3D to be multithread safe. This makes D3D
    * take the global crtisec more frequently.
    */
   DDSCL_MULTITHREADED = &H00000400

   /*
    * App specifies that it would like to keep the FPU set up for optimal Direct3D
    * performance (single precision and exceptions disabled) so Direct3D
    * does not need to explicitly set the FPU each time. This is assumed by
    * default in DirectX 7. See also DDSCL_FPUPRESERVE
    */
   DDSCL_FPUSETUP = &H00000800

   /*
    * App specifies that it needs either double precision FPU or FPU exceptions
    * enabled. This makes Direct3D explicitly set the FPU state eah time it is
    * called. Setting the flag will reduce Direct3D performance. The flag is
    * assumed by default in DirectX 6 and earlier. See also DDSCL_FPUSETUP
    */
   DDSCL_FPUPRESERVE = &H00001000
End Enum
Public Enum DDBLTFLAGS
    /*
    * Use the alpha information in the pixel format or the alpha channel surface
    * attached to the destination surface as the alpha channel for this blt.
    */
   DDBLT_ALPHADEST = &H00000001

   /*
    * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
    * for the destination surface for this blt.
    */
   DDBLT_ALPHADESTCONSTOVERRIDE = &H00000002

   /*
    * The NEG suffix indicates that the destination surface becomes more
    * transparent as the alpha value increases. (0 is opaque)
    */
   DDBLT_ALPHADESTNEG = &H00000004

   /*
    * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
    * channel for the destination for this blt.
    */
   DDBLT_ALPHADESTSURFACEOVERRIDE = &H00000008

   /*
    * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
    * for the edges of the image that border the color key colors.
    */
   DDBLT_ALPHAEDGEBLEND = &H00000010

   /*
    * Use the alpha information in the pixel format or the alpha channel surface
    * attached to the source surface as the alpha channel for this blt.
    */
   DDBLT_ALPHASRC = &H00000020

   /*
    * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
    * for the source for this blt.
    */
   DDBLT_ALPHASRCCONSTOVERRIDE = &H00000040

   /*
    * The NEG suffix indicates that the source surface becomes more transparent
    * as the alpha value increases. (0 is opaque)
    */
   DDBLT_ALPHASRCNEG = &H00000080

   /*
    * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
    * for the source for this blt.
    */
   DDBLT_ALPHASRCSURFACEOVERRIDE = &H00000100

   /*
    * Do this blt asynchronously through the FIFO in the order received.  If
    * there is no room in the hardware FIFO fail the call.
    */
   DDBLT_ASYNC = &H00000200

   /*
    * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
    * to fill the destination rectangle on the destination surface with.
    */
   DDBLT_COLORFILL = &H00000400

   /*
    * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
    * to use for the blt.
    */
   DDBLT_DDFX = &H00000800

   /*
    * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
    * that are not part of the Win32 API.
    */
   DDBLT_DDROPS = &H00001000

   /*
    * Use the color key associated with the destination surface.
    */
   DDBLT_KEYDEST = &H00002000

   /*
    * Use the dckDestColorkey field in the DDBLTFX structure as the color key
    * for the destination surface.
    */
   DDBLT_KEYDESTOVERRIDE = &H00004000

   /*
    * Use the color key associated with the source surface.
    */
   DDBLT_KEYSRC = &H00008000&

   /*
    * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
    * for the source surface.
    */
   DDBLT_KEYSRCOVERRIDE = &H00010000

   /*
    * Use the dwROP field in the DDBLTFX structure for the raster operation
    * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
    */
   DDBLT_ROP = &H00020000

   /*
    * Use the dwRotationAngle field in the DDBLTFX structure as the angle
    * (specified in 1/100th of a degree) to rotate the surface.
    */
   DDBLT_ROTATIONANGLE = &H00040000

   /*
    * Z-buffered blt using the z-buffers attached to the source and destination
    * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
    * z-buffer opcode.
    */
   DDBLT_ZBUFFER = &H00080000

   /*
    * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
    * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
    * for the destination.
    */
   DDBLT_ZBUFFERDESTCONSTOVERRIDE = &H00100000

   /*
    * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
    * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
    * respectively for the destination.
    */
   DDBLT_ZBUFFERDESTOVERRIDE = &H00200000

   /*
    * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
    * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
    * for the source.
    */
   DDBLT_ZBUFFERSRCCONSTOVERRIDE = &H00400000

   /*
    * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
    * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
    * respectively for the source.
    */
   DDBLT_ZBUFFERSRCOVERRIDE = &H00800000

   /*
    * wait until the device is ready to handle the blt
    * this will cause blt to not return DDERR_WASSTILLDRAWING
    */
   DDBLT_WAIT = &H01000000

   /*
    * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
    * to fill the destination rectangle on the destination Z-buffer surface
    * with.
    */
   DDBLT_DEPTHFILL = &H02000000


   /*
    * Return immediately (with DDERR_WASSTILLDRAWING) if the device is not
    * ready to schedule the blt at the time Blt() is called.
    */
   DDBLT_DONOTWAIT = &H08000000

   /*
    * These flags indicate a presentation blt (i.e. a blt
    * that moves surface contents from an offscreen back buffer to the primary
    * surface). The driver is not allowed to "queue"  more than three such blts.
    * The "end" of the presentation blt is indicated, since the
    * blt may be clipped, in which case the runtime will call the driver with 
    * several blts. All blts (even if not clipped) are tagged with DDBLT_PRESENTATION
    * and the last (even if not clipped) additionally with DDBLT_LAST_PRESENTATION.
    * Thus the true rule is that the driver must not schedule a DDBLT_PRESENTATION
    * blt if there are 3 or more DDBLT_PRESENTLAST blts in the hardware pipe.
    * If there are such blts in the pipe, the driver should return DDERR_WASSTILLDRAWING
    * until the oldest queued DDBLT_LAST_PRESENTATION blts has been retired (i.e. the
    * pixels have been actually written to the primary surface). Once the oldest blt
    * has been retired, the driver is free to schedule the current blt.
    * The goal is to provide a mechanism whereby the device's hardware queue never
    * gets more than 3 frames ahead of the frames being generated by the application.
    * When excessive queueing occurs, applications become unusable because the application
    * visibly lags user input, and such problems make windowed interactive applications impossible.
    * Some drivers may not have sufficient knowledge of their hardware's FIFO to know
    * when a certain blt has been retired. Such drivers should code cautiously, and 
    * simply not allow any frames to be queued at all. DDBLT_LAST_PRESENTATION should cause
    * such drivers to return DDERR_WASSTILLDRAWING until the accelerator is completely
    * finished- exactly as if the application had called Lock on the source surface
    * before calling Blt. 
    * In other words, the driver is allowed and encouraged to 
    * generate as much latency as it can, but never more than 3 frames worth.
    * Implementation detail: Drivers should count blts against the SOURCE surface, not
    * against the primary surface. This enables multiple parallel windowed application
    * to function more optimally.
    * This flag is passed only to DX8 or higher drivers.
    *
    * APPLICATIONS DO NOT SET THESE FLAGS. THEY ARE SET BY THE DIRECTDRAW RUNTIME.
    * 
    */
   DDBLT_PRESENTATION = &H10000000
   DDBLT_LAST_PRESENTATION = &H20000000

   /*
    * If DDBLT_EXTENDED_FLAGS is set, then the driver should re-interpret
    * other flags according to the definitions that follow.
    * For example, bit 0 (= &H00000001L) means DDBLT_ALPHADEST, unless
    * DDBLT_EXTENDED_FLAGS is also set, in which case bit 0 means
    * DDBLT_EXTENDED_LINEAR_CONTENT.
    * Only DirectX9 and higher drivers will be given extended blt flags.
    * Only flags explicitly mentioned here should be re-interpreted.
    * All other flags retain their original meanings.
    *
    * List of re-interpreted flags:
    *
    * Bit Hex value   New meaning                                  old meaning
    * ---------------------------------------------------------------
    *  2  = &H00000004  DDBLT_EXTENDED_LINEAR_CONTENT                DDBLT_ALPHADESTNEG
    *  4  = &H00000010  DDBLT_EXTENDED_PRESENTATION_STRETCHFACTOR    DDBLT_ALPHAEDGEBLEND
    *
    *
    * NOTE: APPLICATIONS SHOULD NOT SET THIS FLAG. THIS FLAG IS INTENDED
    * FOR USE BY THE DIRECT3D RUNTIME.
    */
   DDBLT_EXTENDED_FLAGS = &H40000000

   /*
    * EXTENDED FLAG. SEE DEFINITION OF DDBLT_EXTENDED_FLAGS.
    * This flag indidcates that the source surface contains content in a
    * linear color space. The driver may perform gamma correction to the
    * desktop color space (i.e. sRGB, gamma 2.2) as part of this blt.
    * If the device can perform such a conversion as part of the copy,
    * the driver should also set D3DCAPS3_LINEAR_TO_SRGB_PRESENTATION
    *
    * NOTE: APPLICATIONS SHOULD NOT SET THIS FLAG. THIS FLAG IS INTENDED
    * FOR USE BY THE DIRECT3D RUNTIME. Use IDirect3DSwapChain9::Present
    * and specify D3DPRESENT_LINEAR_CONTENT in order to use this functionality.
    */
   DDBLT_EXTENDED_LINEAR_CONTENT = &H00000004

    
End Enum
Public Enum DDBLTFASTFLAGS
    DDBLTFAST_NOCOLORKEY = &H00000000
    DDBLTFAST_SRCCOLORKEY = &H00000001
    DDBLTFAST_DESTCOLORKEY = &H00000002
    DDBLTFAST_WAIT = &H00000010
    DDBLTFAST_DONOTWAIT = &H00000020
End Enum
Public Enum DDFLIPFLAGS
    DDFLIP_WAIT = &H00000001

    /*
     * Indicates that the target surface contains the even field of video data.
     * This flag is only valid with an overlay surface.
     */
    DDFLIP_EVEN = &H00000002

    /*
     * Indicates that the target surface contains the odd field of video data.
     * This flag is only valid with an overlay surface.
     */
    DDFLIP_ODD = &H00000004

    /*
     * Causes DirectDraw to perform the physical flip immediately and return
     * to the application. Typically, what was the front buffer but is now the back
     * buffer will still be visible (depending on timing) until the next vertical
     * retrace. Subsequent operations involving the two flipped surfaces will
     * not check to see if the physical flip has finished (i.e. will not return
     * DDERR_WASSTILLDRAWING for that reason (but may for other reasons)).
     * This allows an application to perform Flips at a higher frequency than the
     * monitor refresh rate, but may introduce visible artifacts.
     * Only effective if DDCAPS2_FLIPNOVSYNC is set. If that bit is not set,
     * DDFLIP_NOVSYNC has no effect.
     */
    DDFLIP_NOVSYNC = &H00000008


    /*
     * Flip Interval Flags. These flags indicate how many vertical retraces to wait between
     * each flip. The default is one. DirectDraw will return DDERR_WASSTILLDRAWING for each
     * surface involved in the flip until the specified number of vertical retraces has
     * ocurred. Only effective if DDCAPS2_FLIPINTERVAL is set. If that bit is not set,
     * DDFLIP_INTERVALn has no effect.
     */

    /*
     * DirectDraw will flip on every other vertical sync
     */
    DDFLIP_INTERVAL2 = &H02000000


    /*
     * DirectDraw will flip on every third vertical sync
     */
    DDFLIP_INTERVAL3 = &H03000000


    /*
     * DirectDraw will flip on every fourth vertical sync
     */
    DDFLIP_INTERVAL4 = &H04000000

    /*
     * DirectDraw will flip and display a main stereo surface
     */
    DDFLIP_STEREO = &H00000010

    /*
     * On IDirectDrawSurface7 and higher interfaces, the default is DDFLIP_WAIT. If you wish
     * to override the default and use time when the accelerator is busy (as denoted by
     * the DDERR_WASSTILLDRAWING return code) then use DDFLIP_DONOTWAIT.
     */
    DDFLIP_DONOTWAIT = &H00000020
 
End Enum
Public Enum DDOVERFLAGS
    /*
    * Use the alpha information in the pixel format or the alpha channel surface
    * attached to the destination surface as the alpha channel for the
    * destination overlay.
    */
   DDOVER_ALPHADEST = &H00000001

   /*
    * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
    * destination alpha channel for this overlay.
    */
   DDOVER_ALPHADESTCONSTOVERRIDE = &H00000002

   /*
    * The NEG suffix indicates that the destination surface becomes more
    * transparent as the alpha value increases.
    */
   DDOVER_ALPHADESTNEG = &H00000004

   /*
    * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
    * channel destination for this overlay.
    */
   DDOVER_ALPHADESTSURFACEOVERRIDE = &H00000008

   /*
    * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
    * channel for the edges of the image that border the color key colors.
    */
   DDOVER_ALPHAEDGEBLEND = &H00000010

   /*
    * Use the alpha information in the pixel format or the alpha channel surface
    * attached to the source surface as the source alpha channel for this overlay.
    */
   DDOVER_ALPHASRC = &H00000020

   /*
    * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
    * alpha channel for this overlay.
    */
   DDOVER_ALPHASRCCONSTOVERRIDE = &H00000040

   /*
    * The NEG suffix indicates that the source surface becomes more transparent
    * as the alpha value increases.
    */
   DDOVER_ALPHASRCNEG = &H00000080

   /*
    * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
    * source for this overlay.
    */
   DDOVER_ALPHASRCSURFACEOVERRIDE = &H00000100

   /*
    * Turn this overlay off.
    */
   DDOVER_HIDE = &H00000200

   /*
    * Use the color key associated with the destination surface.
    */
   DDOVER_KEYDEST = &H00000400

   /*
    * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
    * for the destination surface
    */
   DDOVER_KEYDESTOVERRIDE = &H00000800

   /*
    * Use the color key associated with the source surface.
    */
   DDOVER_KEYSRC = &H00001000

   /*
    * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
    * for the source surface.
    */
   DDOVER_KEYSRCOVERRIDE = &H00002000

   /*
    * Turn this overlay on.
    */
   DDOVER_SHOW = &H00004000

   /*
    * Add a dirty rect to an emulated overlayed surface.
    */
   DDOVER_ADDDIRTYRECT = &H00008000&

   /*
    * Redraw all dirty rects on an emulated overlayed surface.
    */
   DDOVER_REFRESHDIRTYRECTS = &H00010000

   /*
    * Redraw the entire surface on an emulated overlayed surface.
    */
   DDOVER_REFRESHALL = &H00020000


   /*
    * Use the overlay FX flags to define special overlay FX
    */
   DDOVER_DDFX = &H00080000

   /*
    * Autoflip the overlay when ever the video port autoflips
    */
   DDOVER_AUTOFLIP = &H00100000

   /*
    * Display each field of video port data individually without
    * causing any jittery artifacts
    */
   DDOVER_BOB = &H00200000

   /*
    * Indicates that bob/weave decisions should not be overridden by other
    * interfaces.
    */
   DDOVER_OVERRIDEBOBWEAVE = &H00400000

   /*
    * Indicates that the surface memory is composed of interleaved fields.
    */
   DDOVER_INTERLEAVED = &H00800000

   /*
    * Indicates that bob will be performed using hardware rather than
    * software or emulated.
    */
   DDOVER_BOBHARDWARE = &H01000000

   /*
    * Indicates that overlay FX structure contains valid ARGB scaling factors.
    */
   DDOVER_ARGBSCALEFACTORS = &H02000000

   /*
    * Indicates that ARGB scaling factors can be degraded to fit driver capabilities.
    */
   DDOVER_DEGRADEARGBSCALING = &H04000000
    
End Enum
Public Enum DDSETSURFACEDESCFLAGS 'No DXVB
    /*
    * The default.  The GDI DC will be tore down.
    */
    DDSETSURFACEDESC_RECREATEDC = &H00000000  ' default
    /*
    * The default.  The GDI DC will be kept.
    */
    DDSETSURFACEDESC_PRESERVEDC = &H00000001
End Enum

Public Enum DDLOCKFLAGS
    /*
    * The default.  Set to indicate that Lock should return a valid memory pointer
    * to the top of the specified rectangle.  If no rectangle is specified then a
    * pointer to the top of the surface is returned.
    */
   DDLOCK_SURFACEMEMORYPTR = &H00000000 ' default

   /*
    * Set to indicate that Lock should wait until it can obtain a valid memory
    * pointer before returning.  If this bit is set, Lock will never return
    * DDERR_WASSTILLDRAWING.
    */
   DDLOCK_WAIT = &H00000001

   /*
    * Set if an event handle is being passed to Lock.  Lock will trigger the event
    * when it can return the surface memory pointer requested.
    */
   DDLOCK_EVENT = &H00000002

   /*
    * Indicates that the surface being locked will only be read from.
    */
   DDLOCK_READONLY = &H00000010

   /*
    * Indicates that the surface being locked will only be written to
    */
   DDLOCK_WRITEONLY = &H00000020


   /*
    * Indicates that a system wide lock should not be taken when this surface
    * is locked. This has several advantages (cursor responsiveness, ability
    * to call more Windows functions, easier debugging) when locking video
    * memory surfaces. However, an application specifying this flag must
    * comply with a number of conditions documented in the help file.
    * Furthermore, this flag cannot be specified when locking the primary.
    */
   DDLOCK_NOSYSLOCK = &H00000800

   /*
    * Used only with Direct3D Vertex Buffer Locks. Indicates that no vertices
    * that were referred to in Draw*PrimtiveVB calls since the start of the
    * frame (or the last lock without this flag) will be modified during the
    * lock. This can be useful when one is only appending data to the vertex
    * buffer
    */
   DDLOCK_NOOVERWRITE = &H00001000

   /*
    * Indicates that no assumptions will be made about the contents of the
    * surface or vertex buffer during this lock.
    * This enables two things:
    * -    Direct3D or the driver may provide an alternative memory
    *      area as the vertex buffer. This is useful when one plans to clear the
    *      contents of the vertex buffer and fill in new data.
    * -    Drivers sometimes store surface data in a re-ordered format.
    *      When the application locks the surface, the driver is forced to un-re-order
    *      the surface data before allowing the application to see the surface contents.
    *      This flag is a hint to the driver that it can skip the un-re-ordering process
    *      since the application plans to overwrite every single pixel in the surface
    *      or locked rectangle (and so erase any un-re-ordered pixels anyway).
    *      Applications should always set this flag when they intend to overwrite the entire
    *      surface or locked rectangle.
    */
   DDLOCK_DISCARDCONTENTS = &H00002000
    /*
     * DDLOCK_OKTOSWAP is an older, less informative name for DDLOCK_DISCARDCONTENTS
     */
   DDLOCK_OKTOSWAP = &H00002000

   /*
    * On IDirectDrawSurface7 and higher interfaces, the default is DDLOCK_WAIT. If you wish
    * to override the default and use time when the accelerator is busy (as denoted by
    * the DDERR_WASSTILLDRAWING return code) then use DDLOCK_DONOTWAIT.
    */
   DDLOCK_DONOTWAIT = &H00004000

   /*
    * This indicates volume texture lock with front and back specified.
    */
   DDLOCK_HASVOLUMETEXTUREBOXRECT = &H00008000&

   /*
    * This indicates that the driver should not update dirty rect information for this lock.
    */
   DDLOCK_NODIRTYUPDATE = &H00010000
    
End Enum
    

Public Enum DDOVERFXFLAGS
    /*
    * If stretching, use arithmetic stretching along the Y axis for this overlay.
    */
   DDOVERFX_ARITHSTRETCHY = &H00000001

   /*
    * Mirror the overlay across the vertical axis
    */
   DDOVERFX_MIRRORLEFTRIGHT = &H00000002

   /*
    * Mirror the overlay across the horizontal axis
    */
   DDOVERFX_MIRRORUPDOWN = &H00000004

   /*
    * Deinterlace the overlay, if possible
    */
   DDOVERFX_DEINTERLACE = &H00000008
End Enum

Public Enum DDWAITVBFLAGS
    /*
    * return when the vertical blank interval begins
    */
   DDWAITVB_BLOCKBEGIN = &H00000001

   /*
    * set up an event to trigger when the vertical blank begins
    */
   DDWAITVB_BLOCKBEGINEVENT = &H00000002

   /*
    * return when the vertical blank interval ends and display begins
    */
   DDWAITVB_BLOCKEND = &H00000004
    
End Enum

Public Enum DDGFSFLAGS
	DDGFS_CANFLIP = 1
	DDGFS_ISFLIPDONE = 2
End Enum

Public Enum DDGBSFLAGS
	DDGBS_CANBLT = 1
	DDGBS_ISBLTDONE = 2
End Enum

Public Enum DDENUMOVERLAYZFLAGS
	DDENUMOVERLAYZ_BACKTOFRONT = 0
	DDENUMOVERLAYZ_FRONTTOBACK = 1
End Enum

Public Enum DDOVERZFLAGS
    /*
    * Send overlay to front
    */
   DDOVERZ_SENDTOFRONT = &H00000000

   /*
    * Send overlay to back
    */
   DDOVERZ_SENDTOBACK = &H00000001

   /*
    * Move Overlay forward
    */
   DDOVERZ_MOVEFORWARD = &H00000002

   /*
    * Move Overlay backward
    */
   DDOVERZ_MOVEBACKWARD = &H00000003

   /*
    * Move Overlay in front of relative surface
    */
   DDOVERZ_INSERTINFRONTOF = &H00000004

   /*
    * Move Overlay in back of relative surface
    */
   DDOVERZ_INSERTINBACKOF = &H00000005
End Enum

Public Enum DDSGRFLAGS
	DDSGR_DEFAULT = 0
    /*
     * Request calibrator to adjust the gamma ramp according to the physical
     * properties of the display so that the result should appear identical
     * on all systems.
     */
	DDSGR_CALIBRATE = 1
End Enum

Public Enum DDSMTFLAGS 'no dxvb
    /*
    * Indicates that the mode being tested has passed
    */
   DDSMT_ISTESTREQUIRED = &H00000001
End Enum

Public Enum DDEMFLAGS
    /*
    * Indicates that the mode being tested has passed
    */
    DDEM_MODEPASSED = &H00000001
    /*
    * Indicates that the mode being tested has failed
    */
    DDEM_MODEFAILED = &H0000000
End Enum

Public Enum DBOOLFLAGS
	D_FALSE = 0
	D_TRUE = 1
End Enum

Public Enum DDRAWERR
    DD_OK = S_OK
    DD_FALSE = S_FALSE

    /*
     * stop the enumeration
     */
    DDENUMRET_CANCEL = 0

    /*
     * continue the enumeration
     */
    DDENUMRET_OK = 1
    
     /*
    * This object is already initialized
    */
    DDERR_ALREADYINITIALIZED = &H88760005
    /*
    * This surface can not be attached to the requested surface.
    */
    DDERR_CANNOTATTACHSURFACE = &H8876000A
    /*
    * This surface can not be detached from the requested surface.
    */
    DDERR_CANNOTDETACHSURFACE = &H88760014
    /*
    * Support is currently not available.
    */
    DDERR_CURRENTLYNOTAVAIL = &H88760028
    /*
    * An exception was encountered while performing the requested operation
    */
    DDERR_EXCEPTION = &H88760037
    /*
    * Generic failure.
    */
    DDERR_GENERIC = E_FAIL
    /*
    * Height of rectangle provided is not a multiple of reqd alignment
    */
    DDERR_HEIGHTALIGN = &H8876005A
    /*
    * Unable to match primary surface creation request with existing
    * primary surface.
    */
    DDERR_INCOMPATIBLEPRIMARY = &H8876005F
    /*
    * One or more of the caps bits passed to the callback are incorrect.
    */
    DDERR_INVALIDCAPS = &H88760064
    /*
    * DirectDraw does not support provided Cliplist.
    */
    DDERR_INVALIDCLIPLIST = &H8876006E
    /*
    * DirectDraw does not support the requested mode
    */
    DDERR_INVALIDMODE = &H88760078
    /*
    * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
    */
    DDERR_INVALIDOBJECT = &H88760082
    /*
    * One or more of the parameters passed to the callback function are
    * incorrect.
    */
    DDERR_INVALIDPARAMS = E_INVALIDARG
    /*
    * pixel format was invalid as specified
    */
    DDERR_INVALIDPIXELFORMAT = &H88760091
    /*
    * Rectangle provided was invalid.
    */
    DDERR_INVALIDRECT = &H88760096
    /*
    * Operation could not be carried out because one or more surfaces are locked
    */
    DDERR_LOCKEDSURFACES = &H887600A0
    /*
    * There is no 3D present.
    */
    DDERR_NO3D = &H887600AA
    /*
    * Operation could not be carried out because there is no alpha accleration
    * hardware present or available.
    */
    DDERR_NOALPHAHW = &H887600B4
    /*
    * Operation could not be carried out because there is no stereo
    * hardware present or available.
    */
    DDERR_NOSTEREOHARDWARE = &H887600B5
    /*
    * Operation could not be carried out because there is no hardware
    * present which supports stereo surfaces
    */
    DDERR_NOSURFACELEFT = &H887600B6
    /*
    * no clip list available
    */
    DDERR_NOCLIPLIST = &H887600CD
    /*
    * Operation could not be carried out because there is no color conversion
    * hardware present or available.
    */
    DDERR_NOCOLORCONVHW = &H887600D2
    /*
    * Create function called without DirectDraw object method SetCooperativeLevel
    * being called.
    */
    DDERR_NOCOOPERATIVELEVELSET = &H887600D4
    /*
    * Surface doesn't currently have a color key
    */
    DDERR_NOCOLORKEY = &H887600D7
    /*
    * Operation could not be carried out because there is no hardware support
    * of the dest color key.
    */
    DDERR_NOCOLORKEYHW = &H887600DC
    /*
    * No DirectDraw support possible with current display driver
    */
    DDERR_NODIRECTDRAWSUPPORT = &H887600DE
    /*
    * Operation requires the application to have exclusive mode but the
    * application does not have exclusive mode.
    */
    DDERR_NOEXCLUSIVEMODE = &H887600E1
    /*
    * Flipping visible surfaces is not supported.
    */
    DDERR_NOFLIPHW = &H887600E6
    /*
    * There is no GDI present.
    */
    DDERR_NOGDI = &H887600F0
    /*
    * Operation could not be carried out because there is no hardware present
    * or available.
    */
    DDERR_NOMIRRORHW = &H887600FA
    /*
    * Requested item was not found
    */
    DDERR_NOTFOUND = &H887600FF
    /*
    * Operation could not be carried out because there is no overlay hardware
    * present or available.
    */
    DDERR_NOOVERLAYHW = &H88760104
    /*
    * Operation could not be carried out because the source and destination
    * rectangles are on the same surface and overlap each other.
    */
    DDERR_OVERLAPPINGRECTS = &H8876010E
    /*
    * Operation could not be carried out because there is no appropriate raster
    * op hardware present or available.
    */
    DDERR_NORASTEROPHW = &H88760118
    /*
    * Operation could not be carried out because there is no rotation hardware
    * present or available.
    */
    DDERR_NOROTATIONHW = &H88760122
    /*
    * Operation could not be carried out because there is no hardware support
    * for stretching
    */
    DDERR_NOSTRETCHHW = &H88760136
    /*
    * DirectDrawSurface is not in 4 bit color palette and the requested operation
    * requires 4 bit color palette.
    */
    DDERR_NOT4BITCOLOR = &H8876013C
    /*
    * DirectDrawSurface is not in 4 bit color index palette and the requested
    * operation requires 4 bit color index palette.
    */
    DDERR_NOT4BITCOLORINDEX = &H8876013D
    /*
    * DirectDraw Surface is not in 8 bit color mode and the requested operation
    * requires 8 bit color.
    */
    DDERR_NOT8BITCOLOR = &H88760140
    /*
    * Operation could not be carried out because there is no texture mapping
    * hardware present or available.
    */
    DDERR_NOTEXTUREHW = &H8876014A
    /*
    * Operation could not be carried out because there is no hardware support
    * for vertical blank synchronized operations.
    */
    DDERR_NOVSYNCHW = &H8876014F
    /*
    * Operation could not be carried out because there is no hardware support
    * for zbuffer blting.
    */
    DDERR_NOZBUFFERHW = &H88760154
    /*
    * Overlay surfaces could not be z layered based on their BltOrder because
    * the hardware does not support z layering of overlays.
    */
    DDERR_NOZOVERLAYHW = &H8876015E
    /*
    * The hardware needed for the requested operation has already been
    * allocated.
    */
    DDERR_OUTOFCAPS = &H88760168
    /*
    * DirectDraw does not have enough memory to perform the operation.
    */
    DDERR_OUTOFMEMORY = E_OUTOFMEMORY
    /*
    * DirectDraw does not have enough memory to perform the operation.
    */
    DDERR_OUTOFVIDEOMEMORY = &H8876017C
    /*
    * hardware does not support clipped overlays
    */
    DDERR_OVERLAYCANTCLIP = &H8876017E
    /*
    * Can only have ony color key active at one time for overlays
    */
    DDERR_OVERLAYCOLORKEYONLYONEACTIVE = &H88760180
    /*
    * Access to this palette is being refused because the palette is already
    * locked by another thread.
    */
    DDERR_PALETTEBUSY = &H88760183
    /*
    * No src color key specified for this operation.
    */
    DDERR_COLORKEYNOTSET = &H88760190
    /*
    * This surface is already attached to the surface it is being attached to.
    */
    DDERR_SURFACEALREADYATTACHED = &H8876019A
    /*
    * This surface is already a dependency of the surface it is being made a
    * dependency of.
    */
    DDERR_SURFACEALREADYDEPENDENT = &H887601A4
    /*
    * Access to this surface is being refused because the surface is already
    * locked by another thread.
    */
    DDERR_SURFACEBUSY = &H887601AE
    /*
    * Access to this surface is being refused because no driver exists
    * which can supply a pointer to the surface.
    * This is most likely to happen when attempting to lock the primary
    * surface when no DCI provider is present.
    * Will also happen on attempts to lock an optimized surface.
    */
    DDERR_CANTLOCKSURFACE = &H887601B3
    /*
    * Access to Surface refused because Surface is obscured.
    */
    DDERR_SURFACEISOBSCURED = &H887601B8
    /*
    * Access to this surface is being refused because the surface is gone.
    * The DIRECTDRAWSURFACE object representing this surface should
    * have Restore called on it.
    */
    DDERR_SURFACELOST = &H887601C2
    /*
    * The requested surface is not attached.
    */
    DDERR_SURFACENOTATTACHED = &H887601CC
    /*
    * Height requested by DirectDraw is too large.
    */
    DDERR_TOOBIGHEIGHT = &H887601D6
    /*
    * Size requested by DirectDraw is too large --  The individual height and
    * width are OK.
    */
    DDERR_TOOBIGSIZE = &H887601E0
    /*
    * Width requested by DirectDraw is too large.
    */
    DDERR_TOOBIGWIDTH = &H887601EA
    /*
    * Action not supported.
    */
    DDERR_UNSUPPORTED = E_NOTIMPL
    /*
    * Pixel format requested is unsupported by DirectDraw
    */
    DDERR_UNSUPPORTEDFORMAT = &H887601FE
    /*
    * Bitmask in the pixel format requested is unsupported by DirectDraw
    */
    DDERR_UNSUPPORTEDMASK = &H88760208
    /*
    * The specified stream contains invalid data
    */
    DDERR_INVALIDSTREAM = &H88760209
    /*
    * vertical blank is in progress
    */
    DDERR_VERTICALBLANKINPROGRESS = &H88760219
    /*
    * Informs DirectDraw that the previous Blt which is transfering information
    * to or from this Surface is incomplete.
    */
    DDERR_WASSTILLDRAWING = &H8876021C
    /*
    * The specified surface type requires specification of the COMPLEX flag
    */
    DDERR_DDSCAPSCOMPLEXREQUIRED = &H8876021E
    /*
    * Rectangle provided was not horizontally aligned on reqd. boundary
    */
    DDERR_XALIGN = &H88760230
    /*
    * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
    * identifier.
    */
    DDERR_INVALIDDIRECTDRAWGUID = &H88760231
    /*
    * A DirectDraw object representing this driver has already been created
    * for this process.
    */
    DDERR_DIRECTDRAWALREADYCREATED = &H88760232
    /*
    * A hardware only DirectDraw object creation was attempted but the driver
    * did not support any hardware.
    */
    DDERR_NODIRECTDRAWHW = &H88760233
    /*
    * this process already has created a primary surface
    */
    DDERR_PRIMARYSURFACEALREADYEXISTS = &H88760234
    /*
    * software emulation not available.
    */
    DDERR_NOEMULATION = &H88760235
    /*
    * region passed to Clipper::GetClipList is too small.
    */
    DDERR_REGIONTOOSMALL = &H88760236
    /*
    * an attempt was made to set a clip list for a clipper objec that
    * is already monitoring an hwnd.
    */
    DDERR_CLIPPERISUSINGHWND = &H88760237
    /*
    * No clipper object attached to surface object
    */
    DDERR_NOCLIPPERATTACHED = &H88760238
    /*
    * Clipper notification requires an HWND or
    * no HWND has previously been set as the CooperativeLevel HWND.
    */
    DDERR_NOHWND = &H88760239
    /*
    * HWND used by DirectDraw CooperativeLevel has been subclassed,
    * this prevents DirectDraw from restoring state.
    */
    DDERR_HWNDSUBCLASSED = &H8876023A
    /*
    * The CooperativeLevel HWND has already been set.
    * It can not be reset while the process has surfaces or palettes created.
    */
    DDERR_HWNDALREADYSET = &H8876023B
    /*
    * No palette object attached to this surface.
    */
    DDERR_NOPALETTEATTACHED = &H8876023C
    /*
    * No hardware support for 16 or 256 color palettes.
    */
    DDERR_NOPALETTEHW = &H8876023D
    /*
    * If a clipper object is attached to the source surface passed into a
    * BltFast call.
    */
    DDERR_BLTFASTCANTCLIP = &H8876023E
    /*
    * No blter.
    */
    DDERR_NOBLTHW = &H8876023F
    /*
    * No DirectDraw ROP hardware.
    */
    DDERR_NODDROPSHW = &H88760240
    /*
    * returned when GetOverlayPosition is called on a hidden overlay
    */
    DDERR_OVERLAYNOTVISIBLE = &H88760241
    /*
    * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
    * has never been called on to establish a destionation.
    */
    DDERR_NOOVERLAYDEST = &H88760242
    /*
    * returned when the position of the overlay on the destionation is no longer
    * legal for that destionation.
    */
    DDERR_INVALIDPOSITION = &H88760243
    /*
    * returned when an overlay member is called for a non-overlay surface
    */
    DDERR_NOTAOVERLAYSURFACE = &H88760244
    /*
    * An attempt was made to set the cooperative level when it was already
    * set to exclusive.
    */
    DDERR_EXCLUSIVEMODEALREADYSET = &H88760245
    /*
    * An attempt has been made to flip a surface that is not flippable.
    */
    DDERR_NOTFLIPPABLE = &H88760246
    /*
    * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
    * created.
    */
    DDERR_CANTDUPLICATE = &H88760247
    /*
    * Surface was not locked.  An attempt to unlock a surface that was not
    * locked at all, or by this process, has been attempted.
    */
    DDERR_NOTLOCKED = &H88760248
    /*
    * Windows can not create any more DCs, or a DC was requested for a paltte-indexed
    * surface when the surface had no palette AND the display mode was not palette-indexed
    * (in this case DirectDraw cannot select a proper palette into the DC))
    */
    DDERR_CANTCREATEDC = &H88760249
    /*
    * No DC was ever created for this surface.
    */
    DDERR_NODC = &H8876024A
    /*
    * This surface can not be restored because it was created in a different
    * mode.
    */
    DDERR_WRONGMODE = &H8876024B
    /*
    * This surface can not be restored because it is an implicitly created
    * surface.
    */
    DDERR_IMPLICITLYCREATED = &H8876024C
    /*
    * The surface being used is not a palette-based surface
    */
    DDERR_NOTPALETTIZED = &H8876024D
    /*
    * The display is currently in an unsupported mode
    */
    DDERR_UNSUPPORTEDMODE = &H8876024E
    /*
    * Operation could not be carried out because there is no mip-map
    * texture mapping hardware present or available.
    */
    DDERR_NOMIPMAPHW = &H8876024F
    /*
    * The requested action could not be performed because the surface was of
    * the wrong type.
    */
    DDERR_INVALIDSURFACETYPE = &H88760250
    /*
    * Device does not support optimized surfaces, therefore no video memory optimized surfaces
    */
    DDERR_NOOPTIMIZEHW = &H88760258
    /*
    * Surface is an optimized surface, but has not yet been allocated any memory
    */
    DDERR_NOTLOADED = &H88760259
    /*
    * Attempt was made to create or set a device window without first setting
    * the focus window
    */
    DDERR_NOFOCUSWINDOW = &H8876025A
    /*
    * Attempt was made to set a palette on a mipmap sublevel
    */
    DDERR_NOTONMIPMAPSUBLEVEL = &H8876025B
    /*
    * A DC has already been returned for this surface. Only one DC can be
    * retrieved per surface.
    */
    DDERR_DCALREADYCREATED = &H8876026C
    /*
    * An attempt was made to allocate non-local video memory from a device
    * that does not support non-local video memory.
    */
    DDERR_NONONLOCALVIDMEM = &H88760276
    /*
    * The attempt to page lock a surface failed.
    */
    DDERR_CANTPAGELOCK = &H88760280
    /*
    * The attempt to page unlock a surface failed.
    */
    DDERR_CANTPAGEUNLOCK = &H88760294
    /*
    * An attempt was made to page unlock a surface with no outstanding page locks.
    */
    DDERR_NOTPAGELOCKED = &H887602A8
    /*
    * There is more data available than the specified buffer size could hold
    */
    DDERR_MOREDATA = &H887602B2
    /*
    * The data has expired and is therefore no longer valid.
    */
    DDERR_EXPIRED = &H887602B3
    /*
    * The mode test has finished executing.
    */
    DDERR_TESTFINISHED = &H887602B4
    /*
    * The mode test has switched to a new mode.
    */
    DDERR_NEWMODE = &H887602B5
    /*
    * D3D has not yet been initialized.
    */
    DDERR_D3DNOTINITIALIZED = &H887602B6
    /*
    * The video port is not active
    */
    DDERR_VIDEONOTACTIVE = &H887602B7
    /*
    * The monitor does not have EDID data.
    */
    DDERR_NOMONITORINFORMATION = &H887602B8
    /*
    * The driver does not enumerate display mode refresh rates.
    */
    DDERR_NODRIVERSUPPORT = &H887602B9
    /*
    * Surfaces created by one direct draw device cannot be used directly by
    * another direct draw device.
    */
    DDERR_DEVICEDOESNTOWNSURFACE = &H887602BB
    /*
    * An attempt was made to invoke an interface member of a DirectDraw object
    * created by CoCreateInstance()) before it was initialized.
    */
    DDERR_NOTINITIALIZED = &H800401F0 'CO_E_NOTINITIALIZED
End Enum


'ddstream.h

Public Enum DDSFF_CS_FLAGS
    DDSFF_PROGRESSIVERENDER = &H00000001
End Enum
End Module
#End If