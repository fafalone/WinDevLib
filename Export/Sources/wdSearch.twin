'*****************************************************************************************
'This file is a part of WinDevLib - Windows Development Library for twinBASIC
'https://github.com/fafalone/WinDevLib
'Code ported by Jon Johnson. 
'"Windows" is a trademark of the Microsoft Corporation.
'Certain Description attributes (c) Microsoft, taken from SDK headers and official docs.
'Licensed under Creative Commons CC0 1.0 Universal
'*****************************************************************************************

'WinDevLib - structuredquery.idl and related

[InterfaceId("a0ffbc28-5482-4366-be27-3e81e78e06c2")]
[OleAutomation(False)]
Interface ISearchFolderItemFactory Extends stdole.IUnknown
    Sub SetDisplayName(ByVal pszDisplayName As LongPtr)
    Sub SetFolderIdType(ftid As UUID)
    Sub SetFolderLogicalViewMode(ByVal flvm As FOLDERLOGICALVIEWMODE)
    Sub SetIconSize(ByVal iIconSize As Long)
    Sub SetVisibleColumns(ByVal cVisibleColumn As Long, rgKey As PROPERTYKEY)
    Sub SetSortColumns(ByVal cSortColumns As Long, rgSortColumns As SORTCOLUMN)
    Sub SetGroupColumn(KeyGroup As PROPERTYKEY)
    Sub SetStacks(ByVal cStackKeys As Long, rgStackKeys As PROPERTYKEY)
    Sub SetScope(ByVal psiaScope As IShellItemArray)
    Sub SetCondition(ByVal pCondition As ICondition)
    Sub GetShellItem(riid As UUID, ppv As Any)
    Sub GetIDList(ppidl As LongPtr)
End Interface

[InterfaceId("4FDEF69C-DBC9-454e-9910-B34F3C64B510")]
[OleAutomation(False)]
Interface IRichChunk Extends stdole.IUnknown
    Sub GetData(pLength As Long, ppsz As LongPtr, pValue As Variant)
End Interface

[InterfaceId("0FC988D4-C935-4b97-A973-46282EA175C8")]
[OleAutomation(False)]
Interface ICondition Extends IPersistStream
    Function GetConditionType() As CONDITION_TYPE
    Sub GetSubConditions(riid As UUID, ppv As Any)
    Sub GetComparisonInfo(ppszPropertyName As LongPtr, pcop As CONDITION_OPERATION, ppropvar As Variant)
    Function GetValueType() As LongPtr
    Function GetValueNormalization() As LongPtr
    Sub GetInputTerms(ppPropertyTerm As IRichChunk, ppOperationTerm As IRichChunk, ppValueTerm As IRichChunk)
    Function Clone() As ICondition
End Interface

[InterfaceId("0DB8851D-2E5B-47eb-9208-D28C325A01D7")]
[OleAutomation(False)]
Interface ICondition2 Extends ICondition
    Sub GetLocale(ppszLocaleName As LongPtr)
    Sub GetLeafConditionInfo(ppropkey As PROPERTYKEY, pcop As CONDITION_OPERATION, ppropvar As Variant)
End Interface

[InterfaceId("A5EFE073-B16F-474f-9F3E-9F8B497A3E08")]
[OleAutomation(False)]
Interface IConditionFactory Extends stdole.IUnknown
    Sub MakeNot(ByVal pcSub As ICondition, ByVal fSimplify As Long, ppcResult As ICondition)
    Function MakeAndOr(ByVal ct As CONDITION_TYPE, ByVal peuSubs As IEnumUnknown, ByVal fSimplify As Long) As ICondition
    Sub MakeLeaf(ByVal pszPropertyName As LongPtr, ByVal cop As CONDITION_OPERATION, ByVal pszValueType As LongPtr, ppropvar As Variant, ByVal pPropertyNameTerm As IRichChunk, ByVal pOperationTerm As IRichChunk, ByVal pValueTerm As IRichChunk, ByVal fExpand As Long, ppcResult As ICondition)
    Sub Resolve(ByVal pc As ICondition, ByVal sqro As STRUCTURED_QUERY_RESOLVE_OPTION, pstReferenceTime As SYSTEMTIME, ppcResolved As ICondition)
End Interface

[InterfaceId("71D222E1-432F-429e-8C13-B6DAFDE5077A")]
[OleAutomation(False)]
Interface IConditionFactory2 Extends IConditionFactory
    Sub CreateTrueFalse(ByVal fVal As Long, ByVal cco As CONDITION_CREATION_OPTIONS, riid As UUID, ppv As Any)
    Sub CreateNegation(ByVal pcSub As ICondition, ByVal cco As CONDITION_CREATION_OPTIONS, riid As UUID, ppv As Any)
    Sub CreateCompoundFromObjectArray(ByVal ct As CONDITION_TYPE, ByVal poaSubs As IObjectArray, ByVal cco As CONDITION_CREATION_OPTIONS, riid As UUID, ppv As Any)
    Sub CreateCompoundFromArray(ByVal ct As CONDITION_TYPE, ppcondSubs As ICondition, ByVal cSubs As Long, ByVal cco As CONDITION_CREATION_OPTIONS, riid As UUID, ppv As Any)
    Sub CreateStringLeaf(propkey As PROPERTYKEY, ByVal cop As CONDITION_OPERATION, ByVal pszValue As LongPtr, ByVal pszLocaleName As LongPtr, ByVal cco As CONDITION_CREATION_OPTIONS, riid As UUID, ppv As Any)
    Sub CreateIntegerLeaf(propkey As PROPERTYKEY, ByVal cop As CONDITION_OPERATION, ByVal lValue As Long, ByVal cco As CONDITION_CREATION_OPTIONS, riid As UUID, ppv As Any)
    Sub CreateBooleanLeaf(propkey As PROPERTYKEY, ByVal cop As CONDITION_OPERATION, ByVal fValue As Long, ByVal cco As CONDITION_CREATION_OPTIONS, riid As UUID, ppv As Any)
    Sub CreateLeaf(propkey As PROPERTYKEY, ByVal cop As CONDITION_OPERATION, propvar As Variant, ByVal pszSemanticType As LongPtr, ByVal pszLocaleName As LongPtr, ByVal pPropertyNameTree As IRichChunk, ByVal pOperationTerm As IRichChunk, ByVal pValueTerm As IRichChunk, ByVal cco As CONDITION_CREATION_OPTIONS, riid As UUID, ppv As Any)
    Sub ResolveCondition(ByVal pc As ICondition, ByVal sqro As STRUCTURED_QUERY_RESOLVE_OPTION, pstReferenceTime As SYSTEMTIME, riid As UUID, ppv As Any)
End Interface

[InterfaceId("2EBDEE67-3505-43f8-9946-EA44ABC8E5B0")]
[OleAutomation(False)]
Interface IQueryParser Extends stdole.IUnknown
    Function Parse(ByVal pszInputString As LongPtr, ByVal pCustomProperties As IEnumUnknown) As IQuerySolution
    Sub SetOption(ByVal option As STRUCTURED_QUERY_SINGLE_OPTION, pOptionValue As Variant)
    Function GetOption(ByVal option As STRUCTURED_QUERY_SINGLE_OPTION) As Variant
    Sub SetMultiOption(ByVal option As STRUCTURED_QUERY_MULTIOPTION, ByVal pszOptionKey As LongPtr, pOptionValue As Variant)
    Function GetSchemaProvider() As ISchemaProvider
    Sub RestateToString(ByVal pCondition As ICondition, ByVal fUseEnglish As Long, ppszQueryString As LongPtr)
    Function ParsePropertyValue(ByVal pszPropertyName As LongPtr, ByVal pszInputString As LongPtr) As IQuerySolution
    Sub RestatePropertyValueToString(ByVal pCondition As ICondition, ByVal fUseEnglish As Long, ppszPropertyName As LongPtr, ppszQueryString As LongPtr)
End Interface

[InterfaceId("D6EBC66B-8921-4193-AFDD-A1789FB7FF57")]
[OleAutomation(False)]
Interface IQuerySolution Extends IConditionFactory
    Sub GetQuery(ppQueryNode As ICondition, ppMainType As IEntity)
    Sub GetErrors(riid As UUID, ppParseErrors As Any)
    Sub GetLexicalData(ppszInputString As LongPtr, ppTokens As ITokenCollection, plcid As Long, ppWordBreaker As IUnknownUnrestricted)
    
End Interface

[InterfaceId("92D2CC58-4386-45a3-B98C-7E0CE64A4117")]
[OleAutomation(False)]
Interface IConditionGenerator Extends stdole.IUnknown
    Sub Initialize(ByVal pSchemaProvider As ISchemaProvider)
    Sub RecognizeNamedEntities(ByVal pszInputString As LongPtr, ByVal lcidUserLocale As Long, ByVal pTokenCollection As ITokenCollection, pNamedEntities As INamedEntityCollector)
    Function GenerateForLeaf(ByVal pConditionFactory As IConditionFactory, ByVal pszPropertyName As LongPtr, ByVal cop As CONDITION_OPERATION, ByVal pszValueType As LongPtr, ByVal pszValue As LongPtr, ByVal pszValue2 As LongPtr, ByVal pPropertyNameTree As IRichChunk, ByVal pOperationTerm As IRichChunk, ByVal pValueTerm As IRichChunk, ByVal automaticWildcard As Long, pNoStringQuery As Long) As ICondition
    Function DefaultPhrase(ByVal pszValueType As LongPtr, ppropvar As Variant, ByVal fUseEnglish As Long) As LongPtr
End Interface

[InterfaceId("6BF0A714-3C18-430b-8B5D-83B1C234D3DB")]
[OleAutomation(False)]
Interface IInterval Extends stdole.IUnknown
    Sub GetLimits(pilkLower As INTERVAL_LIMIT_KIND, ppropvarLower As Variant, pilkUpper As INTERVAL_LIMIT_KIND, ppropvarUpper As Variant)
End Interface

[InterfaceId("780102B0-C43B-4876-BC7B-5E9BA5C88794")]
[OleAutomation(False)]
Interface IMetaData Extends stdole.IUnknown
    Sub GetData(pkey As PROPERTYKEY, ppszValue As LongPtr)
End Interface

[InterfaceId("24264891-E80B-4fd3-B7CE-4FF2FAE8931F")]
[OleAutomation(False)]
Interface IEntity Extends stdole.IUnknown
    Function Name() As LongPtr
    Function Base() As IEntity
    Sub Relationships(riid As UUID, pRelationships As Any)
    Function GetRelationship(ByVal pszRelationName As LongPtr) As IRelationship
    Sub MetaData(riid As UUID, pMetaData As Any)
    Sub NamedEntities(riid As UUID, pNamedEntities As Any)
    Function GetNamedEntity(ByVal pszValue As LongPtr) As INamedEntity
    Function DefaultPhrase() As LongPtr
End Interface

[InterfaceId("2769280B-5108-498c-9C7F-A51239B63147")]
[OleAutomation(False)]
Interface IRelationship Extends stdole.IUnknown
    Function Name() As LongPtr
    Function IsReal() As Long
    Function Destination() As IEntity
    Sub MetaData(riid As UUID, pMetaData As Any)
    Function DefaultPhrase() As LongPtr
End Interface

[InterfaceId("ABDBD0B1-7D54-49fb-AB5C-BFF4130004CD")]
[OleAutomation(False)]
Interface INamedEntity Extends stdole.IUnknown
    Function GetValue() As LongPtr
    Function DefaultPhrase() As LongPtr
End Interface

[InterfaceId("8CF89BCB-394C-49b2-AE28-A59DD4ED7F68")]
[OleAutomation(False)]
Interface ISchemaProvider Extends stdole.IUnknown
    Sub Entities(riid As UUID, pEntities As Any)
    Function RootEntity() As IEntity
    Function GetEntity(ByVal pszEntityName As LongPtr) As IEntity
    Sub MetaData(riid As UUID, pMetaData As Any)
    Sub Localize(ByVal lcid As Long, ByVal pSchemaLocalizerSupport As ISchemaLocalizerSupport)
    Sub SaveBinary(ByVal pszSchemaBinaryPath As LongPtr)
    Sub LookupAuthoredNamedEntity(ByVal pEntity As IEntity, ByVal pszInputString As LongPtr, ByVal pTokenCollection As ITokenCollection, ByVal cTokensBegin As Long, pcTokensLength As Long, ppszValue As LongPtr)
End Interface

[InterfaceId("22D8B4F2-F577-4adb-A335-C2AE88416FAB")]
[OleAutomation(False)]
Interface ITokenCollection Extends stdole.IUnknown
    Sub NumberOfTokens(pCount As Long)
    Sub GetToken(ByVal i As Long, pBegin As Long, pLength As Long, ppsz As LongPtr)
End Interface

[InterfaceId("AF2440F6-8AFC-47d0-9A7F-396A0ACFB43D")]
[OleAutomation(False)]
Interface INamedEntityCollector Extends stdole.IUnknown
    Sub Add(ByVal beginSpan As Long, ByVal EndSpan As Long, ByVal beginActual As Long, ByVal EndActual As Long, ByVal pType As IEntity, ByVal pszValue As LongPtr, ByVal certainty As NAMED_ENTITY_CERTAINTY)
End Interface

[InterfaceId("CA3FDCA2-BFBE-4eed-90D7-0CAEF0A1BDA1")]
[OleAutomation(False)]
Interface ISchemaLocalizerSupport Extends stdole.IUnknown
    Function Localize(ByVal pszGlobalString As LongPtr) As LongPtr 'ppszLocalString
End Interface

[InterfaceId("A879E3C4-AF77-44fb-8F37-EBD1487CF920")]
[OleAutomation(False)]
Interface IQueryParserManager Extends stdole.IUnknown
    Sub CreateLoadedParser(ByVal pszCatalog As LongPtr, ByVal langidForKeywords As Integer, riid As UUID, ppQueryParser As Any)
    Sub InitializeOptions(ByVal fUnderstandNQS As Long, ByVal fAutoWildcard As Long, ByVal pQueryParser As IQueryParser)
    Sub SetOption(ByVal option As QUERY_PARSER_MANAGER_OPTION, pOptionValue As Variant)
End Interface


'SearchAPI
    [InterfaceId("89BCB740-6119-101A-BCB7-00DD010655AF")]
    [OleAutomation(False)]
    Interface IFilter Extends stdole.IUnknown
        [PreserveSig]
        Function Init(ByVal grfFlags As IFILTER_INIT, ByVal cAttributes As Long, ByRef aAttributes As FULLPROPSPEC, ByRef pFlags As IFILTER_FLAGS) As Long
        [PreserveSig]
        Function GetChunk(ByRef pStat As STAT_CHUNK) As Long
        [PreserveSig]
        Function GetText(ByRef pcwcBuffer As Long, ByRef awcBuffer As Integer) As Long
        [PreserveSig]
        Function GetValue(ByRef ppPropValue As LongPtr) As Long
    #If Win64 Then
        [PreserveSig]
        Function BindRegion(ByRef origPos As FILTERREGION, ByRef riid As UUID, ByRef ppunk As Any) As Long
    #Else
        [PreserveSig]
        Function BindRegion(ByVal origPosChunk As Long, ByVal origPosStart As Long, ByVal origPosExtent As Long, ByRef riid As UUID, ByRef ppunk As Any) As Long
    #End If
    End Interface

    [InterfaceId("C7310722-AC80-11D1-8DF3-00C04FB6EF4F")]
    [Description("ILoadFilter Interface")]
    [OleAutomation(False)]
    Interface ILoadFilter Extends stdole.IUnknown
        Sub LoadIFilter(ByVal pwcsPath As LongPtr, ByRef pFilteredSources As FILTERED_DATA_SOURCES, ByVal pUnkOuter As IUnknown, ByVal fUseDefault As Long, ByRef pFilterClsid As UUID, ByRef SearchDecSize As Long, ByRef pwcsSearchDesc As LongPtr, ByRef ppIFilt As IFilter)
        Sub LoadIFilterFromStorage(ByVal pStg As IStorage, ByVal pUnkOuter As IUnknown, ByVal pwcsOverride As LongPtr, ByVal fUseDefault As Long, ByRef pFilterClsid As UUID, ByRef SearchDecSize As Long, ByRef pwcsSearchDesc As LongPtr, ByRef ppIFilt As IFilter)
        Sub LoadIFilterFromStream(ByVal pStm As IStream, ByRef pFilteredSources As FILTERED_DATA_SOURCES, ByVal pUnkOuter As IUnknown, ByVal fUseDefault As Long, ByRef pFilterClsid As UUID, ByRef SearchDecSize As Long, ByRef pwcsSearchDesc As LongPtr, ByRef ppIFilt As IFilter)
    End Interface

    [InterfaceId("40BDBD34-780B-48D3-9BB6-12EBD4AD2E75")]
    [Description("ILoadFilterWithPrivateComActivation Interface")]
    [OleAutomation(False)]
    Interface ILoadFilterWithPrivateComActivation Extends ILoadFilter
        Sub LoadIFilterWithPrivateComActivation(ByRef filteredSources As FILTERED_DATA_SOURCES, ByVal useDefault As Long, ByRef filterClsid As UUID, ByVal isFilterPrivateComActivated As Long, ByRef filterObj As IFilter)
    End Interface

    [InterfaceId("0B63E318-9CCC-11D0-BCDB-00805FCCCE04")]
    [Description("URL Accessor Interface")]
    [OleAutomation(False)]
    Interface IUrlAccessor Extends stdole.IUnknown
        Sub AddRequestParameter(ByRef pSpec As PROPSPEC, ByRef pVar As Variant)
        Sub GetDocFormat(ByRef wszDocFormat As Integer, ByVal dwSize As Long, ByRef pdwLength As Long)
        Sub GetCLSID(ByRef pclsid As UUID)
        Sub GetHost(ByRef wszHost As Integer, ByVal dwSize As Long, ByRef pdwLength As Long)
        [PreserveSig]
        Function IsDirectory() As Long
        Sub GetSize(ByRef pllSize As LongLong)
        Sub GetLastModified(ByRef pftLastModified As FILETIME)
        Sub GetFileName(ByRef wszFileName As Integer, ByVal dwSize As Long, ByRef pdwLength As Long)
        Sub GetSecurityDescriptor(ByRef psd As Byte, ByVal dwSize As Long, ByRef pdwLength As Long)
        Sub GetRedirectedURL(ByRef wszRedirectedURL As Integer, ByVal dwSize As Long, ByRef pdwLength As Long)
        Sub GetSecurityProvider(ByRef pSPClsid As UUID)
        Sub BindToStream(ByRef ppStream As IStream)
        Sub BindToFilter(ByRef ppFilter As IFilter)
    End Interface

    [InterfaceId("C7310734-AC80-11D1-8DF3-00C04FB6EF4F")]
    [Description("URL Accessor Interface")]
    [OleAutomation(False)]
    Interface IUrlAccessor2 Extends IUrlAccessor
        Sub GetDisplayUrl(ByRef wszDocUrl As Integer, ByVal dwSize As Long, ByRef pdwLength As Long)
        [PreserveSig]
        Function IsDocument() As Long
        Sub GetCodePage(ByRef wszCodePage As Integer, ByVal dwSize As Long, ByRef pdwLength As Long)
    End Interface
    
    [InterfaceId("6FBC7005-0455-4874-B8FF-7439450241A3")]
    [Description("URL Accessor Interface")]
    [OleAutomation(False)]
    Interface IUrlAccessor3 Extends IUrlAccessor2
        Sub GetImpersonationSidBlobs(ByVal pcwszURL As LongPtr, ByRef pcSidCount As Long, ByRef ppSidBlobs As LongPtr)
    End Interface

    [InterfaceId("5CC51041-C8D2-41D7-BCA3-9E9E286297DC")]
    [Description("URL Accessor Interface")]
    [OleAutomation(False)]
    Interface IUrlAccessor4 Extends IUrlAccessor3
        Sub ShouldIndexItemContent(ByVal pfIndexContent As Long)
        Sub ShouldIndexProperty(ByRef key As PROPERTYKEY, ByVal pfIndexProperty As Long)
    End Interface

    [InterfaceId("C73106E1-AC80-11D1-8DF3-00C04FB6EF4F")]
    [Description("Search Protocol Handler Thread Context Interface")]
    [OleAutomation(False)]
    Interface ISearchProtocolThreadContext Extends stdole.IUnknown
        Sub ThreadInit()
        Sub ThreadShutdown()
        Sub ThreadIdle(ByVal dwTimeElaspedSinceLastCallInMS As Long)
    End Interface

    [InterfaceId("C731065D-AC80-11D1-8DF3-00C04FB6EF4F")]
    [Description("Opportunistic Locking Status")]
    [OleAutomation(False)]
    Interface IOpLockStatus Extends stdole.IUnknown
        Sub IsOplockValid(ByRef pfIsOplockValid As BOOL)
        Sub IsOplockBroken(ByRef pfIsOplockBroken As BOOL)
        Sub GetOplockEventHandle(ByRef phOplockEv As LongPtr)
    End Interface
    
    [InterfaceId("C73106BA-AC80-11D1-8DF3-00C04FB6EF4F")]
    [Description("Protocol Handler Interface")]
    [OleAutomation(False)]
    Interface ISearchProtocol Extends stdole.IUnknown
        Sub Init(ByRef pTimeoutInfo As TIMEOUT_INFO, ByVal pProtocolHandlerSite As IProtocolHandlerSite, ByRef pProxyInfo As PROXY_INFO)
        Sub CreateAccessor(ByVal pcwszURL As LongPtr, ByRef pAuthenticationInfo As AUTHENTICATION_INFO, ByRef pIncrementalAccessInfo As INCREMENTAL_ACCESS_INFO, ByRef pItemInfo As ITEM_INFO, ByRef ppAccessor As IUrlAccessor)
        Sub CloseAccessor(ByVal pAccessor As IUrlAccessor)
        Sub Shutdown()
    End Interface

    [InterfaceId("7789F0B2-B5B2-4722-8B65-5DBD150697A9")]
    [Description("Protocol Handler Interface")]
    [OleAutomation(False)]
    Interface ISearchProtocol2 Extends ISearchProtocol
        Sub CreateAccessorEx(ByVal pcwszURL As LongPtr, ByRef pAuthenticationInfo As AUTHENTICATION_INFO, ByRef pIncrementalAccessInfo As INCREMENTAL_ACCESS_INFO, ByRef pItemInfo As ITEM_INFO, ByRef pUserData As BLOB, ByRef ppAccessor As IUrlAccessor)
    End Interface

    [InterfaceId("0B63E385-9CCC-11D0-BCDB-00805FCCCE04")]
    [Description("Protocol Handler Site Interface")]
    [OleAutomation(False)]
    Interface IProtocolHandlerSite Extends stdole.IUnknown
        Sub GetFilter(ByRef pclsidObj As UUID, ByVal pcwszContentType As LongPtr, ByVal pcwszExtension As LongPtr, ByRef ppFilter As IFilter)
    End Interface

    [InterfaceId("04C18CCF-1F57-4CBD-88CC-3900F5195CE3")]
    [OleAutomation(False)]
    Interface ISearchRoot Extends stdole.IUnknown
        Property Let Schedule(ByVal pszTaskArg As LongPtr)
        Property Get Schedule() As LongPtr
        Property Let RootURL(ByVal pszURL As LongPtr)
        Property Get RootURL() As LongPtr
        Property Let IsHierarchical(ByVal fIsHierarchical As BOOL)
        Property Get IsHierarchical() As BOOL
        Property Let ProvidesNotifications(ByVal fProvidesNotifications As BOOL)
        Property Get ProvidesNotifications() As BOOL
        Property Let UseNotificationsOnly(ByVal fUseNotificationsOnly As BOOL)
        Property Get UseNotificationsOnly() As BOOL
        Property Let EnumerationDepth(ByVal dwDepth As Long)
        Property Get EnumerationDepth() As Long
        Property Let HostDepth(ByVal dwDepth As Long)
        Property Get HostDepth() As Long
        Property Let FollowDirectories(ByVal fFollowDirectories As BOOL)
        Property Get FollowDirectories() As BOOL
        Property Let AuthenticationType(ByVal pAuthType As AUTH_TYPE)
        Property Get AuthenticationType() As AUTH_TYPE
        Property Let User(ByVal pszUser As LongPtr)
        Property Get User() As LongPtr
        Property Let Password(ByVal pszPassword As LongPtr)
        Property Get Password() As LongPtr
    End Interface

    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF52")]
    [OleAutomation(False)]
    Interface IEnumSearchRoots Extends stdole.IUnknown
        Sub Next(ByVal celt As Long, ByRef rgelt As ISearchRoot, ByRef pceltFetched As Long)
        Sub Skip(ByVal celt As Long)
        Sub Reset()
        Function Clone() As IEnumSearchRoots
    End Interface
    
    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF53")]
    [OleAutomation(False)]
    Interface ISearchScopeRule Extends stdole.IUnknown
        Property Get PatternOrURL() As LongPtr
        Property Get IsIncluded() As Long
        Property Get IsDefault() As Long
        Property Get FollowFlags() As Long
    End Interface

    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF54")]
    [OleAutomation(False)]
    Interface IEnumSearchScopeRules Extends stdole.IUnknown
        Sub Next(ByVal celt As Long, ByRef pprgelt As ISearchScopeRule, ByRef pceltFetched As Long)
        Sub Skip(ByVal celt As Long)
        Sub Reset()
        Function Clone() As IEnumSearchScopeRules
    End Interface
    
    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF55")]
    [OleAutomation(False)]
    Interface ISearchCrawlScopeManager Extends stdole.IUnknown
        Sub AddDefaultScopeRule(ByVal pszUrl As LongPtr, ByVal fInclude As BOOL, ByVal fFollowFlags As Long)
        Sub AddRoot(ByVal pSearchRoot As ISearchRoot)
        Sub RemoveRoot(ByVal pszUrl As LongPtr)
        Function EnumerateRoots() As IEnumSearchRoots
        Sub AddHierarchicalScope(ByVal pszUrl As LongPtr, ByVal fInclude As BOOL, ByVal fDefault As BOOL, ByVal fOverrideChildren As BOOL)
        Sub AddUserScopeRule(ByVal pszUrl As LongPtr, ByVal fInclude As BOOL, ByVal fOverrideChildren As BOOL, ByVal fFollowFlags As Long)
        Sub RemoveScopeRule(ByVal pszRule As LongPtr)
        Function EnumerateScopeRules() As IEnumSearchScopeRules
        Function HasParentScopeRule(ByVal pszUrl As LongPtr) As BOOL
        Function HasChildScopeRule(ByVal pszUrl As LongPtr) As BOOL
        Function IncludedInCrawlScope(ByVal pszUrl As LongPtr) As BOOL
        Sub IncludedInCrawlScopeEx(ByVal pszUrl As LongPtr, ByRef pfIsIncluded As BOOL, ByRef pReason As CLUSION_REASON)
        Sub RevertToDefaultScopes()
        Sub SaveAll()
        Function GetParentScopeVersionId(ByVal pszUrl As LongPtr) As Long
        Sub RemoveDefaultScopeRule(ByVal pszUrl As LongPtr)
    End Interface

    [InterfaceId("6292F7AD-4E19-4717-A534-8FC22BCD5CCD")]
    [OleAutomation(False)]
    Interface ISearchCrawlScopeManager2 Extends ISearchCrawlScopeManager
        Sub GetVersion(ByRef plVersion As Long, ByRef phFileMapping As LongPtr)
    End Interface
    
    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF58")]
    [OleAutomation(False)]
    Interface ISearchItemsChangedSink Extends stdole.IUnknown
        Sub StartedMonitoringScope(ByVal pszUrl As LongPtr)
        Sub StoppedMonitoringScope(ByVal pszUrl As LongPtr)
        Sub OnItemsChanged(ByVal dwNumberOfChanges As Long, ByRef rgDataChangeEntries As SEARCH_ITEM_CHANGE, ByRef rgdwDocIds As Long, ByRef rghrCompletionCodes As Long)
    End Interface

    [InterfaceId("A2FFDF9B-4758-4F84-B729-DF81A1A0612F")]
    [OleAutomation(False)]
    Interface ISearchPersistentItemsChangedSink Extends stdole.IUnknown
        Sub StartedMonitoringScope(ByVal pszUrl As LongPtr)
        Sub StoppedMonitoringScope(ByVal pszUrl As LongPtr)
        Sub OnItemsChanged(ByVal dwNumberOfChanges As Long, ByRef DataChangeEntries As SEARCH_ITEM_PERSISTENT_CHANGE, ByRef hrCompletionCodes As Long)
    End Interface

    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF65")]
    [OleAutomation(False)]
    Interface ISearchViewChangedSink Extends stdole.IUnknown
        Sub OnChange(ByRef pdwDocID As Long, ByRef pChange As SEARCH_ITEM_CHANGE, ByRef pfInView As BOOL)
    End Interface
    
    [InterfaceId("B5702E61-E75C-4B64-82A1-6CB4F832FCCF")]
    [Description("Search Inline Notification Site Client Interface")]
    [OleAutomation(False)]
    Interface ISearchNotifyInlineSite Extends stdole.IUnknown
        Sub OnItemIndexedStatusChange(ByVal sipStatus As SEARCH_INDEXING_PHASE, ByVal dwNumEntries As Long, ByRef rgItemStatusEntries As SEARCH_ITEM_INDEXING_STATUS)
        Sub OnCatalogStatusChange(ByRef guidCatalogResetSignature As UUID, ByRef guidCheckPointSignature As UUID, ByVal dwLastCheckPointNumber As Long)
    End Interface

    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF50")]
    [OleAutomation(False)]
    Interface ISearchCatalogManager Extends stdole.IUnknown
        Property Get Name() As LongPtr
        Function GetParameter(ByVal pszName As LongPtr) As Variant
        Sub SetParameter(ByVal pszName As LongPtr, ByRef pValue As Variant)
        Sub GetCatalogStatus(ByRef pStatus As CatalogStatus, ByRef pPausedReason As CatalogPausedReason)
        Sub Reset()
        Sub Reindex()
        Sub ReindexMatchingURLs(ByVal pszPattern As LongPtr)
        Sub ReindexSearchRoot(ByVal pszRootURL As LongPtr)
        Property Let ConnectTimeout(ByVal pdwConnectTimeout As Long)
        Property Get ConnectTimeout() As Long
        Property Let DataTimeout(ByVal pdwDataTimeout As Long)
        Property Get DataTimeout() As Long
        Function NumberOfItems() As Long
        Sub NumberOfItemsToIndex(ByRef plIncrementalCount As Long, ByRef plNotificationQueue As Long, ByRef plHighPriorityQueue As Long)
        Function URLBeingIndexed() As LongPtr
        Function GetURLIndexingState(ByVal pszUrl As LongPtr) As Long
        Function GetPersistentItemsChangedSink() As ISearchPersistentItemsChangedSink
        Sub RegisterViewForNotification(ByVal pszView As LongPtr, ByVal pViewChangedSink As ISearchViewChangedSink, ByRef pdwCookie As Long)
        Sub GetItemsChangedSink(ByVal pISearchNotifyInlineSite As ISearchNotifyInlineSite, ByRef riid As UUID, ByRef ppv As Any, ByRef pGUIDCatalogResetSignature As UUID, ByRef pGUIDCheckPointSignature As UUID, ByRef pdwLastCheckPointNumber As Long)
        Sub UnregisterViewForNotification(ByVal dwCookie As Long)
        Sub SetExtensionClusion(ByVal pszExtension As LongPtr, ByVal fExclude As BOOL)
        Function EnumerateExcludedExtensions() As IEnumString
        Function GetQueryHelper() As ISearchQueryHelper
        Property Let DiacriticSensitivity(ByVal fDiacriticSensitive As BOOL)
        Property Get DiacriticSensitivity() As BOOL
        Function GetCrawlScopeManager() As ISearchCrawlScopeManager
    End Interface
    [InterfaceId("7AC3286D-4D1D-4817-84FC-C1C85E3AF0D9")]
    [OleAutomation(False)]
    Interface ISearchCatalogManager2 Extends ISearchCatalogManager
        Sub PrioritizeMatchingURLs(ByVal pszPattern As LongPtr, ByVal dwPrioritizeFlags As PRIORITIZE_FLAGS)
    End Interface
    
    
    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF63")]
    [OleAutomation(False)]
    Interface ISearchQueryHelper Extends stdole.IUnknown
        Property Get ConnectionString() As LongPtr
        Property Let QueryContentLocale(ByVal pLcid As Long)
        Property Get QueryContentLocale() As Long
        Property Let QueryKeywordLocale(ByVal pLcid As Long)
        Property Get QueryKeywordLocale() As Long
        Property Let QueryTermExpansion(ByVal pExpandTerms As SEARCH_TERM_EXPANSION)
        Property Get QueryTermExpansion() As SEARCH_TERM_EXPANSION
        Property Let QuerySyntax(ByVal pQuerySyntax As SEARCH_QUERY_SYNTAX)
        Property Get QuerySyntax() As SEARCH_QUERY_SYNTAX
        Property Let QueryContentProperties(ByVal pszContentProperties As LongPtr)
        Property Get QueryContentProperties() As LongPtr
        Property Let QuerySelectColumns(ByVal pszSelectColumns As LongPtr)
        Property Get QuerySelectColumns() As LongPtr
        Property Let QueryWhereRestrictions(ByVal pszRestrictions As LongPtr)
        Property Get QueryWhereRestrictions() As LongPtr
        Property Let QuerySorting(ByVal pszSorting As LongPtr)
        Property Get QuerySorting() As LongPtr
        Function GenerateSQLFromUserQuery(ByVal pszQuery As LongPtr) As LongPtr
        Sub WriteProperties(ByVal itemID As Long, ByVal dwNumberOfColumns As Long, ByRef pColumns As PROPERTYKEY, ByRef pValues As SEARCH_COLUMN_PROPERTIES, ByRef pftGatherModifiedTime As FILETIME)
        Property Let QueryMaxResults(ByVal pcMaxResults As Long)
        Property Get QueryMaxResults() As Long
    End Interface
    
    [InterfaceId("42811652-079D-481B-87A2-09A69ECC5F44")]
    [OleAutomation(False)]
    Interface IRowsetPrioritization Extends stdole.IUnknown
        Sub SetScopePriority(ByVal Priority As PRIORITY_LEVEL, ByVal scopeStatisticsEventFrequency As Long)
        Sub GetScopePriority(ByRef Priority As PRIORITY_LEVEL, ByRef scopeStatisticsEventFrequency As Long)
        Sub GetScopeStatistics(ByRef indexedDocumentCount As Long, ByRef oustandingAddCount As Long, ByRef oustandingModifyCount As Long)
    End Interface
    
    [InterfaceId("1551AEA5-5D66-4B11-86F5-D5634CB211B9")]
    [OleAutomation(False)]
    Interface IRowsetEvents Extends stdole.IUnknown
        Sub OnNewItem(ByRef itemID As Variant, ByVal newItemState As ROWSETEVENT_ITEMSTATE)
        Sub OnChangedItem(ByRef itemID As Variant, ByVal rowsetItemState As ROWSETEVENT_ITEMSTATE, ByVal changedItemState As ROWSETEVENT_ITEMSTATE)
        Sub OnDeletedItem(ByRef itemID As Variant, ByVal deletedItemState As ROWSETEVENT_ITEMSTATE)
        Sub OnRowsetEvent(ByVal eventType As ROWSETEVENT_TYPE, ByRef EventData As Variant)
    End Interface

    [InterfaceId("AB310581-AC80-11D1-8DF3-00C04FB6EF69")]
    [OleAutomation(False)]
    Interface ISearchManager Extends stdole.IUnknown
        Sub GetIndexerVersionStr(ByRef ppszVersionString As LongPtr)
        Sub GetIndexerVersion(ByRef pdwMajor As Long, ByRef pdwMinor As Long)
        Function GetParameter(ByVal pszName As LongPtr) As Variant
        Sub SetParameter(ByVal pszName As LongPtr, ByRef pValue As Variant)
        Property Get ProxyName() As LongPtr
        Property Get BypassList() As LongPtr
        Sub SetProxy(ByVal sUseProxy As PROXY_ACCESS, ByVal fLocalByPassProxy As Long, ByVal dwPortNumber As Long, ByVal pszProxyName As LongPtr, ByVal pszByPassList As LongPtr)
        Function GetCatalog(ByVal pszCatalog As LongPtr) As ISearchCatalogManager
        Property Get UserAgent() As LongPtr
        Property Let UserAgent(ByVal pszUserAgent As LongPtr)
        Property Get UseProxy() As PROXY_ACCESS
        Property Get LocalBypass() As Long
        Property Get PortNumber() As Long
    End Interface

    [InterfaceId("DBAB3F73-DB19-4A79-BFC0-A61A93886DDF")]
    [OleAutomation(False)]
    Interface ISearchManager2 Extends ISearchManager
        Sub CreateCatalog(ByVal pszCatalog As LongPtr, ByRef ppCatalogManager As ISearchCatalogManager)
        Sub DeleteCatalog(ByVal pszCatalog As LongPtr)
    End Interface

    [InterfaceId("24C3CBAA-EBC1-491A-9EF1-9F6D8DEB1B8F")]
    [OleAutomation(False)]
    Interface ISearchLanguageSupport Extends stdole.IUnknown
        Sub SetDiacriticSensitivity(ByVal fDiacriticSensitive As Long)
        Function GetDiacriticSensitivity() As Long
        Sub LoadWordBreaker(ByVal lcid As Long, ByRef riid As UUID, ByRef ppWordBreaker As Any, ByRef pLcidUsed As Long)
        Sub LoadStemmer(ByVal lcid As Long, ByRef riid As UUID, ByRef ppStemmer As Any, ByRef pLcidUsed As Long)
        Sub IsPrefixNormalized(ByVal pwcsQueryToken As LongPtr, ByVal cwcQueryToken As Long, ByVal pwcsDocumentToken As Long, ByVal cwcDocumentToken As Long, ByRef pulPrefixLength As Long)
    End Interface
    
    [InterfaceId("CC906FF0-C058-101A-B554-08002B33B0E6")]
    [OleAutomation(False)]
    Interface IPhraseSink Extends stdole.IUnknown
    	Sub PutSmallPhrase(ByVal pwcNoun As LongPtr, ByVal cwcNoun As Long, ByVal pwcModifier As LongPtr, ByVal cwcModifier As Long, ByVal ulAttachmentType As Long)
        Sub PutPhrase(ByVal pwcPhrase As LongPtr, ByVal cwcPhrase As Long)
    End Interface
    
    [InterfaceId("CC907054-C058-101A-B554-08002B33B0E6")]
    [OleAutomation(False)]
    Interface IWordSink Extends stdole.IUnknown
    	Sub PutWord(ByVal cwc As Long, ByVal pwcInBuf As LongPtr, ByVal cwcSrcLen As Long, ByVal cwcSrcPos As Long)
        Sub PutAltWord(ByVal cwc As Long, ByVal pwcInBuf As LongPtr, ByVal cwcSrcLen As Long, ByVal cwcSrcPos As Long)
        Sub StartAltPhrase()
        Sub EndAltPhrase()
        Sub PutBreak(ByVal breakType As WORDREP_BREAK_TYPE)
    End Interface
    
    [InterfaceId("D53552C8-77E3-101A-B552-08002B33B0E6")]
    [OleAutomation(False)]
    Interface IWordBreaker Extends stdole.IUnknown
    	Sub Init(ByVal fQuery As Long, ByVal ulMaxTokenSize As Long, pfLicense As Long)
        Sub BreakText(pTextSource As TEXT_SOURCE, ByVal pWordSink As IWordSink, ByVal pPhraseSink As IPhraseSink)
        Sub ComposePhrase(ByVal pwcNoun As LongPtr, ByVal cwcNoun As LongPtr, ByVal pwcModifier As LongPtr, ByVal cwcModifier As Long, ByVal ulAttachmentType As Long, pwcPhrase As LongPtr, pcwcPhrase As Long)
        Sub GetLicenseToUse(ppwcsLicene As LongPtr)
    End Interface
    
    [InterfaceId("fe77c330-7f42-11ce-be57-00aa0051fe20")]
    [OleAutomation(False)]
    Interface IWordFormSink Extends stdole.IUnknown
    	Sub PutAltWord(ByVal pwcInBuf As LongPtr, ByVal cwc As Long)
        Sub PutWord(ByVal pwcInBuf As LongPtr, ByVal cwc As Long)
    End Interface
    
    [InterfaceId("efbaf140-7f42-11ce-be57-00aa0051fe20")]
    [OleAutomation(False)]
    Interface IStemmer Extends stdole.IUnknown
    	Sub Init(ByVal ulMaxTokenSize As Long, pfLicense As Long)
        Sub GenerateWordForms(ByVal pwcInBuf As LongPtr, ByVal cwc As Long, ByVal pStemSink As IWordFormSink)
        Sub GetLicenseToUse(ppwcsLicene As LongPtr)
    End Interface
    
    'CLSID_ConditionFactory 
    [CoClassId("E03E85B0-7BE3-4000-BA98-6C13DE9FA486")]
    CoClass ConditionFactory
        [Default] Interface IConditionFactory
    End CoClass
    'CLSID_SearchFolderItemFactory 
    [CoClassId("14010e02-bbbd-41f0-88e3-eda371216584")]
    CoClass SearchFolderItemFactory
        [Default] Interface ISearchFolderItemFactory
    End CoClass
    'CLSID_QueryParserManager 
    [CoClassId("5088B39A-29B4-4d9d-8245-4EE289222F66")]
    CoClass QueryParserManager
        [Default] Interface IQueryParserManager
    End CoClass
    'CLSID_QueryParser 
    [CoClassId("B72F8FD8-0FAB-4dd9-BDBF-245A6CE1485B")]
    CoClass QueryParser
        [Default] Interface IQueryParser
    End CoClass
    'CLSID_NegationCondition 
    [CoClassId("8DE9C74C-605A-4acd-BEE3-2B222AA2D23D")]
    CoClass NegationCondition
        [Default] Interface ICondition
    End CoClass
    'CLSID_CompoundCondition 
    [CoClassId("116F8D13-101E-4fa5-84D4-FF8279381935")]
    CoClass CompoundCondition
        [Default] Interface ICondition
    End CoClass
    'CLSID_LeafCondition 
    [CoClassId("52F15C89-5A17-48e1-BBCD-46A3F89C7CC2")]
    CoClass LeafCondition
        [Default] Interface ICondition
    End CoClass
    'CLSID_Interval 
    [CoClassId("D957171F-4BF9-4de2-BCD5-C70A7CA55836")]
    CoClass Interval
        [Default] Interface IInterval
    End CoClass
        
    [CoClassId("7D096C5F-AC08-4F1F-BEB7-5C22C517CE39")]
    [COMCreatable]
    [Description("ISearchManager Implementation Class")]
    CoClass CSearchManager
        [Default] Interface ISearchManager
    End CoClass

    [CoClassId("30766BD2-EA1C-4F28-BF27-0B44E2F68DB7")]
    [COMCreatable]
    [Description("ISearchRoot Implementation Class")]
    CoClass CSearchRoot
        [Default] Interface ISearchRoot
    End CoClass

    [CoClassId("E63DE750-3BD7-4BE5-9C84-6B4281988C44")]
    [COMCreatable]
    [Description("ISearchScopeRule Implementation Class")]
    CoClass CSearchScopeRule
        [Default] Interface ISearchScopeRule
    End CoClass

    [CoClassId("9E175B8D-F52A-11D8-B9A5-505054503030")]
    [COMCreatable]
    CoClass FilterRegistration
        [Default] Interface ILoadFilter
        Interface ILoadFilterWithPrivateComActivation
    End CoClass
    
Module wdSearch
	
Public Type TEXT_SOURCE
	pfnFillTextBuffer As LongPtr
	awcBuffer As LongPtr
	iEnd As Long
	iCur As Long
End Type


Public Enum WORDREP_BREAK_TYPE
	WORDREP_BREAK_EOW = 0
	WORDREP_BREAK_EOS = 1
	WORDREP_BREAK_EOP = 2
	WORDREP_BREAK_EOC = 3
End Enum

Public Enum STRUCTURED_QUERY_RESOLVE_OPTION
	SQRO_DEFAULT = &H00000000 ' None of the below.
	SQRO_DONT_RESOLVE_DATETIME = &H00000001
	SQRO_ALWAYS_ONE_INTERVAL = &H00000002
	SQRO_DONT_SIMPLIFY_CONDITION_TREES = &H00000004
	SQRO_DONT_MAP_RELATIONS = &H00000008
	SQRO_DONT_RESOLVE_RANGES = &H00000010
	SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS = &H00000020 ' An unrestricted keyword is a keyword that is not associated with a value to make a real condition.
	SQRO_DONT_SPLIT_WORDS = &H00000040 ' If this flag is set, groups of words that are not separated by whitespace
	'  will be kept together and it is up to the consumer of the parse result to do any
	'  additional separation. (Note that it is possible through this interface to obtain
	'  how the input string was broken into words as well as the word breaker used.)
	'  If this flag is not set, then each word will end up in a separate condition tree node.
	SQRO_IGNORE_PHRASE_ORDER = &H00000080 ' If this flag is set, a full-text query for a phrase will disregard the order of the words in the phrase.
                                        ' In this case, the query from:"foo bar" will behave like from:(foo bar).
	SQRO_ADD_VALUE_TYPE_FOR_PLAIN_VALUES = &H00000100 ' Normally only unresolved named entities have a semantic type but this flag causes a semantic type
                                                        ' to be added for leaves with a numeric, Boolean, date/time or string value.
	SQRO_ADD_ROBUST_ITEM_NAME = &H00000200 ' Work around known issues in word breakers, adding conditions on PKEY_ItemNameDisplay as needed.
End Enum

Public Enum STRUCTURED_QUERY_SYNTAX
	SQS_NO_SYNTAX
	SQS_ADVANCED_QUERY_SYNTAX
	SQS_NATURAL_QUERY_SYNTAX
End Enum

Public Enum CONDITION_TYPE
	CT_AND_CONDITION   '// AND of subconditions
	CT_OR_CONDITION    '// OR of subconditions
	CT_NOT_CONDITION   '// NOT of a single subcondition
	CT_LEAF_CONDITION  '// No subcondition: property, operation, value.
End Enum

Public Enum CONDITION_CREATION_OPTIONS
	CONDITION_CREATION_DEFAULT = &H00000000
	CONDITION_CREATION_NONE = &H00000000
	CONDITION_CREATION_SIMPLIFY = &H00000001
	CONDITION_CREATION_VECTOR_AND = &H00000002
	CONDITION_CREATION_VECTOR_OR = &H00000004
	CONDITION_CREATION_VECTOR_LEAF = &H00000008
	CONDITION_CREATION_USE_CONTENT_LOCALE = &H00000010
End Enum

Public Enum STRUCTURED_QUERY_SINGLE_OPTION
	SQSO_SCHEMA ' The value should be VT_LPWSTR and the path to a file containing a schema binary.

	SQSO_LOCALE_WORD_BREAKING ' The value must be VT_EMPTY (the default) or a VT_UI4 that is an LCID. It is used
							   ' as the locale of contents (not keywords) in the query to be searched for, when no
							   ' other information is available. The default value is the current keyboard locale.
							   ' Retrieving the value always returns a VT_UI4.

	SQSO_WORD_BREAKER ' This option is used to override the default word breaker used when identifying keywords
							 ' in queries. The default word breaker is chosen according to the language of the keywords
							 ' (cf. SQSO_LANGUAGE_KEYWORDS below). When setting this option, the value should be VT_EMPTY
							 ' for using the default word breaker, or a VT_UNKNOWN with an object supporting
							 ' the IWordBreaker interface. Retrieving the option always returns a VT_UNKNOWN with an object
							 ' supporting the IWordBreaker interface.

	SQSO_NATURAL_SYNTAX ' The value should be VT_EMPTY or VT_BOOL with VARIANT_TRUE to allow natural query
							 ' syntax (the default) or VT_BOOL with VARIANT_FALSE to allow only advanced query syntax.
							 ' Retrieving the option always returns a VT_BOOL.
							 ' This option is now deprecated, use SQSO_SYNTAX.

	SQSO_AUTOMATIC_WILDCARD ' The value should be VT_BOOL with VARIANT_TRUE to generate query expressions
							 ' as if each word in the query had a star appended to it (unless followed by punctuation
							 ' other than a parenthesis), or VT_EMPTY or VT_BOOL with VARIANT_FALSE to
							 ' use the words as they are (the default). A word-wheeling application
							 ' will generally want to set this option to true.
							 ' Retrieving the option always returns a VT_BOOL.

	SQSO_TRACE_LEVEL ' Reserved. The value should be VT_EMPTY (the default) or VT_I4.
							 ' Retrieving the option always returns a VT_I4.

	SQSO_LANGUAGE_KEYWORDS ' The value must be a VT_UI4 that is a LANGID. It defaults to the default user UI language.

	SQSO_SYNTAX ' The value must be a VT_UI4 that is a STRUCTURED_QUERY_SYNTAX value.
							 ' It defaults to SQS_NATURAL_QUERY_SYNTAX.

	SQSO_TIME_ZONE ' The value must be a VT_BLOB that is a copy of a TIME_ZONE_INFORMATION structure.
							 ' It defaults to the current time zone.

	SQSO_IMPLICIT_CONNECTOR ' This setting decides what connector should be assumed between conditions when none is specified.
							 ' The value must be a VT_UI4 that is a CONDITION_TYPE. Only CT_AND_CONDITION and CT_OR_CONDITION
							 ' are valid. It defaults to CT_AND_CONDITION.

	SQSO_CONNECTOR_CASE ' This setting decides whether there are special requirements on the case of connector keywords (such
							 ' as AND or OR). The value must be a VT_UI4 that is a CASE_REQUIREMENT value.
							 ' It defaults to CASE_REQUIREMENT_UPPER_IF_AQS.
End Enum

Public Enum STRUCTURED_QUERY_MULTIOPTION
	SQMO_VIRTUAL_PROPERTY   ' The key should be property name P. The value should be a
							 ' VT_UNKNOWN with an IEnumVARIANT which has two values: a VT_BSTR that is another
							 ' property name Q and a VT_I4 that is a CONDITION_OPERATION cop. A predicate with
							 ' property name P, some operation and a value V will then be replaced by a predicate
							 ' with property name Q, operation cop and value V before further processing happens.

	SQMO_DEFAULT_PROPERTY   ' The key should be a value type name V. The value should be a
							 ' VT_LPWSTR with a property name P. A predicate with no property name and a value of type
							 ' V (or any subtype of V) will then use property P.

	SQMO_GENERATOR_FOR_TYPE ' The key should be a value type name V. The value should be a
							 ' VT_UNKNOWN with a IConditionGenerator G. The GenerateForLeaf method of
							 ' G will then be applied to any predicate with value type V and if it returns a query
							 ' expression, that will be used. If it returns NULL, normal processing will be used
							 ' instead.

	SQMO_MAP_PROPERTY       ' The key should be a property name P. The value should be a VT_VECTOR|VT_LPWSTR,
							 ' where each string is a property name. The count must be at least one. This "map" will be
							 ' added to those of the loaded schema and used during resolution. A second call with the
							 ' same key will replace the current map. If the value is VT_NULL, the map will be removed.
End Enum

Public Enum STRUCTURED_QUERY_PARSE_ERROR
	SQPE_NONE
	SQPE_EXTRA_OPENING_PARENTHESIS ' A spurious (
	SQPE_EXTRA_CLOSING_PARENTHESIS ' A spurious )
	SQPE_IGNORED_MODIFIER ' A spurious NOT, <, >=, etc.
	SQPE_IGNORED_CONNECTOR ' A spurious AND or OR.
	SQPE_IGNORED_KEYWORD ' A spurious property.
	SQPE_UNHANDLED ' Something else.
End Enum

Public Enum CASE_REQUIREMENT
	CASE_REQUIREMENT_ANY ' Keywords are recognized regardless of case.
	CASE_REQUIREMENT_UPPER_IF_AQS ' Keywords are recognized only if uppercase, when AQS is the syntax, regardless of case otherwise.
End Enum

Public Enum INTERVAL_LIMIT_KIND
	ILK_EXPLICIT_INCLUDED
	ILK_EXPLICIT_EXCLUDED
	ILK_NEGATIVE_INFINITY
	ILK_POSITIVE_INFINITY
End Enum

Public Enum QUERY_PARSER_MANAGER_OPTION
	QPMO_SCHEMA_BINARY_NAME                 ' The value must be VT_LPWSTR and be the name of the file containing a schema binary.
											 ' The default value depends on the catalog. For the SystemIndex catalog it is
											 ' "StructuredQuerySchema.bin".

	QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH     ' The value must be either a VT_BOOL or a VT_LPWSTR. If it is a VT_BOOL and the value
											 ' IS VARIANT_FALSE, a prelocalized schema binary path will not be used. If it is VARIANT_TRUE,
											 ' a default prelocalized schema binary path will be used, depending on the catalog.
											 ' If it is a VT_LPWSTR, the value should be a full folder part (though an LCID may be
											 ' appended to it according to the QPMO_APPEND_LCID_TO_LOCALIZED_PATH setting).
											 ' The default is VT_BOOL with VARIANT_TRUE; the actual path is
											 ' "%COMMONAPPDATA%\Microsoft\Windows" (note though that environment variables in the
											 ' given string will not be expanded).

	QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH      ' The value must be VT_LPWSTR and be the full path of a folder in which an unlocalized
											 ' schema binary resides and can be read.
											 ' The default value is the expansion of "%SYSTEMROOT%\System32" (note though
											 ' that environment variables in the given string will not be expanded).

	QPMO_LOCALIZED_SCHEMA_BINARY_PATH        ' The value must be VT_LPWSTR and be the full path of a folder in which a localized
											 ' schema binary can be read, or written as necessary.
											 ' The default value is "%LOCALAPPDATA%\Microsoft\Windows" (note though
											 ' that environment variables in the given string will not be expanded).

	QPMO_APPEND_LCID_TO_LOCALIZED_PATH       ' The value must be a VT_BOOL. If it is VARIANT_TRUE, then the path(s) for localized
											 ' binary will have "\<LCID>" appended to it, e.g., "\1042". The default is VARIANT_TRUE.

	QPMO_LOCALIZER_SUPPORT                   ' The value must be a VT_UNKNOWN with an object supporting ISchemaLocalizerSupport.
											 ' It will be used instead of the default localizer support object which expects "global"
											 ' mnemonics to be on the form "@foo.dll,-12345" and will return the resourec with ID 12345
End Enum

Public Enum NAMED_ENTITY_CERTAINTY
	NEC_LOW    '// It could be this named entity but additional evidence advisable.
	NEC_MEDIUM '// It quite likely is this named entity; it is OK to use it.
	NEC_HIGH   '// It almost certainly is this named entity; it should be ok to toss other possibilities.
End Enum


Public Type FULLPROPSPEC
	guidPropSet As UUID
	psProperty As PROPSPEC
End Type

Public Enum IFILTER_INIT
	IFILTER_INIT_CANON_PARAGRAPHS = 1
	IFILTER_INIT_HARD_LINE_BREAKS = 2
	IFILTER_INIT_CANON_HYPHENS = 4
	IFILTER_INIT_CANON_SPACES = 8
	IFILTER_INIT_APPLY_INDEX_ATTRIBUTES = 16
	IFILTER_INIT_APPLY_OTHER_ATTRIBUTES = 32
	IFILTER_INIT_APPLY_CRAWL_ATTRIBUTES = 256
	IFILTER_INIT_INDEXING_ONLY = 64
	IFILTER_INIT_SEARCH_LINKS = 128
	IFILTER_INIT_FILTER_OWNED_VALUE_OK = 512
	IFILTER_INIT_FILTER_AGGRESSIVE_BREAK = 1024
	IFILTER_INIT_DISABLE_EMBEDDED = 2048
	IFILTER_INIT_EMIT_FORMATTING = 4096
End Enum

Public Enum IFILTER_FLAGS
	IFILTER_FLAGS_OLE_PROPERTIES = 1
End Enum

Public Enum CHUNKSTATE
	CHUNK_TEXT = &H1
	CHUNK_VALUE = &H2
	CHUNK_FILTER_OWNED_VALUE = &H4
End Enum

Public Enum CHUNK_BREAKTYPE
	CHUNK_NO_BREAK = 0
	CHUNK_EOW = 1
	CHUNK_EOS = 2
	CHUNK_EOP = 3
	CHUNK_EOC = 4
End Enum

Public Type FILTERREGION
	idChunk As Long
	cwcStart As Long
	cwcExtent As Long
End Type

Public Type STAT_CHUNK
	idChunk As Long
	breakType As CHUNK_BREAKTYPE
	flags As CHUNKSTATE
	locale As Long
	attribute As FULLPROPSPEC
	idChunkSource As Long
	cwcStartSource As Long
	cwcLenSource As Long
End Type

Public Type FILTERED_DATA_SOURCES
	pwcsExtension As LongPtr ' file extension
	pwcsMime As LongPtr ' mime type string
	pClsid As LongPtr
	pwcsOverride As LongPtr
End Type

Public Type BLOB
	cbSize As Long
	pBlobData As LongPtr
End Type


[PackingAlignment(8)]
Public Type TIMEOUT_INFO
	dwSize As Long '  Actual size of structure (bytes)
	dwConnectTimeout As Long '  Timeout for connection (seconds)
	dwDataTimeout As Long '  Timeout for data (seconds)
End Type

Public Enum PROXY_ACCESS
	PROXY_ACCESS_PRECONFIG = 0
	PROXY_ACCESS_DIRECT = 1
	PROXY_ACCESS_PROXY = 2
End Enum

[PackingAlignment(8)]
Public Type PROXY_INFO
	dwSize As Long '  Actual size of structure (bytes)
	pcwszUserAgent As LongPtr '
	paUseProxy As PROXY_ACCESS '
	fLocalBypass As Long '  Bypass proxy for local address
	dwPortNumber As Long
	pcwszProxyName As LongPtr
	pcwszBypassList As LongPtr
End Type

Public Enum AUTH_TYPE
	eAUTH_TYPE_ANONYMOUS = 0
	eAUTH_TYPE_NTLM = 1
	eAUTH_TYPE_BASIC = 2
End Enum

[PackingAlignment(8)]
Public Type AUTHENTICATION_INFO
	dwSize As Long '  Actual size of structure (bytes)
	atAuthenticationType As AUTH_TYPE '  Anonymous, Basic, or NTLM
	pcwszUser As LongPtr
	pcwszPassword As LongPtr
End Type

[PackingAlignment(8)]
Public Type INCREMENTAL_ACCESS_INFO
	dwSize As Long '  Actual size of structure (bytes)
	ftLastModifiedTime As FILETIME
End Type

[PackingAlignment(8)]
Public Type ITEM_INFO
	dwSize As Long '  Actual size of structure (bytes)
	pcwszFromEMail As LongPtr
	pcwszApplicationName As LongPtr
	pcwszCatalogName As LongPtr
	pcwszContentClass As LongPtr
End Type

Public Enum FOLLOW_FLAGS
	' 
	'  Whether or not to index complex URLs (contains '?')
	' 
	FF_INDEXCOMPLEXURLS = &H00000001
	' 
	'  Suppress indexing this URL (i.e., follow but do not index)
	' 
	FF_SUPPRESSINDEXING = &H00000002
End Enum

Public Enum CLUSION_REASON
	' 
	'  By unknown scope - i.e., there is no scope that would include or
	'  exclude this URL so it is by default excluded
	' 
	CLUSIONREASON_UNKNOWNSCOPE = 0
	' 
	'  By default rule
	' 
	CLUSIONREASON_DEFAULT = 1
	' 
	'  By a user rule
	' 
	CLUSIONREASON_USER = 2
	' 
	'  By group policy
	' 
	CLUSIONREASON_GROUPPOLICY = 3
End Enum

Public Enum SEARCH_KIND_OF_CHANGE
	SEARCH_CHANGE_ADD = 0
	SEARCH_CHANGE_DELETE = 1
	SEARCH_CHANGE_MODIFY = 2
	' 
	'  Item has been moved or renamed
	' 
	SEARCH_CHANGE_MOVE_RENAME = 3
	' 
	'  This is a directory--optimization since crawl needs to define it
	' 
	SEARCH_CHANGE_SEMANTICS_DIRECTORY = &H40000
	' 
	'  Only index directory properties
	' 
	SEARCH_CHANGE_SEMANTICS_SHALLOW = &H80000
	' 
	'  Update security only--optimization
	' 
	SEARCH_CHANGE_SEMANTICS_UPDATE_SECURITY = &H400000
End Enum

Public Enum SEARCH_NOTIFICATION_PRIORITY
	SEARCH_NORMAL_PRIORITY = 0
	SEARCH_HIGH_PRIORITY = 1
End Enum

Public Type SEARCH_ITEM_CHANGE
	Change As SEARCH_KIND_OF_CHANGE
	' High priority is done before normal priority is done before incrementals
	Priority As SEARCH_NOTIFICATION_PRIORITY
	pUserData As LongPtr
	lpwszURL As LongPtr
	lpwszOldURL As LongPtr 'valid only for moves
End Type

Public Type SEARCH_ITEM_PERSISTENT_CHANGE
	Change As SEARCH_KIND_OF_CHANGE
	URL As LongPtr
	OldURL As LongPtr 'valid only for moves
	' High priority is done before normal priority is done before incrementals
	Priority As SEARCH_NOTIFICATION_PRIORITY
End Type

Public Enum SEARCH_INDEXING_PHASE
	SEARCH_INDEXING_PHASE_GATHERER = 0
	SEARCH_INDEXING_PHASE_QUERYABLE = 1
	SEARCH_INDEXING_PHASE_PERSISTED = 2
End Enum

Public Type SEARCH_ITEM_INDEXING_STATUS
	dwDocID As Long
	hrIndexingStatus As Long
End Type

Public Enum CatalogStatus
	' 
	'  No indexing is needed
	' 
	CATALOG_STATUS_IDLE = 0
	' 
	'  Indexer is paused, queries are still OK
	' 
	CATALOG_STATUS_PAUSED = 1
	' 
	'  Indexer is recovering--no indexing or querying
	' 
	CATALOG_STATUS_RECOVERING = 2
	' 
	'  Indexer is doing a full crawl and indexing everything
	' 
	CATALOG_STATUS_FULL_CRAWL = 3
	' 
	'  Indexer is checking to see if anything needs to be indexed because it has changed
	' 
	CATALOG_STATUS_INCREMENTAL_CRAWL = 4
	' 
	'  Indexer is processing notification queue which is done before resuming any crawl.
	' 
	CATALOG_STATUS_PROCESSING_NOTIFICATIONS = 5
	' 
	'  Indexer is shutting down and is not indexing and can't be queried.
	' 
	CATALOG_STATUS_SHUTTING_DOWN = 6
End Enum

Public Enum CatalogPausedReason
	' 
	'  Not paused
	' 
	CATALOG_PAUSED_REASON_NONE = 0
	' 
	'  Paused due to high I/O
	' 
	CATALOG_PAUSED_REASON_HIGH_IO = 1
	' 
	'  Paused due to high CPU usage
	' 
	CATALOG_PAUSED_REASON_HIGH_CPU = 2
	' 
	'  Paused due to high NTF rate
	' 
	CATALOG_PAUSED_REASON_HIGH_NTF_RATE = 3
	' 
	'  Paused due to low battery
	' 
	CATALOG_PAUSED_REASON_LOW_BATTERY = 4
	' 
	'  Paused due to low memory
	' 
	CATALOG_PAUSED_REASON_LOW_MEMORY = 5
	' 
	'  Paused due to low disk space
	' 
	CATALOG_PAUSED_REASON_LOW_DISK = 6
	' 
	'  Paused due to need for delayed recovery
	' 
	CATALOG_PAUSED_REASON_DELAYED_RECOVERY = 7
	' 
	'  Paused due to user activity on the machine
	' 
	CATALOG_PAUSED_REASON_USER_ACTIVE = 8
	' 
	'  Paused by external request
	' 
	CATALOG_PAUSED_REASON_EXTERNAL = 9
	' 
	'  Paused by upgrading
	' 
	CATALOG_PAUSED_REASON_UPGRADING = 10
End Enum

Public Enum PRIORITIZE_FLAGS
	'  In prioritization, kick off a retry of items that have failed indexing with the
	'  requested pattern.
	PRIORITIZE_FLAG_RETRYFAILEDITEMS = &H00000001
	'  Valid only in combination with PRIORITIZE_FLAG_RETRYFAILEDITEMS.
	'  Normally, items are no longer retried after a series of failed indexing attempts.
	'  This flag indicates that those items should also be re-attempted.
	PRIORITIZE_FLAG_IGNOREFAILURECOUNT = &H00000002
End Enum

Public Enum SEARCH_TERM_EXPANSION
	'  No Expansion
	SEARCH_TERM_NO_EXPANSION = 0
	'  All search terms become <term>*
	SEARCH_TERM_PREFIX_ALL = 1
	'  Stem expansion is applied to all terms
	SEARCH_TERM_STEM_ALL = 2
End Enum

Public Enum SEARCH_QUERY_SYNTAX
	'  No query syntax in user input
	SEARCH_NO_QUERY_SYNTAX = 0
	'  Understand AQS (from:chris)
	SEARCH_ADVANCED_QUERY_SYNTAX = 1
	'  Understand NQS (mail from chris) in addition to AQS.
	'  NOTE: This is not enough to allow a semantic canvas.  For
	'  that I think people either have to host our query control
	'  or go to SemThing directly.
	SEARCH_NATURAL_QUERY_SYNTAX = 2
End Enum

Public Type SEARCH_COLUMN_PROPERTIES
	Value As Variant
	lcid As Long
End Type

Public Enum PRIORITY_LEVEL
	PRIORITY_LEVEL_FOREGROUND = 0 ' process items in the scope first as quickly as possible
	PRIORITY_LEVEL_HIGH = 1 ' process items in the scope first at the normal rate
	PRIORITY_LEVEL_LOW = 2 ' process items in this scope before those at the normal rate, but after any other prioritization requests
	PRIORITY_LEVEL_DEFAULT = 3 ' process items at the normal indexer rate
End Enum

Public Enum ROWSETEVENT_ITEMSTATE
	ROWSETEVENT_ITEMSTATE_NOTINROWSET = 0 ' The item is definitely not in the rowset
	ROWSETEVENT_ITEMSTATE_INROWSET = 1 ' The item is definitely contained within the rowset
	ROWSETEVENT_ITEMSTATE_UNKNOWN = 2 ' The item MAY be in the rowset
End Enum

Public Enum ROWSETEVENT_TYPE
	ROWSETEVENT_TYPE_DATAEXPIRED = 0 ' Sent when the data backing the rowset has expired.  A new rowset should be requested
	ROWSETEVENT_TYPE_FOREGROUNDLOST = 1 ' Sent when a request for foreground prioritization has been automatically downgraded to high
	ROWSETEVENT_TYPE_SCOPESTATISTICS = 2 ' Sent on an interval of roughly scopeStatisticsEventFrequency when there is a statistics change. Also sent once when all stats go to zero.
End Enum

Public Const sCLSID_ConditionFactory = "new: {E03E85B0-7BE3-4000-BA98-6C13DE9FA486}"
Public Const sCLSID_SearchFolderItemFactory = "new: {14010e02-bbbd-41f0-88e3-eda371216584}"
Public Const sCLSID_QueryParserManager = "new: {5088B39A-29B4-4d9d-8245-4EE289222F66}"
Public Const sCLSID_QueryParser = "new: {B72F8FD8-0FAB-4dd9-BDBF-245A6CE1485B}"
Public Const sCLSID_NegationCondition = "new: {8DE9C74C-605A-4acd-BEE3-2B222AA2D23D}"
Public Const sCLSID_CompoundCondition = "new: {116F8D13-101E-4fa5-84D4-FF8279381935}"
Public Const sCLSID_LeafCondition = "new: {52F15C89-5A17-48e1-BBCD-46A3F89C7CC2}"
Public Const sCLSID_Interval = "new: {D957171F-4BF9-4de2-BCD5-C70A7CA55836}"

Public Const sCLSID_CSearchManager = "new: {7D096C5F-AC08-4F1F-BEB7-5C22C517CE39}"
Public Const sCLSID_CSearchRoot = "new: {30766BD2-EA1C-4F28-BF27-0B44E2F68DB7}"
Public Const sCLSID_CSearchScopeRule = "new: {E63DE750-3BD7-4BE5-9C84-6B4281988C44}"
Public Const sCLSID_FilterRegistration = "new: {9E175B8D-F52A-11D8-B9A5-505054503030}"

    Public Function CLSID_ConditionFactory() As UUID
    '{E03E85B0-7BE3-4000-BA98-6C13DE9FA486}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE03E85B0, CInt(&H7BE3), CInt(&H4000), &HBA, &H98, &H6C, &H13, &HDE, &H9F, &HA4, &H86)
     CLSID_ConditionFactory = iid
    End Function
    Public Function CLSID_SearchFolderItemFactory() As UUID
    '{14010e02-bbbd-41f0-88e3-eda371216584}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H14010e02, CInt(&Hbbbd), CInt(&H41f0), &H88, &He3, &Hed, &Ha3, &H71, &H21, &H65, &H84)
     CLSID_SearchFolderItemFactory = iid
    End Function
    Public Function CLSID_QueryParserManager() As UUID
    '{5088B39A-29B4-4d9d-8245-4EE289222F66}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H5088B39A, CInt(&H29B4), CInt(&H4d9d), &H82, &H45, &H4E, &HE2, &H89, &H22, &H2F, &H66)
     CLSID_QueryParserManager = iid
    End Function
    Public Function CLSID_QueryParser() As UUID
    '{B72F8FD8-0FAB-4dd9-BDBF-245A6CE1485B}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HB72F8FD8, CInt(&H0FAB), CInt(&H4dd9), &HBD, &HBF, &H24, &H5A, &H6C, &HE1, &H48, &H5B)
     CLSID_QueryParser = iid
    End Function
    Public Function CLSID_NegationCondition() As UUID
    '{8DE9C74C-605A-4acd-BEE3-2B222AA2D23D}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H8DE9C74C, CInt(&H605A), CInt(&H4acd), &HBE, &HE3, &H2B, &H22, &H2A, &HA2, &HD2, &H3D)
     CLSID_NegationCondition = iid
    End Function
    Public Function CLSID_CompoundCondition() As UUID
    '{116F8D13-101E-4fa5-84D4-FF8279381935}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H116F8D13, CInt(&H101E), CInt(&H4fa5), &H84, &HD4, &HFF, &H82, &H79, &H38, &H19, &H35)
     CLSID_CompoundCondition = iid
    End Function
    Public Function CLSID_LeafCondition() As UUID
    '{52F15C89-5A17-48e1-BBCD-46A3F89C7CC2}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H52F15C89, CInt(&H5A17), CInt(&H48e1), &HBB, &HCD, &H46, &HA3, &HF8, &H9C, &H7C, &HC2)
     CLSID_LeafCondition = iid
    End Function
    Public Function CLSID_Interval() As UUID
    '{D957171F-4BF9-4de2-BCD5-C70A7CA55836}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HD957171F, CInt(&H4BF9), CInt(&H4de2), &HBC, &HD5, &HC7, &H0A, &H7C, &HA5, &H58, &H36)
     CLSID_Interval = iid
    End Function
    Public Function CLSID_CSearchManager() As UUID
    '{7D096C5F-AC08-4F1F-BEB7-5C22C517CE39}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H7D096C5F, CInt(&HAC08), CInt(&H4F1F), &HBE, &HB7, &H5C, &H22, &HC5, &H17, &HCE, &H39)
     CLSID_CSearchManager = iid
    End Function
    Public Function CLSID_CSearchRoot() As UUID
    '{30766BD2-EA1C-4F28-BF27-0B44E2F68DB7}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H30766BD2, CInt(&HEA1C), CInt(&H4F28), &HBF, &H27, &H0B, &H44, &HE2, &HF6, &H8D, &HB7)
     CLSID_CSearchRoot = iid
    End Function
    Public Function CLSID_CSearchScopeRule() As UUID
    '{E63DE750-3BD7-4BE5-9C84-6B4281988C44}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HE63DE750, CInt(&H3BD7), CInt(&H4BE5), &H9C, &H84, &H6B, &H42, &H81, &H98, &H8C, &H44)
     CLSID_CSearchScopeRule = iid
    End Function
    Public Function CLSID_FilterRegistration() As UUID
    '{9E175B8D-F52A-11D8-B9A5-505054503030}
    Static iid As UUID
     If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H9E175B8D, CInt(&HF52A), CInt(&H11D8), &HB9, &HA5, &H50, &H50, &H54, &H50, &H30, &H30)
     CLSID_FilterRegistration = iid
    End Function

#If WINDEVLIB_LITE = 0 Then
'NTQuery.h

Public Const CI_VERSION_WDS30  = &H102  ' 258
Public Const CI_VERSION_WDS40  = &H109  ' 265
Public Const CI_VERSION_WIN70  = &H700  ' 1792
'  Use this path for the null catalog, one that doesn't have an index.
'  Use it to search for properties of files that are not indexed.
Public Const CINULLCATALOG  = "::_noindex_::"
'  Use this path to connect to the server for administration work
'  (i.e. DocStoreAdmin.) No catalog is associated with the connection
Public Const CIADMIN  = "::_nodocstore_::"

[UseGetLastError(False)]
Public DeclareWide PtrSafe Function LoadIFilter Lib "Query.dll" (ByVal pwcsPath As String, ByVal pUnkOuter As IUnknown, ppIUnk As Any) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function LoadIFilter Lib "Query.dll" (ByVal pwcsPath As LongPtr, ByVal pUnkOuter As IUnknown, ppIUnk As Any) As Long

Public Enum LoadIFilterExFlags
    LIFF_LOAD_DEFINED_FILTER = 1
    LIFF_IMPLEMENT_TEXT_FILTER_FALLBACK_POLICY = 2
    LIFF_FORCE_TEXT_FILTER_FALLBACK = 3
End Enum

[UseGetLastError(False)]
Public DeclareWide PtrSafe Function LoadIFilterEx Lib "Query.dll" (ByVal pwcsPath As String, ByVal dwFlags As LoadIFilterExFlags, ByVal pUnkOuter As IUnknown, ppIUnk As Any) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function LoadIFilterEx Lib "Query.dll" (ByVal pwcsPath As LongPtr, ByVal dwFlags As LoadIFilterExFlags, ByVal pUnkOuter As IUnknown, ppIUnk As Any) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function BindIFilterFromStorage Lib "Query.dll" (ByVal pStg As IStorage, ByVal pUnkOuter As IUnknown, ppIUnk As Any) As Long
[UseGetLastError(False)]
Public Declare PtrSafe Function BindIFilterFromStream Lib "Query.dll" (ByVal pStg As IStream, ByVal pUnkOuter As IUnknown, ppIUnk As Any) As Long


Public Const PID_FILENAME = 100
Public Function CLSID_INDEX_SERVER_DSO() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HF9AE8980, &H7E52, &H11d0, &H89, &H64, &H00, &HC0, &H4F, &HD6, &H11, &HD7)
CLSID_INDEX_SERVER_DSO = iid
End Function
Public Function PSGUID_FILENAME() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H41CF5AE0, &HF75A, &H4806, &HBD, &H87, &H59, &HC7, &HD9, &H24, &H8E, &HB9)
PSGUID_FILENAME = iid
End Function
Public Function DBPROPSET_FSCIFRMWRK_EXT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HA9BD1526, &H6A80, &H11D0, &H8C, &H9D, &H00, &H20, &HAF, &H1D, &H74, &H0E)
DBPROPSET_FSCIFRMWRK_EXT = iid
End Function
Public Function DBPROPSET_SESS_QUERYEXT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &H63623309, &H2d8b, &H4d17, &Hb1, &H52, &H6e, &H29, &H56, &Hc2, &H6a, &H70)
DBPROPSET_SESS_QUERYEXT = iid
End Function
Public Function DBPROPSET_QUERYEXT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &HA7AC77ED, &HF8D7, &H11CE, &HA7, &H98, &H00, &H20, &HF8, &H00, &H80, &H25)
DBPROPSET_QUERYEXT = iid
End Function
Public Function DBPROPSET_CIFRMWRKCORE_EXT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Hafafaca5, &Hb5d1, &H11d0, &H8c, &H62, &H00, &Hc0, &H4f, &Hc2, &Hdb, &H8d)
DBPROPSET_CIFRMWRKCORE_EXT = iid
End Function
Public Function DBPROPSET_MSIDXS_ROWSETEXT() As UUID
Static iid As UUID
 If (iid.Data1 = 0) Then Call DEFINE_UUID(iid, &Haa6ee6b0, &He828, &H11d0, &Hb2, &H3e, &H00, &Haa, &H00, &H47, &Hfc, &H01)
DBPROPSET_MSIDXS_ROWSETEXT = iid
End Function

Public Enum DBPROP_CI
    DBPROP_CI_CATALOG_NAME = 2
    DBPROP_CI_INCLUDE_SCOPES = 3
    DBPROP_CI_DEPTHS = 4  ' obsolete
    DBPROP_CI_SCOPE_FLAGS = 4
    DBPROP_CI_EXCLUDE_SCOPES = 5
    DBPROP_CI_SECURITY_ID = 6
    DBPROP_CI_QUERY_TYPE = 7
    DBPROP_CI_PROVIDER = 8
End Enum

Public Enum CI_PROVIDER
    CI_PROVIDER_MSSEARCH = 1  ' Only try MSSearch
    CI_PROVIDER_INDEXING_SERVICE = 2  ' Only try Indexing Service
    CI_PROVIDER_ALL = &Hffffffff  ' Try all -- the default
End Enum

Public Const DBPROP_DEFAULT_EQUALS_BEHAVIOR  = 2
'  Query Extension property set
Public Const DBPROP_USECONTENTINDEX  = 2
Public Const DBPROP_DEFERNONINDEXEDTRIMMING  = 3
Public Const DBPROP_USEEXTENDEDDBTYPES  = 4
Public Const DBPROP_IGNORENOISEONLYCLAUSES  = 5
Public Const DBPROP_GENERICOPTIONS_STRING  = 6
Public Const DBPROP_FIRSTROWS  = 7
Public Const DBPROP_DEFERCATALOGVERIFICATION  = 8
Public Const DBPROP_CATALOGLISTID  = 9
Public Const DBPROP_GENERATEPARSETREE  = 10
Public Const DBPROP_APPLICATION_NAME  = 11
Public Const DBPROP_FREETEXTANYTERM  = 12
Public Const DBPROP_FREETEXTUSESTEMMING  = 13
Public Const DBPROP_IGNORESBRI  = 14
Public Const DBPROP_DONOTCOMPUTEEXPENSIVEPROPS  = 15
Public Const DBPROP_ENABLEROWSETEVENTS  = 16
'  Content Index Framework Core property set
Public Const DBPROP_MACHINE  = 2
Public Const DBPROP_CLIENT_CLSID  = 3
'  MSIDXS Rowset property set
Public Const MSIDXSPROP_ROWSETQUERYSTATUS  = 2
Public Const MSIDXSPROP_COMMAND_LOCALE_STRING  = 3
Public Const MSIDXSPROP_QUERY_RESTRICTION  = 4
Public Const MSIDXSPROP_PARSE_TREE  = 5
Public Const MSIDXSPROP_MAX_RANK  = 6
Public Const MSIDXSPROP_RESULTS_FOUND  = 7
Public Const MSIDXSPROP_WHEREID  = 8
Public Const MSIDXSPROP_SERVER_VERSION  = 9
Public Const MSIDXSPROP_SERVER_WINVER_MAJOR  = 10
Public Const MSIDXSPROP_SERVER_WINVER_MINOR  = 11
Public Const MSIDXSPROP_SERVER_NLSVERSION  = 12
Public Const MSIDXSPROP_SERVER_NLSVER_DEFINED  = 13
Public Const MSIDXSPROP_SAME_SORTORDER_USED  = 14

Public Enum NtQueryFillStatus
    STAT_BUSY = (0)
    STAT_ERROR = (&H1)
    STAT_DONE = (&H2)
    STAT_REFRESH = (&H3)
End Enum

Public Function QUERY_FILL_STATUS(ByVal x As Long) As Long: Return (x And &H7): End Function

Public Enum NtQueryReliabilityStatus
    STAT_PARTIAL_SCOPE = (&H8)
    STAT_NOISE_WORDS = (&H10)
    STAT_CONTENT_OUT_OF_DATE = (&H20)
    STAT_REFRESH_INCOMPLETE = (&H40)
    STAT_CONTENT_QUERY_INCOMPLETE = (&H80)
    STAT_TIME_LIMIT_EXCEEDED = (&H100)
    STAT_SHARING_VIOLATION = (&H200)
    STAT_MISSING_RELDOC = (&H400)
    STAT_MISSING_PROP_IN_RELDOC = (&H800)
    STAT_RELDOC_ACCESS_DENIED = (&H1000)
    STAT_COALESCE_COMP_ALL_NOISE = (&H2000)
End Enum
    
Public Function QUERY_RELIABILITY_STATUS(ByVal x As Long) As Long: Return (x And &HFFF8&): End Function

Public Const QUERY_SHALLOW  = 0
Public Const QUERY_DEEP  = 1
Public Const QUERY_PHYSICAL_PATH  = 0
Public Const QUERY_VIRTUAL_PATH  = 2
'  query property set (PSGUID_QUERY) properties not defined in oledb.h
Public Const PROPID_QUERY_WORKID  = 5
Public Const PROPID_QUERY_UNFILTERED  = 7
Public Const PROPID_QUERY_VIRTUALPATH  = 9
Public Const PROPID_QUERY_LASTSEENTIME  = 10
'  Change or get the current state of a catalog specified.
Public Enum NtQueryCatalogStatus
    CICAT_STOPPED = &H1
    CICAT_READONLY = &H2
    CICAT_WRITABLE = &H4
    CICAT_NO_QUERY = &H8
    CICAT_GET_STATE = &H10
    CICAT_ALL_OPENED = &H20
End Enum
    

[UseGetLastError(False)]
Public DeclareWide PtrSafe Function SetCatalogState Lib "Query.dll" (ByVal pwcsCat As String, ByVal pwcsMachine As String, ByVal dwNewState As NtQueryCatalogStatus, pdwOldState As NtQueryCatalogStatus) As Long

Public Enum NtQueryCatalogState
    CI_STATE_SHADOW_MERGE = &H0001  ' Index is performing a shadow merge
    CI_STATE_MASTER_MERGE = &H0002  ' Index is performing a master merge
    CI_STATE_CONTENT_SCAN_REQUIRED = &H0004  ' Index is likely corrupt, and a rescan is required
    CI_STATE_ANNEALING_MERGE = &H0008  ' Index is performing an annealing (optimizing) merge
    CI_STATE_SCANNING = &H0010  ' Scans are in-progress
    CI_STATE_RECOVERING = &H0020  ' Index metadata is being recovered
    CI_STATE_INDEX_MIGRATION_MERGE = &H0040  ' Reserved for future use
    CI_STATE_LOW_MEMORY = &H0080  ' Indexing is paused due to low memory availability
    CI_STATE_HIGH_IO = &H0100  ' Indexing is paused due to a high rate of I/O
    CI_STATE_MASTER_MERGE_PAUSED = &H0200  ' Master merge is paused
    CI_STATE_READ_ONLY = &H0400  ' Indexing has been manually paused (read-only)
    CI_STATE_BATTERY_POWER = &H0800  ' Indexing is paused to conserve battery life
    CI_STATE_USER_ACTIVE = &H1000  ' Indexing is paused due to high user activity (keyboard/mouse)
    CI_STATE_STARTING = &H2000  ' Index is still starting up
    CI_STATE_READING_USNS = &H4000  ' USNs on NTFS volumes are being processed
    CI_STATE_DELETION_MERGE = &H8000&  ' Index is performing a deletion merge
    CI_STATE_LOW_DISK = &H10000  ' Index is paused due to low disk availability
    CI_STATE_HIGH_CPU = &H20000  ' Index is paused due to high CPU
    CI_STATE_BATTERY_POLICY = &H40000  ' Indexing is paused due to backoff on battery policy
End Enum
Public Type CI_STATE
    cbStruct As Long
    cWordList As Long
    cPersistentIndex As Long
    cQueries As Long
    cDocuments As Long
    cFreshTest As Long
    dwMergeProgress As Long
    eState As NtQueryCatalogState
    cFilteredDocuments As Long
    cTotalDocuments As Long
    cPendingScans As Long
    dwIndexSize As Long
    cUniqueKeys As Long
    cSecQDocuments As Long
    dwPropCacheSize As Long
End Type

Public Enum DBKIND
    DBKIND_GUID_NAME = 0
    DBKIND_GUID_PROPID = (DBKIND_GUID_NAME + 1)
    DBKIND_NAME = (DBKIND_GUID_PROPID + 1)
    DBKIND_PGUID_NAME = (DBKIND_NAME + 1)
    DBKIND_PGUID_PROPID = (DBKIND_PGUID_NAME + 1)
    DBKIND_PROPID = (DBKIND_PGUID_PROPID + 1)
    DBKIND_GUID = (DBKIND_PROPID + 1)
End Enum
Public Type DBID
    ' /* [switch_is][switch_type] */ union 
        ' {
        ' /* [case()] */ GUID guid;
        ' /* [case()] */ GUID *pguid;
        ' /* [default] */  /* Empty union arm */ 
        ' }     uGuid;
    ' DBKIND eKind;
    ' /* [switch_is][switch_type] */ union 
        ' {
        ' /* [case()] */ LPOLESTR pwszName;
        ' /* [case()] */ ULONG ulPropid;
        ' /* [default] */  /* Empty union arm */ 
        ' }     uName;
        uGuid(3) As Long
        eKind As DBKIND
        uName As LongPtr
End Type
Public Type CIPROPERTYDEF
    wcsFriendlyName As LongPtr
    dbType As Long
    dbCol As DBID
End Type


'WindowsSearchErrors.h

Public Enum WindowsSearchErrorSources
    ERROR_SOURCE_NETWORKING = &H0300
    ERROR_SOURCE_DATASOURCE = &H0400
    ERROR_SOURCE_COLLATOR = &H0500
    ERROR_SOURCE_CONNMGR = &H0600
    ERROR_SOURCE_QUERY = &H0700
    ERROR_SOURCE_SCHEMA = &H0C00
    ERROR_SOURCE_GATHERER = &H0D00
'  DO NOT use 0x0E00.  Errors 0x0E00 - 0x0EFF are OLE-DB error codes
    ERROR_SOURCE_CATALOG = &H0F00
    ERROR_SOURCE_INDEXER = &H1100
    ERROR_SOURCE_SETUP = &H1300
    ERROR_SOURCE_SECURITY = &H1400
    ERROR_SOURCE_CMDLINE = &H1500
'  DO NOT use 0x1600 - 0x1800   these belong to CI
    ERROR_SOURCE_NLADMIN = &H1900
    ERROR_SOURCE_SCRIPTPI = &H2000
    ERROR_SOURCE_MSS = &H2100
    ERROR_SOURCE_XML = &H2200
    ERROR_SOURCE_DAV = &H2300
    ERROR_SOURCE_FLTRDMN = &H2400
    ERROR_SOURCE_OLEDB_BINDER = &H2500
    ERROR_SOURCE_NOTESPH = &H2600
    ERROR_SOURCE_EXSTOREPH = &H2700
    ERROR_SOURCE_SRCH_SCHEMA_CACHE = &H3300
    ERROR_SOURCE_CONTENT_SOURCE = &H3400
    ERROR_SOURCE_REMOTE_EXSTOREPH = &H3500
    ERROR_SOURCE_PEOPLE_IMPORT = &H4000
    ERROR_FTE = &H3600
    ERROR_FTE_CB = &HCB00&
    ERROR_FTE_FD = &HFD00&
End Enum

[Description("A network read or write operation has failed.")] Public Const NET_E_GENERAL = &H80040300
[Description("The network connection was lost. Try the query again.")] Public Const NET_E_DISCONNECTED = &H80040303
[Description("The parameters passed were not valid.")] Public Const NET_E_INVALIDPARAMS = &H80040308
[Description("Another operation is already in progress on this socket. Try the query again.")] Public Const NET_E_OPERATIONINPROGRESS = &H80040309
[Description("The search service is running as a local System service. To access Exchange documents, check that the search service is running in a user account with administrative privileges on the Exchange server.")] Public Const SEC_E_INVALIDCONTEXT = &H80041403
[Description("The Exchange search provider cannot be initialized. You may have to reinstall the  application.")] Public Const SEC_E_INITFAILED = &H80041401
[Description("The security provider was not initialized. You may have to reinstall the application.")] Public Const SEC_E_NOTINITIALIZED = &H80041402
[Description("Access is denied. You may not have sufficient privileges to perform the operation.")] Public Const SEC_E_ACCESSDENIED = &H800414FF







[Description("The query syntax is not valid. ")] Public Const QRY_E_QUERYSYNTAX = &H80040701
[Description("The column type in the search query does not match the column type in the index. ")] Public Const QRY_E_TYPEMISMATCH = &H80040702
[Description("The query type specified is unknown. ")] Public Const QRY_E_UNHANDLEDTYPE = &H80040703
[Description("No matching items were found for this query. ")] Public Const QRY_S_NOROWSFOUND = &H00040704
[Description("The number of columns requested exceeds the limit. ")] Public Const QRY_E_TOOMANYCOLUMNS = &H80040705
[Description("The query contained too many content index IDs. ")] Public Const QRY_E_TOOMANYDATABASES = &H80040706
[Description("The query start hit is larger than the total number of results. ")] Public Const QRY_E_STARTHITTOBIG = &H80040707
[Description("The query contains too many terms. ")] Public Const QRY_E_TOOMANYQUERYTERMS = &H80040708
[Description("No indexes were specified. ")] Public Const QRY_E_NODATASOURCES = &H80040709
[Description("The query operation timed out. ")] Public Const QRY_E_TIMEOUT = &H8004070A
[Description("The query specified sorting a non-sortable column. ")] Public Const QRY_E_COLUMNNOTSORTABLE = &H8004070B
[Description("The query specified searching a non-searchable column. ")] Public Const QRY_E_COLUMNNOTSEARCHABLE = &H8004070C
[Description("The query specified a nonexistent column. ")] Public Const QRY_E_INVALIDCOLUMN = &H8004070D
[Description("The query data is not valid or is inconsistent. ")] Public Const QRY_E_QUERYCORRUPT = &H8004070E
[Description("A query term begins with a wildcard character. ")] Public Const QRY_E_PREFIXWILDCARD = &H8004070F
[Description("A query term contains an invalid embedded wildcard character. ")] Public Const QRY_E_INFIXWILDCARD = &H80040710
[Description("A wildcard term in the query does not contain a sufficiently long prefix. ")] Public Const QRY_E_WILDCARDPREFIXLENGTH = &H80040711
[Description("The query term was successfully ignored.")] Public Const QRY_S_TERMIGNORED = &H00040712
[Description("The search server is unable to process the query. ")] Public Const QRY_E_ENGINEFAILED = &H80040713
[Description("The search criteria are too general or matched too many terms. ")] Public Const QRY_E_SEARCHTOOBIG = &H80040714
[Description("The query does not contain any meaningful restrictions. ")] Public Const QRY_E_NULLQUERY = &H80040715
[Description("The query found some matching items, but is unable to compile the entire result set. ")] Public Const QRY_S_INEXACTRESULTS = &H00040716
[Description("The query did not specify any return columns. ")] Public Const QRY_E_NOCOLUMNS = &H80040717
[Description("The scopes specified for the query were incorrectly formatted. ")] Public Const QRY_E_INVALIDSCOPES = &H80040718
[Description("The indexes specified for the query were incorrectly formatted. ")] Public Const QRY_E_INVALIDCATALOG = &H80040719
[Description("The number of scopes or depths was not valid. ")] Public Const QRY_E_SCOPECARDINALIDY = &H8004071A
[Description("The operation is invalid in the current context. ")] Public Const QRY_E_UNEXPECTED = &H8004071B
[Description("An invalid path was supplied. ")] Public Const QRY_E_INVALIDPATH = &H8004071C
[Description("The log manager is not initialized. ")] Public Const QRY_E_LMNOTINITIALIZED = &H8004071D
[Description("An invalid interval was passed to the log manager. ")] Public Const QRY_E_INVALIDINTERVAL = &H8004071E
[Description("No log manager was attached to the logger. ")] Public Const QRY_E_NOLOGMANAGER = &H8004071F




[Description("An unexpected error occurred in the filtering process. Contact Microsoft Product Support.")] Public Const FLTRDMN_E_UNEXPECTED = &H80042401
[Description("The document IFilter cannot provide the needed interface. The IFilter may contain errors.")] Public Const FLTRDMN_E_QI_FILTER_FAILED = &H80042402
[Description("A document IFilter cannot be initialized. The document or IFilter may contain errors.")] Public Const FLTRDMN_E_FILTER_INIT_FAILED = &H80042404
[Description("An encrypted document cannot be filtered.")] Public Const FLTRDMN_E_ENCRYPTED_DOCUMENT = &H80042405
[Description("The password for the content access account cannot be decrypted because it was stored with different credentials.  Re-type the password for the account used to crawl this content.")] Public Const FLTRDMN_E_CANNOT_DECRYPT_PASSWORD = &H80042406




[Description("The account password was not specified. Specify the password.")] Public Const FTE_E_SECRET_NOT_FOUND = &H80043602
[Description("The named pipe used to communicate with the filter daemon has not been connected.")] Public Const FTE_E_PIPE_NOT_CONNECTED = &H80043603
[Description("The configuration data given to the MSFTESQL service is corrupt.")] Public Const FTE_E_ADMIN_BLOB_CORRUPT = &H80043604
[Description("The system attempted to load an apartment threading model filter marked in a multi-threaded filter daemon. The document will be retried in a single-threaded filter daemon process. Since multithreaded filtering is more efficient, try to obtain the version of the filter that is multi-threaded.")] Public Const FTE_E_FILTER_SINGLE_THREADED = &H80043605
[Description("The value cannot be set, because the object was already deleted or was not initialized properly. Make sure the object reference is still valid, increase the registry size, or recreate the catalog configuration.")] Public Const FTE_E_ERROR_WRITING_REGISTRY = &H80043606
[Description("An internal interface is being used after the corresponding catalog has been shutdown. The operation will be aborted.")] Public Const FTE_E_PROJECT_SHUTDOWN = &H80043607
[Description("An internal interface is being used prior to being initialized. The operation will be aborted.")] Public Const FTE_E_PROJECT_NOT_INITALIZED = &H80043608
[Description("Data transferred between the MSFTESQL service and a filter daemon process is corrupted. This is an internal error.")] Public Const FTE_E_PIPE_DATA_CORRUPTED = &H80043609
[Description("This is an internal error: The URB has exceeded the maximum size.")] Public Const FTE_E_URB_TOO_BIG = &H80043610
[Description("This is an internal error: Document IDs should be greater than 0 and less than or equal to 0x7fffffff.")] Public Const FTE_E_INVALID_DOCID = &H80043611
[Description("An external status change has put the catalog in a paused state.")] Public Const FTE_E_PAUSE_EXTERNAL = &H80043612
[Description("A status change is occurring or the project is in a force paused state, so MSFTESQL cannot accept input at this time.")] Public Const FTE_E_REJECTED_DUE_TO_PROJECT_STATUS = &H80043613
[Description("The MSFTEFD process was launched but did not connect with the MSFTESQL service.")] Public Const FTE_E_FD_DID_NOT_CONNECT = &H80043614
[Description("This is an internal error: Initialization of the datasink is incorrect.  At least one protocol handler PROGID is required.")] Public Const FTE_E_PROGID_REQUIRED = &H80043616
[Description("This is an internal error:  A static thread has gotten invalid arguments and will force batches to be aborted and retried.")] Public Const FTE_E_STATIC_THREAD_INVALID_ARGUMENTS = &H80043617
[Description("A catalog already exists with this name, so another can be created or mounted.")] Public Const FTE_E_CATALOG_ALREADY_EXISTS = &H80043618
[Description("The Full Text Engine's input queue is getting full.  This batch has been accepted for processing.  This success code is intended to help pause input until the queue is less full.")] Public Const FTE_S_RESOURCES_STARTING_TO_GET_LOW = &H00043619
[Description("A file path exceeds the maximum limit for paths in Windows, so it can't be used.")] Public Const FTE_E_PATH_TOO_LONG = &H8004361A
[Description("Access is denied to the caller of this administration interface.")] Public Const FTE_INVALID_ADMIN_CLIENT = &H8004361B
[Description("Signature validation cannot be performed on modules loaded by COM, so the object will not be created. The object is likely a filter, wordbreaker, stemmer, or protocol handler.")] Public Const FTE_E_COM_SIGNATURE_VALIDATION = &H8004361C
[Description("The processor affinity mask is invalid.")] Public Const FTE_E_AFFINITY_MASK = &H8004361D
[Description("This is an internal error that should be handled. The FD has been killed and this chunk buffer has already been reassigned.")] Public Const FTE_E_FD_OWNERSHIP_OBSOLETE = &H8004361E
[Description("The maximum number of plug-ins has been exceeded, so a new plug-in can't be loaded.")] Public Const FTE_E_EXCEEDED_MAX_PLUGINS = &H80043621
[Description("The Full Text Engine's input queue is full.  This batch has been accepted for processing; however, the Full Text Engine will soon go into a forced paused state until the queue is less full.")] Public Const FTE_S_BEYOND_QUOTA = &H00043622
[Description("An object could not be inserted because it was a duplicate of an existing object. The object may be a catalog or other named entity.")] Public Const FTE_E_DUPLICATE_OBJECT = &H80043624
[Description("This transaction was superseded by a subsequent transaction, so it will not be completed.")] Public Const FTE_S_REDUNDANT = &H00043625
[Description("The transaction that superseded this one ended in error.")] Public Const FTE_E_REDUNDANT_TRAN_FAILURE = &H80043626
[Description("The transaction that superseded this one ended in error.")] Public Const FTE_E_DEPENDENT_TRAN_FAILED_TO_PERSIST = &H80043627
[Description("This is an internal error: This request cannot be completed because the Filter Daemon has been shutdown.")] Public Const FTE_E_FD_SHUTDOWN = &H80043628
[Description("The catalog does not exist, so the operation can't be performed.")] Public Const FTE_E_CATALOG_DOES_NOT_EXIST = &H80043629
[Description("There are no plug-in components in the indexing pipeline, so the data collected will not be used.")] Public Const FTE_E_NO_PLUGINS = &H8004362A
[Description("The project state has changed or is changing due to a status change request.")] Public Const FTE_S_STATUS_CHANGE_REQUEST = &H0004362B
[Description("Processing of this batch of transactions has been aborted.")] Public Const FTE_E_BATCH_ABORTED = &H8004362C
[Description("A status change is active on another thread. Since only one status change is allowed at a time this request can't be handled.")] Public Const FTE_E_ANOTHER_STATUS_CHANGE_IS_ALREADY_ACTIVE = &H8004362D
[Description("This is an internal error: The project will be resumed.")] Public Const FTE_S_RESUME = &H0004362E
[Description("A previous error prevented further processing of the batch.")] Public Const FTE_E_NOT_PROCESSED_DUE_TO_PREVIOUS_ERRORS = &H8004362F
[Description("The filter daemon process MSFTEFD timed out for an unknown reason. This may indicate a bug in a filter, wordbreaker, or protocol handler.")] Public Const FTE_E_FD_TIMEOUT = &H80043630
[Description("This is an internal error: This activity is no longer valid because the resource is shutdown.")] Public Const FTE_E_RESOURCE_SHUTDOWN = &H80043631
[Description("The property specified is invalid.")] Public Const FTE_E_INVALID_PROPERTY = &H80043632
[Description("There are no more properties.")] Public Const FTE_E_NO_MORE_PROPERTIES = &H80043633
[Description("The plug-in specified is not known likely because it isn't loaded, so the operation can't succeed. Only specify plug-ins that are loaded.")] Public Const FTE_E_UNKNOWN_PLUGIN = &H80043634
[Description("The performance monitor library could not be loaded.")] Public Const FTE_E_LIBRARY_NOT_LOADED = &H80043635
[Description("There are no more slots available for this performance monitor instance")] Public Const FTE_E_PERFMON_FULL = &H80043636
[Description("The filter daemon process MSFTEFD was not able to create an accessor object for the batch.")] Public Const FTE_E_FAILED_TO_CREATE_ACCESSOR = &H80043637
[Description("The property type specified is incorrect for this property. Please see the product documentation for the correct data type for this property.")] Public Const FTE_E_INVALID_TYPE = &H80043638
[Description("The value specified is out of range. Please see the product documentation for the valid range.")] Public Const FTE_E_OUT_OF_RANGE = &H80043639
[Description("The property store for upgrade is corrupted.")] Public Const FTE_E_CORRUPT_PROPERTY_STORE = &H8004363A
[Description("The workid is not valid for the property store.")] Public Const FTE_E_PROPERTY_STORE_WORKID_NOTVALID = &H8004363B
[Description("The enumeration has finished for the property store.")] Public Const FTE_S_PROPERTY_STORE_END_OF_ENUMERATION = &H0004363C
[Description("The gatherer hash map for upgrade is corrupted.")] Public Const FTE_E_CORRUPT_GATHERER_HASH_MAP = &H8004363D
[Description("The key is not cached in the property store.")] Public Const FTE_E_KEY_NOT_CACHED = &H8004363E
[Description("The upgrade interface has already been shutdown.")] Public Const FTE_E_UPGRADE_INTERFACE_ALREADY_SHUTDOWN = &H8004363F
[Description("The upgrade interface has already been instantiated. Only one instance of the upgrade interface is allowed.")] Public Const FTE_E_UPGRADE_INTERFACE_ALREADY_INSTANTIATED = &H80043640
[Description("The stack for a thread in this process is corrupted due to a programming bug. This may be a security threat and indicate your system has been attacked. The process will be shutdown.")] Public Const FTE_E_STACK_CORRUPTED = &H80043641
[Description("The protocol handler index passed to the OnDataChange function is invalid.")] Public Const FTE_E_INVALID_PROG_ID = &H80043642
[Description("The serial stream being indexed is corrupted.")] Public Const FTE_E_SERIAL_STREAM_CORRUPT = &H80043643
[Description("The catalog is opened for read-only operations. Writing is prohibited to this catalog.")] Public Const FTE_E_READONLY_CATALOG = &H80043644
[Description("The performance monitor counters cannot be unloaded because they are not loaded in the first place.")] Public Const FTE_E_PERF_NOT_LOADED = &H80043645
[Description("The catalog has been opened for read-only operations.")] Public Const FTE_S_READONLY_CATALOG = &H00043646
[Description("This huge document will be retried in dedicated filter daemon MSFTEFD process.")] Public Const FTE_E_RETRY_HUGE_DOC = &H80043648
[Description("This is an internal error: The filter daemon MSFTEFD type is unknown or invalid.")] Public Const FTE_E_UNKNOWN_FD_TYPE = &H80043649
[Description("There are not enough resources to process the document or row.")] Public Const FTE_E_DOC_TOO_HUGE = &H8004364A
[Description("This is an internal error: Datatype misalignment was detected likely due to a programming error.")] Public Const FTE_E_DATATYPE_MISALIGNMENT = &H8004364B
[Description("The object is already initialized.")] Public Const FTE_E_ALREADY_INITIALIZED = &H8004364C
[Description("The filter daemon process MSFTEFD used too much memory and will be terminated.")] Public Const FTE_E_FD_USED_TOO_MUCH_MEMORY = &H8004364D
[Description("%1")] Public Const FTE_E_UNEXPECTED_EXIT = &H8004364E
[Description("High memory pressure was detected by the MSFTESQL memory manager.")] Public Const FTE_E_HIGH_MEMORY_PRESSURE = &H8004364F
[Description("A batch flagged to isolate a previous error had too many transactions in it.")] Public Const FTE_E_INVALID_ISOLATE_ERROR_BATCH = &H80043650
[Description("msftesql should reprocess this document in an isolated fashion to confirm the error.")] Public Const FTE_E_RETRY_SINGLE_DOC_PER_BATCH = &H80043651
[Description("An internal identifier for naming catalogs has been corrupted.")] Public Const FTE_E_INVALID_PROJECT_ID = &H80043652
[Description("A failure occurred when tracking the completion of wordlists which will cause current activity to be aborted.")] Public Const FTE_E_FAILURE_TO_POST_SETCOMPLETION_STATUS = &H80043653
[Description("The specified code page is not installed or not available.")] Public Const FTE_E_INVALID_CODEPAGE = &H80043654
[Description("Internal Error Code: Filter Daemon is terminated because it is idle.")] Public Const FTE_E_FD_IDLE = &H80043655
[Description("Filter Daemon was unresponsive to a directive to shut itself down.")] Public Const FTE_E_FD_UNRESPONSIVE = &H80043656
[Description("Internal Success Code.  Crawl is done.  Chunk buffers can be flushed; there is no additional input data.")] Public Const FTE_S_TRY_TO_FLUSH = &H00043657
[Description("The caller should either call SetProperty with the value returned or dismount the catalog and mount it back with the blob.")] Public Const FTE_S_CATALOG_BLOB_MISMATCHED = &H00043658
[Description("One or more properties were reset to the default value.")] Public Const FTE_S_PROPERTY_RESET = &H00043659
[Description("Property Store is not found in the indexer. The possible causes are that the call came during a catalog reset or that the property store plug-in failed to load during indexer initialization.")] Public Const FTE_E_NO_PROPERTY_STORE = &HC004365A
[Description("This is an internal error: The chunk buffer is out of memory.")] Public Const FTE_E_CB_OUT_OF_MEMORY = &H8004CB00
[Description("This is an internal error: The chunk buffer id is out of bounds.")] Public Const FTE_E_CB_CBID_OUT_OF_BOUND = &H8004CB01
[Description("There is not enough available physical or virtual memory for chunk buffers. Chunk buffers are needed to index data. Please free up memory.")] Public Const FTE_E_CB_NOT_ENOUGH_AVAIL_PHY_MEM = &H8004CB02
[Description("There is not enough occurrence buffer memory available. Possible causes include too many processors, too many filter threads, or the occurrence buffer is not being returned.")] Public Const FTE_E_CB_NOT_ENOUGH_OCC_BUFFER = &H8004CB03
[Description("The in-memory wordlist is corrupted. This is due to a faulty filter, wordbreaker, or other indexing component.")] Public Const FTE_E_CORRUPT_WORDLIST = &H8004CB04
[Description("The IPersistStream and IPersistFile interfaces were unavailable from an IFilter filter DLL to load data for indexing.")] Public Const FTE_E_FD_NO_IPERSIST_INTERFACE = &H8004FD00
[Description("The IFilter::Init() function call failed.")] Public Const FTE_E_FD_IFILTER_INIT_FAILED = &H8004FD01
[Description("The filter daemon MSFTEFD failed to load an IFilter interface for document, so it can't be indexed.")] Public Const FTE_E_FD_FAILED_TO_LOAD_IFILTER = &H8004FD02
[Description("The document being indexed timed out for an unknown reason. This may be due to a bug in a filter or wordbreaker.")] Public Const FTE_E_FD_DOC_TIMEOUT = &H8004FD03
[Description("%1")] Public Const FTE_E_FD_UNEXPECTED_EXIT = &H8004FD04
[Description("%5")] Public Const FTE_E_FD_DOC_UNEXPECTED_EXIT = &H8004FD05
[Description("The system failed to load the text filter for parsing a noise word file.")] Public Const FTE_E_FD_NOISE_NO_TEXT_FILTER = &H8004FD06
[Description("The system failed to load noise words stream into text filter because text filter does not support IPersistStream.")] Public Const FTE_E_FD_NOISE_NO_IPERSISTSTREAM_ON_TEXT_FILTER = &H8004FD07
[Description("The system failed to load noise words stream into text filter because the IPersistStream::Load() function failed.")] Public Const FTE_E_FD_NOISE_TEXT_FILTER_LOAD_FAILED = &H8004FD08
[Description("The system failed to load noise words stream into text filter because IFilter::Init() function failed.")] Public Const FTE_E_FD_NOISE_TEXT_FILTER_INIT_FAILED = &H8004FD09
[Description("Occurrence counter overflow, document is not indexed.")] Public Const FTE_E_FD_OCCURRENCE_OVERFLOW = &H8004FD0A
[Description("The filter has caused a sharing violation.")] Public Const FTE_E_FD_FILTER_CAUSED_SHARING_VIOLATION = &H8004FD0B
Public Const ERROR_SOURCE_PROTHNDLR = &H120
[Description("A communication error occurred.")] Public Const PRTH_E_COMM_ERROR = &H80041200
[Description("The object was not found.")] Public Const PRTH_E_OBJ_NOT_FOUND = &H80041201
[Description("The options used are not supported. Check that your version of Internet Explorer is supported.")] Public Const PRTH_E_REQUEST_ERROR = &H80041202
[Description("The content did not change.")] Public Const PRTH_S_NOT_MODIFIED = &H00041203
[Description("Access is denied. Check that the Default Content Access Account in Windows Search Central Administration is correct, or follow the Exclude and Include Content link to add a rule to specify the proper crawling account to access this URL.")] Public Const PRTH_E_ACCESS_DENIED = &H80041205
[Description("A server error occurred. Check that the server is available.")] Public Const PRTH_E_SERVER_ERROR = &H80041206
[Description("You have been redirected to an address that does not exist. Check that the source address is redirecting to an accessible address.")] Public Const PRTH_E_NOT_REDIRECTED = &H80041207
[Description("The address appears to be in error. Check that the address is valid.")] Public Const PRTH_E_BAD_REQUEST = &H80041208
[Description("Cannot Connect to the server.  Please make sure the site is accessible.")] Public Const PRTH_E_HTTP_CANNOT_CONNECT = &H80041209
[Description("The Access Control List was successfully changed to be readable by everyone.")] Public Const PRTH_S_ACL_IS_READ_EVERYONE = &H00041210
[Description("The item will not be crawled because the Access Control List allows no one to read the item. Check that this is intended.")] Public Const PRTH_E_ACL_IS_READ_NONE = &H80041211
[Description("Search cannot crawl the item, because its Access Control List exceeded 64 KB. Check that the item has a valid Access Control List.")] Public Const PRTH_E_ACL_TOO_BIG = &H80041212
[Description("Some parts of this document cannot be accessed.")] Public Const PRTH_S_NOT_ALL_PARTS = &H0004121B
[Description("       of leaving it empty.")] Public Const NOT_AN_ERROR1                    = &H00081600
[Description("The call failed for an unknown reason.")] Public Const QUERY_E_FAILED                   = &H80041600
[Description("The parameter is invalid.")] Public Const QUERY_E_INVALIDQUERY             = &H80041601
[Description("The query restriction cannot be parsed.")] Public Const QUERY_E_INVALIDRESTRICTION       = &H80041602
[Description("An invalid sort order was requested.")] Public Const QUERY_E_INVALIDSORT              = &H80041603
[Description("An invalid categorization order was requested.")] Public Const QUERY_E_INVALIDCATEGORIZE        = &H80041604
[Description("A clause of the query contained only words that are ignored.")] Public Const QUERY_E_ALLNOISE                 = &H80041605
[Description("The query was too complex to be executed.")] Public Const QUERY_E_TOOCOMPLEX               = &H80041606
[Description("The query exceeded its execution time limit.")] Public Const QUERY_E_TIMEDOUT                 = &H80041607
[Description("One or more columns in the output column list is a duplicate.")] Public Const QUERY_E_DUPLICATE_OUTPUT_COLUMN  = &H80041608
[Description("One or more columns in the output column list is not valid.")] Public Const QUERY_E_INVALID_OUTPUT_COLUMN    = &H80041609
[Description("The directory name is invalid.")] Public Const QUERY_E_INVALID_DIRECTORY        = &H8004160A
[Description("The specified directory is on a removable medium.")] Public Const QUERY_E_DIR_ON_REMOVABLE_DRIVE   = &H8004160B
[Description("The index is still being crawled, but queries are no longer allowed.")] Public Const QUERY_S_NO_QUERY                 = &H8004160C
[Description("The relevant specified documents were not found, because a clause of the query contained only words that are ignored.")] Public Const QUERY_E_ALLNOISE_AND_NO_RELDOC   = &H8004160D
[Description("None of the relevant documents specified in the query can be found.")] Public Const QUERY_E_NO_RELDOC                = &H8004160E
[Description("No information was found in the relevant documents with the specified properties, because a clause of the query contained only words that are ignored.")] Public Const QUERY_E_ALLNOISE_AND_NO_RELPROP  = &H8004160F
[Description("No relevant information is found in the relevant documents with the specified properties for this query.")] Public Const QUERY_E_NO_RELPROP               = &H80041610
[Description("The same relevant document is specified multiple times.")] Public Const QUERY_E_REPEATED_RELDOC          = &H80041611
[Description("The reldoc specification is not supported.")] Public Const QUERY_E_RELDOC_SYNTAX_NOT_SUPPORTED = &H80041612
[Description("The specified document identifier is not valid.")] Public Const QUERY_E_INVALID_DOCUMENT_IDENTIFIER = &H80041613
[Description("The server is running an older version of software that cannot handle this query.")] Public Const QUERY_E_INCORRECT_VERSION        = &H80041614
[Description("Scopes should be the same in all of the components of a coalesce query")] Public Const QUERY_E_INVALIDSCOPE_COALESCE    = &H80041615
[Description("Order by list should be same in all the components of a coalesce query.")] Public Const QUERY_E_INVALIDSORT_COALESCE     = &H80041616
[Description("Coalesce is either not used properly or this form is not currently supported. Check for possible mixing of grouping with coalesce")] Public Const QUERY_E_INVALIDCOALESCE          = &H80041617
[Description("Queries are disabled because the index is being updated. Try your query again in a few minutes.")] Public Const QUERY_E_UPGRADEINPROGRESS        = &H80041618
[Description("Aggregate is not supported.")] Public Const QUERY_E_AGGREGATE_NOT_SUPPORTED  = &H80041619
[Description("The top level group does not support ORDER IN GROUP since there is no parent group.")] Public Const QUERY_E_TOP_LEVEL_IN_GROUP       = &H8004161A
[Description("Each name for a ranged label must be unique.")] Public Const QUERY_E_DUPLICATE_RANGE_NAME     = &H8004161B
[Description("The file cannot be opened.")] Public Const QPLIST_E_CANT_OPEN_FILE          = &H80041651
[Description("Read error in file.")] Public Const QPLIST_E_READ_ERROR              = &H80041652
[Description("Expecting property name.")] Public Const QPLIST_E_EXPECTING_NAME          = &H80041653
[Description("Expecting type specifier.")] Public Const QPLIST_E_EXPECTING_TYPE          = &H80041654
[Description("Unrecognized type.")] Public Const QPLIST_E_UNRECOGNIZED_TYPE       = &H80041655
[Description("Expecting integer.")] Public Const QPLIST_E_EXPECTING_INTEGER       = &H80041656
[Description("Expecting closing parenthesis.")] Public Const QPLIST_E_EXPECTING_CLOSE_PAREN   = &H80041657
[Description("Expecting GUID.")] Public Const QPLIST_E_EXPECTING_GUID          = &H80041658
[Description("Invalid guid.")] Public Const QPLIST_E_BAD_GUID                = &H80041659
[Description("Expecting property specifier.")] Public Const QPLIST_E_EXPECTING_PROP_SPEC     = &H8004165A
[Description("Failed to set property name.")] Public Const QPLIST_E_CANT_SET_PROPERTY       = &H8004165B
[Description("Duplicate property name.")] Public Const QPLIST_E_DUPLICATE               = &H8004165C
[Description("DBTYPE_VECTOR or DBTYPE_BYREF used alone.")] Public Const QPLIST_E_VECTORBYREF_USED_ALONE  = &H8004165D
[Description(" or DBTYPE_UI1 types.")] Public Const QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE = &H8004165E
[Description("Unexpected end of string.")] Public Const QPARSE_E_UNEXPECTED_EOS          = &H80041672
[Description("The file is too large to filter.")] Public Const FILTER_E_TOO_BIG                 = &H80041730
[Description("A partial content scan of the disk must be scheduled for immediate execution.")] Public Const FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE = &H00041731
[Description("A full content scan of the disk must be scheduled for immediate execution.")] Public Const FILTER_S_FULL_CONTENTSCAN_IMMEDIATE = &H00041732
[Description("A content scan of the disk needs to be scheduled for execution later.")] Public Const FILTER_S_CONTENTSCAN_DELAYED     = &H00041733
[Description("The content index cannot be read. A content scan will be scheduled after chkdsk or autochk is run.")] Public Const FILTER_E_CONTENTINDEXCORRUPT     = &HC0041734
[Description("The disk is almost full.")] Public Const FILTER_S_DISK_FULL               = &H00041735
[Description("The file cannot be opened, because another file is already open.")] Public Const FILTER_E_ALREADY_OPEN            = &H80041736
[Description("The file is not reachable.")] Public Const FILTER_E_UNREACHABLE             = &H80041737
[Description("The document is in use by another process.")] Public Const FILTER_E_IN_USE                  = &H80041738
[Description("The document is not open.")] Public Const FILTER_E_NOT_OPEN                = &H80041739
[Description("The document has no property sets.")] Public Const FILTER_S_NO_PROPSETS             = &H0004173A
[Description("There is no property with the given GUID.")] Public Const FILTER_E_NO_SUCH_PROPERTY        = &H8004173B
[Description("The document has no security descriptor.")] Public Const FILTER_S_NO_SECURITY_DESCRIPTOR  = &H0004173C
[Description("The document is offline.")] Public Const FILTER_E_OFFLINE                 = &H8004173D
[Description("The document was too large to filter completely.  Portions of the document were not emitted.")] Public Const FILTER_E_PARTIALLY_FILTERED      = &H8004173E
[Description("End of text was reached in the text source.")] Public Const WBREAK_E_END_OF_TEXT             = &H80041780
[Description("The word exceeds the maximum length, and may be truncated by the word sink.")] Public Const LANGUAGE_S_LARGE_WORD            = &H00041781
[Description("This feature is only available in query mode.")] Public Const WBREAK_E_QUERY_ONLY              = &H80041782
[Description("The buffer is too small to hold the composed phrase.")] Public Const WBREAK_E_BUFFER_TOO_SMALL        = &H80041783
[Description("The language database/cache file cannot be found.")] Public Const LANGUAGE_E_DATABASE_NOT_FOUND    = &H80041784
[Description("Initialization of the word breaker failed.")] Public Const WBREAK_E_INIT_FAILED             = &H80041785
[Description("Feature only available in query mode.")] Public Const PSINK_E_QUERY_ONLY               = &H80041790
[Description("This feature is only available in index mode.")] Public Const PSINK_E_INDEX_ONLY               = &H80041791
[Description("The attachment type is beyond the valid range.")] Public Const PSINK_E_LARGE_ATTACHMENT         = &H80041792
[Description("The word exceeds the maximum length, and may be truncated by the phrase sink.")] Public Const PSINK_S_LARGE_WORD               = &H00041793
[Description("The content index database is corrupt.")] Public Const CI_CORRUPT_DATABASE              = &HC0041800
[Description("The content index catalog is corrupt.")] Public Const CI_CORRUPT_CATALOG               = &HC0041801
[Description("The content index partition is invalid.")] Public Const CI_INVALID_PARTITION             = &HC0041802
[Description("The priority is invalid.")] Public Const CI_INVALID_PRIORITY              = &HC0041803
[Description("There is no starting key.")] Public Const CI_NO_STARTING_KEY               = &HC0041804
[Description("The content index is out of index ids.")] Public Const CI_OUT_OF_INDEX_IDS              = &HC0041805
[Description("There is no index.")] Public Const CI_NO_CATALOG                    = &HC0041806
[Description("The filter buffer cannot be read.")] Public Const CI_CORRUPT_FILTER_BUFFER         = &HC0041807
[Description("The index is invalid.")] Public Const CI_INVALID_INDEX                 = &HC0041808
[Description("Inconsistency was detected in the property store.")] Public Const CI_PROPSTORE_INCONSISTENCY       = &HC0041809
[Description("The object is already initialized.")] Public Const CI_E_ALREADY_INITIALIZED         = &H8004180A
[Description("The object is not initialized.")] Public Const CI_E_NOT_INITIALIZED             = &H8004180B
[Description("The buffer is too small.")] Public Const CI_E_BUFFERTOOSMALL              = &H8004180C
[Description("The given property is not cached.")] Public Const CI_E_PROPERTY_NOT_CACHED         = &H8004180D
[Description("The workid is deleted.")] Public Const CI_S_WORKID_DELETED              = &H0004180E
[Description("The object is not in a valid state.")] Public Const CI_E_INVALID_STATE               = &H8004180F
[Description("Filtering is disabled for this content index.")] Public Const CI_E_FILTERING_DISABLED          = &H80041810
[Description("The disk is full and the specified operation cannot be completed.")] Public Const CI_E_DISK_FULL                   = &H80041811
[Description("The content index service was stopped.")] Public Const CI_E_SHUTDOWN                    = &H80041812
[Description("The workid is not valid.")] Public Const CI_E_WORKID_NOTVALID             = &H80041813
[Description("There are no more documents to enumerate.")] Public Const CI_S_END_OF_ENUMERATION          = &H00041814
[Description("The object was not found.")] Public Const CI_E_NOT_FOUND                   = &H80041815
[Description("The passed-in property id is not supported.")] Public Const CI_E_USE_DEFAULT_PID             = &H80041816
[Description("There were two alerts for the same workid.")] Public Const CI_E_DUPLICATE_NOTIFICATION      = &H80041817
[Description("A document update was rejected because updates were disabled.")] Public Const CI_E_UPDATES_DISABLED            = &H80041818
[Description("The combination of flags specified is invalid.")] Public Const CI_E_INVALID_FLAGS_COMBINATION   = &H80041819
[Description("The incremental data given to Load is not valid. It may be out of sequence.")] Public Const CI_E_OUTOFSEQ_INCREMENT_DATA     = &H8004181A
[Description("A sharing or locking violation caused a failure.")] Public Const CI_E_SHARING_VIOLATION           = &H8004181B
[Description("A logon permission violation caused a failure.")] Public Const CI_E_LOGON_FAILURE               = &H8004181C
[Description("The index does not exist or is currently unavailable. Try again later. If this problem persists, contact the system administrator.")] Public Const CI_E_NO_CATALOG                  = &H8004181D
[Description("Page size is not an integral multiple of the sector size of the volume where the index is located.")] Public Const CI_E_STRANGE_PAGEORSECTOR_SIZE   = &H8004181E
[Description("The service is too busy.")] Public Const CI_E_TIMEOUT                     = &H8004181F
[Description("The service is not running.")] Public Const CI_E_NOT_RUNNING                 = &H80041820
[Description("The content index data on disk is for the wrong version.")] Public Const CI_INCORRECT_VERSION             = &HC0041821
[Description("Enumeration was already started for this query.")] Public Const CI_E_ENUMERATION_STARTED         = &HC0041822
[Description("The specified variable length property is too large for the property cache.")] Public Const CI_E_PROPERTY_TOOLARGE           = &HC0041823
[Description("The filtering of the object was stopped by the client.")] Public Const CI_E_CLIENT_FILTER_ABORT         = &HC0041824
[Description("Administrative connections from client were not associated with a document store.")] Public Const CI_S_NO_DOCSTORE                 = &H00041825
[Description("The index has been stopped.")] Public Const CI_S_CAT_STOPPED                 = &H00041826
[Description("The cardinality of machine, indexes, and scopes is mismatched.")] Public Const CI_E_CARDINALITY_MISMATCH        = &H80041827
[Description("The disk has reached its configured space limit.")] Public Const CI_E_CONFIG_DISK_FULL            = &H80041828
[Description("This is a new entry in the auxiliary metadata storage.")] Public Const CI_S_NEW_AUXMETADATA             = &H00041829
[Description("The property store is not configured to handle auxiliary metadata storage.")] Public Const CI_E_NO_AUXMETADATA              = &H8004182A
[Description("The client requested that the document be stopped.")] Public Const CI_S_CLIENT_REQUESTED_ABORT      = &H0004182B
[Description("The client can now try to crawl a document.")] Public Const CI_S_RETRY_DOCUMENT              = &H0004182C
[Description("The forward index cannot be read.")] Public Const CI_E_CORRUPT_FWIDX               = &HC004182D
[Description("Catalog was created with different diacritic settings.")] Public Const CI_E_DIACRITIC_SETTINGS_DIFFER   = &HC004182E
[Description("The specified index list version is outdated or invalid.")] Public Const CI_E_INVALID_CATALOG_LIST_VERSION = &H8004182F
[Description("The catalog was reset due to diacritic difference or corruption.")] Public Const CI_S_CATALOG_RESET               = &H00041830
[Description("The catalog manager does not exist.")] Public Const CI_E_NO_CATALOG_MANAGER          = &HC0041831
[Description("The transaction in catalog is found as inconsistent.")] Public Const CI_E_INCONSISTENT_TRANSACTION    = &HC0041832
[Description("Protected catalog for the user is not available due to key drop status.")] Public Const CI_E_PROTECTED_CATALOG_NOT_AVAILABLE = &HC0041833
[Description("The system only stores index entries in a protected catalog, but no protected user currently exists.")] Public Const CI_E_NO_PROTECTED_USER           = &HC0041834
[Description("Content indexer only currently supports having a single protected user per device, but multiple protected users were present.")] Public Const CI_E_MULTIPLE_PROTECTED_USERS_UNSUPPORTED = &HC0041835
[Description("The system detected a SID owner for a protected item that did not match the SID owner of the protected catalog for the item.")] Public Const CI_E_PROTECTED_CATALOG_SID_MISMATCH = &HC0041836
[Description("On a system with a protected catalog, indexer only supports queries from the interactive user account.")] Public Const CI_E_PROTECTED_CATALOG_NON_INTERACTIVE_USER = &HC0041837
#End If
End Module